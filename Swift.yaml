#keyword: Swift.yaml
mac:  #keyword: mac  #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#mac
    mac キー操作、トラックパッド:  #keyword: mac keyboard
        スクリーン ショット: #// Shift + Command + 3  #keyword: mac screen shot,　mac スクショ スクリーンショット
            デバッグ用にスクショを撮って表示します:
                撮ります: Shift + Command + 3
                    #// ツール チップ をキャプチャーするには Shift + Command を押しながらマウスを合わせます
                トリミングします: 切り取り ボタン（上）
                保存します: 完了 ボタン（右上）  #// デスクトップに画像ファイルができます
                表示します: （デスクトップにできた画像ファイルをダブルクリック） #// プレビュー アプリ が起動します
                トリミングします（プレビュー アプリ）:
                    （トリミングする範囲をドラッグ）>> ツール（メニュー）>> 切り取り
                ウィンドウのサイズをトリミングした大きさにします:
                    プレビュー アプリ >> 閉じる >> デスクトップの画像ファイルをダブルクリック >>
                    ウィンドウを適切な場所に移動
            移動先: #ref: ${my_images}  #// USB メモリーと現在の PC  #search: ファイル転送
            関連:
                #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#mac_screen_shot
                #関連: 動画の収録: #search: mac capture
        Finder:  #// フォルダーとウィンドウ  #keyword: mac Finder (folder), Finder
            新しいウィンドウ:  #// フォルダーを新しいウィンドウで開きます
                フォルダーを右クリック >> 新規タブで開く >>（タブをドラッグします）
            ウィンドウの切り替え:
                前にアクティブだったウィンドウをアクティブにします:
                    できません。その代わり、アプリの切り替えとウィンドウの切り替えをします。
                アプリを切り替えます: Command + Tab キー
                現在のアプリの別のウィンドウに切り替えます: Command + [`] キー
            ウィンドウの一覧（Mission Control）を表示します: トラックパッドに、指3本を触れさせ、手を上にずらします
            Dock: #// #keyword: mac Dock  #// デスクトップ画面の下にあるアプリ一覧
            Launch Pad を表示します: トラックパッドに、指４本（通常小指以外）を触れさせ、手を閉じます  #keyword: mac Launch Pad
            デスクトップを表示します: トラックパッドに、指４本（通常小指以外）を触れさせ、手を広げます
            ファイル選択でデスクトップを表示します: Command + Shift + D
            隠しファイルを表示します: Finder >> shift + command + . (ピリオド)  #keyword: mac 隠しファイル,  mac finder hidden files
            ~/Library を開きます: #keyword: Finder ~/Library
                option キーを押しながら Finder の 移動 メニューを開くと ライブラリ がメニュー項目に表示されます
                    または
                Finder >> 移動 >> フォルダへ移動 >> ~/Library（と入力して Enter）
            パスを入力してフォルダーを開きます:  #keyword: mac open,  mac open dialog by path ファイル 選択
                _: Finder >> shift + command + G >> （パス）  #// ホームは ~。$HOME は使えません
                関連:
                    新規にファイルを作成して保存します: #keyword: new file save
                        Windows: VSCode >> タブの右の空きをダブルクリック >> 編集 >>
                            File メニュー >> Save >>
                            フォルダーのパスのコピー >> パスの貼り付け >> ファイル名の入力
                        mac: VSCode >> タブの右の空きをダブルクリック >> 編集 >>
                            ターミナルで code __Path__/__NewFileName__
                                （__Path__ はドラッグ＆ドロップで入力できます）>>
                            内容をコピペ >> 
                            File メニュー >> Save >>
        VSCode(mac): #keyword: VSCode mac keyboard
            右端折り返し:  #keyword: mac VSCode word wrap,  mac VSCode 右端折り返し
                オン・オフ:
                    option + Z
                    ω が入力されてしまう場合、日本語入力を英数入力に切り替えます。
                折り返したときのインデント: #search: VSCode editor.wrappingIndent
            対応するカッコに移動します: Shift + Command + ¥  #// editor.action.jumpToBracket
            矩形選択: shift + option + ドラッグ
            ブックマーク: option + command + K
            ジャンプ元へ戻る: control + -
            ジャンプ先へ進む: control + _ (アンダースコア)
            ファイルの先頭: command + ↑
        再起動:  #// mac 本体をキーボード操作で再起動します
            control + ▲ キー（▲ の下に _ ）>> tab キー を押して再起動に枠を合わせる >> スペース キー
    初期設定をします:  #keyword: mac initialize
        参考: #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg >> mac
        mac OS を初期化します:
            すべてのコンテンツと設定を消去:  #ref: https://support.apple.com/ja-jp/102664
        フォルダーのパスを表示します:
        日本語変換（JapaneseIM）の設定をします:  #keyword: mac JapaneseIM 初期設定, 日本語変換
            設定:
                メニュー:
                    macOS13: リンゴ（メニュー）>> システム環境設定（やや上） >> キーボード（最下付近）>>（テキスト入力）編集 >>
                        日本語 - ローマ字入力
                    旧: リンゴ（メニュー）>> システム環境設定（やや上） >> 言語と地域（右上）>> "キーボード"環境設定
                ライブ変換: オフ (*1)
                Windows風のキー操作: オン (*2)
                ¥ キーで入力する文字: バックスラッシュ  #// 全角の円: ￥
                数字を全角入力: オフ
            (*1) ライブ変換:
                ライブ変換をオフにすると、
                変換候補が入力箇所の下に一覧されるようになり、
                変換候補を選んだ後に続けて入力するときに変換候補が確定されるようになります
            (*2) Windows風のキー操作:
                Windows風のキー操作をオンにすると、
                変換候補の一覧から選んだらすぐに変換候補が確定されるようになります
            常に半角スペースにする:  #// 不明、未確認
                常に半角スペースにするのは大変  #//https://mac.flatsystems.net/data/archives/180.html
        2回スペースキーを押したときにピリオドを入力しないようにする:
            メニュー: りんご（メニュー）>> システム環境設定 >> キーボード >>（テキスト入力）編集
            スペースバーを2回押してピリオドを入力: オフ
            文頭を大文字にする: オフ
        ファンクション キー:
            りんご（メニュー）>> システム環境設定 >> キーボード >> キーボードショートカット >> ファンクションキー >> オフ
        連続入力の速さを設定する（オートリピート）:
            キーのリピート速度: 速い（右端）
            リピート入力認識までの時間: 速い（右端）から 2番目
        カーソルを画面を越えさせないようにする:  #// ユニバーサルコントロールのオフ。カーソル移動を 2台の mac を超えることをやめる
            メニュー: リンゴ（メニュー）>> システム環境設定（やや上） >> ディスプレイ（第4グループ）>> 詳細設定（右下）
            ポインタとキーボードを近くにある全ての Mac または iPad で移動することを許可: オフ
        mac に steps をダウンロード（git clone）します:
            - ssh-keygen -t ed25519 -C "your_email@example.com"
            - pbcopy < ~/.ssh/id_ed25519.pub
            - GitHub Settings → SSH and GPG keys → New SSH key
            - cd $HOME
            - git clone git@github.com:Takakiriy/steps.git
                #// git のインストールを選びます
            - cd steps
            - ls
            - steps リポジトリと同期します:
                - 以下は一度に実行できます:
                    #// mac >> 端末
                    cd $HOME/steps
                    git pull
                    git status
                    git diff
                - 以下は一度に実行できます(2):
                    git add .
                    git commit -m "1"
                - git push
        ダウンロードした zip ファイルを勝手に解凍させないようにします: #keyword: disable mac extract,  disable Safari download zip extract
            Safari >> Safari メニュー >> 設定 >> 一般 タブ（左上）>> ダウンロード後、"安全な"ファイルを開く = オフ
        VSCode をインストールします:  #search: VSCode mac install
        Node.js をインストールします:  #search: nvm
        mac に mem の一部をインストールします:
            #search: mem to mac
        PATH 環境変数: #keyword: mac PATH 環境変数
            ~/.zshrc: |  #// 下記を追加
                export PATH="$HOME/bin:$PATH"
        FileZilla のインストール:
        gitpull, gitstatus:
            #search: settings back up
            #search: gitpull
            #search: gitstatus
        会計キーの動作確認:
            #search: Secret Vault USB memory
    RDP:
        mac → Windows:  #keyword: mac Windows RDP  #// mac から Windows に RDP で接続します
            Parallels Client を使う場合:  #keyword: Parallels Client
                インストール:
                    - https://apps.apple.com/jp/app/parallels-client/id600925318
                    - アプリをインストール
                    - 追加 >> 標準RDP >> 詳細設定 >> IPアドレスやアカウントを入力
                        #// アカウントは、Microsoft アカウントを指定すると失敗します
                        #// 接続先のローカルのユーザーを指定してください。C:\Users\__UserName__ の __UserName__
                control キーと command キーを入れ替えます:  #// リモートの Windows がアクティブのときだけの設定です
                    Parallels Client >> Parallels Client >> 基本設定 >> キーボード（タブ）
                日本語キー配列にします:
                    - Windows スタート >> regedit（と入力）
                    - コンピューター\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\KeyboardType Mapping\JPN
                        kbd101.dll ⇨　kbd106.dll
                    - 参考: https://sutepulu.com/japanese-keyboard-with-microsoft-remote-desktop-2/
                IME のオン/オフを切り替えられるようにします:
                    メニュー: Windows スタート >> 設定 >> 時刻と言語 >> 言語 >> 日本語 >> オプション >>
                        Microsoft IME >> オプション >> キーとタッチのカスタマイズ
                    Shift + Space: IME オン/オフ
                画面の品質: #search: RDP display quarity
                トラブルシューティング:
                    日本語モードのときのキー配列が英語キーボードになってしまう:
                        レジストリを戻す？　ログインするときに英語キーボードになってしまった。問題はそれだけ？
                        【追記 2021/02/08】 Big Sur 標準IMEからのRDP接続だとUSキーボードになってしまうようです (汗)
                        https://qiita.com/hidecha/items/33624f6ae57d41f3cd86
            Microsoft Remote Desktop を使う場合:
                Microsoft Remote Desktop を AppStore からインストールします:
                日本語キー配列にします:
                    - コンピューター\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\KeyboardType Mapping\JPN
                        kbd101.dll ⇨　kbd106.dll
                    - 参考: https://sutepulu.com/japanese-keyboard-with-microsoft-remote-desktop-2/
                IME のオン/オフを切り替えられるようにします:
                    メニュー: Microsoft IME >> キーとタッチのカスタマイズ
                        #// 日本語入力モードのときだけ有効です
                    Shift + Space: IME オン/オフ
                トラブルシューティング:
                    mac リモートデスクトップ Alt Windows キーになってしまう:
                        対処法不明。Parallels Clien‪t‬ なら問題ありません
            VNC を使う場合:
                mac から別の mac へ接続する場合:
                    接続先の Mac の画面共有を有効にします:
                        Mac >> システム環境設定 > 共有 > 画面共有（にチェック：左の一覧の最も上）>>
                        コンピュータ設定（右）>> VNC使用者が画面を操作することを許可 >> パスワードを入力
                    接続先の Mac の IP アドレスをメモします:
                        チェックを入れた場所の右に、アクセスするための IP アドレスなどが表示されます
                    接続元から接続を開始します:
                        共通:
                            接続元の Mac の Finder >> 移動 メニュー >> サーバーへ接続（最も下）>>
                            vnc://192.168.___.___/ >> 接続 ボタン（右下）
                        接続先を直接操作できる人がいる場合:
                            接続元:
                                アクセス権を要求して接続（にチェック）>> サインイン
                            接続先:
                                （ポップアップした）画面の共有 ボタン
                Windows から mac へ接続する場合: #search: Windows mac VNC
            mac で全画面表示したアプリケーションと mac のデスクトップを切り替えます:
                指3本を左右にスワイプします
            キーボードをカスタマイズします:
                下記「Karabiner Elements をインストールする」
        Windows → mac:  #keyword: Windows mac RDP  #// Windows から mac に RDP で接続します
            公式:  #ref: https://support.apple.com/ja-jp/guide/mac-help/mh11848/mac
            VNC を使う場合: #keyword: Windows mac VNC
                ポート番号: 5900
                mac OS 13:
                    注意: 通信内容は暗号化されていません
                    Mac の画面共有を有効にします: #keyword: mac 画面共有
                        🍎（左上）>> システム設定 >>（3つ目のグループの）一般 >> 共有（中央）>>
                        画面共有（オン：一覧の最も上）>>
                        (i)（右）>> コンピュータ設定 >> VNC使用者が画面を操作することを許可 >> パスワードを入力
                    Mac の IP アドレスをメモします:
                        #search: my terminal IDs
                    Windows に VNC ビューアーをインストールします:
                        アカウントを作る必要はありません
                    接続します:
                        （初回のみ）:
                            メニュー: VNC >> File >> New Connection
                            VNC Sserver: __Mac_IP_Address__
                            OK ボタン:
                        （2回目以降）:
                            端末のアイコンをダブルクリック
                        警告:
                            （確認して）Continue
                        Username: __MacUserName__
                            #// 🍎（左上）>> システム設定 >> Apple ID の上
                        Password: __MacPassword__
                    全画面にする:
                以前の mac OS:
                    Windows に VNC ビューアーをインストールします:
                    Mac の画面共有を有効にします:
                        Mac >> システム環境設定 >> 共有 >> 画面共有（にチェック：左の一覧の最も上）>>
                        コンピュータ設定（右）>> VNC使用者が画面を操作することを許可 >> パスワードを入力
                    Mac の IP アドレスをメモします:
                        チェックを入れた場所の右に、アクセスするための IP アドレスなどが表示されます
                    画面のサイズを調整する:
                        Windows >> VNC >> Show Options >> Display タブ >> Fit to screen, no scrollbars >> Save
                    クリップボードの共有:
                        Windows のクリップボードが使えるようにするためにします:
                            Windows >> VNC >> Show Options >> Security タブ >> Disable clipboard transfer >> Save
                        Windows Mac 間のクリップボードの共有:
                            できないようです。 OneNote や  Google Apps Script などを経由してください。
                    フォルダーの共有:
                        不明。Google Drive などを経由してください。
            操作: #// Windows → mac
                所感: mac でしか使えない Xcode だけリモートで最大化（全画面ではない）して操作すればいい。
                    物理キーボードが大変役に立つ
                文字を拡大: 🍎 >> システム設定 >> ディスプレイ（左下）>> 文字を拡大
                全選択, 貼り付け: Alt + A, Alt + V
                スクロール: Page Up, Page Down
                Mission Control を開く: Ctrl + ↑
            Apple Remote Desktop: 社内向けで有料
                #ref: https://support.apple.com/ja-jp/HT208922
            どこでも My Mac: 提供中止
                #ref: https://support.apple.com/ja-jp/HT208922
            Chrome リモート デスクトップ を使う場合:
                #ref: https://blog.skeg.jp/archives/2019/11/chrome-remote-access.html
                危険性:
                    #ref: https://persol-tech-s.co.jp/hatalabo/it_engineer/579.html
                    - Googleアカウントの情報流出で悪用される可能性がある
                    - 通信を盗聴される可能性がある
        iPhone|iPad → mac:   #keyword: iPhone mac RDP
            Simple Remote (MONITOUCH) を使う場合:  #// 操作ができない
                所感: iPhone にはキーボードが付いていないのでかなりつらい。
                操作:
                    - 名前＋パスワードでログインできます
                    - タッチでスクロールするときは 2本指で操作するが、感度が強すぎて使えない
                    - 全画面を切り替えできません。大型 iPad でも
                    - iPad では カーソル キー、コントロール キー などが表示されません
                    - キーボードを日本語オフにできません
            VNC Viewer を使う場合:  #// 使えません
                - 名前＋パスワードでログインできません。
                - パスワードだけ入力する画面から変えられません。
    拡張子によって開くアプリケーションを設定します:
        参考:
            http://inforati.jp/apple/mac-tips-techniques/system-hints/how-to-change-the-default-application-of-a-specific-file-in-macos.html
        メニュー: ファイルを右クリック >> 情報を見る >> このアプリケーションで開く >> 
            （ドロップダウンリストからアプリケーションを選ぶ）>> すべてを変更 ボタン
    Gatekeeper: #keyword: Gatekeeper,  mac セキュリティ
        ブロックされたアプリを実行します: #keyword: open mac blocked application
            ログ:
                Apple は、"____" に Mac に損害を与えたり、プライバイシーを侵害する可能性のあるマルウェアが含まれていないことを検証できませんでした。
            対処:
                🍎 >> システム設定 >> プライバシーとセキュリティ >>（最も下へスクロール）>> お使いの Mac を保護するために "____" がブロックされました。 >>
                このまま開く
            参考:
                #search: Karabiner Elements
    Karabiner Elements:  #// キーボード　 #keyword: Karabiner Elements
        Karabiner Elements をインストールする:
            - .dmg ファイルをダウンロードします
            - .dmg ファイルをダブルクリックし、.pkg ファイルをダブルクリックして、インストールします
            - Finder >> 移動 >> アプリケーション >> Karabiner Elements
            - 機能拡張がブロックされました、と表示されたら:
                - 実行のブロックを解除します:
                    - セキュリティ 環境設定を開く ボタンを押します。
                        これは、mac >> りんごアイコン >> システム環境設定 >>
                        セキュリティとプライバシー >> 一般（タブ）と同じです
                    - 鍵アイコン（左下）を押して、パスワードを入力します
                    - .Karabiner ____ のシステムソフトウェアの読み込みがブロックされました、
                        の右の 許可 ボタンを押します
                - プライバシーの設定を解除します:
                    - mac >> りんごアイコン >> システム環境設定 >>
                        セキュリティとプライバシー >> プライバシー（タブ）
                    - 鍵アイコン（左下）を押して、パスワードを入力します
                    - 入力監視（左のリスト内）>>（下記の項目にチェックを入れる）:
                        - karabiner_grabber
                        - karabiner_observer
                - Karabiner Elements がまだ起動していたら終了する
        F12キーを Windows の Delete キー相当にする:
            - Finder >>　移動 >> アプリケーション >> Karabiner Elements
            - Function keys（タブ）>> f12 >> delete_forward
    日本語変換, JapaneseIM: #keyword: mac JapaneseIM,  旧）ことえり mac 日本語変換
        初期設定:  #search: mac JapaneseIM 初期設定
        辞書: #keyword: mac JapaneseIM 辞書
            追加:  #// 独自の変換をする内容を登録します
                1つずつ登録する場合:
                    日本語入力ソースに切り替えます:
                        日本語入力できる状態にします。日本語をオンにします
                    ユーザー辞書を開きます:
                        mac >> メニューバーの入力メニュー（右上）>> ユーザー辞書を編集 >> ＋（左下）
                    入力/読み: #// ひらがなで入力します
                    変換/語句: #// 変換後の文字列を入力します
                    追加 ボタン:
                一度に登録する場合:  #// 未確認
                    #// 未確認。追加辞書にドラッグ＆ドロップしても反応しません
                    登録する内容が書かれた テキスト ファイル を作ります:
                        #ref: ${typrm_files}/日本語変換辞書-mac.txt
                        書式: 単語の読み,単語,品詞,（,,メモ）
                        サンプル: みぎ,→,普通名詞
                        #ref: https://support.apple.com/ja-jp/guide/japanese-input-method/jpim10226/mac
                    登録します:
                        日本語入力ソースに切り替えます:
                            日本語入力できる状態にします
                        設定を開き、追加辞書の項目を表示します:
                            mac >> メニューバーの入力メニュー（右上）>> 日本語 - __Mode__ の設定を開く（最も下）>>
                            日本語 - __Mode__（左）>> 追加辞書（右半分の最も下）
                        テキスト ファイル を追加辞書の項目にドラッグ＆ドロップします:
    アプリケーション フォルダー:  #// .app フォルダー, .bundle フォルダー  #keyword: mac .app folder, mac .bundle folder, mac アプリケーション フォルダー
        説明:
            Finder では アプリケーション フォルダー の直下にある .app フォルダーは、
            パッケージという種類のフォルダーであり、ダブルクリックしてもフォルダーの中に入れません。
            .bundle フォルダーも同様です。
        フォルダーの中を開く: フォルダーを右クリック >> パッケージの内容を表示
    フォルダーを比較します: #keyword: mac compare folders
        #// WinMerge のような無料ツールは mac には存在しないようです
        Visual Studio Code:  #search: VSCode compare folders
            mac ではフォルダーの指定が難しい
        CompareMerge2:  #keyword:  #// 無料版は 30アイテムまで
            無料版:  #// 200ファイルまで
                インストール:  #ref: https://apps.apple.com/jp/app/comparemerge-lite/id1459748650?mt=12
            有料版:
                ¥1720
            注意:
                _base フォルダーのようなサブフォルダーとの比較はできません
            参考:
                Macでオススメするマージツール:  #ref: https://qiita.com/Labi/items/e35b944bd98c12e2050d
        その他:  #search: diff folder
    mac 用バイナリ エディター:
        Hex Friend:
            Hex Friend のインストール:
                App Store >> 検索 >> Hex Friend（と入力）>> Hex Friend の起動
            初期設定:
                1バイトごとの表示にします:
                    Hex Friend >> Views >> Byte Grouping >> 1
                文字コードを UTF-8 にします:
                    Text Encoding >> Other >> UTF-8
    ファイル名の濁点・半濁点問題:  #keyword: mac file name portability
        Macの文字コード: UTF-8-Mac。NFDの変種。例えば「プ」を「フ」と「゜」、「ブ」を「フ」と「゛」の二文字を合成して表現する。
        Windowsの文字コード: NFC。
        Unicode正規化:
            NFD, 正規化形式D: 文字は正準等価性によって分解される
            NFC, 正規化形式C: 文字は正準等価性によって分解され、再度合成される
            参考: #ref: https://ja.wikipedia.org/wiki/Unicode正規化
        参考: #ref: https://tech.synapse.jp/entry/2019/10/01/133000
    写真:  #keyword: mac 写真
        関連:  #search: iPhone 写真
        写真（アプリ）:
            キーワードで検索できるようにします:
                写真（アプリ）>> 1つの写真（を右クリック）>> 情報を見る >> タイトル >>
                約10秒後に検索できるようになります
            キーワードで検索します: 写真（アプリ）>> 検索（右上）
        プレビュー（アプリ）:  #keyword: mac preview
            画像:
                開始: スペース キー
                前後: カーソル キー
                トリミング: #keyword: mac trimming
                    （画像ファイルをダブルクリック）>> マークアップツールバーを表示（鉛筆ボタン：右上）>>
                    （切り抜く範囲をドラッグ）>> 選択範囲に切り取り（トリミング ボタン：右上）
                    #// 一括トリミング: #search: Node.js JavaScript sharp
                座標やサイズを調べます:
                    座標: #// 画像の中の1点の座標を調べます
                        画像ファイルをダブルクリック >> 調べる点の位置から左上端へドラッグ。画像の外に飛び出しても良い >>
                        表示された幅・高さが座標に相当します
                    幅・高さ・サイズ:  #keyword: mac image width height size
                        画像全体:
                            画像ファイルをダブルクリック >> (i)（上）
                        選択範囲:
                            画像ファイルをダブルクリック >> 調べる範囲をドラッグ >> 幅・高さが表示されます
            PDF: #keyword: mac preview PDF
                起動: PDF 表示中の Safari の下の方にカーソルを移動して表示されるボタンの右から2つ目
                全画面: フルスクリーン（緑）>>（マウスを画面上に移動してメニューを表示）>>
                    （サイドバーディスプレイを表示 ボタン）>> 常にサイドバーを表示 >>
                    （サイドバーディスプレイを表示 ボタン）>> 連続スクロール >>（ズームアウト） 
    収録, 動画キャプチャー:  #keyword: mac capture, mac 収録 動画キャプチャー
        mac:
            収録開始: Shift + Command + 5 >> 画面全体を収録（中央）>> 収録（右）
            音声を含めた録画:
                デフォルト: 音声は録音されません。 https://tech-camp.in/note/technology/96042/#Soundflower
                    #search: Windows capture
                Background Music: #ref: https://github.com/kyleneideck/BackgroundMusic
                    失敗 2021年9月:
                        ダウンロード:
                            https://github.com/kyleneideck/BackgroundMusic >> Releases（右下）Background Music v_.__ >>
                            BackgroundMusic-_._._.pkg
                        インストール:
                            ダウンロード（右下）>> BackgroundMusic-_._._.pkg >> ... >>
                            #// インストールが完了すると、ツールバーに丸いアイコンが表示されます
                            #ref: https://narisako.com/blog-entry-2842.html
                        起動:
                            Launchpad（左下）>> Quick Time Player >> キャンセル >> ファイル >> 新規画面収録 >>
                            オプション >> Background Music >> 収録
                        内蔵スピーカーに戻す:
                            りんご >> システム環境設定 >> サウンド（下）>> 出力（タブ）>> MacBook Airのスピーカー
                    2020年11月: macOS Big Sur で一時的に非対応に  https://btuber.jp/mac-screen-movie-internal-sound/
                Soundflower: #ref: https://github.com/mattingalls/Soundflower
                    2021年9月: macOS Big Sur に対応。ただし M1 mac は未対応  https://github.com/mattingalls/Soundflower/releases/tag/2.0b2
                    2016年9月: macOS Sierra で非対応に  https://btuber.jp/mac-screen-movie-internal-sound/
            収録終了: 四角い停止ボタン（メニューバー, 右上）>> （右下に表示された）プレビュー（を右にスワイプ）
            再生: デスクトップにできた動画ファイルをダブルクリックします
            公式: https://support.apple.com/ja-jp/HT208721
        iPhone:
            画面収録:
                ディスク容量
                写真を撮らない
                完了するまでリザルト画面から抜けない
        Windows:  #search: Windows movie capture
    動画編集:  #keyword: mac movie editor
        mac:
            iMovie: #keyword:
                字幕:  #// 動画の一部に字幕を追加します
                    背景が透明な PNG 画像を Google Slides などで作ります:
                    PNG ファイルをタイムラインにドラッグ＆ドロップします:
                    #// Keynote は思い通りにならない（上にずれる、パディングが大きい）
                    文字レイヤーの画像と合成する:
                        #ref: https://bamka.info/imovie-text-layout
                出力: #// 動画ファイルを出力します
                    iMovie >> 共有 ボタン（右上）>> ファイルを書き出す
        iPhone:
            画面収録:
            iMovie: #ref: https://time-space.kddi.com/mobile/20220518/3318
    動画再生:
        iPad:
            再生: Google Drive などに動画ファイルをコピーし、iPad でそのファイルを開きます
    カメラ: #keyword: カメラ 撮影
        遠近両方にピントを合わせる:
            x0.9にする
    通知音: #keyword: mac 通知音
        afplay /System/Library/Sounds/Ping.aiff
    Safari: #keyword: mac Safari  #// ブラウザー
        お気に入り: #// 新しいタブで表示されます
            追加:
                メニュー: Safari >> ↑（共有：右上）>> ブックマークに追加
                追加先: お気に入り
        初期設定:
            bing に変える:  #// 毎日現在位置を聞かれるため
                Safari メニュー >> 設定 >> 検索 タブ >> 検索エンジン
        スーパー リロード: #keyword: Safari super reload
            アプリを終了して開き直します。frameset タグの内容が更新されます
        PDF: #keyword: mac Safari PDF
            プレビュー表示:  #search: mac preview PDF
        開発: #keyword: mac Safari development,  Safari debug
            開発メニューを表示します:
                Safari >> Safari メニュー >> 環境設定 >> 詳細（右上）>>
                メニューバーに“開発”メニューを表示（下）
            Web インスペクター: #// HTML を表示します
                option + command + i
                #ref: ${my_images}/2022/Safari_develop.png?name=select&x=224&y=397
        Web アプリ: #keyword: mac Web アプリ,  Dock Web ページ  #// Dock に Web ページを追加します  #ref: https://support.apple.com/ja-jp/HT213583
            Safari でページを開きます >> ファイル メニュー >> Dock に追加
    SVG ファイルの途中を表示します:  #keyword: mac SVG viewer
        Chrome >> file:///Users/totadashi/Downloads/JavaScript.svg#string
        #// Safari, VSCode では開けません
    ディスク不足: #keyword: mac disk,  mac df size
        ストレージ, アプリを削除する:
            メニュー: mac >> 🍎 >> システム設定 >> 一般 >> ストレージ
            Xcode 関連:  #keyword: clear Xcode cache
                ストレージ >> デベロッパー (i) >> Xcode キャッシュ（など）>> 削除
            OnyX を使う:  #// mac のメンテンナンスを行う有名なフリーソフト
    ハードウェア:
        mac キー操作、トラックパッド:  #search: mac keyboard
        電源を入れっぱなしにします:  #search: mac sleep time
    トラブルシューティング（mac）:  #keyword: mac trouble shooting,  mac 使いにくい
        - #// 親フォルダーに戻ったとき、いままでいたフォルダーがどこか分からない
            仕様
        - #// ファインダーにコピーしたファイルが表示されない
            手順: ファインダーでコピペ
            対処: ファイルがあるはずのフォルダーの親フォルダーを表示 >> 該当フォルダーをダブルクリック
        - #// コピペしたら1行おきになってしまう
            手順: コピペ
            エラー: 1行おきになってしまう
            対処: 別の VSCode に貼り付けてコピーします
        - #// Bluetooth の接続が切れてしまった
            手順: Bluetooth オフ
            対処: 有線 USB のトラックボールを mac mini に接続します。
                倉庫部屋のケースの中 #keyword: mac USB track ball
        - #// Xcode や VSCode でフォルダーに見えるものが Finder ではファイルに見えて開けない
            手順: Finder でファイルをダブルクリックしたとき
            エラー: 書類"__FileName__"を開くために設定されているアプリケーションがありません。
            対処: 参照  #search: mac .bundle folder
        - #// codesign
            手順: アプリケーションからパスワードにアクセスする必要があったとき
            エラー:
                codesign がキーチェーンに含まれるキー "Apple Development:__Name__"へアクセスしようとしています。
            対処:
                mac の ログイン パスワードを入力します
コピペしたら1行おきになってしまう:
    別の VSCode に貼り付けてコピーします
Homeblew:
    公式: #ref: https://brew.sh/index_ja
    内容: Git, Ruby, その他細かいツール #ref: https://formulae.brew.sh/formula/
    手順 >> インストールします:
        ターミナルを開きます:
            mac >> Launchpad >> ターミナル
        下記のコマンドを入力します: #ref: https://brew.sh/index_ja
            /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            #// 約10分待ちます
Objective-C: #keyword:
    ブロック:  #keyword: Objective-C block
        コード サンプル:
            (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^ _Nullable)(_Nullable id, NSError * _Nullable error))completionHandler;
        意味: |
            evaluateJavaScript:               関数名
                (NSString *)javaScriptString    第1引数
                completionHandler:(             第2引数(?)
                        void (^ _Nullable)(_Nullable id, NSError * _Nullable error)  ブロックの型
                    ) completionHandler         ブロック。関数呼び出しの次に書く無名の関数 { (__Parameters__) in __Operations__ } 
Swift 言語:  #// プログラミング言語  #keyword: Swift
    #ref: ${programming}/プログラミング言語、環境/Swift.svg
    関連: IDE は #search: Xcode
    特殊記号一覧: #glossary: Swift
        (@): #// @attribute, @attribute(parameter)
            アトリビュート:  #keyword: Swift attribute
                関連: GUI に関するアトリビュート  #search: Xcode attribute
                公式: https://docs.swift.org/swift-book/ReferenceManual/Attributes.html >>
                    "@" を付けないキーワードで検索
                SwiftUI 表示用: #glossary:
                    (@State): #// 表示する値を持つ変数（非オブジェクト）に、@State を付けます
                        #snote: @State
                        サンプル: |
                            struct ContentView: View {
                                @State var isChecked_person1: Bool = false
                        関連 >> 表示する値がオブジェクトの中の変数の場合: #search: @ObservedObject
                    (@Binding): #// 親の @State 変数を参照する変数に @Binding を付けます
                        #snote: @Binding  #book: SwiftUI 2020 p330
                        関連 >> Binding:  #search: SwiftUI Binding
                        ケース: 子の View に表示する値を、親の View の @State が付いた変数の値にするとき、
                            子の View の変数に @Binding を付けます
                        サンプル: |  #// 親の View の変数に @State、子の View の変数に @Binding、子の View に渡すときに $ を付けます
                            struct ContentView: View {
                                @State var isChecked_person1: Bool = false

                                var body: some View {
                                    HStack {
                                        Text("担当者1のチェック").padding(.horizontal, 10)
                                        PersonCheckMark(isChecked: $isChecked_person1)

                            struct PersonCheckMark: View {
                                @Binding var isChecked: Bool
                    (@ObservedObject): #// 表示する値を持つ ObservedObject オブジェクトを代入する変数に、@ObservedObject を付けます
                        #snote: @EnvironmentObject
                        サンプル: |  #// 親の View の変数に @ObservedObject、子の ObservableObject の変数に @Published を付けます
                            struct ContentView: View {
                                @ObservedObject var user = User()

                            class User: ObservableObject {
                                @Published var name = ""
                                @Published var tall = ""
                    (@EnvironmentObject): #// 複数のビューに影響するオブジェクト
                        #snote: @EnvironmentObject
                一覧: #glossary:
                    #// https://qiita.com/shtnkgm/items/2cba98b545c913d990bc
                    (@IBAction): #// Storyboard の中の GUI 部品に関連づけるメソッドに付けるアクション
                        サンプル:  #search: Xcode connect example
                    (@IBOutlet): #// Storyboard の中の GUI 部品に関連づける変数に付けるアウトレット
                        サンプル プロジェクト:  #search: Xcode connect example
                        サンプル: |
                            @IBOutlet weak var __Variable__: __UIView__!
                        weak:
                            使い方: 通常、@IBOutlet と同時に指定します
                            詳細の参考: https://qiita.com/chocovayashi/items/a96adc1356b7c45524b7
                        (!):
                            使い方: 通常、@IBOutlet と同時に指定します
                            詳細の参考: https://qiita.com/chocovayashi/items/a96adc1356b7c45524b7
                    (@main): App プロトコルに準拠する構造体に付けます  #snote: @main
                    (@objc): Objective-Cから利用可能にします
        (...):  #// スライス, 配列の置き換え
        "[____:____]": ｜
            #// [____:____] 辞書  #search: Swift dictionary
        ____:____:  #// 変数または引数と、型
        \: |
            -   "\(__Variable__)":  #search: Swift expression in string
            -   \.__Attribute__  キー パス  #search: Swift KeyPath
        _: #// アンダースコア
            _ = __Func__():  返り値が参照されていないというエラーを回避するため  #search: @discardableResult
            引数の _: |  #search: Swift argument _
                func  __FunctionName__(_ __ArgumentLabel__: __Type__) -> __ReturnType__ { 
            1_234_567:  #search: Swift int _
        (?):
            Int?: #search: Swift type ?
        in:
            #search: Swift closure
        def __FuntionName__(__ArgumentLabel__ __ParameterName__; __Type__):  #// __FuntionName__(__ArgumentLabel__ __ParameterName__: __Type__)
            #search: Swift argument label
        def __FuntionName__(_ __ParameterName__; __Type__):  #// __FuntionName__(_ __ParameterName__: __Type__)
            #search: Swift argument _
    公式:
        Swift.org: https://swift.org/
        ドキュメント: https://swift.org/documentation/#the-swift-programming-language
        検索: https://developer.apple.com/documentation/technologies
    インストール:
        Swift Docker:  #keyword: Swift Docker
            参考: https://swift.org/download/#docker
            Docker for Windows をインストールします:
            ダウンロードします:
                #PowerShell
                - docker pull swift
            Docker コンテナーを起動してシェルを開きます:
                #PowerShell
                - docker run --privileged --interactive --tty --name swift-latest swift:latest /bin/bash;
            Swift シェルを開きます:
                #bash in docker
                - swift
            Swift シェルを終了します:
                #swift shell
                - |
                    :exit  #// 先頭にコロンが必要です
            bash in docker から抜けます:
                #bash in docker
                - exit
            試行中: |
                Windows（ホストOS）のフォルダーと共有させます
        Swift for Windows:
            #// Windows版は、Visual Studio 2019 が必要です。
            参考:
                - https://swift.org/download/#releases
                - https://swift.org/getting-started/ >> OnWindows
                - https://swift.org/blog/swift-on-windows/
                - |
                    Windows to Mac
                    https://cloud-work.jp/windows_pc/windows/win2mac_vnc/amp/
                    https://www.ipentec.com/document/mac-os-x-remote-connection-from-windows-using-vnc

                    mac wake on lan … 検索
                    https://documentation.logmein.com/webhelp/JA/LogMeInGetStart/LogMeIn/t_host_preferences_WakeonLAN.html

                    Swift Windows
                    https://www.google.co.jp/amp/s/forest.watch.impress.co.jp/docs/news/1278/413/amp.index.html

                    Swift Playground
                    https://developer.apple.com/jp/swift-playgrounds/
            関連:
                Snap Note >> mac へ Visual Studio Code をインストールする
        Swift Playgrounds: #keyword:  #// Swift の学習ができる ローカル アプリケーション  #ref: https://developer.apple.com/jp/swift-playgrounds/
            手順, インストール:
                Swift Playgrounds for mac:
                    ダウンロードします:
                        https://developer.apple.com/jp/swift-playgrounds/  >>  Mac 用の Swift Playgrounds  >>
                        入手 >> ダウンロード
        Swift が使える Web サービス:
            SwiftFiddle:  #ref: https://swiftfiddle.com
            補足: UIKitやCore Animationのようなフレームワークはサポートされていないことが多いらしい
    コーディングの基本:
        - defer が使えます
        - in は名前がない関数  #search: Swift closure
    import: #keyword: Swift import
        import が不要なケース:
            同じモジュール（＝ターゲット）の中にある場合:
                - 同じフォルダーの swift ファイルで定義したシンボルは、import しないで参照できます。
                - ターゲットの外のフォルダーの中のソースファイルには、Target Membership を設定します。
                    #search: Xcode Target Membership
                #// https://stackoverflow.com/questions/35222044/swift-import-my-swift-class/35222348
        文法:
            - import __Module__   #// モジュールの中で定義されているすべてのシンボルが参照できるようになります
            - import __Module__.__SubModule__
            - import __ImportKind__  __Module__.__Symbol__
            - import Foundation  #// Foundation は、最も基本的なモジュール。UIKit などは内部で import しています
        文法の補足:
            __ImportKind__: class | typealias | struct | enum | protocol | let | var | func
            __ImoprtKind__ の補足: https://thoughtbot.com/blog/swift-imports
        モジュール構成:
            構成するファイルを調べる:  #// コード上には現れません
                Xcode >> Project navigator（左上）>> プロジェクト ファイル（ツリーのルート）>>
                TARGETS（左）>> Build Phases >> Compile Sources
        スコープ:  #keyword: Swift scope
            書く場所: 関数や変数のスコープを指定するには、var や let や func の前にスコープを書きます。デフォルトのスコープは internal です。
            open: モジュール外からアクセスと継承とオーバーライド可能
            public: モジュール外から参照可能
            internal: （デフォルト）モジュール内の他のファイルから参照可能
            fileprivate: ファイル内のみ参照可能
            private: 定義されたスコープ内でのみ参照可能
            #ref: ${programming}/プログラミング言語、環境/Swift.svg#module
    制御構文:
        条件式: #keyword: swift if
            - if a == 1 {
            - if a != 1 {
            - if !a {
            - if !( notCondition ) {
            - if a == 1  &&  b == 2 {
            - if a == 1  ||  b == 2 {
            - if let result = result as? NSArray {
        分岐:  #// if ___ {},  switch ___ {}
            処理の分岐:
                if: |
                    if __Condition__ {
                        ...
                    } else if __Condition__ {
                        ...
                    } else {
                        ...
                    }
                switch: |  #// C言語のような break は不要です
                    switch __Value__ {
                        case __Value__:
                            __Statement__
                        case __Value1__, __Value2__:
                            __Statement__
                        case __Value1__　... __Value2__:
                            __Statement__
                        case __Value1__　..< __Value2__:
                            __Statement__
                        default:
                            __Statement__
                    }
                guard:  #keyword: Swift guard,  guard
                    チェック処理: |
                        - guard __Variable__ else { fatalError() }  // nil なら fatalError
                        - guard __Variable__ else { throw NSError(domain: "", code: 101) }  // nil なら throw
                    返り値を変数へ代入: |  #// String? 型のように Optinal な型が返り値の場合。Optional ではない関数は　guard の外に書かないとエラーになります
                        guard let  okStr = helloStr() else { throw NSError(domain: "", code: 101) }
                    複数の代入: |
                        guard                            // guard と let は同じ行に書く必要はありません
                            let  okStr1 = helloStr(),    // # 行末にコンマを付けること
                            let  okStr2 = helloStr()     // # 最後は行末にコンマを付けないこと
                        else { throw NSError(domain: "", code: 101) }
            View の分岐: |  #focus: if
                var body: some View {
                    VStack {
                        Text(card.title)
                        if !card.description.isEmpty {
                            Text(card.description)
        繰り返し: #keyword: Swift for loop  #// for in ... {}
            処理の繰り返し:
                for __Variable__ in __Array__ {} :  #// 最後のコロンはコードには書きません
                for (__Index__, __Variable__) in __Array__.enumerated() {} :
                for __Variable__ in __Start__...___Last__ {} :
                for __Variable__ in __Start__..<___Over__ {} :
                for in: | #keyword: Swift for in
                    for num in [10,20,30,40,50] {
                        print(num)
                    }
                forEach: | #keyword: Swift forEach
                    nums.forEach { num in
                    }
            View の繰り返し:
                ForEach: | #keyword: SwiftUI ForEach
                    ForEach(0..<2) { i in:  // 範囲は定数であること。さもなくばエラー Non-constant range: argument must be an integer literal
                    }
                    ForEach(0..<count, id: \.self) { i in:
                    }
                    ForEach(Array(repeating: 0, count: count), id: \.self) { _ in
                    }
                    ForEach(views, id: \.self) { view in:
                    }
                    ForEach(views.indices, id: \.self) { index in
                    }
                    ForEach(views) { view in
                    }
                    ForEach(Array(self.viewModel.reminders.enumerated()), id: \.offset) { index, reminder in
                        // enumerated() は、「id に指定した属性の値」と「reminders 配列の要素」の 2つからなるタブルを返し、
                        // in の左の 2つの変数に渡します
                    }
                    //↓ 第2キーも使ってソートします。iOS 16+ / macOS 13+ 以降
                    ForEach(Array(self.viewModel.reminders.sorted(using: [
                                KeyPathComparator(\EKReminder.priority),
                                KeyPathComparator(\EKReminder.title),
                            ]).enumerated()),
                            id: \.element.calendarItemIdentifier) { index, reminder in
                    ForEach(Array(self.viewModel.reminders.sorted { a, b in
                                let  shiftPriorityA = (a.priority == 0) ? 10 : a.priority
                                let  shiftPriorityB = (b.priority == 0) ? 10 : b.priority
                                return  shiftPriorityA < shiftPriorityB
                            }.enumerated()), id: \.element.calendarItemIdentifier) { index, reminder in
                List の基本（繰り返す前）: |
                    var body: some View {
                        List(__Collection__, id: \.__Attribute__) { __Item__ in
                List とインデックス: |  #focus: List
                    var body: some View {
                        List {
                            ForEach(Array(__Collection__.enumerated()), id: \.element.__Attribute__) { index, __Item__ in
        エラー ハンドリング, 例外処理: #keyword: Swift error,  Swift try catch exception
            参考: #ref: https://dev.classmethod.jp/articles/about-error-handling/
            例外:
                例外を投げる:
                    throw:  #keyword: Swift throw
                        throw LibraryError.Public("error example.")  #search: LibraryError.Public
                    throws: |  #// 例外を投げる関数には throws を付けます
                        open func removeItem(atPath path: String) throws
                    関連: #search: fatalError
                throws がある関数を呼び出す:  #keyword: Swift try,  Swift try! try?
                    try:  #// エラーが発生したら例外を投げる関数を呼び出す場合は必ず要る。throws を書けば do ブロックの中でなくても使えます  #search: Swift do try catch
                        関数の呼び出し元へ例外を投げない場合: |  #focus: try, catch
                            do {
                                try FileManager.default.removeItem(atPath: path)
                            } catch ...
                        関数の呼び出し元へ例外を投げる場合: |  #focus: try, throws
                            func  __Function__() throws {
                                try FileManager.default.removeItem(atPath: path)
                            }
                    try!: |  #// エラーが発生したら即時停止させる場合、エラーが発生しないと分かっている場合
                        try! FileManager.default.removeItem(atPath: path)
                    try?:
                        基本: |  #// エラーが発生しても次を続行する場合
                            try? FileManager.default.removeItem(atPath: path)
                        エラーが発生したときの値を指定する場合: |  #focus: else  #// エラー発生時は contents = []
                                guard let contents = try? FileManager.default.contentsOfDirectory(atPath: directoryPath) else {
                                    return []
                                }
                            #// エラーの情報は無視します
                do { try } catch {}:  #keyword: Swift do try catch,  catch let,  Swift NSError
                    基本: |
                        do {
                            try __FunctionCall__()  // try, try! or try?
                            let ret = try __FunctionCall__()
                        } catch let error {    // または catch のみの省略形。省略形でも error という名前の変数が使えます
                            // error の型は Error プロトコルであり NSError クラス(?)です。
                            print(error)
                            let nsError = error as NSError
                            print(nsError.domain)
                            print(nsError.code)
                            print(nsError.userInfo)
                        }
                    特定のクラスをキャッチする: |
                        do {
                            let path = "/wrong/path" // 不正なファイルパス
                            try FileManager.default.removeItem(at: URL(fileURLWithPath: path))
                        } catch CocoaError.fileNoSuchFile {
                            // ファイルやディレクトリが見つからなかった場合の処理
                        } catch CocoaError.fileLocking {
                            // ファイルがロックされている場合の処理
                        } catch {
                            // その他のエラー時
                        }
                finally:
                    Swift には finally はありません。defer を使います  #search: Swift defer
                defer: |  #keyword: Swift defer  #// 関数を抜ける時に呼び出すようにします
                    do {
                        let file = File("ファイル/パス")
                        
                        let fileReader = FileReader(file)
                        defer {
                            fileReader.close()
                        }
                        
                        while let data = try fileReader.read() as Int?, data != -1 {
                            print(data)
                        }
                    } catch let error {
                        print(error.localizedDescription)
                        return []
                    }
                エラー オブジェクト:
                    LibraryError.Public: |  #keyword:  #// 推奨される方式に従った独自エラー
                        enum LibraryError: Error {
                            case Public(String)
                        }

                        func  foo() throws -> String {
                            throw LibraryError.Public("error example.")
                        }

                        func  main() {
                            do {
                                let result = try foo("example input")
                                print(result)
                            } catch LibraryError.Public(let errorMessage) {
                                print(errorMessage)
                            } catch let error {
                                print("Unknown error: \(error)")
                            }
                        }
                        #search: (ChatGPT-GPT4) Swift でアプリケーション固有の例外を発生させるときに推奨されるコードを教えてください
                    NSError:  #search: Swift NSError
                    AssociatedValuesEnum:  #ref: https://dev.classmethod.jp/articles/about-error-handling/
                    カスタムエラーの定義:  #ref: https://dev.classmethod.jp/articles/about-error-handling/ >> カスタムエラーの定義
            fatalError:  #keyword: Swift fatalError
                - fatalError()
                - fatalError("message")
        メソッド:  #search: Swift method
        非同期: #keyword: Swift 非同期処理
            Promise: PromiseKit のダウンロードが必要です。（非推奨？）
            async/await パターン: #keyword: Swift async await  #// iOS 15以降
            completion ハンドラー: #keyword: Swift completion handler,  Swift completion closure
                #// 非同期処理が完了したら実行するクロージャー
                推奨: Swift 5.5 以降, iOS 15以降なら async/await を使ってください  #search: Swift async await
                サンプル: |  #focus: newURL in
                    let coordinator = NSFileCoordinator()
                    coordinator.coordinate(writingItemAt: url, options: [], error: nil) { newURL in
                        do {
                            try content.write(to: newURL, atomically: true, encoding: .utf8)
                            try self.saveBookmark(for: newURL)
                            continuation.resume()
                        } catch {
                            continuation.resume(throwing: error)
                        }
                    }
            DispatchQueue.main.async:
                代わり >> Task:
            MainActor.run:   #// UIの更新を確実にメインスレッドで行うようにします
        Custom Flags, デバッグ オプション: #keyword: Swift Custom Flags  #// 未確認。
            定義:
                Xcode >> プロジェクト エディター（左上）>>（プロジェクト名：左上）>> All タブ >>
                （最も下へスクロールして少し上へ）Swift Compiler - Custom Flags >>
                Other Swift Flags
                #// 定義すると Not found __Project__/__CustomFlag__ エラーになります。Swift だから？
            コード:
                #if __CustomFlag__
                #elseif __CustomFlag__
                #else
                #endif
    データ:
        定数か変数か: #keyword: Swift var, Swift let, Swift var let
            var: 変数
            let: 定数  #// 関連: Swift setting object
            if で値を分ける:  #ref: ${typrm_files}/ref/Swift-AI.yaml#label: Swift if else value
                if else: |
                    var myVariable: Int
                    if someCondition {
                        myVariable = 10
                    } else {
                        myVariable = 20
                    }
                できません: |
                    if someCondition {
                        var myVariable = 10
                    } else {
                        var myVariable = 20
                    }
                三項演算子: |
                    let myVariable = someCondition ? 10 : 20
            guard let: #// 代入する値が nil の場合は else の処理が行われます
                サンプル: |
                    guard let  okStr = helloStr else { return ____ }
                    guard let  string = any?.property as? String else { return nil }
        基本の型: #keyword: Xcode primitive type,  Xcode String Int Float 文字列 正規表現 配列 辞書
            数値:
                型: Int, Int8, Int16, Int32, Int64
                区切り記号: #keyword: Swift int _
                    1_234_567 == 1234567  #// _ は無視されます
            文字列: #keyword: Swift String
                基本: let  userName = "Taro"
                文字数, 長さ: userName.count
                複数行:
                    書き方: (")を3つで囲みます。最後の """ のインデントの深さと
                        同じ深さの行頭の空白文字は文字列に含まれません。
                        たとえば、下記の 1行目の左に空白文字はありません。
                    サンプル: |
                        let  s = """
                            1行目
                            2行目
                            """
                変数埋め込み:  #// 文字列の中に変数や式を埋め込みます  #// "\(__Variable__)"  #keyword: Swift expression in string
                    var  count = 0;
                    print("count = \(count)")
                書式指定: |  #// %02d
                    String(format: "%02d:%02d", minutes, seconds)
                一部: #keyword: Swift String.SubSequence  #// 文字列の一部.  String.SubSequence 型
                    インデックス指定の場合:  #// 数字の場合
                        プレフィックス: |
                            "text".prefix(2) == "te"
                            if __String__.hasPrefix(__PrefixString__) {
                                let  indexNextToPrefix = __String__.index(__String__.startIndex, offsetBy: __PrefixString__.count)  // 先頭を0にしたインデックス
                                let  withoutPrefix = String(__String__[indexNextToPrefix...])  // String() casts the type from String.SubSequence to String
                                以下は読みにくいため非推奨
                                    __String__.removeFirst(prefix.count)  // __String__ を変更してしまいます
                        サフィックス: |
                            "text".suffix(2)
                        一部:
                            範囲指定: #keyword: Swift ...
                                - __String__[__StartIndex__...__LastIndex__]
                                - __String__[__StartIndex__...]  #// 最後まで
                                - __String__[...__LastIndex__]   #// 最初から
                                - String(__String__[__StartIndex__...__LastIndex__])   #// String.SubSequence 型 ではなくす
                                #search: Swift index
                            スライス: #keyword: Swift slice,  Swift ..< range  #// 終わりの次の位置を指定する場合
                                - __String__[__StartIndex__..<__OverIndex__]  #// __StartIndex__ と __OverIndex__ は Int 型ではありません  #search: Swift index
                                - __String__[..<__OverIndex__]  #// ..<__OverIndex__ は PartialRangeUpTo<Int> 型
                                #search: Swift index
                            __StartIndex__ など:  #search: Swift index
                        インデックス, Index 型: #keyword: Swift index  #// 文字列の中の位置。インデックスの単位は文字
                            3 など, index: |
                                __String__.index(__String__.startIndex, offsetBy: __Offset__)
                            0, startIndex: |
                                __String__.startIndex
                            endIndex, 最後:  #// 文字数に一致します
                                書式: __String__.endIndex
                                count と endIndex の違い:
                                    __String__.count と __String__.endIndex.encodedOffset は単位が違います。
                                    __String__.count 結合文字列の場合 2以上になります。
                            +1, after: |  #// 1つ右。範囲外になるとエラーになります（nil を返すのではありません）
                                __String__.index(after: __Index__)
                            -1, before: |  #// 1つ左。範囲外になるとエラーになります（nil を返すのではありません）
                                __String__.index(before: __Index__)
                            検索した位置, firstIndex, lastIndex:
                                複数文字:
                                    range: | #keyword: Swift string range
                                        let str = "This is a sample string"
                                        let keyword = "sample"

                                        if let range = str.range(of: keyword) {
                                            let startIndex = str.distance(from: str.startIndex, to: range.lowerBound)
                                            let endIndex = str.distance(from: str.startIndex, to: range.upperBound)
                                            print("Keyword found at index \(startIndex) to \(endIndex)")
                                        } else {
                                            print("Keyword not found")
                                        }
                                1文字:
                                    firstIndex: | #keyword: Swift firstIndex  #// 最も左に見つかった位置
                                        str.firstIndex(of: "x") -> Optional(Index)
                                    lastIndex: | #keyword: Swift lastIndex  #// 最も右に見つかった位置
                                        str.lastIndex(of: "x") -> Optional(Index)
                                #search: Swift String search
                        範囲外の場合:
                            エラーになります  #// 未確認
                    検索した位置の場合:  #search: Swift firstIndex
                両端の空白を取り除きます: |  #keyword: Swift trimmingCharacters
                    " word ".trimmingCharacters(in: .whitespaces)
                検索: #keyword: Swift String search
                    contains: |
                        str.contains("BC") -> Bool
                    range:  #search: Swift string range
                    firstIndex:  #search: Swift index  #// 最も左に見つかった位置
                    lastIndex:   #search: Swift index  #// 最も右に見つかった位置
                    分割:  #search: Swift String components
                置き換え:  #keyword: Swift replacingOccurrences,  Swift String replace
                    コード: |
                        let replaceStr = str.replacingOccurrences(of: "__From__", with: "__To__")
                    occurrences: 出現。A の(of)出現を B に(with)置き換えます
                    改行を空白に置き換えるとき: ¥n と \n の違いに注意
                分割: | #keyword: Swift String components,  Swift split #// 区切り文字を指定して、文字列から文字列配列に変換します
                    - str.components(separatedBy: " ")  #// 連続した空白があるとき、空の要素は除外されます
                    - str.components(separatedBy: "\n", omittingEmptySubsequences: false)  #// 空の要素（空行）も含めます
                String(contentsOf:):  #search: Swift String contentsOf
            String.SubSequence:  #search: Swift String.SubSequence  #// 文字列の一部を参照する型
                String 型 への変換: |
                    String(subSequence)
            正規表現: | #keyword: Swift regular expression
                let  indentRegularExpression = (try? NSRegularExpression(pattern: "^ *"))!

                func  getIndent(_ line: String) -> String {

                    let  matched = indentRegularExpression.firstMatch(in: line, range: NSRange(0..<line.count))
                    var  indent = ""
                    if matched != nil {
                        let  matchedStrings = (0 ..< matched!.numberOfRanges).map {
                            NSString(string: line).substring(with: matched!.range(at: $0))
                        }

                        indent = matchedStrings[0]
                    }
                    return  indent
                }
            Bool:
                true, false
            enum: #keyword: Swift enum
                定義:
                    値指定なし: |  #focus: BloodType
                        enum  BloodType {
                            case  ab
                            case  a
                            case  b
                            case  o
                        }
                        let  typeAB = BloodType.ab
                    Int: |  #focus: Signal
                        enum  Signal: Int {
                            case  blue = 1
                            case  yellow = 2
                            case  red = 3
                        }
                        let  signalBlue = Signal.blue
                    String: |  #focus: Weather
                        enum  Weather: String {
                            case  sunny = "晴れ"
                            case  cloudy = "曇り"
                            case  rain = "雨"
                            case  snow = "雪"
                        }
                        let  weatherSunny = Weather.sunny
                使用:
                    初期化: |  #focus: Signal
                        let  signalBlue = Signal.blue
                        let  signalBlue: Signal = .blue
                    enum → 値: |  #focus: .rawValue
                        signalBlue.rawValue == 1
                    値 → enum: |  #focus: rawValue
                        let  signalYellow: Signal? = Signal(rawValue: 2)
                Associated Value:
                    #ref: https://qiita.com/hachinobu/items/392c96820588d1c03b0c#付属型enumassociated-value
                ネスト:  #ref: https://qiita.com/hachinobu/items/392c96820588d1c03b0c#列挙型のネストnested-types
                    let weapon = Character.weapon.bow
                列挙型のメソッドとプロパティの宣言:
                プロトコルの準拠とExtension:
                ジェネリクスを使った列挙型(Generic enum):
                列挙子(要素)なしのenum:
                全ての列挙子を配列で取得する:
                #ref: https://qiita.com/hachinobu/items/392c96820588d1c03b0c
            OptionSet: #keyword: Swift OptionSet  #// ビット フィールド
                値のサンプル:
                    - []
                    - [.__Flag__]
                #ref: https://qiita.com/KentaKudo/items/149c5672b0ee246f63c1
                定義のサンプル: |
                    extension UIMenuElement {
                        public struct Attributes : OptionSet, @unchecked Sendable {
                            public init(rawValue: UInt)
                            public static var disabled: UIMenuElement.Attributes { get }
                            public static var destructive: UIMenuElement.Attributes { get }
                            public static var hidden: UIMenuElement.Attributes { get }
                補足:
                    "{ get }": |  #// getter を表します  #search: Swift getter
                        weak open var webView: WKWebView? { get }
            Date: #keyword: Swift Date
                表示: |  #focus: now  #// 国際化対応
                    import Foundation
                    let  formatter = DateFormatter()
                    formatter.timeStyle = .short // Hour and minute
                    formatter.dateStyle = .none
                    formatter.locale = Locale.current

                    let  now = Date()
                    print(formatter.string(from: now))
                1分後: |  #focus: value
                    let  now = Date()
                    guard let  oneMinuteLater = calendar.date(value: +1, byAdding: .minute, to: now) {print("ERROR: oneMinuteLater")}
                秒数: |  #focus: timeIntervalSinceNow
                    let  now = Date()
                    let  fiveMinutesLater = Calendar.current.date(byAdding: .minute, value: 5, to: now)!
                    let  secondsUntilFiveMinutesLater = fiveMinutesLater.timeIntervalSinceNow

                    print("5分後の時刻まであと \(secondsUntilFiveMinutesLater) 秒です。")
                比較:
                    let  now1 = Date()
                    let  now2 = Date()
                    if now1 < now2 { ____ }
        演算子:
            三項演算子:  #keyword: Swift 三項演算子
                書式: |
                    -   ____ ? ____ : ____
                    -   (____) ? (____) : (____)
                （関連）>> nil ??:  #search: Swift nil ??
        配列:  #keyword: Swift array
            宣言:  #// [ ___, ___ ]
                - let  numbers1 = [ 1, 3, 7 ]  // let は変更不可。要素も変更不可。型推論で Int 型配列
                - var  numbers2 = [ 1, 3, 7 ]  // var は変更可能
                - var  numbers3:[Int] = []  // 空の Int 型配列
                - var  numbers4 = [Int]()   // 空の Int 型配列の別の書き方。 () はオブジェクト生成と同じ
            追加:  #// append, +, +=
                append: |  #keyword: Swift append  #// 最後に追加します
                    var  a1:[Int] = []
                    a1.append( 1 )     // [ 1 ]
                    a1.append(contentsOf: [ 2, 3 ])
                    // a1 == [ 1, 2, 3 ]
                +, += 演算子: |
                    var  a1 = [ 1, 2, 3 ]
                    let  a2 = [ 4, 5 ]

                    let  a3 = a1 + a2  // a3 == [ 1, 2, 3, 4, 5 ]
                    a1 += [ 6, 7 ]     // a1 == [ 1, 2, 3, 6, 7 ]
            置き換え、除外と挿入: |  #// [ ... ] =,  [ ..< ] =
                var  numbers = [ 0, 1, 2, 3, 4 ]

                numbers[2...3] = [ 22 ]  // ... は、配列番号 2〜3 を除外して、そこへ 22 を挿入します
                numbers == [ 0, 1, 22, 4 ]

                numbers[1..<3] = [ 33 ]  // ..< は、配列番号 1〜3未満 を除外して、そこへ 33 を挿入します
                numbers == [ 0, 33, 4 ]
            値型:  #// 配列は値型。代入や値渡し
                代入: 配列は値型なので = を使ったシンプルな代入では配列のコピーが作られます
                参照:
                    配列を属性に持つクラスがあれば、そのクラスを参照することができます。
                        objA.items = [...]
                        var objB = objA
                        objB.items.append("a")
                    以下のコードはコピーに append してしまいます
                        objA.items = [...]
                        var arr = objA.items
                        arr.append("a")
                        arr.last == "a"
                        objA.items.last != "a"
                関数の引数に渡した配列の要素を変更します:  #// func ____(____: inout [__Type__])
                    説明: 関数の引数に指定した配列の要素を関数の内部で変更するときは、
                        関数定義の引数に inout を付け、関数呼び出しの引数に & を付けてください。
                    サンプル: |
                        func  main() {
                            var  numbers = [ 0, 1 ]

                            functionA( array: &numbers )  // & を付けます
                            numbers == [ 0, 11 ]
                        }
                        func  functionA( array:inout [Int] ) {  // inout を付けます
                            array[1] = 11
                        }
                        main()
            要素数:
                numbers1.count
            スライス: |  #// [ ... ],  [ ..< ] #keyword: Swift slice
                let  numbers = [ 0, 1, 2, 3, 4 ]
                numbers[2...3] == [ 2, 3 ]
                numbers[2..<3] == [ 2 ]
                numbers[...3] == [ 0, 1, 2, 3 ]
                numbers[..<3] == [ 0, 1, 2 ]
                numbers[3...] == [ 3, 4 ]
            範囲外のデフォルト: |  #// 配列要素を返しますが、配列番号が範囲外のときは default 値 を返します
                    extension  Array {
                        func  element(_ index: Int, default_: Element) -> Element {
                            guard index >= 0 && index < count else {
                                return  default_
                            }
                            return  self[index]
                        }
                    }
                #// 上記のコードはどこのファイルでもいいので、グローバルに書きます
                #// 上記のコードはジェネリクスを使っていて任意の型の配列に対応できます。Element は Array<Element> として定義されています
            最大最小: |  #// min, max  #keyword: Swift min, Swift max
                let  numbers = [ 1, 0, 2, 5, 3 ]
                numbers.max()!  // 0
                numbers.min()!  // 5
            繰り返し:  #search: Swift for loop
            iterator: |  #// イテレーター  #keyword: Swift iterator
                var  listItemIterator = listItems.makeIterator()
                var  listItem = listItemIterator.next()!
            filter:  #keyword: Swift filter
                サンプル: |
                    let array = [1,2,3,4,5]
                    let newArray = array.filter{ $0 < 3 }  // [1,2]
                関連:
                    #search: Swift first
            first: |  #keyword: Swift first
                let firstElement = array.first(where: { $0 < 3 })  #// firstElement は Optional 型 です
            map:  #keyword: Swift map
                基本型の配列: |
                    let array = [1,2,3,4,5]
                    let newArray = array.map{ $0 * 5 }  // [5, 10, 15, 20, 25]
                辞書の配列: |
                    let celsius = ["Tokyo":14.0, "Osaka":17.0, "Okinawa":26.0]
                    let fahrenheit = celsius.map { ($0.0, 1.8 * $0.1 + 32) }
                        // [("Okinawa", 78.8), ("Tokyo", 57.2), ("Osaka", 62.6)]
        辞書:  #keyword: Swift dictionary
            参考:
                - Dictionary Type in https://docs.swift.org/swift-book/ReferenceManual/Types.html#grammar_dictionary-type
                - https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html#ID113
            リテラル:  #// { } ではなく [ ] で囲みます。配列も辞書もどちらも [ ] で囲みます
                基本: [__Key__: __Value__]
                基本の例:
                    - ["key": "value"]
                    - ["keyA": "value", "keyB": 0]
                    - [:]  #// 空の辞書:
            変数の初期値: |
                let someDictionary: [String: Int] = ["Alex": 31, "Paul": 39]
                または
                let someDictionary: Dictionary<String, Int> = ["Alex": 31, "Paul": 39]
            アイテムを参照します: |
                let dic: [String: Int] = ["Alex": 31, "Paul": 39]
                print(dic["Alex"])
            キーが見つからないとき: |
                dic["Unknown"] == nil
            ループ: |
                let  keyValues = [
                    "Prime": 1000,
                    "Second": 500,
                ]
                for (_, number) in keyValues {  // _ は参照しないときに指定します
                }
        クラス:  #keyword: Swift class
            class:
                インスタンスを生成します:  #// let  __Variable__ = __ClassName__()
                    - let  __Variable__ = __ClassName__()
                    - let  __Variable__ = __ClassName__(__NameAndInitialValues__)
                初期化 >> 公式: https://docs.swift.org/swift-book/LanguageGuide/Initialization.html
                基本形, init なし: |
                    class  __ClassName__ {
                        var  __VariableName__: __Type__ = __InitialValue__
                        let  __ConstantName__: __Type__ = __Value__
                    }
                基本形, 初期値指定なし: |  #// インスタンス生成時に初期値を指定しない場合:
                    未確認
                    class  __ClassName__ {
                        var  __VariableName__: __Type__ = __InitialValue__
                        let  __ConstantName__: __Type__ = __Value__

                        func  __MethodName__() {  // #keyword: Swift method example
                            ____
                        }

                        func  __MethodName__(__ArgumentLabel__ __ParameterName__: __Type__) -> __ReturnType__ {
                            ____
                            return  __ReturnValue__
                        }
                    }

                    let  __Variable__ = __ClassName__()  // インスタンスを生成します
                基本形, 初期値指定あり: |  #// インスタンス生成時に初期値を指定することがある場合
                    未確認
                    class  __ClassName__ {
                        var  __StoredPropertyName__: __Type__
                        let  __ConstantName__: __Type__ = __Value__

                        init(__VariableName__: __Type__) {  // #keyword: Swift class init
                            self.__VariableName__ = __VariableName__  // わざわざ書く必要があります
                        }
                            #// UIView でエラーになる場合  #search: UIView init
                    }

                    let  __Variable__ = __ClassName__(__NameAndInitialValues__)  // インスタンスを生成します
                メソッド:  #keyword: Swift method
                    サンプル:  #search: Swift method example
                static インスタンス:  #keyword: Swift class static
                    サンプル: |
                        class WCManager: NSObject, WCSessionDelegate {
                            static var default = WCManager()  #// default がよく使われている様子
                    参考:
                        static:  #// https://qiita.com/surfinhamster/items/830e760e441d040c1a10
                        default: #ref: ${GitHub}/MyPrivateCode/Swift/watch/UsingWatchConnectivity/SimpleWatchConnectivity/AppDelegate.swift:27
                getter: #keyword: Swift getter,  Swift 算出プロパティ
                    書式: |  #focus: get
                        class __ClassName__ {
                            var __GetterName__: __Type__ {
                                get {
                                    return __Code__
                    サンプル: |  #focus: fullName
                        class Person {
                            var firstName: String
                            var lastName: String
                            
                            init(firstName: String, lastName: String) {
                                self.firstName = firstName
                                self.lastName = lastName
                            }
                            
                            var fullName: String {
                                get {
                                    return "\(firstName) \(lastName)"
                                }
                            }
                        }

                        let person = Person(firstName: "John", lastName: "Doe")
                        print(person.fullName) // 出力: "John Doe"
                setter: #keyword: Swift setter
                    サンプル: |  #focus: fullName
                            var fullName: String {
                                set {
                デリゲート メソッド:  #keyword: UIKit delegate method, UIKit に見られるプロトコルを実装するメソッドの形
                    書式: |
                        func __CallerShortName__(_ __Argument__: __CallerClassName__, __EventName__: ____, ____)
                    完全修飾メソッド名, メソッド参照構文: #keyword:  #// Swift でメソッドを一意に識別するための名前
                        __Class__.__CallerShortName__(_:__CallerClassName__:)
                        #// 引数ラベルの右に、コロンを付けます。上記は 2つの引数について書いています。_ と __CallerClassName__ です
                関連:
                    関数: #search: Swift func
                    キャスト: #search: Swift cast
            struct:
                class と struct の違い:
                    - 公式: https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html
                    - struct のインスタンス変数の変更をするメソッドには、mutating が必要です
                    - struct は init を定義しなくても構いません
                    - struct は値型なので a = b とするとプロパティのコピーが作られます
                定義 >> 構造体の定義のサンプル: |
                    struct  Example {
                        var  count: Int
                        mutating func  methodA() {  // #keyword: Swift mutating
                            self.count += 1
                        }
                    }
                初期化: |  #// new 演算子は不要です。プロパティは ( ) で囲み、引数ラベルを付けます
                    Example(count: 1)
            プロパティ:  #// クラス、構造体、列挙型などにプロパティがあります
                ストアド プロパティ: 変数
                計算プロパティ: getter (?)
                属性, アトリビュート:  #ref: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/attributes/
            設定オブジェクト: #keyword: Swift setting object
                #// ネストしています。値に型があります。深い位置にあるオブジェクトにも型があります。
                #// shared をクラスの中に入れなくてはいけない理由は不明ですが、グローバル変数にしたときの問題点があると AI がうるさいのでこうしています #search: setting object
                基本サンプル: |  #focus: version  #ref: ${GitHub}/MyPrivateCode/Swift/tutorial/settingObject/settingObject.swift
                    // Simple
                    import Foundation

                    class Config {
                        static var shared = ConfigShared()  // Replacable Singleton
                    }
                    class ConfigShared: Codable {
                        var version: String = "1.0.0"
                        var settings: Settings = Settings()
                        class Settings: Codable {
                            var theme: String = "dark"
                            var notifications: Bool = true
                            var maxItems: Int = 50
                        }
                    }
                    typealias ConfigSettings = ConfigShared.Settings

                    func main() {
                        let config: ConfigShared = Config.shared
                        print("App version: \(config.version)")
                        print("Theme: \(config.settings.theme)")
                    }

                    main()
                配列を含むサンプル: |  #focus: name  #ref: ${GitHub}/MyPrivateCode/Swift/tutorial/settingObject/settingObjectArray.swift
                    // Array
                    import Foundation

                    class Config {
                        static var shared = ConfigData()  // Replacable Singleton
                    }
                    class ConfigData {
                        var version: String = "1.0.0"
                        var settings: Settings = Settings()
                        class Settings {
                            var theme: String = "dark"
                            var notifications: Bool = true
                            var maxItems: Int = 50
                        }
                        var features: [Feature] = [Feature(
                            name: "chat",
                            enabled: true,
                            config: ["maxLength": "1000"]
                        ), Feature(
                            name: "videoCall",
                            enabled: false,
                            config: ["quality": "high"]
                        )]
                        class Feature {
                            var name: String
                            var enabled: Bool
                            var config: [String: String]
                            init(
                                name: String,
                                enabled: Bool,
                                config: [String: String]
                            ) {
                                self.name = name
                                self.enabled = enabled
                                self.config = config
                            }
                        }
                    }
                    typealias ConfigSettings = ConfigData.Settings
                    typealias ConfigFeature = ConfigData.Feature

                    func main() {
                        let config: ConfigData = Config.shared
                        print("App version: \(config.version)")
                        print("Theme: \(config.settings.theme)")
                        print("Chat feature enabled: \(config.features.first { $0.name == "chat" }?.enabled ?? false)")
                        processFeature(config.features[0])
                        processFeature(config.features[1])
                    }

                    func processFeature(_ feature: ConfigFeature) {
                        print("  Processing feature: \(feature.name)")
                        print("  Enabled: \(feature.enabled)")
                        print("  Config: \(feature.config)")
                    }

                    main()
                スレッドごとに変わるサンプル:  #// get 関数を使わない実装
                    #ref: ${GitHub}/MyPrivateCode/Swift/tutorial/settingObject/settingObjectThreadLocal.swift
            継承:  #// コロンで区切ります  #keyword: Swift 継承
                サンプル: |
                    class  __ClassName__: __SuperClassOrProtocol__ {

                        // スーパークラスに追加する変数やメソッド

                        override func  __MethodName__() {  // オーバーライドするときは override を書きます
                            ____
                        } 
                    }
                複数継承するサンプル: |  #// コンマで区切ります
                    class  __ClassName__: __SuperClassOrProtocolA__, __SuperClassOrProtocolB__ {}
            extension: #keyword: Swift extension  #// クラスにメソッドなどを追加します
                概要: クラスを拡張します。 定義済みのクラスに Computed プロパティやメソッドを動的に
                    追加できます。 継承ではサブクラスの名前を参照しなければなりませんが、
                    extension では同じクラス名を使って参照できます。
                    メソッドのオーバーライドはできません。（？）
                参考:
                    - #snote: %programming%\プログラミング言語、環境\Swift.svg#extension
                    - https://www.sejuku.net/blog/33334
                サンプル コード >> 色の名前を追加: |
                    extension Color {
                        static var hagiiro: Color {
                            return Color(red: 223/255, green: 87/255, blue: 143/255, opacity: 1.0)
                        }
                    }
                プロトコルに準拠するようにクラスを拡張します: |  #// コロンの右に準拠するプロトコル名を書きます
                    extension Dice: TextRepresentable {
                    }
                    protocol TextRepresentable {
                    }
                関連:  #search: TypeScript module augmentation
            protocol >> プロトコル:  #// Java 用語でのインターフェースと同じ意味  #keyword: Swift プロトコル,  Existential Type
                サンプル: |
                    class  __ProtocolName__ {
                        var  __VariableName__: __Type__ {get set}
                        func  __MethodName__(__ArgumentLabel__ __ParameterName__: __Type__) -> __ReturnType__
                        mutating func  __MethodName__(__ArgumentLabel__ __ParameterName__: __Type__) -> __ReturnType__
                    }
                サンプルの説明:
                    - get set はどちらかでもできます
                    - let は使えません
                    - mutating が付いたメソッドしか変数の値を変更できません  #keyword: Swift mutating
            プロトコル型とジェネリクスの違い:  #ref: https://techblog.recochoku.jp/7754 >> プロトコル型とジェネリクス
                プロトコル型: |  #focus: Hoge  #// 実行時にダウンキャストします
                    func withProtocolX(_ instance: ProtocolX) { instance.method() }
                ジェネリクス: |  #focus: T  #// コンパイル時にダウンキャストします。高速です
                    func withProtocolX<T: ProtocolX>(_ instance: T) { instance.method() }
                リバース ジェネリクス: |  #// some の概念を説明するための架空の書き方  #ref: https://qiita.com/koher/items/338d2f2d0c4731e3508f >> リバースジェネリクス
                    func getProtocolX() -> <T: ProtocolX> T {
                        return InstanceX()
                    }
            some, Opaque Result Type: #keyword: Swift some, Opaque Result Type  #// 返り値に対するジェネリクス。Swift5.1 以降
                #ref: https://qiita.com/koher/items/338d2f2d0c4731e3508f
                #ref: https://techblog.recochoku.jp/7754 >> Opaque Result Typeとは
                コンパイル エラー: |  #// 使う側が T を別の型に変えて使うジェネリクスを、実装側が別の型に変えてしまっているため
                    func getProtocolX<T: ProtocolX>() -> T {
                        return InstanceX()
                    }
                some を使って解決: |  #// コンパイル時に返り値が InstanceX 型であると決まります
                    func getProtocolX() -> some ProtocolX {
                        return InstanceX()
                    }
                使う側ができること:
                    object = getProtocolX()
                    object.methodOfProtocolX()  // コンパイル時にダウンキャストします。高速です
                    object.methodOfInstanceX()  // ただし、ダウンキャストした型のメソッド等を使うとエラー！
            Deep Copy:
                https://stackoverflow.com/questions/45833983/best-way-to-assign-the-properties-of-one-object-to-another-trying-to-implement
        キャスト, as:
            アップ キャスト: |  #keyword: Swift up cast
                let any: Any = string as Any
            ダウン キャスト:  #keyword: Swift down cast
                as!: |  #keyword: Swift as!
                    let string = any as! String  // String型。ダウンキャストに失敗したらアプリを強制終了します
                as?: |  #keyword: Swift as?
                    - let string = any as? String  // String型 または nil。つまり Optional(String)
                    - if let result = result as? [String] {  // _Nullable から [String]（文字列配列）にキャストします。nil なら if ブロックは実行されません
                guard let as? else: |
                    guard let  string = any as? String else { return nil }
                UIKit でのサンプル:  #focus: rootViewController
                    initialize: |
                        let  window = UIWindow(windowScene: windowScene)
                        self.window = window
                        window.rootViewController = TabBarController()
                    event: |
                        let tabBarController = self.window!.rootViewController as! TabBarController
                        tabBarController.myMethod())  
                エラー処理の必要性:
                    ダウンキャストが失敗することが予想されない場合は、エラー処理を行わなくても構いません。
            基本型の変換:
                Double(intCount)
                TimeInterval(intCount)
            #ref: https://fukatsu.tech/swift-cast
        Optional 型:  #keyword: Swift Optional  #// nil も取りうる型
            代入: |  #keyword: Swift type ?
                var b: Int? = 2  // nilじゃない値も入れることができる
                b = nil          // nilを代入することもできる
            nil 合体演算子 (??):  #keyword: Swift nil-coalescing operator,  Swift nil 合体演算子,  Swift nil 結合演算子 ??
                基本:  #// ?? の左が nil 以外ならその値、nil なら ?? の右の値。 JavaScript の || に近い
                    -   let  __Value__ = __ValueOrNil__ ?? __ValueIfNil__
                    -   let  __Value__ = __ValueOrNil__?.string() ?? __ValueIfNil__  #// string は extension で追加したメソッドでもよい
                サンプル: |
                    let  windowPosition = self.superview?.convert(self.frame.origin, to: nil).string() ?? ""

                    extension  CGPoint {  // Return type of convert method
                        func  string() -> String {
                            return  "\(self.x), \(self.y)"
                        }
                    }
            アンラップ, unwrap:  #keyword: Swift unwrap
                if let: |  #keyword: if let
                    if let item = itemOrNil {
                        item  #// Optional 型 ではありません
                    }
                    #// ここでは item を使えません
                guard let: |  #keyword: guard let
                    guard let item = __ItemOrNil__ else {return}
                    item  #// ここでも item を使えます。 Optional 型 ではありません
                #//↓ != nil で判定、かつ ! でアンラップ（Optional 型 ではなくす）
                if: |  #// エラーになる可能性があります
                    if index != nil {
                        index!
                    }
                (!): |  #keyword: ! ?  #// nil だったらエラーになりますが、以後は Optional 型 ではなくなります
                    -   item!
                    -   (item)!
                    -   getOpt()!
                    #// ! の前に空白を入れることはできません
                (?): |  #// nil だったら以後のプロパティは評価せず nil を返します。以後も Optional 型 のままです
                    getOpt()?.property
                (?)!: |  #// ? は nil だったら以後のプロパティは評価せず nil を返します。以後も Optional 型 のままです。! で Optional 型 ではなくなります
                    (getOpt()?.property)!
            #ref: https://fukatsu.tech/optional-swift
        AnyObject: #keyword: Swift AnyObject  #// 任意のクラス、または Class only protocol の具象型
            サンプル: |
                result1 = anyObject as? AnyObject
                if let line = result1.value(forKey: "line") as? String {
        Any: #keyword: Swift Any  #// クラス、構造体、または列挙型のすべてのインスタンス
        Data 型: #keyword: Swift Data type
            .count: サイズ(byte)
            ダンプ表示: |
                let previewSize = min(32, bookmarkData.count)
                let previewData = bookmarkData.prefix(previewSize)
                let hexString = previewData.map { String(format: "%02hhx", $0) }.joined(separator: " ")
                print("First \(previewSize) bytes (hex): \(hexString)")
        ビュー階層: #keyword: Swift ビュー階層,  Swift View
            一時変数の定義: #keyword: Swift View auto variable
                一般の変数: |
                    クロージャーの中で一時変数を宣言できます。
                        { item in
                            let a = ____
                            Text(a)
                        }
                View の変数: |
                    変数に代入した View を参照するだけのコードを書きます。
                    Java などの言語では、文を評価した結果のオブジェクトはどこにも参照されませんが、
                    ビュー階層の中では親のビューから（間接的に）参照されます。
                        { item in
                            let text = Text(a)
                            text
                        }
            親子関係:
                サンプル: |
                    VStack {
                        Image(systemName: "globe")
                        Text("Hello, world!")
                    }
                解説:
                    VStack オブジェクトが直接 Image オブジェクトを参照しているわけではありません。
            ビュー モディファイアー, メソッド: #keyword: SwiftUI view modifier
                基本:
                    サンプル: |  #focus: onAppear
                        Text("Welcome!")
                            .onAppear {
                                print("The text view has appeared!")
                            }
                    解説:
                        Text(): Text クラス のオブジェクト
                        onAppear の左のピリオド:
                            Text ビューは View プロトコル に適合しており、
                            View プロトコル の onAppear ビュー モディファイアー を書くことができます。
                        onAppear の右の中カッコ:
                            クロージャー、閉じ込めるの意味、無名の関数、実行は後でクロージャーを受け取ったものを呼び出したとき。
                            定義したときの変数と関係を持つことができます。
                            中カッコは関数オブジェクトになります。onApper メソッドを呼び出すときの第1引数です。
                        中カッコがカッコの中に無いこと:  #// トレーリング クロージャ 構文
                            引数がクロージャのみである場合や、クロージャが最後の引数である場合は、
                            メソッドに渡す引数でもカッコの中に入れる必要がありません。
                            これは Swift の トレーリング クロージャ 構文 です。
                    一時変数を定義する場合:
                        #search: Swift View auto variable
                ビュー モディファイアー の並びを関数にしたい場合:  #// 複数の View に対して同様の ビュー モディファイアー を呼び出します
                    Custom View Modifier:  #ref: ${GitHub}/FiveMint/FiveMint Watch App/ContentView.swift#modifyCardView
                        サンプル: |  #focus: __Method__, __MethodObject__
                            struct ContentView: View {
                                var body: some View {
                                    VStack {
                                        Text("Hello, World!")
                                            .__Method__(1)
                                        Text("SwiftUI is awesome!")
                                            .__Method__(2)
                                    }
                                }
                                func  __Method__(_ __View__: __MethodObject__.Content, _ __Parameter__: __Type__) -> some View {
                                    return  __View__
                                        .__ModifierA__(__Parameter__)
                                        .__ModifierB__(__Parameter__)
                                }
                            }

                            extension View {
                                func __Method__(_ self_: ContentView, _ __Parameter__: __Type__) -> some View {
                                    self.modifier(__MethodObject__(self_: self_, __Parameter__: __Type__))
                                }
                            }

                            struct __MethodObject__: ViewModifier {
                                var self_: ContentView;  var __Parameter__: __Type__
                                func body(content view: Content) -> some View {
                                    return  self_.__Method__(view, __Parameter__)
                                }
                            }
                    Custom View:
                    #ref: ${typrm_files}/ref/Swift-AI.yaml#label: view modifier function
            キー パス: #keyword: Swift KeyPath,  Swift key path キーパス
                ジェネリクス使用版:
                    生成: \.__Attribute__
                    サンプル: |  #focus: \.id,  reminders
                        List(reminders, id: \.id)
                    定義サンプル: |  #focus: \.id,  KeyPath, Item, ID, Hashable
                        struct CustomList<Item, ID: Hashable> where Item: Identifiable, ID == Item.ID {
                            var items: [Item]
                            var id: KeyPath<Item, ID>
                        }
                        let customList = CustomList(items: people, id: \.id)
                シンプル版:
                    生成: |
                        \__Class__.__Attribute__
                    属性の参照: |
                        __Instance__[keyPath: __KeyPath__]
        enum　>> 列挙型:  #keyword: Swift enum
            基本サンプル: |
                enum  __EnumName__ {
                    let  __ConstantName__: __Type__ = __Value__
                    let  __ConstantName__: __Type__ = __Value__
                }
            文字列の列挙型のサンプル: |
                enum Phrase: String {
                    case updated = "Updated"
                    case sent = "Sent"
                    case received = "Received"
                }
            プロトコルに準拠した列挙型: |
                enum  __EnumName__: __Protocol__ {
                    let  __ConstantName__: __Type__ = __Value__
                    let  __ConstantName__: __Type__ = __Value__

                    mutating func  __MethodName__(__ArgumentLabel__ __ParameterName__: __Type__) -> __ReturnType__ {
                        ____
                    }
                }
            プロトコルの継承: |
                protocol  __ProtocolName__: __SuperProtocolName__ {}
            プロトコルの拡張: |  #search: Swift extension
                extension  __ProtocolName__ {}
    ファイル: #keyword: Swift file  #// ファイル操作
        一覧: #keyword: Swift file list
            サンドボックス内:
                listUpFileURLs:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/File-14-1/FirstUIKit-14-1/ViewController.swift#func  listUpFileURLs()
                    #ref: https://stackoverflow.com/questions/76186967/swift-relativepath-property-that-filemanager-default-enumerator-outputs-is-full
                    #ref: https://stackoverflow.com/questions/57640119/listing-all-files-in-a-folder-recursively-with-swift
            DocumentBasedApp 環境: #keyword: Swift file list in DocumentBasedApp  #// 「ファイル」アプリで見ることができるフォルダー
                注意: ファイルを一覧することはできません。iOS のセキュリティによって禁止されているようです。
                    #ref: ${typrm_files}/ref/Swift-AI.yaml#label: list up files in DocumentBasedApp
            Textastic 版:  #search: Textastic external folder
            AsyncStream 版:  #ref: https://stackoverflow.com/questions/57640119/listing-all-files-in-a-folder-recursively-with-swift#answer-74984577
        ストレージ: #search: iOS storage
        内容へのアクセス: #keyword: Swift file access,  Swift file read write
            UserDefaults: #search:
            URL を使ったアクセス:  #search: Xcode URL
            SMB へのアクセス:  #search: Xcode SMB  #search: startAccessingSecurityScopedResource
            NSFileCoordinator: #keyword:  #// ファイルの排他制御を管理します
                coordinate: #keyword: NSFileCoordinator coordinate
                    不要なケース: 単一アプリ内のみアクセスするファイルの場合
                    withoutChanges: #keyword:  #// アプリでファイルの内容を変更しないことを NSFileCoordinator に知らせ、排他制御を最適化します
        UUType:
            YAML の UTType:
                UTType.yaml
            画像や動画の UTType: #keyword:
                #ref: https://stackoverflow.com/questions/70102279/how-to-get-all-extensions-for-uttype-image-audio-and-video
                #ref: https://developer.apple.com/documentation/uniformtypeidentifiers/uttypereference
            その他のタイプ:
                Xcode で UTType の定義にジャンプすると一覧できます
    関数: #keyword: Swift func,  Swift function
        呼び出し >> 関数呼び出しの書式のサンプル:
            サンプル: |
                __FunctionName__()
                __Variable__ = __FunctionName__(__ArgumentLabel__: __Value__)
            __ArgumentLabel__ を省略したいとき:  #search: Swift argument _
        定義 >> 関数定義の書式のサンプル: |  #ref: https://docs.swift.org/swift-book/LanguageGuide/Functions.html
            func  __FunctionName__() {
                ____
            }

            func  __FunctionName__(__ArgumentLabel__: __Type__) -> __ReturnType__ {
                ____
                return  __ReturnValue__
            }

            func  __FunctionName__(_ __ArgumentLabel__: __Type__) -> __ReturnType__ {  // #search: Swift argument _
                ____
                return  __ReturnValue__
            }
        関数の識別:  #focus: a(a:),  b(a:b:)  #// 引数ラベルも含みます
            引数が 1つの場合:
                サンプル: |
                    func  __FunctionName__(__ArgumentLabel__: __Type__) -> __ReturnType__ {
                説明: |
                    __FunctionName__ だけでなく __FunctionName__(__ArgumentLabel__:) までが他と識別されます。
                    たとえば下記の2つは別の名前の関数です。
                        func a(a: Int) { ...   // a(a:) の定義
                        func a(b: Int) { ...   // a(b:) の定義
            引数が 2つの場合: |
                func b(a: Int, b: Int) { ...   // b(a:b:) の定義
        引数ラベルとパラメータ名: #keyword: Swift argument label
            #ref: https://docs.swift.org/swift-book/LanguageGuide/Functions.html  >>  Function Argument Labels and Parameter Names
            2つのシンボルの場合:  #// ある引数のコロンより左に 2つのシンボルがある場合。ただし 1つ目は _ ではない場合
                定義: |  #focus: __ArgumentLabel__,  __ParameterName__
                    func  __FunctionName__(__ArgumentLabel__ __ParameterName__: __Type__) {
                        print(__ParameterName__)
                    }
                呼び出し: |
                    __FunctionName__(__ArgumentLabel__: __Value__)
                概要:
                    ある引数のコロンより左に 2つのシンボルがある場合、1つ目を「引数ラベル」と呼び、関数を呼び出すときに使います。
                    2つ目を「パラメーター名」と呼び、関数の定義内で使います。
            _ とシンボルの場合: #keyword: Swift argument _  #// ある引数のコロンより左に _ と 1つのシンボルがある場合
                #// __ArgumentLabel__ （引数ラベル）を省略するとき
                定義: |  #focus: (_ __
                    - func  __FunctionName__(_ __ParameterName__: __Type__) { }
                呼び出し: |
                    - __FunctionName__(__Value__)
                概要: 関数定義の中の __ParameterName__ の左に _ を書いた関数を呼び出すときは、
                    __ArgumentLabel__ を省略できます
            1つのシンボルの場合:  #// ある引数のコロンより左に 1つのシンボルがある場合
                定義: |
                    func minMax(array: Int) {
                呼び出し: |
                    minMax(array: 8)
                概要:
                    コロンより左に 1つのシンボルがある場合は、引数ラベルとパラメーター名を同じ名前で兼ねています。
            引数の値を変える場合:  #// 関数の中で関数に渡った引数変数の値を変えます
                #// できません。関数の引数は let で宣言した変数と同様に値を変更できません。
        複数の返り値:  #ref: https://docs.swift.org/swift-book/LanguageGuide/Functions.html  >>  Functions with Multiple Return Values
            定義: |  #// タプル型（カッコで囲んだもの）を返します
                func minMax(array: [Int]) -> (min: Int, max: Int) {
                    return (1, 2)
            呼び出し: |  #// プロパティでアクセスします
                let bounds = minMax(array: [8, -6, 21])
                print("min is \(bounds.min) and max is \(bounds.max)")
            nil または複数の値を返す場合: |  #focus: ?
                func minMax(array: [Int]) -> (min: Int, max: Int)? {
                    return (1, 2)
        暗黙のリターン:  #ref: https://docs.swift.org/swift-book/LanguageGuide/Functions.html  >>  Functions With an Implicit Return
            func minMax() -> Int {
                1     // return 1 と同じ
        クロージャー: #// 名前がない関数  #keyword: Swift closure,  Swift callback function
            定義サンプル: |
                { (__ArgumentLabel__: __Value__) -> __ReturnType__ in
                    ____
                    return  __ReturnValue__
                }
            変数:  #// クロージャーを格納する変数
                書式: |
                    - var closure: () -> Void = {}
                    - let closure: (String) -> Void = { parameter in
                        }
                    - let closure: (Int) -> String = { parameter in
                            return "Result: \(parameter)"
                        }
            completion ハンドラー: #search: Swift completion handler
            参考: https://docs.swift.org/swift-book/GuidedTour/GuidedTour.html >> closures
        (@discardableResult): #keyword: @discardableResult
            呼び出し元に返り値を取ることを要求します。
            返り値を取っていない警告を無視するときは _ に代入します。 _ = __Func__()
            #ref: https://qiita.com/mono0926/items/2eb40d58275d20e89ac8
        関連 >> メソッド:  #search: Swift method
    JavaScript: #keyword: Xcode JavaScript  #// WebKit を使えば JavaScript を実行させることができます
        #ref: ${typrm_files}/ref/Swift-AI.yaml#label: iOS JavaScript
    トラブルシューティング（Swift）:  #keyword: Swift trouble shooting
        - Xcode 関連:  #search: Xcode trouble shooting
        #// ↓ エラー メッセージ
        - #// Optional 型の print
            手順: print("\(text)")
            ログ: |
                String interpolation produces a debug description for an optional value; did you mean to make this explicit?
            対処:
                text ?? "" に置き換えます。 text が Optional 型なので、このエラーが発生します。
        - #// Value of optional type '__Type__?' must be unwrapped to refer to member '__Member__' of wrapped base type '__Type__'
            手順（コード）: |
                let url = self.retrieveFile()
                if url != nil {
                    print("url: \(url.__Member__)")
                }
            ログ: |
                Value of optional type '__Type__?' must be unwrapped to refer to member '__Member__' of wrapped base type '__Type__'
                Chain the optional using '?' to access member '__Member__' only for non-'nil' base values
                Force-unwrap using '!' to abort execution if the optional value contains 'nil'
            対処: |  #// if let を使います  #search: if let
                if let bookmarkURL = self.retrieveFile() {
                    print("url: \(url.__Member__)")
                }
        - #// Closure containing control flow statement cannot be used with result builder 'ViewBuilder'
            手順（コード）: |
                var body: some View {
                    for i in 0..<views.count {
            対処A: |
                ForEach(0..<views.count) { i in
            対処B: |
                ForEach(views, id: \.self) { view in
            #search: Swift for loop
        - #// 'encodedOffset' is deprecated:
            手順: aString.endIndex.encodedOffset
            エラー: |
                'encodedOffset' is deprecated: encodedOffset has been deprecated as most common usage is incorrect. Use utf16Offset(in:) to achieve the same behavior.
            対処: |
                utf16Offset(in: text) に置き換えます
            サンプル: |
                let text = "e\u{0301}" // "e" と結合アクセント記号 "´" の組み合わせ
                print(text.count)     // 1
                print(text.endIndex.utf16Offset(in: text)) // 2
        - #// subscript(_:)' is unavailable: cannot subscript String with an integer range, use a String.Index range instead.
            手順: aString[0..<100]
            エラー: |
                subscript(_:)' is unavailable: cannot subscript String with an integer range, use a String.Index range instead.
            対処:
                Int型の代わりに index 型を指定してください  #search: Swift index
        - #// Binary operator '-' cannot be applied to operands of type 'PartialRangeUpTo<Int>' and 'CGFloat'
            手順: lines[..<lineNum-1].reduce(0)
            エラー: |
                Binary operator '-' cannot be applied to operands of type 'PartialRangeUpTo<Int>' and 'CGFloat'
            対処:
                ..<lineNum-1 を 0..<lineNum-1 に変えます
        - #// Cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
            手順: string.firstIndex など
            エラー: |
                Cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
            対処:
                string.range を使います  #search: Swift string range
        - #// Extra argument in call
            手順: |
                __Function__(__ArgumentLabel__: 0)
            エラー: |
                Extra argument in call
                Extra argument '__ArgumentLabel__' in call
            対処: |
                __ArgumentLabel__ を修正します。__ArgumentLabel__ は定義されていないため。
        - #// Expression implicitly coerced from 'String.Index?' to 'Any'
            手順: |
                print(index)
            エラー: |
                Expression implicitly coerced from 'String.Index?' to 'Any'
            対処: |  #focus: !
                print(index!)
        - #// Value of optional type 'String.Index?' must be unwrapped to a value of type 'String.Index'
            手順: |
                __String__[index]
            エラー: |
                Value of optional type 'String.Index?' must be unwrapped to a value of type 'String.Index'
            対処: |  #focus: !
                __String__[index!]
        - #// Consecutive statements on a line must be separated by ';'
            手順: |
                "a" +"b"
            エラー: |
                Consecutive statements on a line must be separated by ';'
            対処:
                + の前後に空白を入れます
                "a" + "b"
        - #// The compiler is unable to type-check this expression in reasonable time
            手順: ビルド
            エラー: |
                struct  ContentView: View {
                    var body: some View {  // The compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions
            対処:
                ForEach の中の self.__Variable__ の __Variable__ が見つからない問題を対処してください。
        - #// Class 'ListItem' has no initializers
            手順: ビルド
            エラー: |
                Class 'ListItem' has no initializers
            対処:
                init メソッドを書きます  #search: Swift class
        - #// Non-class type '____' cannot conform to class protocol '____'
            手順: ビルド
            エラー: |
                Non-class type '____' cannot conform to class protocol '____'
            対処:
                struct を class に変更します
        - #// ! __Variable__
            手順: |
                ! __Variable__
            エラー: |
                Unary operator cannot be separated from its operand
            対処A: |
                __Variable__ == false で判定します
            対処B: |
                単項演算子の影響範囲をカッコで囲み、括弧の内側に空白を入れます。
                !( __Variable__ )
                （これも見逃しやすい）
            対処C: |
                単項演算子の右の空白を削除します。ただし、単項演算子を読み逃しやすくなります。
                !__Variable__
        - #// Cannot use mutating member on immutable value
            手順: コンパイル エラー
            エラー: |
                Cannot use mutating member on immutable value: '__Variable__' is a 'let' constant
            対処:
                var  __Variable__ = __Variable__ を書きます
        - #// 関数の引数を変数にしたい
            エラー: |
                Cannot assign to value: '__Argument__' is a 'let' constant
            対処:
                var  __Argument__ = __Argument__
Xcode:  #// IDE  #keyword: Xcode  #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode
    手順, サンプル:  #keyword: Xcode project steps
        注意: プロジェクトが壊れることがあるため、Git によるバージョン管理が必須です
        #// ↓ よく使う項目
        プロジェクト: #keyword: Xcode projects  #// サンプル
            UIKit の シンプル プロジェクト: #keyword: UIKit simple projects
                構成: |
                    first-14-1
                    FirstUIKit-14-1
                        FirstUIKitCode-14-1
                            UIButton2-14-1
                            TabBar-14-1
                                UIStackView-14-1
                                AutoLayout-14-1
                                    UIButton-14-1
                                        UIMenu-14-1
                                        DownloadButton-14-1
                                UITextField-14-1
                                    UITextFieldKeyboard-14-1
                                UITextViewAttribute-14-1
                                UITableView-14-1
                                UIImageView-14-1
                                DocumentBrowser-14-1
                                    DocumentBookmark-14-1
                            File-14-1
                            UITableView2-14-1
                            UNUserNotification-14-1
                一覧:  #glossary: UIKit simple projects
                    AutoLayout-14-1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/AutoLayout-14-1
                    DocumentBrowser-14-1: #keyword: DocumentBrowser  #ref: ${GitHub}/MyPrivateCode/Swift/1st/DocumentBrowser-14-1
                        #search: DocumentBasedApp
                        クラス構成: |
                            AppDelegate:UIApplicationDelegate  #search: UIKit class structure
                                SceneDelegate:UIWindowSceneDelegate
                                    TabBarController
                                        DocumentBrowserViewController
                                        ViewController
                        動作確認手順:
                            アップロードします:  #// アプリで開くファイルをシミュレーターにアップロードします  #search: Xcode simulator file
                                .yaml などの テキスト ファイル をアップロードします
                            タップします:  #// アプリで開くファイルをタップします
                                内容とパスが print されます
                        コール ツリー: #keyword: DocumentBrowser code  #search: Xcode DocumentBasedApp
                            viewDidLoad:
                                # class ViewController: UIViewController {
                                #     override func viewDidLoad() {
                                # class DocumentBrowserViewController: UIDocumentBrowserViewController, UIDocumentBrowserViewControllerDelegate {
                                #     override func viewDidLoad() {
                                _: ドキュメント ブラウザー（ファイル一覧）が開きます
                            +（新規）をタップしたとき:
                                documentBrowser(_:didRequestDocumentCreationWithHandler:):
                                    # func documentBrowser(_ controller: UIDocumentBrowserViewController, didRequestDocumentCreationWithHandler
                            ファイルをタップしたとき:
                                func documentBrowser(_:didPickDocumentsAt:):
                                    # func documentBrowser(_ controller: UIDocumentBrowserViewController, didPickDocumentsAt documentURLs: [URL]) {
                                    startAccessingSecurityScopedResource:
                                    #     let fileContents = try! String(contentsOf: sourceURL)
                                    String(contentsOf:):  #// ファイル リード  #search: Swift String contentsOf
                                    stopAccessingSecurityScopedResource:
                                    _:    print(fileContents)
                    DocumentBookmark-14-1: #keyword: DocumentBookmark  #ref: ${GitHub}/MyPrivateCode/Swift/1st/DocumentBookmark-14-1
                        セキュリティスコープ付きブックマーク: #keyword: Xcode url.bookmarkData
                            saveBookmark:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/DocumentBookmark-14-1/FirstUIKit-14-1/ViewController.swift#func saveBookmark
                            retrieveFile:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/DocumentBookmark-14-1/FirstUIKit-14-1/ViewController.swift#func retrieveFile
                        動作確認手順:
                            基本:
                                アップロードします:  #// アプリで開くファイルをシミュレーターにアップロードします  #search: Xcode simulator file
                                    .yaml などの テキスト ファイル をアップロードします
                                タップします:  #// アプリで開くファイルをタップします
                                    ブックマークに保存され、内容とパスが print されます
                                アプリを再起動します:
                                    ブックマークに保存されているパスと内容が print されます
                            更新:
                                内容を変えてアップロードします:
                                    .yaml などの テキスト ファイル をアップロードします
                                アプリを再起動します:
                                    内容はアップロードする前です
                        コール ツリー: #keyword: DocumentBookmark code
                            ベース:  #search: DocumentBrowser
                            #focus: saveBookmark, retrieveFileFromBookmark
                            ファイルをタップしたとき:
                                # func documentBrowser(_ controller: UIDocumentBrowserViewController, didPickDocumentsAt documentURLs: [URL]) {
                                #     self.saveBookmark(for: sourceURL)
                                saveBookmark:
                                    _: |
                                        let bookmarkData = try url.bookmarkData(options: .minimalBookmark, includingResourceValuesForKeys: nil, relativeTo: nil)
                                    #   UserDefaults.standard.set(bookmarkData, forKey: Config.shared.bookmarkKey)
                                    url.bookmarkData:
                            アプリを起動したとき:
                                viewDidLoad:
                                    # class DocumentBrowserViewController: UIDocumentBrowserViewController, UIDocumentBrowserViewControllerDelegate {
                                    #     override func viewDidLoad() {
                                    _:        if let bookmarkURL = self.retrieveFileFromBookmark() {
                                    retrieveFileFromBookmark:
                                    #             let accessing = bookmarkURL.startAccessingSecurityScopedResource()
                                    startAccessingSecurityScopedResource:
                                    #     let fileContents = try! String(contentsOf: sourceURL)
                                    String(contentsOf:):  #// ファイル リード  #search: Swift String contentsOf
                                    stopAccessingSecurityScopedResource:
                                    __:   print(fileContents)
                        参考にしたサンプル:
                            コード: |
                                import UIKit

                                @available(iOS 15.0, *)
                                class DocumentAccessManager {
                                    static let shared = DocumentAccessManager()
                                    private let bookmarkKey = "fileBookmark"
                                    
                                    private init() {}
                                    
                                    func saveBookmark(for url: URL) throws {
                                        let bookmarkData = try url.bookmarkData(options: .minimalBookmark, includingResourceValuesForKeys: nil, relativeTo: nil)
                                        UserDefaults.standard.set(bookmarkData, forKey: bookmarkKey)
                                    }
                                    
                                    func retrieveFile() throws -> URL {
                                        guard let bookmarkData = UserDefaults.standard.data(forKey: bookmarkKey) else {
                                            throw DocumentAccessError.fileNotFound
                                        }
                                        
                                        var isStale = false
                                        let url = try URL(resolvingBookmarkData: bookmarkData, options: [], relativeTo: nil, bookmarkDataIsStale: &isStale)
                                        
                                        if isStale {  // #search: Swift URL isStale
                                            try saveBookmark(for: url)
                                        }
                                        
                                        return url
                                    }
                                    
                                    func accessFile() async throws -> String {
                                        let url = try retrieveFile()
                                        
                                        guard url.startAccessingSecurityScopedResource() else {
                                            throw DocumentAccessError.accessDenied
                                        }
                                        
                                        defer {
                                            url.stopAccessingSecurityScopedResource()
                                        }
                                        
                                        let coordinator = NSFileCoordinator()
                                        return try await coordinator.coordinate(readingItemAt: url, options: .withoutChanges) { url in
                                            try String(contentsOf: url, encoding: .utf8)
                                        }
                                    }
                                    
                                    func updateFile(with content: String) async throws {
                                        let url = try retrieveFile()
                                        
                                        guard url.startAccessingSecurityScopedResource() else {
                                            throw DocumentAccessError.accessDenied
                                        }
                                        
                                        defer {
                                            url.stopAccessingSecurityScopedResource()
                                        }
                                        
                                        let coordinator = NSFileCoordinator()
                                        try await coordinator.coordinate(writingItemAt: url, options: []) { url in
                                            try content.write(to: url, atomically: true, encoding: .utf8)
                                            try self.saveBookmark(for: url)
                                        }
                                    }
                                }

                                enum DocumentAccessError: Error {
                                    case fileNotFound
                                    case accessDenied
                                }

                                // 使用例
                                @available(iOS 15.0, *)
                                class ViewController: UIViewController {
                                    @IBOutlet weak var textView: UITextView!
                                    
                                    override func viewDidAppear(_ animated: Bool) {
                                        super.viewDidAppear(animated)
                                        
                                        Task {
                                            await loadFile()
                                        }
                                    }
                                    
                                    private func loadFile() async {
                                        do {
                                            let content = try await DocumentAccessManager.shared.accessFile()
                                            await MainActor.run {
                                                self.textView.text = content
                                            }
                                        } catch {
                                            print("Failed to load file: \(error)")
                                            await MainActor.run {
                                                self.presentDocumentPicker()
                                            }
                                        }
                                    }
                                    
                                    private func presentDocumentPicker() {
                                        let documentPicker = UIDocumentPickerViewController(forOpeningContentTypes: [.plainText])
                                        documentPicker.delegate = self
                                        documentPicker.allowsMultipleSelection = false
                                        present(documentPicker, animated: true)
                                    }
                                    
                                    @IBAction func saveButtonTapped(_ sender: Any) {
                                        guard let content = textView.text else { return }
                                        
                                        Task {
                                            do {
                                                try await DocumentAccessManager.shared.updateFile(with: content)
                                                print("File saved successfully")
                                            } catch {
                                                print("Failed to save file: \(error)")
                                            }
                                        }
                                    }
                                }

                                @available(iOS 15.0, *)
                                extension ViewController: UIDocumentPickerDelegate {
                                    func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
                                        guard let selectedFileURL = urls.first else { return }
                                        
                                        Task {
                                            do {
                                                try DocumentAccessManager.shared.saveBookmark(for: selectedFileURL)
                                                await loadFile()
                                            } catch {
                                                print("Failed to save bookmark: \(error)")
                                            }
                                        }
                                    }
                                }
                            コール ツリー:
                                ViewController class:
                                    viewDidAppear:
                                    loadFile:
                                        # private func loadFile() async {
                                        #     let content = try await DocumentAccessManager.shared.accessFile()
                                        accessFile:
                                            # func accessFile() async throws -> String {
                                            #     let url = try retrieveFile()
                                            retrieveFile:
                                                # func retrieveFile() throws -> URL {
                                                #     let url = try URL(resolvingBookmarkData: bookmarkData, options: [], relativeTo: nil, bookmarkDataIsStale: &isStale)
                                                isStale: #keyword: Swift URL isStale  #// ファイルの移動, ファイルシステムの変更, 権限の変更 などがあったかどうか
                                                    true:
                                                        url:
                                                            以前指していたファイルの新しい URL。
                                                            OS が追跡できなければ古い URL のままとなり、ファイルの内容が変わるか、見つからないエラーになるでしょう
                                                #     if isStale {
                                                #         try saveBookmark(for: url)
                                                #     return url
                                                （isStale == true の場合）:  #// ブックマークが指すファイルのパス(URL)を更新します
                                                    saveBookmark:
                                                        # func saveBookmark(for url: URL) throws {
                                                        #     let bookmarkData = try url.bookmarkData(options: .minimalBookmark, includingResourceValuesForKeys: nil, relativeTo: nil)
                                                        #     UserDefaults.standard.set(bookmarkData, forKey: bookmarkKey)
                                            startAccessingSecurityScopedResource:
                                            # let coordinator = NSFileCoordinator()
                                            # return try await coordinator.coordinate(readingItemAt: url, options: .withoutChanges) { url in
                                            #     try String(contentsOf: url, encoding: .utf8)
                                            (defer) stopAccessingSecurityScopedResource:
                                        #     await MainActor.run {
                                        #         self.textView.text = content
                    DocumentPicker-14-1: #keyword: DocumentPicker  #ref: ${GitHub}/MyPrivateCode/Swift/1st/DocumentPicker-14-1
                        #search: UIDocumentPickerViewController
                        動作確認手順:
                            フォルダーのブックマークを保存します:
                                Get ボタン >> _search_target ファイルがあるフォルダー（Working Copy アプリが公開した steps リポジトリ）の内容を表示 >> 開く（右上）
                            ブックマークが指すファイルの内容を表示します:
                                Read ボタン >> Xcode のコンソールを確認
                    DownloadButton-14-1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/DownloadButton-14-1
                        #search: DownloadButton.playground
                    File-14-1:  #glossary:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/File-14-1
                        listUpFileURLs:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/File-14-1/FirstUIKit-14-1/ViewController.swift#func  listUpFileURLs(
                        writeFileByURL:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/File-14-1/FirstUIKit-14-1/ViewController.swift#func  writeFileByURL(
                        readFileByURL:   #ref: ${GitHub}/MyPrivateCode/Swift/1st/File-14-1/FirstUIKit-14-1/ViewController.swift#func  readFileByURL(
                        listUpItems:     #ref: ${GitHub}/MyPrivateCode/Swift/1st/File-14-1/FirstUIKit-14-1/ViewController.swift#func  listUpItems(
                        readFile:        #ref: ${GitHub}/MyPrivateCode/Swift/1st/File-14-1/FirstUIKit-14-1/ViewController.swift#func  readFile(
                        writeFile:       #ref: ${GitHub}/MyPrivateCode/Swift/1st/File-14-1/FirstUIKit-14-1/ViewController.swift#func  writeFile(
                    first-14-1:  #ref: #ref: ${GitHub}/MyPrivateCode/Swift/1st/first-14-1
                    FirstUIKitCode-14-1: #🌟  #ref: ${GitHub}/MyPrivateCode/Swift/1st/FirstUIKitCode-14-1
                        FirstUIKit-14-1 から Storyboard を除いたもの。コードだけで作れるもの
                        self.view.backgroundColor = .blue が画面全体に表示されるだけ
                    FirstUIKit-14-1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/FirstUIKit-14-1
                        新しいプロジェクトで作られるもの ただし Interface = Storyboard
                    JavaScript-14-1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/JavaScript-14-1
                    SubViewControl-14-1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/SubViewControl-14-1
                        #ref: https://www.swiftbysundell.com/basics/child-view-controllers/
                    SwiftApp1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/SwiftApp1
                    TabBar-14-1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/TabBar-14-1
                        ツールバー。画面の下のボタンの並び。
                        ベースは FirstUIKitCode-14-1
                        #ref: https://tech.amefure.com/swift-uikit-uitabbarcontroller
                        #search: Xcode tab bar
                    UIButton-14-1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/UIButton-14-1
                        TabBar あり
                    UIButton2-14-1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/UIButton2-14-1
                        TabBar なし
                    UIImageView-14-1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/UIImageView-14-1
                    UIMenu-14-1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/UIMenu-14-1
                    UIStackView-14-1:  #// うまく動かない  #ref: ${GitHub}/MyPrivateCode/Swift/1st/UIStackView-14-1
                    UITableView-14-1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/UITableView-14-1
                    UITableView2-14-1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/UITableView2-14-1
                    UITableViewCell-14-1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/UITableViewCell-14-1
                    UITextField-14-1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/UITextField-14-1
                    UITextFieldKeyboard-14-1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/UITextFieldKeyboard-14-1
                        #// タブ バー あり
                    UITextFieldKeyboard2-14-1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/UITextFieldKeyboard2-14-1
                        #// タブ バー なし 2025-01版
                    UITextViewAttribute-14-1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/UITextViewAttribute-14-1
                        #search: install CocoaPods
                    UNUserNotification-14-1: #ref: ${GitHub}/MyPrivateCode/Swift/1st/UNUserNotification-14-1
                        #search: Xcode 通知
            SwiftUI の シンプル プロジェクト:
                SwiftUI Xcode 14.1:
                    first-14-1: #ref: ${GitHub}/MyPrivateCode/Swift/1st/first-14-1
            自作アプリケーション:
                もうすぐ通知:  #keyword: CommingSoonNotification, もうすぐ通知  #ref: ${GitHub}/comming-soon-notification
                    #ref: https://github.com/Takakiriy/comming-soon-notification
                    旧: #ref: ${GitHub}/MyPrivateCode/Swift/CommingSoonNotification_old
                typrm for IOS: #keyword: typrm_iOS  #ref: ${GitHub}/typrm_iOS
                ToDoSwicher:  #ref: ${GitHub}/MyPrivateCode/ToDoSwicher
                TreeTextViewer:  #ref: ${GitHub}/TreeTextViewer
        検索: #ref: https://developer.apple.com/search/  #// クラス名（空白）メソッド名で検索できます
            サンプル: DocumentBrowserViewController init(forOpening:)
        Playground:  #search: Xcode Playground
        #// ↓ インストール
        初期設定(Xcode):
            Minimap を消します:  #// Minimap とは、スクロール バー の位置にある ソース ファイル の縮小表示です  #keyword: Xcode minimap
                Xcode >> Editor >> Minimap
            右端で折り返したときのインデントを深くします:
                設定方法:
                    メニュー: Xcode >> Xcode（メニュー）>> Preferences（上から3番目）>> TextEditing（タブ）>>
                    Display（子タブ）:
                        Line Wrapping:
                            Indent wrapped lines by: 8 spaces
                    Indentation（子タブ）:
                        Syntax-Aware Indenting:
                            Indent when typing: オフ
                理由:  インデントが浅いために読み間違えることがあるからです
                サンプル: |
                    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> 
                        Int {  // ここは関数定義の中ではありません
                        return contents.count
                    }
        キーボード ショートカット: #keyword: Xcode keyboard
            行頭・行末へキャレットを移動します: command + ←, command + →
            コメント アウト します: #keywrod: Xcode comment out
                ショートカット: command + /
                インデントした位置に // を挿入する場合:
                    Comment Here 拡張機能をインストールします:
                        #ref: https://itunes.apple.com/us/app/comment-here/id1406737173?mt=12
                        Comment Here を開く >> Open System Preferenced for Extensions >> Xcode Source Editor >>
                            （チェックを入れる）>> 完了 >>
                        Comment Here を起動 >> Comment Here を最小化 >>
                            Xcode を(完全終了してから再度)起動 >> Xcode メニュー >> Settings >>
                        Key Bindings タグ >> (Filter:) Comment（と入力）>>
                            Comment Selection（の Key 列をダブルクリック）>> (-) >>
                            Comment Here（の Key 列をダブルクリック）>> command + / >>
                            （Enter を押さずに Key 列以外をクリック）>>
                        #ref: https://stackoverflow.com/questions/41497913/is-it-possible-to-change-the-way-xcode-indents-comment-lines
        #// ↓ ビルド チュートリアル
        ビルドします:  #search: Xcode run on device
        SwiftUI, Xcode で新規作成アプリをビルドします(Xcode 12.3):  #keyword: Xcode SwiftUI tutorial
            作成済みのプロジェクト: #keyword: SwiftApp1
                SwiftUI Xcode 14.1:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/first-14-1
                旧:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/SwiftApp1
            参考: Swift Xcode でボタンを押したときのコードを書く
                https://dev.classmethod.jp/articles/swift-xcode-beginner01/
            Xcode を起動 >> Create a new Xcode project:  #// または Xcode >> File >> New >> Project
                タブ: iOS
                Application: App
                Next ボタン:
                Product Name: SwiftApp1  #template) __ProductName__
                Organization Identifier: sage-p  #original: OurOrg
                Interface: SwiftUI
                チェック: Include Tests
                Next ボタン(2):
                （保存先フォルダー）: 例： Desktop  #// 指定したフォルダーに Product Name の値の名前のフォルダーができます
                Create ボタン:
                もし、 No author information was supplied by the version control system エラーになったら:
                    Canel ボタン:
                    #// 後で Xcode >> Preferences で設定できます。
            初期設定をします:
                キャンバスを表示する: ContentView.swift ファイルを選択 >> Editor（Edit ではない）>> Canvas
                #// その他、snote の Xcode >> 初期設定 を参照
            プレビューを表示します（簡易エミュレーターを動かします）:  #keyword: Xcode preview
                Xcode >> ContentView.swift ファイルを選択 >>（Editor >> Canvas） >>
                    Resume(Preview) ボタン（Canvas の右上） >> （必要なら）縮小表示ボタン（右下）
                関連  #search: Xcode preview for Watch
            コードを変更してみる: #focus: ハローワールド
                ContentView.swift:
                    変更前: |
                        struct ContentView: View {
                            var body: some View {
                                Text("Hello, world!")
                                    .padding()
                            }
                        } 
                    変更後: |
                        struct ContentView: View {
                            var body: some View {
                                Text("ハローワールド！")  // ここを変更します
                                    .padding()
                            }
                        } 
                #// 保存しなくても即座にプレビューに反映されます
            シミュレーターを起動します:  #keyword: start Xcode simulator
                シミュレーターの種類（スキーム）を変えます:  #keyword: Xcode scheme
                    Set the active scheme（エディターの上左）: iPod, iPhone, iPad など
                    #関連:  #search: Xcode scheme for Watch
                シミュレーターを起動します:
                    Build and then run the current scheme ボタン（エディターの左上、再生ボタン風）:
                #search: Xcode simulator
            実機で動かします:  #keyword: Xcode run on device
                Xcode のプロジェクトを開きます:
                実機と開発用 mac を USB ケーブルで接続します:
                iPhone を開発モードに設定します: #keyword: iPhone developer mode,  デベロッパー モード
                    #// iOS 16 以降
                    メニュー: iPhone >> 設定 >> プライバシーとセキュリティ >> デベロッパモード（最も下のグループ）>>
                        オン >> 再起動 >>（デベロッパモードを）オンにする
                シミュレーターの種類（スキーム）を変えます:
                    （エディターの上）: __自分で付けた実機の名前__
                （必要なら）デバイスの接続状態を確認します: #keyword: Xcode connect device
                    メニュー: Xcode >> Window >> Devices and Simulators（やや下）>> Devices（左上）
                    メモ: PAIRED WATCHES に接続している Apple Watch も表示されます。
                        Go ボタン が表示されたときは、Go ボタン を押してシミュレーターをダウンロードすると接続できるようになります
                    #search: Xcode devices
                    #search: Xcode device trouble
                クリーンします:
                    Xcode >> Product（メニュー）>> Clean Build Folder
                ビルドして実機にアプリを転送します: #keyword: Xcode upload to device
                    Build and then run the current scheme ボタン（エディターの左上、再生ボタン風）:
                （初回の場合）キーチェーン"ログイン"のパスワードを入力します:
                    mac のキーチェーン"ログイン"のパスワードは、mac の電源を入れてから入力する自分のパスワードです。
                （初回の場合）実機からアプリを起動します:
                    #// 初回は信頼されていないデベロッパの警告がされます
                    デベロッパ（自分の開発アカウント）を信頼するように実機に設定します:
                        iOS16:
                            iPhone >> 設定 >> 一般 >> VPN とデバイス管理 >> Apple Development： __Account__ >> 信頼 >>
                            もう一度アプリを起動します
                        旧iOS:
                            iOSデバイス >> 設定 >> 一般 >> プロファイル >> Apple Development： __Account__ >> 信頼 >>
                            もう一度アプリを起動します
                （２回目以降の場合）Build and then run the current scheme ボタンを押すと実機でアプリが起動します:
                不要になったら実機のアプリを削除します:
                （上書きされる場合）:  #// デバイスにアプリをアップロードすると、他のアプリを上書きしてしまう場合
                    バンドル ID を変えます:  #search: bundle ID
        Storyboard, MVC のプロジェクトを新しく作ります:  #keyword: Xcode Storyboard MVC
            #// 以前 Single View App と呼ばれていたものは、この Storyboard を使うプロジェクトのことです  #keyword: Single View App
            作成済みのプロジェクト:
                #ref: ${GitHub}/MyPrivateCode/StoryboardApp1/Swift/old/StoryboardApp1.xcodeproj  #keyword: StoryboardApp1
                #ref: ${GitHub}/MyPrivateCode/StoryboardApp2/Swift/old/StoryboardApp2.xcodeproj  #keyword: StoryboardApp2
                    #search: Xcode Storyboard official tutorial
                #ref: ${GitHub}/MyPrivateCode/StoryboardApp3/Swift/old/StoryboardApp3.xcodeproj  #keyword: StoryboardApp3
            Xcode を起動 >> Create a new Xcode project:  #// または Xcode >> File >> New >> Project
                タブ: iOS
                Application: App  #// Single View App は、どのタブにもありません 
                Next ボタン:
                Product Name: StoryboardApp1
                Team: None
                Organization Identifier: sage-p  #// Your organization
                Interface: Storyboard
                Life Cycle: UIKit App Delegate
                Language: Swift
                Next ボタン (2):
                （保存先フォルダー）: 例： Desktop
                Create ボタン:
            __Project__/__App__/ViewController.swift : |  #// 以下の内容に置き換えます
                import UIKit

                class ViewController: UIViewController {

                    override func viewDidLoad() {
                        super.viewDidLoad()

                        let rect1 = UIView()
                        rect1.frame = CGRect(x: 20, y: 40, width: 30, height: 40)
                        rect1.backgroundColor = UIColor.cyan
                        view.addSubview(rect1)
                    }
                }
            シミュレーターで動かします:
                #search: SwiftApp1
        Storyboard >> 公式:  #keyword: Xcode Storyboard official tutorial
            ❗: 書きかけ
            Storyboard アプリを作ります:  #// Interface Builder を使って UI を配置します
                公式: #// https://developer.apple.com/tutorials/app-dev-training/creating-a-storyboard-app
                プロジェクトを新規作成します:
                    #search: Xcode Storyboard MVC
                        #// プロジェクトを作るところまで
                Table View Controller を Initial View Controller（メイン）に設定します: #keyword: Xcode Initial View Controller tutorial
                    __Project__/__App__/Main.storyboard:
                        初期状態で既にあるビューを削除します:
                            View Controller Scene >> Back Space キー
                        Table View Controller を追加します:
                            - ＋（右上 左）  #search: Xcode Library
                            - Objects: キーワード「Table View Controller」を入力します
                            - Table View Controller からドラッグを開始して Canvas にドロップします  #search: Xcode Canvas
                        メインのビューに設定します:
                            View Controller を選択します:
                                Document Outline:  #search: Xcode Document Outline
                                    Table View Controller: （クリック）
                            Initial View Controller に設定します:
                                Attribute Inspector:  #search: Xcode Attribute Inspector
                                    View Controller: #// 3つ目のグループ
                                    Is Initial View Controller: オン
                iPhone 12 Pro シミュレーターを使うように設定します:
                    device targets: iPhone 12 Pro  #search: Xcode device targets
                    build and run ボタン:  #search: Xcode build and run
                Model（リマインダーデータソース）を作成します:  #keyword: Swift MVC Model
                    参考:
                        MVC:  #search: Swift MVC
                    __Project__/__App__/Reminder.swift : |
                        import Foundation

                        struct Reminder {
                            var title: String
                            var dueDate: Date
                            var notes: String? = nil
                            var isComplete: Bool = false
                        }

                        extension Reminder {
                            static var testData = [
                                Reminder(title: "Submit reimbursement report", dueDate: Date().addingTimeInterval(800.0), notes: "Don't forget about taxi receipts"),
                                Reminder(title: "Code review", dueDate: Date().addingTimeInterval(14000.0), notes: "Check tech specs in shared folder", isComplete: true),
                                Reminder(title: "Pick up new contacts", dueDate: Date().addingTimeInterval(24000.0), notes: "Optometrist closes at 6:00PM"),
                                Reminder(title: "Add notes to retrospective", dueDate: Date().addingTimeInterval(3200.0), notes: "Collaborate with project manager", isComplete: true),
                                Reminder(title: "Interview new project manager candidate", dueDate: Date().addingTimeInterval(60000.0), notes: "Review portfolio"),
                                Reminder(title: "Mock up onboarding experience", dueDate: Date().addingTimeInterval(72000.0), notes: "Think different"),
                                Reminder(title: "Review usage analytics", dueDate: Date().addingTimeInterval(83000.0), notes: "Discuss trends with management"),
                                Reminder(title: "Confirm group reservation", dueDate: Date().addingTimeInterval(92500.0), notes: "Ask about space heaters"),
                                Reminder(title: "Add beta testers to TestFlight", dueDate: Date().addingTimeInterval(101000.0),  notes: "v0.9 out on Friday")
                            ]
                        }
                InterfaceBuilder でプロトタイプセルを構築します:  #// プロトタイプセルは画面上部です
                    __Project__/__App__/Main.storyboard を選択します:
                    Table View Cell の行の高さを99に設定します:
                        Table View Cell を選択します:
                            Document Outline:  #search: Xcode Document Outline
                                Table View Controller:
                                    Table View:
                                        Table View Cell:
                        高さを99に設定します:
                            Size Inspector:  #search: Xcode Size Inspector
                                Table View Cell:
                                    Row Height: 99
                    丸ボタンを新しく配置します:
                        ボタンを新しく配置します:
                            ＋ ボタン（右上 左）:  #search: Xcode Library
                                Objects: キーワード「Button」を入力します
                                ドラッグ＆ドロップ: Button ⇒ Prototype Cells（iPhone 画面上部）
                        タイトルを削除して代わりに円を設定します:
                            Attribute Inspector:  #search: Xcode Attribute Inspector
                                Title（の2行目：上から 4番目）: （空欄にします）
                                Background（上から 9番目）: circle
                        ボタンのサイズを設定します:
                            Size Inspector:  #search: Xcode Size Inspector
                                View:
                                    Width: 44
                                    Height: 44
                                    #// このサイズは、ヒューマンインターフェイスガイドラインを満たす最小サイズです
                                    #//  https://developer.apple.com/design/human-interface-guidelines/accessibility/overview/user-interaction/
                    Title ラベルを新しく配置します:
                        ラベルを新しく配置します:
                            ＋ ボタン（右上 左）:  #search: Xcode Library
                                Objects: キーワード「Label」を入力します
                                ドラッグ＆ドロップ: Label ⇒ 先ほど作った丸ボタンの右
                        ラベルの内容を Title に変更します:
                            Attribute Inspector:  #search: Xcode Attribute Inspector
                                Text（の2行目：上から 2番目）: Title
                    日付ラベルを新しく配置します:
                        ラベルを新しく配置します:
                            ＋ ボタン（右上 左）:  #search: Xcode Library
                                Objects: キーワード「Label」を入力します
                                ドラッグ＆ドロップ: Label ⇒ 先ほど作った Title ラベルの下
                        ラベルの内容を Date に変更します:
                            Attribute Inspector:  #search: Xcode Attribute Inspector
                                Text（の2行目：上から 2番目）: Date
            自動レイアウトによる制約を設定します:  #keyword: Xcode constraint button example
                公式: #// https://developer.apple.com/tutorials/app-dev-training/setting-constraints-with-auto-layout
                参考:
                    制約: #search: Xcode constraints
                __Project__/__App__/LaunchScreen.storyboard :
                    丸ボタン: #keyword: Storyboard rounded button
                        概要:
                            Leading Space to Container: =, Standard
                            Width: 44
                            Aspect Ratio: 1:1
                            Align Center Y to: Superview
                        手順:
                            左側のスペースの制約を設定します:
                                丸ボタンを選択します: クリックします
                                Add New Constraints:  #search: Xcode Add New Constraints usage
                                    Constrain to mergins: オフ
                                    Left: Standard（BackSpace キーを押して空欄にします）
                                    Left |←→|: オン（赤くします）
                                    Add 1 Constraint ボタン:
                                        #// 制約(Constraints)は、Document Outline と Size Inspector に追加されます
                                        #search: Xcode Document Outline
                                        #search: Xcode Size Inspector
                            縦横比の制約を設定します:
                                丸ボタン: クリックします
                                Add New Constraints:  #search: Xcode Add New Constraints usage
                                    Width: チェック, 44
                                    Aspect Ratio: オン
                                    Add 2 Constraints ボタン:
                                Size Inspector:  #search: Xcode Size Inspector
                                    Aspect Ratio:  #// Size Inspector の下側
                                        （Ratio to）Edit:
                                            Multipliier: 1:1
                            縦の中央位置の制約を設定します:
                                丸ボタン: クリックします
                                Align:  #search: Xcode Align
                                    Virtically in Container: オン
                                    Add 1 Constraint ボタン:
                    Title ラベル:
                        概要:
                            Top Space to Container: =, Standard
                            Leading Space to:
                                target: 丸ボタン
                                value: =, Standard
                            Trailing Space to Container: ≧, Standard
                        手順:  #search: Xcode add constraints
                            Top Space to Container 制約を追加します:  #// 上側のスペース  #keyword: Xcode constraint drag example
                                メニュー:
                                    - Document Outline >>（controlを押しながら）[L]Title（から）Content View（親要素：へドラッグ）>>
                                        Top Space to Container
                                    - Size Inspector >>（Top Space to の）Edit
                                Constraint: Standard（右側の青いボタン >> Use Standard Value）
                            Title ラベルと丸ボタンとの間隔の Horizo​​ntal Spacing 制約を追加します:
                                メニュー:
                                    - Canvas >>（controlを押しながら）[L]Title（から）丸ボタン（へドラッグ）>>
                                        Horizo​​ntal Spacing
                                    - Size Inspector >>（Leading Space to の）Edit
                                Constraint: Standard（右側の青いボタン >> Use Standard Value）
                            Trailing Space to Container 制約を追加します:  #// 右側のスペース
                                メニュー:
                                    - Canvas >>（controlを押しながら）[L]Title（から）Content View（へドラッグ）>>
                                        Trailing Space to Container
                                Constraint:
                                    演算子: ≧
                                    値: Standard（右側の青いボタン >> Use Standard Value）
                    Date ラベル:  #search: Xcode add constraints
                        Trailing Space to Container: ≧, Standard
                        Align Leading to: Title
                        Top Space to:
                            target: Title ラベル
                            value: =, Standard
                        Bottom Space to Container: ≧, Standard
            GUI 部品とコード(View)を接続するアウトレットとアクションを追加します:  #keyword: Xcode connect example
                公式: #// https://developer.apple.com/tutorials/app-dev-training/connecting-outlets-and-actions
                ビューとコードを接続します:
                    Table View Cell から ReminderListCell クラスへの参照を設定します:
                        概要:
                            GUI:
                                File: __Project__/__App__/Main.storyboard
                                Object: Table View Cell
                            Code:
                                File: __Project__/__App__/ReminderListCell.swift
                                class: ReminderListCell
                        操作:
                            Table View Cell の親クラスを調べます:
                                __Project__/__App__/Main.storyboard :
                                    Document Outline:  #search: Xcode Document Outline
                                        Table View Controller:
                                            Table View:
                                                Table View Cell: をクリック
                                    Identity Inspector:  #search: Xcode Identity Inspector
                                        Custom Class:
                                            Class: ここに何も入力しないと必要な親クラス UITableViewCell が薄く表示されます
                            ReminderListCell クラスを新しい swift ファイルに作ります:
                                __Project__/__App__/ReminderListCell.swift : |
                                    import UIKit

                                    class ReminderListCell: UITableViewCell {
                                    }
                            Table View Cell の Class 属性を ReminderListCell クラスに設定します:
                                Class: ReminderListCell （項目に入力するか、項目の右にある青いボタンから選びます）
                            クラスを選べないとき:
                                親クラスを調べます:
                                    Identity Inspector:  #search: Xcode Identity Inspector
                                        Custom Class:
                                            Class: ここに何も入力しないと必要な親クラスが薄く表示されます
                                コードを調べます:
                                    必要な親クラスから継承されたクラスの定義（コード）があることをチェックしてください
                GUI 部品を参照するコードにアウトレット（接続）を追加します:  #keyword: Xcode outlet example
                    Title ラベルに接続するコードを追加します:
                        概要:
                            GUI:
                                File: __Project__/__App__/Main.storyboard
                                Object: Title ラベル
                            Code:
                                File: __Project__/__App__/ReminderListCell.swift
                                所属先クラス: ReminderListCell
                                Name: titleLabel
                                Storage: Strong
                        手順:
                            __Project__/__App__/ReminderListCell.swift :
                                画面分割(Assistant Editor)モードで開きます:  #search: Xcode Assistant Editor
                                    - option キーを押しながら、Project Navigator の中のファイルをクリックします
                                    - Navigator は非表示にすると良いでしょう  #keyword: Xcode Navigator button
                            __Project__/__App__/Main.storyboard :
                                Control キーを押しながら、Canvas にある Title ラベルを
                                ReminderListCell クラスのブロックの中へドラッグ＆ドロップします。
                                成功すると次に示す Connection ポップアップが表示されます。
                            Connection ポップアップ:
                                Name: titleLabel
                                Storage: Strong
                                    #// Strong = サイズクラスの変更によるオブジェクトの割り当て解除が防止されます
                                Connect ボタン:
                                追加されるコード: |
                                    @IBOutlet var titleLabel: UILabel!
                                #search: @IBOutlet
                            コードと GUI の対応関係をブラウズします:  #search: Xcode browse GUI code
                    Date ラベルに接続するコードを追加します:
                        GUI:
                            File: __Project__/__App__/Main.storyboard
                            Object: Date ラベル
                        Code:
                            File: __Project__/__App__/ReminderListCell.swift
                            所属先クラス: ReminderListCell
                            Name: dateLabel
                            Storage: Strong
                    丸ボタンに接続するコードを追加します:
                        GUI:
                            File: __Project__/__App__/Main.storyboard
                            Object: 丸ボタン
                        Code:
                            File: __Project__/__App__/ReminderListCell.swift
                            所属先クラス: ReminderListCell
                            Name: doneButton
                            Storage: Strong
                Table View Cell の Identifier を設定します:
                    #// 次のチュートリアルでは、この再利用識別子は、テーブルビューデータソースのセルをデキューするためのセル識別子です。
                    __Project__/__App__/Main.storyboard :
                        Object: Table View Cell
                        Attributes Inspector:
                            Identifier: ReminderListCell
                イベントを発生する GUI 部品を参照するコードにアクション（接続）を追加します:
                    丸ボタンを押したときのアクションを追加します:  #keyword: Xcode action example
                        doneButtonTriggered メソッドを追加します:
                            __Project__/__App__/ReminderListCell.swift : |
                                import UIKit

                                class ReminderListCell: UITableViewCell {
                                    typealias DoneButtonAction = () -> Void

                                    @IBOutlet var titleLabel: UILabel!
                                    @IBOutlet var dateLabel: UILabel!
                                    @IBOutlet var doneButton: UIButton!

                                    var doneButtonAction: DoneButtonAction?

                                    @IBAction func doneButtonTriggered(_ sender: UIButton) {
                                        doneButtonAction?()
                                    }
                                }
                            #search: @IBAction
                        doneButtonTriggered メソッドを GUI 部品に接続します:  #keyword: Xcode connect example
                            Main.storyboard ファイルの内容と ReminderListCell.swift ファイルの内容を並べます:
                                Canvas:  #search: Xcode Canvas
                                    丸ボタン: 選択
                                メニュー: Editor >> Assistant
                            ドラッグ＆ドロップの開始場所:
                                メソッド(@IBAction)の行頭にある○:
                                    __Project__/__App__/ReminderListCell.swift : |
                                        @IBAction func doneButtonTriggered(_ sender: UIButton) {
                            ドラッグ＆ドロップの終了場所:
                                __Project__/__App__/Main.storyboard :
                                    丸ボタン
                            #// 接続された状態に変わると、メソッドの行頭に表示される丸が ○→◉ に変わります
            ViewController から継承し、そこにデータ（Model）をビュー（View）に設定するコードを書きます:
                公式: #// https://developer.apple.com/tutorials/app-dev-training/setting-up-a-table-view
                編集した GUI(View) に合わせるように ViewController を修正します:
                    概要:
                        変更前:
                            __Project__/__App__/ViewController.swift : |
                                class ViewController: UIViewController
                            __Project__/__App__/Main.storyboard :
                                Class: UIViewController
                        変更後:
                            __Project__/__App__/ReminderListViewController.swift : |
                                class ReminderListViewController: UITableViewController
                            __Project__/__App__/Main.storyboard :
                                Class: ReminderListViewController
                    手順:
                        __Project__/__App__/ViewController.swift :
                            UIViewController のサブクラスのクラス名を ReminderListViewController に変更します:
                                リファクタリング機能を使ってクラス名を変更します:
                                    Control を押しながら既存のクラス名 ViewController をクリック
                                    または Control を押さずに右クリック >>
                                    Refactor >> Rename
                                変更前: ViewController
                                変更後: ReminderListViewController
                                注意❗: ファイル名も同時に変わります
                        __Project__/__App__/ReminderListViewController.swift :  #// 同時に変わった後のファイル名
                            スーパークラス UIViewController を UITableViewController に変更します:
                                エディターで普通に編集します:
                                    変更前: |
                                        class ReminderListViewController: UIViewController
                                    変更後: |
                                        class ReminderListViewController: UITableViewController
                            既存の viewDidLoad メソッドの定義全体を削除します:
                        __Project__/__App__/Main.storyboard :
                            Document Outline:  #search: Xcode Document Outline
                                Table View Controller: をクリック
                            Identity Inspector:  #search: Xcode Identity Inspector
                                Custom Class:
                                    Class: ReminderListViewController
                必要なメソッドを実装します: #keyword: Xcode UITableViewController cellForRowAt  #// 表に表示する内容を返すコードを書きます
                    概要:
                        tableView(___, numberOfRowsInSection:) -> Int: 行数を返します
                        tableView(___, cellForRowAt:) -> UITableViewCell: セル（行）を返します
                        データ(Model): let reminder = Reminder.testData[indexPath.row]
                        GUI(View): let cell = tableView.dequeueReusableCell(____)
                    最終的なコード:  #focus: numberOfRowsInSection,  cellForRowAt
                        __Project__/__App__/ReminderListViewController.swift : |
                            import UIKit

                            class ReminderListViewController: UITableViewController {
                            }

                            extension ReminderListViewController {
                                static let reminderListCellIdentifier = "ReminderListCell"
                                
                                override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
                                    return Reminder.testData.count
                                }
                                
                                override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
                                    guard let cell = tableView.dequeueReusableCell(withIdentifier: Self.reminderListCellIdentifier, for: indexPath) as? ReminderListCell else {
                                        fatalError("Unable to dequeue ReminderCell")
                                    }

                                    let reminder = Reminder.testData[indexPath.row]
                                    let image = reminder.isComplete ? UIImage(systemName: "circle.fill") : UIImage(systemName: "circle")

                                    cell.titleLabel.text = reminder.title
                                    cell.dateLabel.text = reminder.dueDate.description
                                    cell.doneButton.setBackgroundImage(image, for: .normal)
                                    cell.doneButtonAction = {
                                        Reminder.testData[indexPath.row].isComplete.toggle()
                                        tableView.reloadRows(at: [indexPath], with: .none)
                                    }
                                    return cell
                                }
                            }
            stack >> Storyboard の公式チュートリアル:  #keyword: Xcode Storyboard stack
                ref:  #(search)if: false
                writing:  #(search)if: false
                memo: |
                    プロジェクト: #ref: ${GitHub}/MyPrivateCode/StoryboardApp3/StoryboardApp3.xcodeproj
        #// ユースケース
        Apple Watch: #keyword: Xcode WatchOS, WatchOS
            新プロジェクトを作ります: #keyword: Xcode new Apple Watch project
                Xcode 15.3:  #ref: https://developer.apple.com/tutorials/swiftui/creating-a-watchos-app
                    1st:
                        作成済み: #keyword: WatchOS watch1 project
                            #ref: ${GitHub}/MyPrivateCode/Swift/watch/1st/watch1-15.3
                        手動:
                            メニュー: Xcode 初期ページ >> Create New Project >> watchOS タブ >> App >> Next ボタン
                            Product Name: watch1-15.3  #template__: __ProductName__
                            Watch-only App: チェック
                            Next ボタン:
                            保存ウィンドウでコピーしたパスに保存します:
                                shift + command + G >> （watch1-15.3 のフォルダーを作る場所のパス）  #template__: __ProductName__
                                #ref: ${GitHub}/MyPrivateCode/Swift/watch/1st/watch1-15.3       #template__: __ProductName__
                            Apple Watch シミュレーター を選びます:  #search: Xcode simulator for Watch
                                Apple Watch Series 9（45mm）
                            実行します:
                        ファイル:
                            watch1_15_3App.swift: |  #// main
                                import SwiftUI

                                @main
                                struct watch1_15_3_Watch_AppApp: App {
                                    var body: some Scene {
                                        WindowGroup {
                                            ContentView()
                                        }
                                    }
                                }
                            ContentView.swift: |  #// メイン ビュー
                                import SwiftUI

                                struct ContentView: View {
                                    var body: some View {
                                        VStack {
                                            Image(systemName: "globe")
                                                .imageScale(.large)
                                                .foregroundStyle(.tint)
                                            Text("Hello, world!")
                                        }
                                        .padding()
                                    }
                                }

                                #Preview {
                                    ContentView()
                                }
                    Landmarks:  #// 公式チュートリアル、複雑
                        #ref: https://developer.apple.com/tutorials/swiftui/creating-a-watchos-app
                        #ref: ${GitHub}/MyPrivateCode/Swift/watch/official/15.3/CreatingAwatchOSApp/StartingPoint
                        #ref: ${GitHub}/MyPrivateCode/Swift/watch/official/15.3/CreatingAwatchOSApp/Complete
                        #ref: ${GitHub}/MyPrivateCode/Swift/watch/official/15.3/CreatingAwatchOSApp
                Xcode 12.5:
                    参考:
                        https://i-app-tec.com/watch/hello-world.html
                        https://developer.apple.com/documentation/watchkit
                        https://developer.apple.com/documentation/watchkit/building_a_watchos_app
                    プロジェクト: #ref: ~/GitProjects/GitHub/MyPrivateCode/Swift/watch/TryAppleWatch
                    用語:  #glossary:
                        WatchKit: Apple Watch 向けアプリ開発フレームワーク
                    設定: #settings:
                        __ApplicationName__: TryAppleWatch
                        __Organization__: OurOrg
                    iPhone アプリをビルドします:
                        プロジェクトを新しく作ります:
                            iPhone のターゲットを作ります:
                                メニュー: Xcode >> Create a new Xcode project >> iOS（タブ）>> App >> Next ボタン
                                Product Name: TryAppleWatch      #template: __ApplicationName__
                                Organization Identifier: OurOrg  #template: __Organization__
                                Next ボタン:
                                （保存先フォルダー）: 例： Desktop
                                Create ボタン:
                            Apple Watch のターゲットを作ります:
                                メニュー: Xcode >> File >> New >> Target >>
                                    watchOS（タブ）>> Application（グループ) >>
                                    Watch App for iOS App（iOS と連動する Watch App）>>
                                    Next ボタン
                                Product Name: TryAppleWatchWatch  #template: __ApplicationName__Watch
                                Finish ボタン:
                                Activate "TryAppleWatchWatch (Complication)" scheme?: Activate  #search: Xcode scheme
                        プレビューを表示します（簡易エミュレーターを動かします）:  #search: Xcode preview for Watch
                            Xcode >> TryAppleWatchWatch Extension フォルダー（左のツリー）>>
                                ContentView.swift ファイルを選択 >> Resume
                                #template-at(-2): __ApplicationName__Watch
                        シミュレーターを起動します:  #keyword: Xcode simulator for Watch
                            シミュレーターの種類（スキーム）を変えます:  #keyword: Xcode scheme for Watch
                                Set the active scheme（エディターの上左）:
                                    TryAppleWatchWatch > (iOS Simulators) Apple Watch Series 6 - 40mn
                                #template-at(-1): __ApplicationName__Watch
                            シミュレーターを起動します:
                                iPhone のアプリを起動するとき:
                                    Set the active scheme（エディターの上左）: __iPhoneApp__ > __Simulator__
                                Apple Watch のアプリを起動するとき:
                                    Set the active scheme（エディターの上左）: __WatchApp__ > __Simulator__
                                Build and then run the current scheme ボタン（エディターの左上、再生ボタン風）:
                        実機で動かします:  #keyword: Xcode run on device for Watch
                            iPhone アプリと Watch アプリをそれぞれ起動します:
                                シミュレーターの種類（スキーム）を変えます:
                                    Set the active scheme（エディターの上左）:
                                        iPhone アプリの場合:
                                            TryAppleWatch >> __Your_iPhoneName__
                                        Watch アプリの場合:
                                            TryAppleWatch Watch >> __YourAppleWatchName__
                                        #template-at(-3): __ApplicationName__ >>
                                        #template-at(-2): __ApplicationName__ Watch >>
                                ビルドし直します:
                                    Xcode >> Product（メニュー）>> Clean Build Folder >> Product（メニュー）>> Build
                                Apple Watch とペアリング済みの iPhone の実機と開発用 mac を USB ケーブルで接続します:
                                再生ボタン（Build and then run the current scheme）（左上）:
                                以上を iPhone アプリと Watch アプリのそれぞれで行ます:
                            参考: iPhone を実機で動かします  #search: Xcode run on device
                            不要になったら実機のアプリを削除します:
                    WatchKit Extension を追加します:
                    WatchKit App を作ります:
            接続:  #search: Xcode devices
            1列テーブル:
                #ref: ${GitHub}/MyPrivateCode/Swift/watch/2nd/CardView-15.3
                #ref: ${GitHub}/FiveMint/FiveMint Watch App/ContentView.swift
            通知:  #search: Xcode 通知
            振動, 効果音: #keyword: watchOS 振動 効果音,  Apple Watch フィードバック 通知音
                書式: WKInterfaceDevice.current().play(.click)
                種類:
                    .click: 超軽い振動のみ
                    .notification: 通知が来た時と同じ音と振動
                    .directionUp: ピロン⤴︎という音と振動
                    .directionDown: ピロン⤵という音と振動
                    .success: ピロリン⤴︎という音と振動
                    .failure: ピピポン⤵という音と振動
                    .retry: ポポポン→という音と振動
                    .start: ポン→という音と振動
                    .stop: ポンポン→という音と振動
            省電力, AOD: #keyword: watchOS AOD  #// 常時表示されるモード（Always-On Display、AOD）
                AOD のときの動作:
                    タイマーイベントが発生しなくなります: |
                        let  timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
                        TopView.onReceive(timer) { _ in self.onTimer()}
                    ユーザー通知が来ても画面は変わりません:  #search: Xcode 通知 AOD
                    腕を上げて AOD モードを抜けると画面が変わります:
                デバッガー接続中: AOD のモードになりません
            リマインダーを表示: #keyword: Swift reminder  #// 内容を表示します
                #ref: ${GitHub}/MyPrivateCode/Swift/watch/2nd/Reminders-15.3
                #ref: ${GitHub}/FiveMint/FiveMint Watch App/ContentView.swift
                リマインダー アプリ の表示:  #// 未確認
                コード:
                    EKReminder クラス:
                        priority:
                            0: 優先度なし
                            9: 優先度 低
                            5: 優先度 中
                            1: 優先度 高
            WKExtensionDelegate: #keyword:  #// アプリのアクティブ化など
                - WatchOS では AppDelegate, @UIApplicationDelegateAdaptor はサポートされません  #search: AppDelegate
                - 代わりに WKExtensionDelegate を使います
                #ref: ${GitHub}/MyPrivateCode/Swift/watch/2nd/LocalNotification-15.3/watch1-15.3 Watch App/ExtensionDelegate.swift
                #ref: https://stackoverflow.com/questions/71192890/functions-of-wkextensiondelegate-are-not-called-for-watchos
            Apple Watch と iPhone 間で通信します:  #keyword: WCSession example
                参考:
                    サンプル: #ref: https://developer.apple.com/documentation/watchconnectivity/using_watch_connectivity_to_communicate_between_your_apple_watch_app_and_iphone_app
                    WCSession: #ref: https://developer.apple.com/documentation/watchconnectivity/wcsession
                ダウンロードして修正したプロジェクト: ~/GitProjects/GitHub/MyPrivateCode/Swift/watch/UsingWatchConnectivityToCommunicateBetweenYourAppleWatchAppAndIPhoneApp
                通信内容一覧:
                    updateAppContext, sendMessage, sendMessageData, transferUserInfo, transferFile, transferCurrentComplicationUserInfo
                操作方法:
                    アプリを起動します:
                        シミュレーターの場合:
                            SimpleWatchConnectivity WatchKit App を選びます（上にある停止ボタンの右）>>
                            再生ボタン（上）>>
                            SimpleWatchConnectivity を選びます（上にある停止ボタンの右）>>
                            再生ボタン（上）
                            #// Reachable と表示されます（iPhone シミュレーターの右上）
                        実機の場合:
                            プロジェクト（SimpleWatchConnectivity）をビルドして実機にアップロードします:
                            iPhone でアプリを起動します:
                                #// 上半分はログ、下半分はボタンです。ボタンは通信する内容の種類ごとにあります
                            Apple Watch でアプリを起動します:
                    iPhone から Apple Watch へ送信します:
                        アプリ(Watch)を左右にスワイプして、受信する内容の種類（SendMessageなど）を選びます:
                        アプリ(iPhone)の下半分のうち、送信する内容の種類（SendMessageなど）のボタンを押します:
                        アプリ(iPhone)に "Sent at" と送信した時刻が表示されます:
                        アプリ(Watch)に "Received at" と受信した時刻が表示されます:
                        アプリ(iPhone)に "Replied at" と受信した時刻が表示されます:
                    Apple Watch から iPhone へ送信します:
                        アプリ(iPhone)を表示します:
                        アプリ(Watch)を左右にスワイプして、送信する内容の種類（SendMessageなど）を選びます:
                        アプリ(Watch)のボタン（SendMessageなど：下）を押します:
                        アプリ(Watch)に "Sent at" と送信した時刻が表示されます:
                        アプリ(iPhone)に "Received at" と受信した時刻が表示されます:
                        アプリ(Watch)に "Replied at" と受信した時刻が表示されます:
                WCSession:  #search: WCSession
            タイマーアプリを作る: #// https://zenn.dev/ryo_kawamata/articles/timer-app-with-swift-ui
        デバイスの接続: #search: Xcode connect device
        Git:  #// GitHub リポジトリにあるプロジェクトを Xcode と連携します  #keyword: Xcode GitHub, mac git
            clone します:
                リポジトリが初期状態ではなく何かファイルがある状態にします:
                メニュー: Xcode >> Clone an existing project
                Enter repository URL: （サンプル） https://github.com/Takakiriy/ToDoSwitcher
                Clone ボタン:
                メールアドレス:
                アクセス トークン:  #search: PAT(Personal Access Token)
                Save As:
        リリース: #keyword: Xcode release
            リリース物を作ります:
                アプリ名とカテゴリーなど: #search: Xcode target identity
                アイコン: #search: Xcode assets
        教材:
            pixiv提供 Xcode 教材:  #ref: https://inside.pixiv.blog/2023/01/19/140000
        関連 >> フレームワーク: #search: SwiftUI, UIKit
    機能:  #// iOS デバイスの機能、構成、GUI、ストレージ、キーボード、ネットワーク
        GUI 部品: #keyword: Xcode GUI parts  #//🌟 ボタン、リストなど
            #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_widget
            手順:
                追加:  #// GUI部品を追加します
                    Storyboard を使っていない UIKit の場合:
                        #search: UITextField-14-1
                        イベント ハンドラー:  #// イベントが発生したことのメッセージを受け取って処理します
                            delegate: #keyword: Xcode delegate
                                概要: 所有関係にある 子 UIView のイベントを 親 UIViewController が処理します
                                サンプル プロジェクト:  #search: UITextField-14-1
                                コード: |  #focus: textViewDidChange, UITextViewDelegate, textView
                                    class ____: UIViewController, UITextViewDelegate {
                                        let textView = UITextView()
                                        override func viewDidLoad() {
                                            super.viewDidLoad()
                                            textView.delegate = self
                                        }
                                        func textViewDidChange(_ textView: UITextView) {  // UITextViewDelegate.textViewDidChange
                                            print(textView.text!)
                                        }
                    Storyboard を使っている場合:
                        ライブラリから追加する:
                            上記「プレビューを表示します」:
                            プラス（＋）ボタン（右上、ライブラリ ボタン）を押します:
                            貼り付けたいビューをプレビューの中の既存の GUI 部品のすぐ隣にドラッグ＆ドロップします:
                                #// 追加した GUI部品に関するコードが自動的に追加されます
                                #// ドラッグ＆ドロップしてもライブラリを表示したままにしたいときは、Option キーを押しながらライブラリ ボタン
                            コードにドラッグ＆ドロップすることもできます p65:
                            GUI部品を追加したいコードの位置にキャレットを動かし、ライブラリの中の GUI 部品をダブルクリックすると追加できます p69,p71:
                            コードを変更してもGUI部品を追加・編集・削除ができます:
                        アクション メニューから追加する:
                            Command を押しながらマウスをコードやプレビューの Text の上に動かすと、
                            Text 全体が選択された状態になります。
                            そこでクリックすると [ Embed in HStack ] などが選べるメニューが開きます。
                UI のレンダリングが完了するまで待ちます:  #keyword: Swift wait layout
                    textView.layoutIfNeeded()
                一瞬経ってから処理します: |  #keyword: DispatchQueue.main.asyncAfter,  Swift delay sleep
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                    }
                アニメーションをさせないようにします:  #keyword: Xcode no animation
                    設定前: |
                        let  shapeLayer = CAShapeLayer()
                        shapeLayer.strokeEnd = 0.0  // 値が 0.0 に徐々に変わるようにアニメーションします
                    設定後: |  #focus: CATransaction
                        let  shapeLayer = CAShapeLayer()
                        CATransaction.begin()
                        CATransaction.setDisableActions(true)

                        shapeLayer.strokeEnd = 0.0  // アニメーションしないようになります
                        CATransaction.commit()
            #↓ 部品
            ラベル: #keyword: Xcode UILabel  #// テキストの表示
                UILabel:
                    numberOfLines: #keyword: Xcode numberOfLines,  UILabel 複数行
                        let label = UILabel()
                        self.view.addSubview(label)
                        label.numberOfLines = 0  #// 0 に設定すると、テキストが長すぎて右端を超えるときに複数行で表示されます
                        #ref: ${GitHub}/MyPrivateCode/Swift/1st/UNUserNotification-14-1/FirstUIKit-14-1/ViewController.swift#numberOfLines
                Highlightr (CocoaPods): #keyword: Highlightr CocoaPods  #ref: https://cocoapods.org/pods/Highlightr
                    テーマ:
                        Web:  #ref: https://highlightjs.org/static/demo/ >> config >> YAML  #// hightlight.js
                        Xcode:  __Project__/Pods/Pods/Highlightr/Resources/
                        ファイル: __Project__/Pods/Highlightr/Pod/Assets/styles/
                        サンプル: xcode, vs2015, ...
                    インストール:  #search: install CocoaPods
                    インストール済み サンプル プロジェクト:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/UITextViewAttribute-14-1/
                    注意: 使わないテーマは削除すべきです  #// 未確認
            ボタン: #keyword: Xcode SwiftUI Button
                SwiftUI:
                    サンプル:  #// ボタンを押すたびにカウンターが増えます
                        ContentView.swift: |  #// SwiftApp1 をベースに ContentView.swift だけ変更します  #search: SwiftApp1
                            import SwiftUI

                            struct ContentView: View {
                                @State var  message:String = "(message)"
                                @State var  count:Int = 0

                                var body: some View {
                                    VStack {
                                        Text(message).padding()
                                        Button("Tap Me !") {
                                            count += 1
                                            message = "Tapped! \(count)"
                                        }.padding()
                                    }
                                }
                            }

                            struct ContentView_Previews: PreviewProvider {  // #keyword: PreviewProvider  #// プレビューの表示対象  #search: Xcode preview
                                static var previews: some View {
                                    ContentView()
                                }
                            }
                UIKit:
                    UIButton: #keyword: UIButton, addTarget
                        #ref: ${GitHub}/MyPrivateCode/Swift/1st/UIButton-14-1/image_UIButton.png
                        サンプル: |  #focus: button  #ref: ${GitHub}/MyPrivateCode/Swift/1st/UIButton-14-1/FirstUIKit-14-1/ViewController.swift#UIButton
                            class ViewController1: UIViewController {
                                override func viewDidLoad() {

                                    let button = UIButton()
                                    self.view.addSubview(button)
                                    button.setTitle("Tap me!", for:.normal)
                                    button.configuration = .filled()  // plain, gray, tinted, filled
                                        // #ref: ${my_images}/2023/UIButton.configuration.png
                                        // #ref: https://ios-docs.dev/new-button/
                                    button.addTarget(self,
                                        action: #selector(ViewController1.buttonTapped(sender:)),
                                        for: .touchUpInside)

                                    let views = ["label":label, "label2": label2, "button": button]

                                @objc func buttonTapped(sender: UIButton){
                                    print("buttonがタップされました")
                                }
                    DownloadButton:  #search: DownloadButton-14-1
                公式チュートリアル:  #search: Storyboard rounded button
                #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_swift_button
                背景色:
                    ボタンの背景色:  Button(____){____}.background(Color.yellow)
                    リストの行の背景色:  #search: Xcode SwiftUI List
                    #search: Xcode Swift Color
            テキスト入力: #keyword: Xcode TextField
                SwiftUI:
                    TextField: #ref: https://qiita.com/chocoyama/items/647cf56c21c3af790c6a
                    TextEditorプロジェクト: https://www.hackingwithswift.com/quick-start/swiftui/how-to-create-multi-line-editable-text-with-texteditor
                UIKit:
                    UITextField: #keyword:
                        #ref: ${GitHub}/MyPrivateCode/Swift/1st/UITextField-14-1/image_UITextField.png
                        キーが押された時のコールバック:
                            textFieldShouldReturn
                        全選択:  #focus: selectAll  #keyword: Xcode UITextField selectAll
                            アプリがアクティブになったときに全選択します: |  #ref: ${typrm_iOS}/FirstUIKit-14-1/ViewController.swift#sceneDidBecomeActive
                                func sceneDidBecomeActive() {
                                    let  textField = self.firstViewController!.textField
                                    textField.selectAll(textField.text)
                                    textField.menuEnabled = false
                                    DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                                        textField.menuEnabled = true
                                    }
                                }
                            テキストをタップしたときに全選択します: |  #ref: ${typrm_iOS}/FirstUIKit-14-1/ViewController.swift#textFieldDidBeginEditing
                                override func viewDidLoad() {
                                    textField.delegate = self
                                }
                                func  textFieldDidBeginEditing(_ textField: UITextField) {
                                    let  textField_ = textField as! MyUITextField
                                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                                        textField_.selectAll(self.textField.text)
                                        textField_.menuEnabled = false
                                    }
                                    DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                                        textField_.menuEnabled = true
                                    }
                                }
                            全選択したときにメニューを非表示にします: |  #ref: ${typrm_iOS}/FirstUIKit-14-1/ViewController.swift#canPerformAction
                                class MyUITextField: UITextField {
                                    var menuEnabled = true
                                    override func canPerformAction(_ action: Selector, withSender sender: Any?) -> Bool {
                                        if !( self.menuEnabled ) {
                                            return false
                                        } else {
                                            return super.canPerformAction(action, withSender: sender)
                                        }
                                    }
                                
                                    override var isAccessibilityElement: Bool {
                                        get {
                                            return false
                                            // ここはコールバックされなくなったようです。
                                            // これでも Speak メニューは表示されてしまいます。2023-06。
                                            // iPhone >> 設定 >> アクセスビリティ >> 読み上げコンテンス >> 選択項目の読み上げ をオフにしてください。
                                        }
                                        set {
                                            // ignore
                                        }
                                    }
                                }
                    UITextView: #keyword:  #// 複数行  #search: CommingSoonNotification
                        サンプル: |
                            class ViewController: UIViewController {
                                let messageField = UITextView()
                                override func viewDidLoad() {
                                    super.viewDidLoad()

                                    let messageField = self.messageField
                                    self.view.addSubview(messageField)
                                    messageField.layer.borderWidth = 1
                                    messageField.layer.borderColor = UIColor.black.cgColor
                                    messageField.layer.cornerRadius = 5
                                    messageField.font = UIFont.systemFont(ofSize: 18)
                                    messageField.autocorrectionType = .no  // 勝手に英語のスペルを正しいのにする機能をoff
                                    messageField.autocapitalizationType = .none  // 勝手に英語の先頭の文字を大文字にするのをoff
                        プレース ホルダー:  #keyword: UITextView placeholder
                            UITextView には .placeholder がありません。 UITextField にはあります。
                            UITextView の プレース ホルダー は、 #search: CommingSoonNotification
                        読み取り専用, リンクなど:
                            読み取り専用: textView.isEditable = false
                            選択可能:    textView.isSelectable = true
                            リンクを有効にする:  textView.dataDetectorTypes = .link  #// http: などを自動的に解析してリンクにします
                        UITextViewController:
                            ありません。UITextViewController もありません。
                            UIViewController の sub view に　UITextView を追加してください  #search: UITextViewAttribute-14-1
                        UITextRange:  #// UITextView.selectedTextRange の型
                            .start:UITextPosition:
                            .end:UITextPosition:
                            選択範囲を変更します: |
                                textView.becomeFirstResponder()
                                textView.selectedTextRange = textView.textRange(from: ____, to: ____)
                            数値で表示します: |  #keyword: print UITextRange
                                let location = textView.offset(from: textView.beginningOfDocument, to: selectedRange.start)
                                let length = textView.offset(from: selectedRange.start, to: selectedRange.end)
                                print("Location: \(location), Length: \(length)")
                        UITextPosition:
                            数値で表示します:  #search: print UITextRange
                            +1 する: |
                                if let newPosition = textView.position(from: currentTextPosition, offset: 1) {
                                    // newPosition は currentTextPosition から1つ先の位置を示します。
                                }
                            UITextView.offset(from:,to:):
                                to - from
                            UITextView.position(from:,offset:):
                                from + offset
                        スクロール可能なTextView:  #ref: https://www.tutorialspoint.com/how-to-create-scrollable-textview-on-ios-app
                        スクロールします: #keyword: Swift scrollRangeToVisible
                            現在の選択位置へ:
                                textView.scrollRangeToVisible(textView.selectedRange)  #search: UITextRange
                                #// 指定した範囲が端に来るようにスクロールします。
                            先頭へ: |
                                textView.scrollRangeToVisible(NSRange(location: 0, length: 0))
                        右端で折り返さない: |  #focus: yamlText, textView  #// ただし、横スクロールできるようにする方法は未調査
                            let attributedString = NSMutableAttributedString(string: yamlText)
                            let paragraphStyle = NSMutableParagraphStyle()

                            paragraphStyle.lineBreakMode = .byClipping
                            attributedString.addAttribute(.paragraphStyle,
                                value: paragraphStyle,
                                range: NSMakeRange(0, attributedString.length))

                            self.textView.attributedText = attributedString
                        数文字入力したら次の TextField へ:  #ref: https://qiita.com/shunya813/items/33cc6187a3fd0e769b34
                        キーボードを隠す:  #// TextField の外をタップしたときに
                            メソッド:  #search: Xcode UITextField.becomeFirstResponder
                            きっかけ: テーブルのスクロール開始など
            画像:
                UIImageView: #keyword: UIImageView,  Xcode image  #// 画像の表示
                    #search: CommingSoonNotification
                    #ref: ${GitHub}/MyPrivateCode/Swift/CommingSoonNotification/FirstUIKit-14-1/ViewController.swift#UIImageView
                ベクター グラフィックス: #keyword: Swift vector graphics
                    CAShapeLayer: #keyword: CAShapeLayer  #ref: https://developer.apple.com/documentation/quartzcore/cashapelayer
                        Playground で表示する場合:
                            プロジェクト:  #search: CAShapeLayer.playground
                            新規作成する場合:
                                UIView が使える Playground を開きます:
                                    #search: Xcode Live View example
                                MyPlayground.swift: |  #// 下記コードを貼り付けます  #focus: shapeLayer,  arc
                                    import UIKit
                                    import PlaygroundSupport
                                    let view = UIView()
                                    view.frame = CGRect(x: 0, y: 0, width: 400, height: 400)
                                    view.backgroundColor = .gray

                                    PlaygroundPage.current.liveView = view
                                    let shapeLayer = CAShapeLayer()
                                    shapeLayer.frame = CGRect(x: 0, y: 0, width: 400, height: 400)

                                    view.layer.addSublayer(shapeLayer)

                                    // 以下は描画内容によって変わります
                                    shapeLayer.lineWidth = 20.0
                                    shapeLayer.strokeColor = UIColor.blue.cgColor
                                    shapeLayer.fillColor = UIColor.cyan.cgColor
                                    let arc = UIBezierPath(
                                        arcCenter: CGPoint(x: 200, y: 200),
                                        radius: CGFloat(100),
                                        startAngle: CGFloat(0.125 * .pi),
                                        endAngle: CGFloat(1.875 * .pi),
                                        clockwise: true)

                                    shapeLayer.path = arc.cgPath
                        UIButton に表示する場合: |  #focus: progressLayer  #ref: ${GitHub}/MyPrivateCode/Swift/1st/DownloadButton-14-1/FirstUIKit-14-1/DownloadButton.swift
                            class ProgressButton: UIButton {
                                private var  progressLayer: CAShapeLayer!
                                override init(frame: CGRect) {
                                    ...
                                }
                                required init?(coder: NSCoder) {
                                    ...
                                }
                                private func setup() {
                                    progressLayer = CAShapeLayer()
                                    layer.addSublayer(progressLayer)

                                    progressLayer.strokeColor = UIColor.blue.cgColor
                                    ...
                                }
                                override func layoutSubviews() {
                                    super.layoutSubviews()

                                    progressLayer.frame = bounds
                                    let center = CGPoint(x: bounds.midX, y: bounds.midY)
                                    let radius = min(bounds.width, bounds.height) * 0.5 - progressLayer.lineWidth * 0.5
                                    let path = UIBezierPath(arcCenter: center, radius: radius, startAngle: -.pi / 2, endAngle: 3 * .pi / 2, clockwise: true)

                                    progressLayer.path = path.cgPath
                                    progressLayer.strokeEnd = 0.7
                                }
                        SVG から変換する場合: #keyword: Xcode SVG  #ref: ${typrm_files}/ref/Swift-AI.yaml#label: SVG to CAShapeLayer
                        API:
                            CAShapeLayer:
                                プロパティ:  #focus: shapeLayer
                                    frame: |
                                        let  bounds = view.bounds  // view: UIView
                                        shapeLayer.frame = CGRect(x: 0, y: 0, width: bounds.width, height: bounds.height)
                                    (stroke):
                                        strokeColor:
                                            - shapeLayer.strokeColor = UIColor.red.cgColor
                                            - shapeLayer.strokeColor = nil
                                        lineWidth:
                                            - shapeLayer.lineWidth = 2.0
                                    (fill):
                                        fillColor:
                                            - shapeLayer.fillColor = UIColor.black.cgColor
                                            - shapeLayer.fillColor = nil
                            UIBezierPath:
                                メソッド:  #focus: path
                                    move, addLine, close: |
                                        let  path = UIBezierPath()
                                        path.move(to: CGPoint(x: 16, y: 0))
                                        path.addLine(to: CGPoint(x: 16, y: 21))
                                        path.addLine(to: CGPoint(x: 0, y: 21))
                                        path.close()
                タップでメニュー: #keyword: UIImageView UIMenu  #// 画像をタップしたときにメニューを表示します
                    ブレンドのアルファ値を 0 にして UIButton を重ねます
                    #ref: https://stackoverflow.com/questions/70813955/show-uimenu-without-uibutton-or-uinavigationbutton
                    #ref: ${GitHub}/MyPrivateCode/Swift/1st/UIImageView-14-1/FirstUIKit-14-1/ViewController.swift#hiddenButton
            タブ バー: #keyword: Xcode tab bar  #// 画面下の複数ボタン
                SwiftUI >> TabView: #keyword:  #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#segmented_control
                UIKit >> UITabBarController: #keyword:
                    #ref: https://tech.amefure.com/swift-uikit-uitabbarcontroller
                ボタンの画像:
                    UITabBarItem.SystemItem.more
                    more, favorites, featured, ...
                    #ref: https://hajihaji-lemon.com/swift/uitabbaritem/
                アクティブのタブを変える場合:
                    self.viewControllers = [firstViewController, secondViewController]
                    のとき、
                    self.selectedViewController = secondViewController  #// アクティブを secondViewController に変えます
                同じダブをタップしたときの処理:
                    サンプル: |  #focus: UITabBarControllerDelegate,  delegate,  shouldSelect,  selectedViewController
                        class TabBarController: UITabBarController, UITabBarControllerDelegate {
                            override func viewDidLoad() {
                                super.viewDidLoad()
                                self.delegate = self
                                ...
                            }
                            func tabBarController(_ tabBarController: UITabBarController, shouldSelect newViewController: UIViewController) -> Bool {
                                if newViewController == self.textViewController  &&  newViewController == self.selectedViewController {
                                    print("textViewController tab 2nd select")
                                    return false  // Do not default behavior
                                }
                                return true  // Do default behavior
                            }
            サムネイル付きリスト:
                上記「Xcode で新規作成アプリをビルドする」:
                1行のデータ構造を定義します:
                    画像ファイルが入ったフォルダーをプロジェクトのアセットに登録します:
                        - Xcode の中の Assets.xcassets フォルダーをクリックします
                        - サムネイル画像ファイルが入ったフォルダーを Assets.xcassets フォルダーを開いて表示された
                            ファイル一覧（AccentColor, AppIcon がある場所）にドラッグ＆ドロップします
                    PhotoData.swift ファイルを作成します:
                        メニュー: Xcode >> File >> New >> File
                        選択: Swift File
                        Next ボタン:
                        Save As: PhotoData.swift
                        Where: （新規ファイルを保存するフォルダー）
                        Group: （新規ファイルを入れる Xcode のツリー表示の中のフォルダー）
                        Targets: （不明）
                        Create ボタン:
                        ファイルの内容: |
                            import Foundation

                            var photoArray:[PhotoData] = makeData()

                            struct PhotoData: Identifiable{
                                var id: Int
                                var imageName:String
                                var title:String
                            }

                            func makeData()->[PhotoData]{
                                var dataArray:[PhotoData] = []
                                dataArray.append(PhotoData(id:1, imageName:"IMG_0996", title: "湘南平展望レストランFlat"))
                                dataArray.append(PhotoData(id:2, imageName:"IMG_1035", title: "アウトリガーカヌー"))
                                dataArray.append(PhotoData(id:3, imageName:"IMG_1504", title: "えぼし号"))

                                return dataArray
                            }
                1行のビューを定義します:
                    RowView.swift ファイルを作成します:
                        メニュー: Xcode >> File >> New >> File
                        選択: SwiftUI View （左下）
                        Next ボタン:
                        Save As: RowView.swift
                        Where: （新規ファイルを保存するフォルダー）
                        Group: （新規ファイルを入れる Xcode のツリー表示の中のフォルダー）
                        Targets: （不明）
                        Create ボタン:
                        ファイルの内容: |
                            import SwiftUI

                            struct RowView: View {
                                var photo:PhotoData
                                var body: some View {
                                    HStack {

                                        // 1行の表示内容
                                        Image(photo.imageName)
                                            .resizable()
                                            .frame(width: 80, height: 80)
                                        Text(photo.title)
                                        Spacer()
                                    }
                                }
                            }

                            // このファイルに対してプレビューを表示させようとしたときの内容
                            struct RowView_Previews: PreviewProvider {
                                static var previews: some View {
                                    RowView(photo:photoArray[0])
                                    .previewLayout(.fixed(width: 300, height: 80))
                                }
                            }
                上記で定義した1行のビューを使ったリストのビューを定義します:
                    ContentView.swift ファイルを下記のように編集します: |
                        import SwiftUI

                        struct ContentView: View {
                            var body: some View {
                                List(photoArray) { item in
                                    RowView(photo: item)
            アプリ名:
                場所: Inof.pList >> Bundle name（旧 Bundle display name）
                $(PRODUCT_NAME): __ProjectName__.xcodeproj（ルート）>> TARGETS = __ProjectName__（中央）>> Build Settings タブ >> Product Name（を検索：右上）
                $(TARGET_NAME): __ProjectName__.xcodeproj（ルート）>> TARGETS = __ProjectName__（中央）>>（Enter キー）>>（新しい名前を入力します）
            ステータス バー:  #keyword: Xcode status bar
                色:
                    #ref: https://qiita.com/fuwamaki/items/f623dbfde233a8b4f0d0
            メニュー: #keyword: Xcode menu,  UIMenu
                フローティング メニュー:
                    ボタンを押したとき:  #// ...にメニューを表示する場合
                        #search: UIMenu-14-1
                        #ref: https://qiita.com/MaShunzhe/items/a4db494b1c07c9e5b5ba#uibutton-にフローティングメニューを表示
                        #ref: ${GitHub}/MyPrivateCode/Swift/1st/UIMenu-14-1/image_UIMenu.png
                    画像を押したとき:  #// ...にメニューを表示する場合
                        #search: UIImageView UIMenu
                        #ref: ${GitHub}/MyPrivateCode/Swift/1st/UIImageView-14-1/image_UIImageView.png
            アラート: #keyword: Xcode alert
                アプリ起動時に表示する場合:  #ref: ${typrm_iOS}/FirstUIKit-14-1/SceneDelegate.swift#func showFirstGuide
            #↓ 構成
            レイアウト, 縦並びと横並び: #keyword: Xcode layout
                制約: #keyword: Xcode constraints  #// コンテナーの大きさが変わってもマージンなどを固定にする機能
                ビジュアル フォーマット 言語:  #search: VFL
                SwiftUI:
                    HStack:  #keyword:
                    VStask:  #keyword:
                    AdaptiveStack:  #// ビューの幅に合わせて縦並びと横並びを動的に変えます
                    View を継承した構造体(struct)の中にある VStack を HStack に変えると、縦並びから横並びに変わります:
                UIKit, Storyboard なし:
                    UITableViewController: #search:
                    UICollectionViewController: #search:
                    UIStackView: #search:
                    自動レイアウト:  #// Storyboard
                        サンプル: #search: Xcode connect example
                        トラブルシューティング:
                            - #// テーブルのセルの高さが足りない
                                対処: セルの中の GUI 部品に、Bottom Space to Container 制約を追加します
                Storyboard:
                    #search: Xcode constraint button example
                    概要:
                        制約とは、コンテナー（親のビュー）の大きさが変わっても、左、下などのマージンなどを固定にする機能です。
                        コンテナーの子要素を動かすと、制約値も変化するので、編集時に動かせなくなることはありません。
                        https://qiita.com/yucovin/items/ff58fcbd60ca81de77cb
                        https://www.youtube.com/watch?v=4RdI6pSLrz8
                    サンプル: #search: Xcode constraint button example
                    用語:  #glossary: Xcode
                        leading:  左側（左上から書く言語の場合）
                        trailing: 右側（左上から書く言語の場合）
                        space: マージン
                        container: 親要素
                        superview: 親要素, container と同じ意味です
                    追加:  #// 制約を追加します  #keyword: Xcode add constraints
                        整列や中央揃えの制約:
                            - Canvas 上の部品（をクリック）>>
                            - （Shift キーを押しながら） Canvas 上の部品（をクリック）>>
                            - Align ボタン  #search: Xcode Align
                            - （Leading Edges などの左を）チェック
                            - Add 1 Constraint
                        整列以外の制約:
                            兄弟要素または親要素との制約を追加する場合:
                                Canvas から追加する場合:  #search: Xcode Canvas
                                    手順:
                                        - Canvas 上の部品（をクリック）>>
                                        - （controlを押しながら）子要素（から）兄弟要素または親要素（へドラッグ）>>
                                            （制約の種類のメニュー）
                                        #// 詳細な値の入力は  #search: edit Xcode constraints
                                    サンプル:  #search: Xcode constraint drag example
                                Document Outline から追加する場合:  #search: Xcode Document Outline
                                    手順:
                                        - Document Outline >>
                                        - （controlを押しながら）子要素（から）兄弟要素または親要素（へドラッグ）>>
                                            （制約の種類のメニュー）
                                        #// 詳細な値の入力は  #search: edit Xcode constraints
                                    サンプル:  #search: Xcode constraint drag example
                            親要素との制約を追加する場合:
                                Add New Constraints ボタンから追加する場合:  #keyword: Xcode Add New Constraints usage
                                    手順:
                                        - Canvas 上の部品（をクリック）>>  #search: Xcode Canvas
                                        - Add New Constraints ボタン >>  #search: Xcode Add New Constraints
                                        - チェックボックス、または赤い |←→| をクリック
                                        - 値を入力します
                                        #// 詳細な値の入力は  #search: edit Xcode constraints
                                    サンプル:  #search: Xcode constraint button example
                    編集:  #// 制約値を編集します  #keyword: edit Xcode constraints
                        数値で設定します:
                            制約の項目を探します:
                                Size Inspector から探す場合:  #search: Xcode Size Inspector
                                    - 対象の部品をクリック >>
                                    - Size Inspector >>
                                    - Constraints（Size Inspector の下半分）>>
                                    - Edit（左に青いアイコンがある領域の右）、または領域（をダブルクリック）
                                    - 次は下へ
                                Document Outline から探す場合:  #search: Xcode Document Outline
                                    - Document Outline >>
                                    - Constraints（対象の部品の子要素）の子要素 >>
                                    - Size Inspector または Attribute Inspector
                                        #search: Xcode Size Inspector
                                        #search: Xcode Attribute Inspector
                                    - 次は下へ
                            制約値の種類:
                                演算子:
                                    ＝:
                                    ≧: 以上。
                                    ≦: 以下。
                                値:
                                    数値を設定する場合: 値（をクリック）>> 数値を入力 >> Enter キー
                                    標準値やキャンバス値を設定する場合: 値の右の青いボタン >>（メニュー項目）
                        制約を満たすように修正します:  #// ドラッグすると制約を満たさない状態にすることができてしまいます
                            満たされていない制約を一覧します:
                                Issue Navigator:  #search: Xcode Issue Navigator
                                    Auto Layout Locallization:
                                        （追加する必要がある制約）
                                    Ambiguous Layout:
                                        （制約を満たしていない部品）
                                    Misplaced View:
                                        （制約を満たしていない部品）
                                Canvas:  #search: Xcode Canvas
                                    部品（をクリック）:  満たさない制約の |←→| が赤く表示されます
                            制約を満たす値を調べます:
                                Issue Navigator から調べる場合:  #search: Xcode Issue Navigator
                                    Misplaced View:
                                        ____ will be different at run time:
                                            （現在の値と制約を満たす値）
                                    Ambiguous Layout:
                                        下記の Canvas から調べる場合を参照
                                Canvas から調べる場合:  #search: Xcode Canvas
                                    部品（をクリック）:
                                        オレンジ色の |←→| が表示される場合:
                                            オレンジ色で表示される制約を満たすまでの差分値を参考に、
                                            数値で設定します
                                        赤い |←→| が表示される場合:
                                            - 中央揃えやスペースの制約を追加します
                                            - 制約値と等しくしなくてもよい制約の演算子を ≧ や ≦ に変更します
                                        ボタンを囲む四角い線のうち、水平線が赤い場合:
                                            縦の位置の制約を追加します
                            値を修正します:
                                Size Inspector:
                                    View:
                                        X, Y, Width, Height:
                    削除:  #// 制約を削除します
                        Size Inspector から制約を選ぶ場合:  #search: Xcode Size Inspector
                            Constraints:
                                対象の制約: ダブルクリック
                                #// Document Outline の中で対象の制約が選択されます。次は Document Outline から制約を選ぶ場合を参照
                        Document Outline から制約を選ぶ場合:
                            ビュー: Document Outline  #search: Xcode Document Outline
                            削除する制約を選択します: クリックします
                            削除します: Back Space キー
                    参考:
                        チュートリアルの一部:  #search: Xcode Storyboard official tutorial
                        公式: #ref: https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html
                オートレイアウト: #keyword: Xcode auto layout,  Xcode 自動レイアウト オートレイアウト
                    サンプル:  #search: AutoLayout-14-1
                    公式:
                        Understanding Auto Layout:
                            #ref: https://techblog.recochoku.jp/7727
                            #ref: https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853-CH7-SW1
                    概要:
                        画面サイズや表示する言語によってレイアウトを自動的に調整します。
                        制約（マージンなど）からサイズが決まります。
                    設計:
                        レイアウト:
                            サンプル:
                                左右に同じ幅で並べる:
                                    Creating Nonambiguous, Satisfiable Layouts:
                                        #ref: https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html
                                    サンプルA:
                                        // Vertical Constraints
                                        Red.top = 1.0 * Superview.top + 20.0
                                        Superview.bottom = 1.0 * Red.bottom + 20.0
                                        Blue.top = 1.0 * Superview.top + 20.0
                                        Superview.bottom = 1.0 * Blue.bottom + 20.0
                                        
                                        // Horizontal Constraints
                                        Red.leading = 1.0 * Superview.leading + 20.0
                                        Blue.leading = 1.0 * Red.trailing + 8.0
                                        Superview.trailing = 1.0 * Blue.trailing + 20.0
                                        Red.width = 1.0 * Blue.width + 0.0
                                    サンプルB:  #// 結果は サンプルA と同じです
                                        // Vertical Constraints
                                        Red.top = 1.0 * Superview.top + 20.0
                                        Superview.bottom = 1.0 * Red.bottom + 20.0
                                        Red.top = 1.0 * Blue.top + 0.0
                                        Red.bottom = 1.0 * Blue.bottom + 0.0
                                        
                                        //Horizontal Constraints
                                        Red.leading = 1.0 * Superview.leading + 20.0
                                        Blue.leading = 1.0 * Red.trailing + 8.0
                                        Superview.trailing = 1.0 * Blue.trailing + 20.0
                                        Red.width = 1.0 * Blue.width + 0.0
                            その他:
                                #ref: https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html
                        制約:
                            属性:
                                Leading: 行頭側（英語は左、アラビア語は右）
                                Trailing: 行末側
                            属性値の単位: 自動レイアウトの値は常にポイントです
                                #// Interpreting Values:  #ref: https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html
                            方程式:
                                #ref: https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html
                                    #// Listing 3-1
                                サンプル:
                                    // 高さの固定値
                                    View.height == 0.0 * NotAnAttribute + 40.0
                                    
                                    // 2つのボタンの間の長さ
                                    Button_2.leading == 1.0 * Button_1.trailing + 8.0
                                    
                                    // 左端を揃える
                                    Button_1.leading == 1.0 * Button_2.leading + 0.0
                                    
                                    // 2つのボタンの幅を同じにする
                                    Button_1.width == 1.0 * Button_2.width + 0.0
                                    
                                    // スーパー ビュー の中央に合わせる
                                    View.centerX == 1.0 * Superview.centerX + 0.0
                                    View.centerY == 1.0 * Superview.centerY + 0.0
                                    
                                    // アスペクト比の固定値
                                    View.height == 2.0 * View.width + 0.0
                            曖昧さをなくす:  #// 少なくとも 2つの制約がないと決定できません
                                Creating Nonambiguous, Satisfiable Layouts:
                                    #ref: https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html
                                少なくとも 2つの制約がないと決定できません:
                                    #ref: ${my_images}/2022/Xcode.html#satisfiable
                            不等式:
                                Constraint Inequalities:
                                    #ref: https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html
                            優先順位:
                                Constraint Priorities:
                                    #ref: https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html
                            コンテンツサイズ:
                                Intrinsic Content Size:
                                    #ref: https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html
                                概要:
                                    テキストの量や画像のサイズによって固有のサイズは異なります。
                                    スクロールを有効にすると、ビューには固有のコンテンツサイズがありません。
                                    コンテンツを拡大縮小します。
                    実装:
                        Interface Builder (GUI):  #keyword: Interface Builder layout
                            #ref: https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html
                        NSLayoutAnchor クラス:  #keyword: NSLayoutAnchor  #// 一次方程式 y = ax + b
                            Layout Anchors:
                                #ref: https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ProgrammaticallyCreatingConstraints.html
                            サンプル: |  #focus: constraint, myView, anotherView
                                let  anotherView = view.layoutMarginsGuide
            
                                // myView.leading == anotherView.leading  #keyword: NSLayoutAnchor alignment,  NSLayoutAnchor leadingAnchor
                                myView.leadingAnchor.constraint(equalTo: anotherView.leadingAnchor).isActive = true

                                // myView.trainling == anotherView.trainling + 2
                                myView.trailingAnchor.constraint(equalTo: anotherView.trailingAnchor, constant: 2).isActive = true

                                // myView.height == myView.width * 2
                                myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: 2.0).isActive = true
                            Anchors:
                                centerXAnchor, leftAnchor, rightAnchor, leadingAnchor, trailingAnchor, widthAnchor,
                                centerYAnchor, topAnchor, bottomAnchor, heightAnchor
                                firstBaselineAnchor, lastBaselineAnchor, 
                            constraint の引数:
                                constant: 加算
                                multiplier: 倍
                        NSLayoutConstraint クラス:  #keyword: NSLayoutConstraint,  addConstraints
                            概要:
                                NSLayoutConstraint.constraints の返り値
                                NSLayoutAnchor クラス または Visual Format Language のほうがシンプルです
                                #search: Visual Format Language
                            属性:
                                ウォッチに表示される属性:
                                    ._constant == 100
                                    ._firstAnchor.baseNSLayoutAnchor.referenceItem == | (parent view)
                                    ._secondAnchor.baseNSLayoutAnchor.referenceItem == textField
                                        #// どのビューであるかはオブジェクトのアドレス（値）で識別できます
                                デバッグ コンソール に表示される値: |  #// po コマンドと p コマンドは違うことに注意。属性名は補完されます
                                    (lldb) po __NSLayoutConstraint__
                                        <NSLayoutConstraint:0x600002997250 V:[UITextField:0x159830400]-(350)-|   (active, names: '|':UIView:0x1595180d0 )>
                                    (lldb) p __NSLayoutConstraint__.firstAttribute
                                        (NSLayoutConstraint.Attribute?) $R6 = bottom
                                デバッガーに表示されない属性: |  #// 算出プロパティ  #keyword: Xcode .firstAttribute
                                    .firstItem == | (parent view)
                                    .firstAttribute == .bottom
                                    .secondItem == textField
                                    .secondAttribute == .bottom
                        ビジュアル フォーマット 言語:  #keyword: Visual Format Language,  VFL
                            Visual Format Language:
                                #ref: https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ProgrammaticallyCreatingConstraints.html
                            参考:
                                #ref: https://qiita.com/fromage-blanc/items/7540c6c58bf9d2f7454f
                            プロジェクト:
                                #ref: ${GitHub}/MyPrivateCode/Swift/1st/AutoLayout-14-1
                            Swift のサンプル:
                                NSLayoutConstraint.constraints: |  #keyword: withVisualFormat,  NSLayoutConstraint.constraints
                                    let views = ["label":label, "label2": label2]
                                    views.forEach { $1.translatesAutoresizingMaskIntoConstraints = false }

                                    self.view.addConstraints(NSLayoutConstraint.constraints(
                                        withVisualFormat: "V:|-100-[label]", options: [], metrics: nil, views: views))
                                    label.addConstraints(NSLayoutConstraint.constraints(
                                        withVisualFormat: "V:[label(==50)]", options: [], metrics: nil, views: views))
                                    self.view.addConstraints(NSLayoutConstraint.constraints(
                                        withVisualFormat: "H:|-50-[label]", options: [], metrics: nil, views: views))
                                    label.addConstraints(NSLayoutConstraint.constraints(
                                        withVisualFormat: "H:[label(==100)]", options: [], metrics: nil, views: views))

                                    let label2Metrics = ["width": 60, "height": 80]
                                    view.addConstraints(NSLayoutConstraint.constraints(
                                        withVisualFormat: "V:[label]-30-[label2]", options: [], metrics: nil, views: views))
                                    label2.addConstraints(NSLayoutConstraint.constraints(
                                        withVisualFormat: "V:[label2(==height)]", options: [], metrics: label2Metrics, views: views))
                                    label2.addConstraints(NSLayoutConstraint.constraints(
                                        withVisualFormat: "H:[label2(==width)]", options: [], metrics: label2Metrics, views: views))
                                options 引数:
                                    "[]": オプションなし
                                    .alignAllTop:
                                    "[.alignAllLeading, .alignAllTrailing]": 
                            ビジュアル フォーマット 言語 のサンプル:
                                サンプル:
                                    - label  "V:[label(==50)]"  .alignAllCenterX   #// label の高さ 50pt 固定
                                    - label  "H:[label(==140)]"  .alignAllTop      #// label の幅 140pt 固定
                                    - superView  "V:[labelB(==labelA)]"  .alignAllCenterX    #// 同じ高さ
                                    - （左整列は VFL ではできませんが NSLayoutAnchor でできます）  #// 左整列  #search: NSLayoutAnchor leadingAnchor
                                    - superView  "V:|-100-[label]"       .alignAllCenterX    #// 親の上端から 100pt のマージン
                                    - superView  "V:|-0-[label]"         .alignAllCenterX    #// （親と）上を揃える
                                    - superView  "V:[label]-100-|"       .alignAllCenterX    #// 親の下端から 100pt のマージン
                                    - superView  "V:|[label]-100-"  #// エラー
                                    - superView  "H:|-50-[label]-50-|"   .alignAllTop        #// 左右マージン
                                    - superView  "V:[topField]-10-[bottomField]"             #// 縦方向の間隔
                                    - superView  "V:|-0-[labelA]-10-[labelB]-0-|"            #// 縦方向の間隔と、親の縦の範囲
                                その他: |
                                    - [button]-[textField]           #// 標準的な間隔
                                    - [button(>=50)]                 #// 幅
                                    - [button(>=70,<=100)]           #// 幅に複数の制約
                                    - [maroonView][blueView]         #// 間隔なし
                                    - |-[find]-[findNext]-[textField(>=20)]-|   #// textField のみ可変
                                    - |-(>=20)-[view]-(>=20)-|       #// センタリング（未確認）  https://stackoverflow.com/questions/12873372/centering-a-view-in-its-superview-using-visual-format-language
                                            options: .alignAllCenterX  #// これは2つの場合？
                                その他 >> 同じ値, 一次方程式:  #search: NSLayoutAnchor
                                #ref: https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html
                            構文:
                                <visualFormatString> :==
                                    (<orientation>:)?(|<connection>)?<view>(<connection><view>)*(<connection><superView>)?
                                <orientation> :== H|V
                                ...
                                #ref: https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ProgrammaticallyCreatingConstraints.html
                            複合指定:
                                基本: |
                                    以下の 2つがあるとき
                                        [button]-[textField]
                                        [button(>=50)]
                                    1つにすることができます。
                                        [button(>=50)]-[textField]
                                サンプル: |  #// 複合指定をするほうが、可変の部分がどこにあるかが一目瞭然になります。
                                    V:|-50-[tableView]-10-[textField(==50)]-90-|
                            メトリクス: #keyword: Xcode metrics  #// VFL に指定する変数
                                サンプル: |  #focus: metrics
                                    let views: [String: Any] = ["customView": customView, "tabBar": tabBarController.tabBar]
                                    let metrics: [String: Any] = ["height": 40] // customView の高さ

                                    let horizontalConstraints = NSLayoutConstraint.constraints(
                                        withVisualFormat: "H:|[customView]|", options: [], metrics: nil, views: views)
                                    let verticalConstraints = NSLayoutConstraint.constraints(
                                        withVisualFormat: "V:[customView(height)]-0-[tabBar]", options: [], metrics: metrics, views: views)
                            変更:  #// 制約の設定値を変更します
                                概要コード:  #focus: var textFieldBottomConstraint,  textFieldConstraint
                                    #// 下記 .bottom は VFL の内容によって変えてください  #search: Xcode .firstAttribute
                                    初期化時: |
                                        var textFieldBottomConstraint: NSLayoutConstraint?
                                        let metrics: [String: Any] = ["bottomMargin": bottomMargin]

                                        override func viewDidLoad() {
                                            let  textFieldConstraint = NSLayoutConstraint.constraints(
                                                withVisualFormat: "V:[textField]-(bottomMargin)-|", options: .alignAllCenterX, metrics: metrics, views: views)
                                            self.textFieldBottomConstraint = textFieldConstraint.first(where: { $0.firstAttribute == .bottom })
                                    イベント発生時: |
                                        @objc private func keyboardWillShow(_ notification: Notification) {
                                            self.textFieldBottomConstraint!.constant = keyboardHeight + 10
                                            self.view.layoutIfNeeded()
                                    補足説明:
                                        textFieldConstraint: textField の bottom（bottomMargin）に関する制約（式）
                                        bottomMargin: constraints を実行するときは、初期値を指定します。
                                            イベントが発生して constant に設定すると textField の bottom の値が constant に設定した値になります
                                サンプル:  #search: UITextFieldKeyboard-14-1
                            制限, サポート外:
                                - アスペクト比の制約は VFL ではできません
                                - 重ね合わせの制約は VFL ではできませんが、親と重ねることはできます
                                    superView  "H:|-0-[label]"
                                    superView  "V:|-0-[label]"
                                    #search: CommingSoonNotification
                                    #ref: https://stackoverflow.com/questions/28460139/giving-views-the-same-position-in-visual-formatting-language
                            トラブルシューティング (Xcode VFL constraint):
                                - #// Options mask required views to be aligned on a vertical edge, which is not allowed for layout that is also vertical.
                                    手順: |
                                        NSLayoutConstraint.constraints(withVisualFormat:
                                            "V:|-50-[tableView]-10-[textField(==50)]-(bottomMargin)-|",
                                            options: .alignAllBottom, metrics: metrics, views: views)
                                    原因:
                                        垂直方向の制約では、垂直方向の align のオプションを指定できません。
                                    対処:
                                        options 引数への指定を [] または alignLeft などの水平方向の align のオプションに変更します
                                    サンプル: |
                                        options: []
                                - #// Unable to install constraint on view.  Does the constraint reference something from outside the subtree of the view?
                                    対処: addConstraints メソッドを持つオブジェクトを 親View に変えます
                    デバッグ:
                        座標や制約を print 表示します:
                            printAllViewFrames: #keyword:
                                使用例: |
                                    override func viewDidLoad() {
                                        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { [weak self] in
                                            self?.view.printAllViewFrames()
                                        }
                                    }
                                出力例:  #focus: UITableView, UITextField, Constraints
                                    UITableView x,y= 0.0, 0.0: #// frame = (0.0, 0.0, 0.0, 0.0), bounds = (0.0, 0.0, 0.0, 0.0)
                                        UITextField x,y= 0.0, 0.0: #// frame = (0.0, 0.0, 300.0, 40.0), bounds = (0.0, 0.0, 300.0, 40.0)
                                        _: | #// Constraints
                                            UITableView.NSLayoutAttribute(rawValue: 4) == UITextField.NSLayoutAttribute(rawValue: 4) * 1.0 + 100.0 (priority: UILayoutPriority(rawValue: 1000.0))
                                            UITextField.NSLayoutAttribute(rawValue: 5) == UITableView.NSLayoutAttribute(rawValue: 5) * 1.0 + 10.0 (priority: UILayoutPriority(rawValue: 1000.0))
                                            UITableView.NSLayoutAttribute(rawValue: 6) == UITextField.NSLayoutAttribute(rawValue: 6) * 1.0 + 10.0 (priority: UILayoutPriority(rawValue: 1000.0))
                                            UITextField.NSLayoutAttribute(rawValue: 8) == nil.NSLayoutAttribute(rawValue: 0) * 1.0 + 50.0 (priority: UILayoutPriority(rawValue: 1000.0))
                                            _UITextLayoutCanvasView: frame = (0.0, 0.0, 0.0, 0.0), bounds = (0.0, 0.0, 0.0, 0.0)
                                            #// end Constraints
                                出力の説明:
                                    - 所有関係がインデントで表現されます
                                    - 実際の座標が x,y と frame と bounds で表示されます
                                    - 座標は左上が 0,0 です
                                    - 制約 Constraints が表示されます
                                    - printAllViewFrames（UIView.subviews）の順番は、表示の順番と関係していて、
                                        配列のインデックスが小さい方が奥、大きい方が手前に表示されます。
                                定義: |  #// 1st output is made by Claude
                                    extension UIView {
                                        func printAllViewFrames(indent: String = "") {
                                            let  windowPosition = self.superview?.convert(self.frame.origin, to: nil).string() ?? ""

                                            print("\(indent)\(type(of: self)) x,y= \(windowPosition): #// frame = \(frame), bounds = \(bounds)")
                                            
                                            if let constraints = self.superview?.constraints.filter({ $0.firstItem === self || $0.secondItem === self }) {
                                                print("\(indent)    _: | #// Constraints")
                                                for constraint in constraints {
                                                    print("\(indent)        \(describeConstraint(constraint))")
                                                }
                                                print("\(indent)        #// end Constraints")
                                            }

                                            self.printCellLabel(indent: indent)

                                            for subview in self.subviews {
                                                subview.printAllViewFrames(indent: indent + "    ")
                                            }
                                        }

                                        private func describeConstraint(_ constraint: NSLayoutConstraint) -> String {
                                            let firstItemDesc = constraint.firstItem != nil ? "\(type(of: constraint.firstItem!))" : "nil"
                                            let secondItemDesc = constraint.secondItem != nil ? "\(type(of: constraint.secondItem!))" : "nil"
                                            
                                            return """
                                            \(firstItemDesc).\(constraint.firstAttribute.displayName) \
                                            \(relationToString(constraint.relation)) \
                                            \(secondItemDesc).\(constraint.secondAttribute.displayName) \
                                            * \(constraint.multiplier) \
                                            + \(constraint.constant) \
                                            (priority: \(constraint.priority.displayName))
                                            """
                                        }

                                        private func printCellLabel(indent: String) {
                                            if let cell = self as? UITableViewCell {
                                                if let textLabel = cell.textLabel {
                                                    if let text = textLabel.text {
                                                        print("\(indent)    .textLabel: \(text.replacingOccurrences(of: "\n", with: " "))")
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    private func relationToString(_ relation: NSLayoutConstraint.Relation) -> String {
                                        switch relation {
                                        case .equal: return "=="
                                        case .lessThanOrEqual: return "<="
                                        case .greaterThanOrEqual: return ">="
                                        @unknown default: return "unknown"
                                        }
                                    }

                                    extension NSLayoutConstraint.Attribute {
                                        var displayName: String {
                                            switch self {
                                            case .left: return "left"
                                            case .right: return "right"
                                            case .top: return "top"
                                            case .bottom: return "bottom"
                                            case .leading: return "leading"
                                            case .trailing: return "trailing"
                                            case .width: return "width"
                                            case .height: return "height"
                                            case .centerX: return "centerX"
                                            case .centerY: return "centerY"
                                            case .lastBaseline: return "lastBaseline"
                                            case .firstBaseline: return "firstBaseline"
                                            case .leftMargin: return "leftMargin"
                                            case .rightMargin: return "rightMargin"
                                            case .topMargin: return "topMargin"
                                            case .bottomMargin: return "bottomMargin"
                                            case .leadingMargin: return "leadingMargin"
                                            case .trailingMargin: return "trailingMargin"
                                            case .centerXWithinMargins: return "centerXWithinMargins"
                                            case .centerYWithinMargins: return "centerYWithinMargins"
                                            case .notAnAttribute: return "notAnAttribute"
                                            @unknown default: return "unknown(\(rawValue))"
                                            }
                                        }
                                    }

                                    extension UILayoutPriority {
                                        var displayName: String {
                                            if self == .required { return "required" }
                                            if self == .defaultHigh { return "defaultHigh" }
                                            if self == .defaultLow { return "defaultLow" }
                                            if self == .fittingSizeLevel { return "fittingSizeLevel" }
                                            return "custom(\(rawValue))"
                                        }
                                    }

                                    extension CGPoint {
                                        func  string() -> String {
                                            return  "\(self.x), \(self.y)"
                                        }
                                    }
                        レイアウトの様子が分かる矩形の補助線を表示します:
                            iPhone シミュレーターで起動します（エラーが発生しないように）>>
                            Xcode >> Debug メニュー >> View Debugging >> Show View Frames
                    リスト:  #keyword: Xcode SwiftUI List
                種類:  #keyword: translatesAutoresizingMaskIntoConstraints
                    true: AutoresizingMask でレイアウトします
                    false: AutoLayout でレイアウトします  #search: Xcode auto layout
                #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Swift_list
                サンプル:  #// 右上の＋ボタンを押すと行を増やします
                    ContentView.swift: |  #// SwiftApp1 をベースに ContentView.swift だけ変更します  #search: SwiftApp1
                        import SwiftUI

                        struct  ListItem {
                            var  id: Int
                            var  text: String
                        }

                        let  initialItems: [ListItem] = [
                            ListItem(id: 0, text: "行をクリックすると行が追加されます"),
                            ListItem(id: 1, text:"    id: \\.element.id によって追加するときのアニメーションが正しくなります"),
                            ListItem(id: 2, text: "end")
                        ]

                        var  nextId = 3;

                        struct  ContentView: View {

                            @State private var  listItems: [ListItem] = initialItems
                            
                            var body: some View {
                                NavigationView {

                                    List {
                                        ForEach(Array(self.listItems.enumerated()), id: \.element.id) { index, item in
                                            Button(action: {
                                                withAnimation {
                                                    self.listItems.insert(
                                                        ListItem(
                                                            id: self.listItems.count,
                                                            text: "追加アイテム \(nextId)"),
                                                        at: index + 1)
                                                }
                                                nextId += 1
                                            }) {
                                                Text(item.text)
                                            }
                                        }
                                    }

                                    // title
                                    .navigationBarTitle(Text("アコーディオン"))

                                    // reset button
                                    .navigationBarItems(trailing: Button(action: {
                                        withAnimation {
                                            self.listItems = initialItems
                                        }
                                    }) {
                                        Text("Reset")
                                    })
                                }
                            }
                        }

                        struct ContentView_Previews: PreviewProvider {
                            static var previews: some View {
                                ContentView()
                            }
                        }
                行の背景色:  __ListChild__(____){____}.listRowBackground(Color.yellow)
                    #search: Xcode Swift Color
            イベント: #keyword: Xcode event
                UIKit, Storyboard なし:  #search: Xcode delegate
                Storyboard:  #search: Xcode connect example
                アプリケーションの状態遷移:  #search: Xcode app state
                NotificationCenter: #keyword: NotificationCenter,  addObserver (#selector) @objc
                    クリップボード:  #search: Xcode clipboard NotificationCenter
                    キーボードの表示非表示:  #search: UITextFieldKeyboard-14-1
                UNUserNotificationCenter:  #// ユーザーへの通知機能  #search: Xcode 通知
                その他: #ref: https://xyk.hatenablog.com/entry/2020/10/09/170112
            アトリビュート:  #// __GUI_Part__.padding()  #keyword: Xcode attribute
                関連: (@)の付いたアトリビュート  #search: Swift attribute
                padding:  #keyword: Xcode padding
                    - __GUI_Part__.padding()    #// GUI部品の上下左右にパディング（余白）を追加します
                    - __GUI_Part__.padding(.top)  #// GUI部品の上だけにパディング（余白）を追加します
                    - __GUI_Part__.padding(.top, 20)  #// パディングの長さは 20（デフォルトは17）
                色の値: #keyword: Xcode Swift Color
                    Color:
                        サンプル: Color.gray.opacity(0.2)
                        #// https://developer.apple.com/documentation/swiftui/color
                    UIColor: #keyword: Xcode UIColor
                        色名指定: |
                            UIColor.white.cgColor
                        数値指定: |
                            UIColor(red: 0.9, green: 0.9, blue: 0.9, alpha: 1.0).cgColor
            MVC:  #search: Swift MVC
        アセット: #keyword: Xcode assets,  Xcode icon  #// アイコンなど
            概要: #ref: https://blog.mothule.com/ios/ios-xcassets-basic
            場所:
                Xcode 内: Xcode >> Project Navigator >>（プロジェクト）>> Assets（ツリー内）
                    #// AccentColor, AppIcon があります
                フォルダー: __Project__/__Target__/Assets.xcassets
                素材:  #// アセットに登録する前の素材の置き場所のサンプル
                    アプリ アイコン: #keyword: AppIcon,  Xcode App icon
                        （親）手順 >> 登録:  #search: Xcode assets
                        ファイルの置き場所: __Project__/__Target__/AssetsSource/mainIcon.png
                            #// AssetsSource は自分で作ります
                        設定: Xcode >> Project Navigator >>（___App内）Assets
            関連:  #search: Xcode project editor
        ストレージ, ファイル: #keyword: iOS storage, iPhone Xcode storage
            パス: #search: Xcode URL
            ローカル, サンドボックス内: #keyword: iOS サンドボックス  #// UserDefaults, FileManager, Bundle, Keychain
                UserDefaults: #keyword:  #// アプリケーションが終了しても、維持される保存されたデータの置き場所
                    対象データ:
                        小さい, 頻繁に読む
                    特徴:
                        - アプリを起動すると、メモリーに展開され、高速に読むことができます
                        - ファイル名の代わりにキー（文字列）を指定します
                    セキュリティ:
                        暗号化: なし
                        削除: アプリを削除（閉じるではない）すると、削除されます
                    値:
                        String, Int, Bool, 配列, 辞書, Data など
                    UserDefaults.standard.set: | #keyword:
                        UserDefaults.standard.set(_ value: Any?, forKey defaultName: String)
                    UserDefaults.standard.data: #keyword:
                        書式:
                            Int: |
                                UserDefaults.standard.integer(forKey defaultName: String) -> Int
                            その他:
                                .string, .stringArray, .array, .dictionary, .float, .double, .bool
                            Data?: |
                                UserDefaults.standard.data(forKey defaultName: String) -> Data?
                    UserDefaults.standard.removeObject: #keyword:
                    #ref: https://qiita.com/shiz/items/c7a9b3218269c5c92fed
                ファイル: #keyword: Xcode FileManager
                    公式: #ref: https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html
                    サンプル:  #search: File-14-1
                    対象データ:
                        PDF などのファイル, 画像, 
                    セキュリティ:
                        暗号化: なし
                        ユーザー: ファイル アプリ から内容が見えます
                        削除: アプリを削除（閉じるではない）すると、削除されます
                    ディレクトリ: #search: Xcode URL
                    コピー: |
                        try! FileManager.default.copyItem(at: imageFileURL, to: imageFileURL.appendingPathExtension("bak"))
                    シミュレーター内ファイル:  #search: Xcode simulator file
                    #ref: https://capibara1969.com/2836/
                    関連:  #search: Swift Document Management API
                Bundle:  #// プロジェクトに含まれているリソースファイル
                    #ref: https://capibara1969.com/2253/
                    #ref: https://dev.classmethod.jp/articles/swift-txt-read-and-write/
                Keychain: #keyword: Keychain,  キーチェーン,  キーチェイン
                    対象データ:
                        個人情報, パスワード, トークン
                    セキュリティ:
                        暗号化: あり
                        削除: アプリを削除しても残ります
                    関連 >> iPhone のパスワード:  #search: iPhone password
                データベース:
                    対象データ:
                        高速アクセスが必要な大量のデータ
                    Core Data:
                    Realm:
                    SQLite:
                参考:
                    公式: #ref: https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW2
                    【iOS】デバイス(ローカル)にデータを保存する方法: #ref: https://qiita.com/shiz/items/c7a9b3218269c5c92fed
            Document Management API:  #keyword: Swift Document Management API  #// ファイルを開くページ
                #// USB ストレージと SMB（共有フォルダー）にも対応  iOS13以降
                イメージ: #ref: ${my_images}/2022/Apple/file_app_iPad.png
                注意: ユーザーが毎回開く操作が必要です。そうさせないようにするには #search: UIDocumentPickerViewController
                公式:
                    動画: #ref: https://developer.apple.com/videos/play/wwdc2018/216/
                    文書:
                        ドキュメント ベース App:  #search: ドキュメント ベース App
                        ドキュメント ブラウザー をアプリに追加する:  #search: Swift ドキュメント ブラウザー 公式
                手順:
                    サンプル プロジェクト:
                        非公式?: #ref: https://github.com/naritaseiji/DocumentBasedApp
                    ファイルを開くページ:  #search: UIDocumentBrowserViewController
                    Quick Look:  #// プレビュー
                    移動 >> FileManager.moveItem: ファイルの移動。ボリュームをまたいで移動することもできます
                概念:
                    ドキュメント ベース App: #keyword:  #ref: https://developer.apple.com/jp/document-based-apps/
                    ファイル URL: #search:
                    ファイル形式:
                        ファイルのタイプ:
                            CFBundleDocumentTypes: #keyword:
                                公式: #ref: https://developer.apple.com/documentation/bundleresources/information_property_list/cfbundledocumenttypes
                                画像形式: #ref: https://stackoverflow.com/questions/28569099/how-to-register-an-ios-app-for-multiple-image-extensions
                                    <key>CFBundleDocumentTypes</key>
                                    <array>
                                        <dict>
                                            <key>CFBundleTypeName</key>
                                            <string>public.jpeg</string>
                                            <key>CFBundleTypeRole</key>
                                            <string>Editor</string>
                                            <key>LSHandlerRank</key>
                                            <string>Owner</string>
                                            <key>LSItemContentTypes</key>
                                            <array>
                                                <string>public.jpeg</string>
                                            </array>
                                        </dict>
                                        <dict>
                                            <key>CFBundleTypeName</key>
                                            <string>public.png</string>
                                            <key>CFBundleTypeRole</key>
                                            <string>Editor</string>
                                            <key>LSHandlerRank</key>
                                            <string>Owner</string>
                                            <key>LSItemContentTypes</key>
                                            <array>
                                                <string>public.png</string>
                                            </array>
                                        </dict>
                                        <dict>
                                            <key>CFBundleTypeName</key>
                                            <string>GIF image</string>
                                            <key>CFBundleTypeRole</key>
                                            <string>Editor</string>
                                            <key>LSHandlerRank</key>
                                            <string>Owner</string>
                                            <key>LSItemContentTypes</key>
                                            <array>
                                                <string>com.compuserve.gif</string>
                                            </array>
                                        </dict>
                                    </array>
                        ファイル パッケージ 形式: #keyword:
                            概要: 実体はフォルダーですが、開いてから閉じるまでが複数のファイルに対する操作のトランザクションになります
                            FileWrapper: #keyword: Swift FileWrapper  #// ファイル パッケージ用 API
                                #ref: https://qiita.com/naritaseiji/items/b5a7839cb53eb34415d2#filewrapper
                                概要: 一括操作, 差分書き出し, 遅延読み込み, ファイル マッピング ができます
                            UIDocument: #keyword: Swift UIDocument
                                #ref: https://qiita.com/naritaseiji/items/b5a7839cb53eb34415d2#uidocument
                                概要: 協調読み書き, 非同期の読み書き, 更新の監視, 安全な書き込み, 自動保存, エラーやコンフリクトの通知, サンドボックス外のファイルアクセス
                                Security-scoped URL:
                                    概要: サンドボックス外のファイルのURL。アクセス権を取得する必要があります。
                                        アクセス権を取得は UIDocument の内部で行われます
                        テンポラリ フォルダー:
                            コード: #ref: https://developer.apple.com/videos/play/wwdc2019/719/ >> 6:19
                                .itemReplacementDirectory:
                                    （今までは FileManager.temporaryDirectory）
                        LIFS: #// Live Item FS. USB と SMB といった ファイル システム の抽象
                        UIDocument: #keyword:  #ref: https://developer.apple.com/documentation/uikit/uidocument
                            関連 >> UIManagedDocument: #// データベース
                            参考: #ref: https://qiita.com/naritaseiji/items/b5a7839cb53eb34415d2
                            サンプル プロジェクト: #ref: https://github.com/naritaseiji/DocumentBasedApp
                            サブクラス化: #ref: https://developer.apple.com/documentation/uikit/uidocument >> Subclassing notes
                                書く場合:
                                    contents(forType:):
                                        コール元: .save(to:for:completionHandler:)
                                        ファイルの場合:  NSData 型で返す？
                                        ファイル パッケージ 形式の場合: FileWrapper 型で返す？
                                自動保存する場合:
                                    #ref: https://developer.apple.com/documentation/uikit/uidocument >> Change tracking
                                    定期的に hasUnsavedChanges メソッドを呼び出して true が返れば自動保存します
                                    UndoManager クラス、または、 updateChangeCount(_:) メソッドで Change tracking します
                                読む場合:
                                    load(fromContents:ofType:):
                                        コール元: .open(completionHandler:)
                                        形式: contents(forType:) と同じ
                                Clowd の場合:
                                    #ref: https://developer.apple.com/documentation/uikit/uidocument >> Conflict resolution and error handling
                                その他:  #ref: https://developer.apple.com/documentation/uikit/uidocument >> Advanced overrides
                                参考: #ref: https://qiita.com/naritaseiji/items/b5a7839cb53eb34415d2 >> Document
                            ファイル URL: #keyword:  #// ファイル URL 関連の　UIDocument のメソッド
                                init(fileURL:): #ref: https://developer.apple.com/documentation/uikit/uidocument/1619979-init
                                localizedName: ドキュメント名  #ref: https://developer.apple.com/documentation/uikit/uidocument/1619959-localizedname
                                fileType: 拡張子  #ref: https://developer.apple.com/documentation/uikit/uidocument/1619992-filetype
                                値:  #// Foundation.URL 型
                                    documentURL: #ref: ${GitHub}/MyPrivateCode/Swift/DocumentBasedApp/images-ref/DocumentBasedApp/DocumentBrowserViewController.swift#func presentDocument
                            新規作成と保存:
                                .save(to:for:completionHandler:): #keyword:  #ref: https://developer.apple.com/documentation/uikit/uidocument/1619988-save
                                    #// UIDocument は、変更内容を定期的にファイルに書き込みます
                            開く:
                                .open(completionHandler:): #keyword:  #ref: https://developer.apple.com/documentation/uikit/uidocument/1619977-open
                            閉じる:
                                .close(completionHandler:): #keyword:  #ref: https://developer.apple.com/documentation/uikit/uidocument/1619976-close
                            completionHandler 引数: #// 非同期処理が終わったときに呼ばれます
                                補足:
                                    非同期処理が失敗したときも呼ばれます。 そのときは false が渡されます
                                サンプル: #search: open(completionHandler:)
                            NSFilePresenter プロトコル:  #ref: https://developer.apple.com/documentation/foundation/nsfilepresenter
                                概要: 他のクライアントが保存中は読むことを待ちます。UIDocument のサブクラスは実装を変更できます
                                relinquishPresentedItem(toReader:):
                                    performAsynchronousFileAccess をブロックします
                                relinquishPresentedItem(toWriter:):
                                    他のクライアントによって更新があったら revert(toContentsOf:completionHandler:) が呼ばれます
                                presentedItemDidMove(to:):
                                    ファイル URL を変更します
                            エラー:  #ref: https://developer.apple.com/documentation/uikit/uidocument >> Conflict resolution and error handling
                            マルチスレッド:  #ref: https://developer.apple.com/documentation/uikit/uidocument >> Thread safety considerations
                    ブラウザー >> UIDocumentBrowserViewController: #keyword: Swift file open browser,  UIDocumentBrowserViewController
                        外観:
                            参考 >> Managing Documents in Your iOS Apps (2018):
                                #ref: https://developer.apple.com/videos/play/wwdc2018/216/
                        サムネイル:
                            コード: https://developer.apple.com/videos/play/wwdc2019/719/ >> 9:16
                                QLThumbnailGenerator.Request
                                QLThumbnailRepresentation
                                CGImage
                                UIImage
                                NSImage
                                updateHandler 高品質のサムネイルに置き換えるとき
                            旧:
                                QLThumbnail: #// mac 用
                                NSURLThumbnailDictionary: #// 今まで
                        コード: #ref: https://developer.apple.com/videos/play/wwdc2019/719/ >> 8:43
                        公式:  #keyword: Swift ドキュメント ブラウザー 公式
                            ドキュメント ブラウザー をアプリに追加する: #ref: https://developer.apple.com/documentation/uikit/view_controllers/adding_a_document_browser_to_your_app
                    ピッカー >> UIDocumentPickerViewController: #keyword:  #// ファイルを1つ選ぶ。(iOS13以降)フォルダーも選べます
                        コード: #ref: https://developer.apple.com/videos/play/wwdc2019/719/ >> 2:55 >>
                            上半分はフォルダーの選択、下半分のコードは画像の選択
                        bookmarkData:  URL を維持する？保存用？
                        保存:
                            必要な処理:
                                - 保存できない時の別の保存先の選択
                                - バックグラウンドでの処理。プログレスバーとキャンセル
                    セキュリティ >> 特定のアプリをフォルダーにアクセスできないようにします:
                        ユーザー設定: Settings >> プライバシーとセキュリティ >> ファイルとフォルダ >>（アプリ）
                        必要なコード: 拒否されたときのエラー処理
                参考: #ref: https://kumonosu.cloudsquare.jp/program/swift/post-4029/
            ファイルプロバイダ拡張機能: #keyword: Document Provider Extension
                UIDocumentPickerViewController: #keyword:
                    ファイルプロバイダ拡張機能を使った他のアプリのフォルダーの中にアクセスします
                    #search: DocumentPicker
                NSFileProviderExtension: #keyword:
                    iOS標準「ファイル」アプリ内で直接表示および操作できるようになります。
                    アプリがExternal files and foldersにフォルダーを公開するだけであれば、NSFileProviderExtensionは必要ありません。
                    Info.plistに適切なキーを設定
                    NSFileProviderExtensionを実装すると、以下のような追加機能が得られます：
                        リモートファイルのオンデマンドダウンロード
                        効率的なファイル同期
                        より詳細なファイルメタデータの提供
                        システム全体でのリアルタイムファイル更新通知
                Security-Scoped Bookmarks: #keyword:
                    UIDocumentBrowserViewController の内部で使っています
                エンタイトルメント: #keyword:  #// iOS のセキュリティモデルの一部
                    _: UIDocumentBrowserViewController を使用してユーザーが選択したフォルダにアクセスする場合、
                        通常は com.apple.security.files.user-selected.read-write エンタイトルメントが必要です。
                    com.apple.security.files.user-selected.read-only:
                        ユーザーが選択したファイルへの読み取り専用アクセスを許可します。
                    com.apple.security.files.user-selected.read-write:
                        ユーザーが選択したファイルへの読み取りと書き込みアクセスを許可します。
                    com.apple.security.files.downloads.read-only:
                        ダウンロードフォルダへの読み取り専用アクセスを許可します。
                    com.apple.security.files.downloads.read-write:
                        ダウンロードフォルダへの読み取りと書き込みアクセスを許可します。
                    com.apple.security.files.pictures.read-only:
                        ピクチャフォルダへの読み取り専用アクセスを許可します。
                    com.apple.security.files.pictures.read-write:
                        ピクチャフォルダへの読み取りと書き込みアクセスを許可します。
            External files and folders: #keyword: Textastic External files and folders
                Texastic の機能です
            SMB: #keyword: Xcode SMB
                #// Textastic（アプリ）で NAS にアクセスできた
                参考 >> Support USB and SMB in Your App:
                    #ref: https://developer.apple.com/forums/thread/131644
                    #ref: https://developer.apple.com/videos/play/wwdc2019/719/
                アクセス:
                    #// セキュリティスコープのURLがある場合は、実際のファイルシステムアクセスを括弧で囲む必要があります。
                    概要: |  #keyword: startAccessingSecurityScopedResource
                        startAccessingSecurityScopedResource()
                        ...
                        stopAccessingSecurityScopedResource()
                    #ref: https://developer.apple.com/forums/thread/131644
                    サンプル: |  #ref: ${GitHub}/MyPrivateCode/Swift/1st/DocumentBrowser-14-1/FirstUIKit-14-1/ViewController.swift#fileContents
                        func documentBrowser(_ controller: UIDocumentBrowserViewController, didPickDocumentsAt documentURLs: [URL]) {
                            guard let sourceURL = documentURLs.first else { return }
                            let accessing = sourceURL.startAccessingSecurityScopedResource()

                            let fileContents = try! String(contentsOf: sourceURL)
                            if (accessing) {
                                sourceURL.stopAccessingSecurityScopedResource()
                Document Browser:
                    #search: DocumentBasedApp
                    #search: Swift Document Management API
                NSOpenPanel:  #// mac 用らしい。iOS では Cannot find 'NSOpenPanel' in scope
                    #ref: https://stackoverflow.com/questions/63764637/open-a-filedialog-in-swiftui-on-macos
                    #ref: https://qiita.com/takecian/items/d31682899768f89a8d80
                #// アプリで SMB クライアントを扱わないとアクセスできない？
                #// しかし、iOSはSMBをネイティブにサポートしていません。 #ref: https://stackoverflow.com/questions/57917671/access-windows-mac-shared-folder-locally-with-smb-from-ios
            ファイル（アプリ）:
                ファイル アプリ でファイルを選んだときに開発したアプリを開く:
                    #ref: https://kumonosu.cloudsquare.jp/program/swift/post-4029/
                UIFileSharingEnabled:
                    Application supports iTunes file sharing：いちばん下
                    #ref: https://qiita.com/ShingoFukuyama/items/e85d34360f3f951ca612
                LSSupportsOpeningDocumentsInPlace:
                    Supports opening documents in place：上から2番目
                    #ref: https://qiita.com/ShingoFukuyama/items/e85d34360f3f951ca612
            iTunes file sharing:  #// ファイル（アプリ）の中にアプリケーションのフォルダーを追加する場合
                イメージ: #ref: ${my_images}/2022/Apple/itunes-file-sharing.png
                参考:
                    #ref: https://support.apple.com/en-us/HT201301
                    #ref: https://qiita.com/ShingoFukuyama/items/e85d34360f3f951ca612
            Google Drive:
                Google Driveのファイル一覧を取得する: #ref: https://www.colorfulbox.jp/media/blog-kakikata-kiji-kotu/
        キーボード: #keyword: Xcode keyboard
            テキスト入力:  #search: Xcode TextField
            表示非表示:
                シミュレーターで表示・非表示させる場合: #keyword: Xcode toggle software keyboard
                    Simulator >> I/O >> Keyboard >> Toggle Software Keyboard
                表示・非表示: #keyword: Xcode UITextField.becomeFirstResponder,  Xcode show hide software keyboard 
                    表示: UITextField.becomeFirstResponder() 
                    非表示: UITextField.resignFirstResponder()
                フォーカスを外します: resignFirstResponder
                ビューの位置を変えるコード:  #search: UITextFieldKeyboard-14-1
        タイマー:
            #ref: https://zenn.dev/ryo_kawamata/articles/timer-app-with-swift-ui
            関連:
                待ち:  #search: Swift wait layout
        ペーストボード, クリップボード: #keyword: Xcode clipboard, UIPasteboard
            公式: https://developer.apple.com/documentation/uikit/uipasteboard
            参考:
                https://dev.classmethod.jp/articles/ios-10-uipasteboard/
                https://pinkstone.co.uk/how-to-access-values-from-the-clipboard-in-ios-from-copy-and-cut-operations/
            サンプルA: |  #// 画像の貼り付け  #ref: ${GitHub}/MyPrivateCode/Swift/CommingSoonNotification/FirstUIKit-14-1/ViewController.swift#UIPasteboard
                let pasteBoard = UIPasteboard.general
                if pasteBoard.hasImages {
                    imageField.image = pasteBoard.image
                }
            サンプルB:  #// クリップボードへの設定と、クリップボードの内容の参照
                ContentView.swift: |  #// SwiftApp1 をベースに ContentView.swift だけ変更します  #search: SwiftApp1
                    import SwiftUI

                    struct ContentView: View {
                        @State var  message:String = "(message)"
                        @State var  count:Int = 0

                        var body: some View {
                            VStack {
                                Text(message).padding()
                                Button("Tap Me !") {

                                    let pasteboard = UIPasteboard.general
                                    if true { // false = get from clipboard
                                        pasteboard.string = "TEST"
                                        pasteboard.url = URL(string: "http://www.sapporoworks.ne.jp")
                                        //pasteboard.image = UIImage(named: "sample.png") // imageをセットするとhasImagesのみがtrueを返す
                                        //pasteboard.color = UIColor.blue　//colorをセットするとhasColorのみがtrueを返す
                                    }
                                    if pasteboard.hasStrings {
                                        print("has Strings!")
                                    }
                                    if pasteboard.hasURLs {
                                        print("has URLs!")
                                    }
                                    if pasteboard.hasImages {
                                        print("has images!")
                                    }
                                    if pasteboard.hasColors {
                                        print("colors!")
                                    }

                                    var  clipboardText = "(no string)"
                                    if pasteboard.hasStrings {
                                        for item in pasteboard.items {
                                            let  text = item["public.utf8-plain-text"]
                                            if text != nil {
                                                clipboardText = text as! String;
                                            }
                                        }
                                    }

                                    count += 1
                                    message = "Tapped! \(count) \(clipboardText)"
                                }.padding()
                            }
                        }
                    }

                    struct ContentView_Previews: PreviewProvider {
                        static var previews: some View {
                            ContentView()
                        }
                    }
            クリップボードが変更された時の処理:
                通知タイミング: フォアグランドのときにクリップボードが変更されたときのみ。
                    バックグラウンドで変更されたときは通知されません。フォアグランドになったときにクリップボードをチェックします
                サンプル: |  #keyword: Xcode clipboard NotificationCenter
                    class SceneDelegate: UIResponder, UIWindowSceneDelegate {
                        func scene(...
                    または
                    class AppDelegate: UIResponder, UIApplicationDelegate {
                        func application(...
                            // クリップボードが変更された時の処理を登録します
                            NotificationCenter.default.addObserver(self,
                                selector: #selector(handleClipboardChanged),
                                name: UIPasteboard.changedNotification, object: nil)
                        }
                        @objc func handleClipboardChanged() {
                            print("handleClipboardChanged")
                        }
        ネットワーク, 非同期処理: #keyword: Xcode URLSession
            URLSession:
                URLSession.shared.downloadTask
                https://stackoverflow.com/questions/39103095/unnotificationattachment-with-uiimage-or-remote-url
            URL: #keyword: Xcode URL,  Xcode path  #ref: https://developer.apple.com/documentation/foundation/url
                値のサンプル: #keyword: Xcode URL example
                    iPhone 内:
                        Home, サンドボックス内:  #keyword: NSHomeDirectory()
                            Documents: #// 形式: file:///var/mobile/Containers/Data/Application/__AppUUID__/Documents/
                                役割: サンドボックスの中にアプリケーションが保存するファイルを入れる場所。ユーザーが存在を意識するファイルもあります
                                バックアップ: iTunes と iCloud を通じてバックアップされます。
                            Library:   #// 形式: file:///var/mobile/Containers/Data/Application/__AppUUID__/Library/
                                役割: 設定ファイルやデータベースなど、ユーザーが直接見ることのないファイルが保存される場所
                                バックアップ: iTunes と iCloud を通じてバックアップされます
                            Caches: #// 再度ダウンロードまたは再生成できるデータ
                            tmp:       #// 形式: file:///var/mobile/Containers/Data/Application/__AppUUID__/tmp/
                                保存期間: デバイスが再起動されると、このフォルダーの内容は削除されます。
                            Documents/Inbox:
                            Library/Cache:
                        private: #keyword: Xcode URL private      #// 形式: file:///private/var/____
                            file:///private/var/ から始まる URL と file:///var/ から始まる URL の違いはありません。
                            file:///var/ -> file:///private/var/ のシンボリックリンクです。
                            プライベートなのでアクセスに制限があるわけではありません。
                            #ref: ${typrm_files}/ref/Swift-AI.yaml#label: private URL
                        AppGroup: #keyword: Xcode URL AppGroup    #// 形式: file:///private/var/mobile/Containers/Shared/AppGroup/
                            アプリケーショングループは、同じ開発者によって作成された複数のアプリケーションがデータを共有できるようにします
                        DocumentBasedApp:  #keyword: Xcode URL DocumentBasedApp  #// 形式: file:///private/var/mobile/Containers/Shared/AppGroup/__AppUUID__/File%20Provider%20Storage/
                            「ファイル」アプリで見えるフォルダーは、DocumentBasedApp でなければ、一覧もリードもできません。ファイルが見つからないエラーになります。
                            "/private/var/mobile/Containers/Shared/AppGroup/23F62319-FB9C-4F7E-AF92-A8531A58E1B0/File%20Provider%20Storage/Repositories/steps/"
                        iCloud:
                        実機でのデバッグ中の例: "file:///private/var/mobile/Containers/Shared/AppGroup/6B60BC57-5DC6-435A-A17D-B391927369CB/File%20Provider%20Storage/Document.mydoc"
                            #template__: file:///private/var/mobile/Containers/Shared/AppGroup/__UUID__/File Provider Storage/__Path__
                        調べ方: #keyword: print Xcode path
                            DocumentBrowser-14-1 を実行してファイルをタップするとパス（と内容）が表示されます  #search: DocumentBrowser-14-1
                    iPhone シミュレーター内: #keyword: Xcode path in simulator
                        例: "file:///Users/user1/Library/Developer/CoreSimulator/Devices/8225DECC-F745-48F9-912D-2FF84ABB99CA/data/Containers/Data/Application/3C80DD9B-E577-46A5-A115-C41A9BABF911/Documents/Document%202.mydoc"
                            #template__: file://__Home__/Library/Developer/CoreSimulator/Devices/__Simulator__/__App__/Documents/__Path__
                        NSHomeDirectory:
                            NSHomeDirectory() ==
                                "__Home__/Library/Developer/CoreSimulator/Devices/FFEEB7F6-161B-4AAD-8A5F-F0F87909AB53/data/Containers/Data/Application/B3943D69-B46D-4634-9B6A-21A56EF24131"
                        temporaryDirectory:
                            FileManager.default.temporaryDirectory ==
                                "file://__Home__/Library/Developer/CoreSimulator/Devices/FFEEB7F6-161B-4AAD-8A5F-F0F87909AB53/data/Containers/Data/Application/B3943D69-B46D-4634-9B6A-21A56EF24131"
                URL クラス: #keyword: Xcode URL class
                    値の設定:
                        サンプル: |
                            let url = URL(fileURLWithPath: "/path/to/file/or/folder")
                            let url = URL(fileURLWithPath: ".", relativeTo: URL(fileURLWithPath: "/base/path"))
                        参考:
                            URL(fileURLWithPath:):
                            URL(filePath:):  #// 公式ドキュメントには載っていません
                                #ref: https://stackoverflow.com/questions/75208448/urlfilepath-strpath-vs-urlfileurlwithpath-strpath
                            URL(URLWithString:): #// 日本語を含むパスには使えません  #ref: https://www.abt.jp/kb/2013/06/nsurl-mistake/
                            URL(string:):  #// URL を指定すると nil が返ってしまいます
                                #ref: https://stackoverflow.com/questions/24410473/how-to-convert-this-var-string-to-url-in-swift/24410536#24410536
                    プロパティ: #glossary: Xcode URL properties
                        .path: フルパス。文字列
                        .relativePath: 相対パス。文字列  #// ただし、初期化時に relativeTo 引数が指定されていないとフルパスが返ります
                        .baseURL: 相対パスの基準。URL オブジェクト
                        .lastPathComponent: ファイル名 または フォルダー名。文字列
                        .deletingLastPathComponent(): 親フォルダーの URL
                    リード: |
                        text = try String(contentsOfFile: url.path, encoding: .utf8)
                    コピー: |
                        copyURL = URL(filePath: sourceURL.relativeString)
                    比較: |
                        if aURL.absoluteString != bURL.absoluteString {
                    一覧:  #search: Swift file list
                ファイル名: |  #search: Xcode URL properties .lastPathComponent
                    let fileName = URL(fileURLWithPath: "/path/to/file/or/folder").lastPathComponent
                リソース: #keyword: Swift URL resources  #// ローカル ファイル, ネットワーク リソース（HTTP/HTTPS, FTP）
                    ローカル ファイル:
                        例: file:///path/to/file.txt
                        Home, サンドボックス内:  #search: NSHomeDirectory()
                    ネットワーク リソース（HTTP/HTTPS）:
                        例: https://example.com/data.json
                    その他のURLスキーム:
                        例: ftp://, data:// など
                    ストレージ, ファイル:  #search: iOS storage
                リード:
                    readFileByURL:   #search: File-14-1
                        #ref: ${GitHub}/MyPrivateCode/Swift/1st/File-14-1/FirstUIKit-14-1/ViewController.swift#func  readFileByURL(
                    例外 >> バイナリ ファイル が指定されたとき: | #keyword: Swift String contentsOf  #// ファイル リード
                        try! String(contentsOf: sourceURL)
                        は、バイナリ ファイル が指定されると例外が発生します。
                        try! String(contentsOfFile: sourceURL)
                        は不明
                    リソース: #search: Swift URL resources
                ライト:
                    writeFileByURL:  #search: File-14-1
                        #ref: ${GitHub}/MyPrivateCode/Swift/1st/File-14-1/FirstUIKit-14-1/ViewController.swift#func  writeFileByURL(
                    リソース: #search: Swift URL resources
                シミュレーター内 File Manager: #search: Xcode simulator file
                関連:
                    ストレージ:  #search: iOS storage
                        #search: Xcode FileManager
                    UIDocument:  #search: ファイル URL
        共有, URL スキーム:
            共有: #keyword: Xcode 共有
                Extension プロジェクトの追加が必要
                #ref: ${typrm_files}/ref/Swift-AI.yaml#label: Xcode share from AI
            URL スキーム: #keyword: Xcode URL scheme  #// URL の書式と同じ iOS でアプリ間でデータを共有するための方式
                概要: myapp://hogehoge という形式のURLを利用して、自身のアプリ内の特定の画面や機能を起動することができます。
                Apple 公式:  #ref: https://developer.apple.com/library/archive/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899
                Working Copy との連携:  #ref: https://workingcopyapp.com/url-schemes.html
                Textastic との連携:  #ref: https://www.textasticapp.com/v9/manual/integration_other_apps/x-callback-url.html
                参考:
                    #ref: https://hibikanblog.net/blog-entry-157.html
        通知, ユーザー通知, プッシュ通知:  #keyword: Xcode 通知
            手順:
                iPhone:
                    ユーザー通知: #keyword: Xcode ユーザー通知,  Xcode 通知  #// タイマーやスケジュールなど、アプリケーションが通知条件を設定し、非アクティブのときに、ユーザーに通知します
                        サンプル プロジェクト:
                            #search: UNUserNotification-14-1
                            #ref: ${GitHub}/MyPrivateCode/Swift/1st/UNUserNotification-14-1/FirstUIKit-14-1/SceneDelegate.swift#UNNotificationRequest
                            #ref: ${GitHub}/MyPrivateCode/Swift/watch/2nd/LocalNotification-15.3
                        画像の添付:
                            #ref: ${GitHub}/MyPrivateCode/Swift/CommingSoonNotification/FirstUIKit-14-1/SceneDelegate.swift#UNNotificationAttachment
                            コード: |  #search: CommingSoonNotification
                                let content = UNMutableNotificationContent()
                                    ...
                                content.attachments = [try! UNNotificationAttachment(
                                    identifier: "CommingSoonNotification-Image-" + UUID().uuidString,
                                    url: URL(fileURLWithPath: self.viewController!.imagePath!), options: nil)]
                            画像:  #// imagePath
                                バンドルする場合:  #search: Xcode copy bundle resources
                            参考:  #ref: https://llcc.hatenablog.com/entry/2017/04/19/210000
                        性質:
                            - 通知のオーナーであるアプリケーションがアクティブのときは、通知が表示されても、ロック画面には残りません。
                                通知内容をすでに確認済みだと扱われるためのようです
                            - 複数の通知が表示された状態で、1つの通知を消去すると、他の通知も消去されてしまう原因は、
                                同じメッセージだからです。異なるメッセージであれば 1つずつ消去されます
                    プッシュ通知: #keyword: Xcode プッシュ通知  #// アプリケーションが起動していなくても、外部サーバーからユーザーに通知します
                        会社のサーバー:
                        APN, Appleプッシュ通知サービス:
                        画像でプッシュ通知:
                            #ref: https://dev.classmethod.jp/articles/ios-push-notification-attach-file/
                            添付できる形式: #ref: https://developer.apple.com/documentation/usernotifications/unnotificationattachment#1682051
                        参考:
                            公式 >> Setting Up a Remote Notification Server: #ref: https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server
                            Push Notifications Tutorial Getting Started: #ref: https://www.raywenderlich.com/11395893-push-notifications-tutorial-getting-started
                            APNsとは？設定と実装方法を解説！: #ref: https://repro.io/contents/ios-remote-push-notifications-in-a-nutshell/
                            <Swift>iOS 10 User Notifications Framework実装まとめ: #ref: https://qiita.com/mshrwtnb/items/3135e931eedc97479bb5
                Apple Watch: #keyword: Apple Watch ユーザー通知 example
                    トリガー, 通知, 内容:  #search: UNTimeIntervalNotificationTrigger
                    通知を繰り返します:
                        注意: 最短 60秒
                        コード: |  #focus: repeats,  timeInterval
                            let  notificationID = "Example"  // UUID().uuidString
                            let  trigger = UNTimeIntervalNotificationTrigger(timeInterval: 60, repeats: true)
                            let  request = UNNotificationRequest(identifier: notificationID, content: content, trigger: trigger)
                        終了:
                            コード:
                                未通知の1つ: |
                                    UNUserNotificationCenter.current().removePendingNotificationRequests(
                                        withIdentifiers: ["myRepeatingNotification"])
                                通知後の1つ: |
                                    UNUserNotificationCenter.current().removeDeliveredNotifications(
                                        withIdentifiers: ["myRepeatingNotification"])
                                未通知のすべて: |  #// 現在のアプリがリクエストしたすべての通知
                                    UNUserNotificationCenter.current().removeAllPendingNotificationRequests()
                                通知後のすべて: |  #// 現在のアプリがリクエストしたすべての通知
                                    UNUserNotificationCenter.current().removeAllDeliveredNotifications()
                                アプリ終了時: |  #// これで終了させない場合、繰り返しの通知は継続します。
                                    func applicationWillTerminate() {
                                        UNUserNotificationCenter.current().removeAllPendingNotificationRequests()
                                        UNUserNotificationCenter.current().removeAllDeliveredNotifications()
                                    }
                            補足:
                                - アプリを終了させても通知は繰り返します
                                - 通知をタップしても通知は繰り返します
                                - Apple Watch を再起動させても通知は繰り返します
                プッシュ通知をエミュレーションします:  #// iPhone シミュレーターで通知を発生させます。ロック画面でも通知が表示されます
                    __Desktop__/test.apns ファイルを作ります: |  #// ファイル名や拡張子は何でも構いません
                        {
                            "Simulator Target Bundle": "_____",
                            "aps":{
                                "alert": "from APNs file",
                                "sound": "default",
                                "badge": 0
                            }
                        }
                    ただし、Simulator Target Bundle の値は編集が必要です:
                        #search: Xcode bundle ID
                    作ったファイルを iPhone シミュレーターにドラッグ＆ドロップします:
                ユーザーの通知設定を参照します: |  #focus: getNotificationSettings
                        class AppDelegate: UIResponder, UIApplicationDelegate {
                            func application(_ application: UIApplication,
                                UNUserNotificationCenter.current().getNotificationSettings { (settings) in
                                    print(settings)  // ユーザーが設定している通知設定の内容をデバッグ出力に出力します
                                }
                    #ref: https://dev.classmethod.jp/articles/user-notifications-framework-14/
            構成:
                通知:  #// ユーザー通知とプッシュ通知の抽象。どちらも通知の見た目や拒否設定の方法は同じです
                ユーザー通知:  #search: Xcode ユーザー通知,  Xcode 通知, ローカル通知  #// タイマーやスケジュールなど、アプリケーションが通知条件を設定し、非アクティブのときに、ユーザーに通知します
                    watchOS:
                        リクエスト: #// UNTimeIntervalNotificationTrigger
                            複数のトリガーをリクエスト可能。最大 64（iOS12）
                        トリガー:  #keyword: UNTimeIntervalNotificationTrigger
                            指定時間後, 繰り返し
                        内容:  #keyword: UNMutableNotificationContent
                            .title: アプリがアクティブではないときは、タイトルだけ表示されます
                            .subtitle: 通知をタップしたときに表示されるサブタイトル
                            .body: 通知をタップしたときに表示される通知本文
                            .sound: 効果音。通知での効果音はデフォルトしか選べません
                        カテゴリー:  #keyword: UNNotificationCategory
                        アクション:  #keyword: UNNotificationAction
                            通知をタップしたときに表示されるボタン
                        タイミングによる通知の違い: #keyword: Xcode 通知 AOD
                            フォアグランドのとき:
                                通常モードのとき:
                                    画面上部にバナーが 5秒間表示されます。効果音はいくつか選べます  #search: watchOS 振動 効果音
                                AOD モード のとき:
                                    画面は更新されません。効果音はいくつか選べます
                            時計表示のとき:
                                通常モードのとき:
                                    画面全体にバナーが 10秒間表示されます。効果音はデフォルトしか選べません
                                AOD モード のとき:
                                    画面は更新されません。効果音はデフォルトしか選べません
                                    #ref: https://forums.developer.apple.com/forums/thread/49512
                            他のアプリのとき:
                                通常モードのとき:
                                    画面上部にバナーが 5秒間表示されます。効果音はデフォルトしか選べません
                                AOD モード のとき:
                                    画面は更新されません。効果音はデフォルトしか選べません
                        #search: Apple Watch ユーザー通知 example
                ntfy.sh: #keyword:
                    インストールと通知をします:
                        iPhone で受信できるようにします:
                            iPhone に ntfy アプリ をインストールします:
                                AppStore から検索します
                            購読を開始します:
                                メニュー: ＋ ボタン（右上）
                                トピック名: topic1828389  #// サンプルです
                                Subscribe ボタン（右上）:
                        PC から通知を送ります:
                            #// bash から  #search: open bash
                            curl -d "Hello from ntfy!" https://ntfy.sh/topic1828389
                                #template__: curl -d "__Message__" https://ntfy.sh/__UniqueTopicName__
                        iPhone に通知が届きます:
                    通知を切ります:
                        購読をやめる場合:
                            ntfy アプリ >>（トピック名）>> …（右上）>> Unsubscribe
                効果音: |  #// watchOS ではできません
                    let content = UNMutableNotificationContent()
                    content.sound = UNNotificationSound(named: UNNotificationSoundName(rawValue: "yourAudioFileName.wav"))
                    #ref: ~/Downloads/decision-2.mp3  #ref: https://sounddictionary.info/interfaces-1/
                    Copy Bundle Resources: #search: Xcode copy bundle resources
                watchOS:  #search: watchOS 振動 効果音
            関連:
                イベント:  #search: Xcode event
                ユーザーの許可:  #search: iOS Xcode privacy permission
                watchOS:  #search: watchOS 振動 効果音
    画面: #keyword: Xcode screen   #ref: ${my_images}/2022/Xcode_main.png
        アプリ:  #search: Xcode GUI parts
        Xcode:  #search: Xcode window  #ref: ${my_images}/2022/Xcode.html  #// Playground、コードのブラウズ、プロジェクトの編集など
            開く: #keyword: Xcode open
                __ProjectName__.xcodeproject パッケージをダブルクリックします
            画面上の位置、ウィンドウ:  #keyword: Xcode window
                メイン ウィンドウ:  #glossary: Xcode  #ref: ${my_images}/2022/Xcode_main.png  #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_main_window
                    Navigator: #// ボタン  #keyword: Xcode Navigator button
                        場所:  #ref: ${my_images}/2022/Xcode_main.png?name=Navigator&x=180&y=132
                        #search: Xcode Project navigator
                    build and run: #// ボタン  #keyword: Xcode build and run button
                        場所:  #ref: ${my_images}/2022/Xcode_main.png?name=build_and_run&x=288&y=130
                        シミュレーターから実機に切り替えます:  #search: Xcode run on device
                    active scheme: #// リスト  #keyword: Xcode active scheme list
                        場所:  #ref: ${my_images}/2022/Xcode_main.png?name=active_scheme&x=410&y=151
                    device targets: #// リスト  #// Xcode ウィンドウの上端にある iPhone などの機種名が表示された位置
                        場所:  #ref: ${my_images}/2022/Xcode_main.png?name=device_targets&x=516&y=149
                    Library: #// ボタン #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_library
                        - ＋（右上 左）  #ref: ${my_images}/2022/Xcode_main.png?name=Library&x=1054&y=157
                    Inspector: #// ボタン  #// Xcode ウィンドウの右上端にある Hide or show the inspectors ボタン
                        場所:  #ref: ${my_images}/2022/Xcode_main.png?name=Inspector&x=1352&y=153
                    Document Outline:
                        表示・非表示: Xcode >> Editor >> Document Outline  #ref: ${my_images}/2022/Xcode_main.png?name=Document_Outline&x=485&y=511
                    Canvas:  #ref: ${my_images}/2022/Xcode_main.png?name=Canvas&x=832&y=459
                Navigator（左）:  #glossary: Xcode  #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_Navigator
                    Project Navigator: 🗂  #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_ProjectNavigator
                        #search: Xcode Project navigator
                    Source Control Navigator: ❎ #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_SourceControlNavigator
                    Symbol Navigator:      #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_SymbolNavigator
                    Find Navigator: 🔍     #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_FindNavigator
                    Issue Navigator: ⚠️     #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_IssueNavigator
                    Test Navigator:        #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_TestNavigator
                    Debug Navigator:       #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_DebugNavigator
                    Breakpoint Navigator:  #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_BreakpointNavigator
                    Report Navigator: 🗒   #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_ReportNavigator
                Inspector（右）:  #glossary: Xcode  #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_Inspector
                    File Inspector: 🗒       #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_FileInspector
                    History Inspector: 🕘    #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_HistoryInspector
                    Quick Help Inspector: ？ #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_QuickHelpInspector
                    Identity Inspector:      #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_IdentityInspector
                    Attributes Inspector:    #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_AttributesInspector
                    Size Inspector: ▲        #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_SizeInspector
                    Connections Inspector:   #ref: ${my_images}/2022/Apple/Xcode_views.png?name=Connections_Inspector&x=404&y=70
                        #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_ConnectionInspector
                Layout(?):  #glossary: Xcode
                    Update Frames:        #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_UpdateFrames
                    Align:                #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_Align
                    Add New Constraints:  #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_AddNewConstraints
                        #search: Xcode Add New Constraints usage
                    Resolve Auto Layout Issues:  #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_ResolveAutoLayoutIssues
                    Embed In:             #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#Xcode_EmbedIn
                画面分割(Assistant Editor)モード:  #// .swift ファイルと .storyboard ファイル など、関連する2つの内容を同時に表示します
                    画面分割モードにします:  #keyword: Xcode Assistant Editor
                        - option キーを押しながら、Project Navigator の中のファイルをクリックします
                        - Navigator は非表示にすると良いでしょう  #keyword: Xcode Navigator button
                    レイアウトを変更します:
                        メニュー: Editor >> Layout >> Assistant on Bottom（など）
                Live View:  #// Xcode Playground でビュー (UIView) の表示内容を表示します
                    Live View を表示します: #keyword: show Xcode Live View
                        メニューの場合: Xcode (Playground プロジェクト) >> Swift ファイルを開く >> 三（右上）>> Live View
                        キーボードの場合: option + command + Enter
                    実行途中のビューの表示内容を表示します:
                        UIView（にカーソルを合わせます、コードの各行の右）>>（目玉 ボタン）
                        #// ポップアップ表示されます。ポップアップ以外で表示することはできないようです
                    サンプル: #keyword: Xcode Live View example
                        Xcode Playground を作ります:
                            #search: open Xcode Playground
                        MyPlayground.swift: |  #// 下記コードを貼り付けます
                            import UIKit
                            import PlaygroundSupport
                            let view = UIView()
                            view.frame = CGRect(x: 0, y: 0, width: 400, height: 400)
                            view.backgroundColor = .gray

                            PlaygroundPage.current.liveView = view
                        実行します:
                            最後の行の行番号にカーソルを合わせて、再生 ボタン を押します
                        Live View を表示します:
                            #search: show Xcode Live View
            （左）:
                Project navigator:
                    Project navigator:  #keyword: Xcode Project navigator
                        プロジェクト エディター: #search: Xcode project editor
                        既存のアイテム:
                            灰色のフォルダー: フォルダーを参照しているグループ
                            灰色のフォルダーの左下に影があるフォルダー: グループ
                            青いフォルダー: フォルダーの参照。adding files ウィンドウ(*1) の Create folder references で追加した、フォルダーの参照
                        追加:
                            フォルダー:
                                灰色のフォルダー:  #// フォルダーを参照しているグループ
                                    注意: 既存のフォルダーを追加するときは、一度フォルダーを改名して、プロジェクトに追加したら、フォルダーの内容を移動します（未確認）
                                    手順: adding files ウィンドウ(*1) >> Create groups
                                    (*1) adding files ウィンドウ: #search: Choose options for adding these files window
                                灰色のフォルダーの左下に影があるフォルダー:  #// グループ
                                    Project navigator のルートを右クリック >> New Group without Folder
                                どれがよいか: #ref: https://stackoverflow.com/questions/13346247/xcode-project-navigator-difference-between-yellow-folder-and-blue-folder
                            ファイル: #keyword: Xcode add files to project
                                _: Xcode >> Project navigator >>（親を右クリック）>> Add Files to "__Target__"
                                関連:
                                    バンドルする:  #search: Xcode copy bundle resources
                    フォルダー構成: #search: SwiftUI App folder
                    フォルダーのスキャン >> プロジェクト フォルダーの直下のフォルダーのファイルの有無をスキャンします:  #keyword: Xcode folder scan refresh
                        すでにプロジェクトに直下のフォルダーが追加されているとき:
                            フォルダーへの参照を削除します >> フォルダー自体は削除しないでプロジェクトから登録の除外をします:
                                対象フォルダーを右クリック >> Delete >> Remove References
                        フォルダーをプロジェクトにドラッグ＆ドロップして Create groups だけします:
                            Project navigator を表示します:
                                Project navigator（左上の横に並んだボタン列の最も左）
                            Finder から対象フォルダーをプロジェクトのルートの直下にドロップします:
                            Create groups オプションのみ指定します:
                                開いた「Choose options for adding these files:」ウィンドウ:  #keyword: Choose options for adding these files window
                                    Added folders:  #search: Xcode Project navigator
                                        Create groups: 黄色いフォルダーになります
                                        Create folder references: 青いフォルダーになります
                                    Add to targets: (*1)
                                    Finish ボタン:
                                    (*1) Add to targets:
                                        追加するファイルに設定する Target Membership です。 #search: Xcode Target Membership
            メイン（右上）:
                テキスト エディター:  #// 括弧、ハイパーリンク、検索  #keyword: Xcode navigation
                    新規ファイル: #keyword: Xcode new file
                        クラス: #keyword: Xcode new class  #// Cocoa Touch Class は　UIKit などにあるクラスのことです
                            メニュー: Xcode >> Project navigator（右上）>>（フォルダーを右クリック）>> New File >> Cocoa Touch Class
                            Class: __NewClassName__
                            Subclass of: __SuperClassName__
                            Next ボタン:
                            （必要なら保存場所を選ぶ）:
                            Create ボタン:
                    紫色の変数: self のメンバーです
                    メソッド名を一覧します: パンくずリストを開きます
                        #// Swift のメソッドの識別には引数ラベルを確認する必要があり、コードから識別することは難しいですが、
                        #// パンくずリストではメソッド名と引数ラベルだけが表示されるため、識別しやすいです。
                    対応する括弧を調べます: 中括弧をダブルクリックします  #keyword: Xcode kakko
                    ワード検索（単語単位検索）します: 入力項目の上にある containing をクリックして選びます
                    コードのブックマーク: #// 文章にメモした場所の情報を元に Xcode で開きます:
                        検索方式:
                            追加: 関数名と引数をコピーして文書に貼り付けます
                            ジャンプ: 関数名と引数をコピーして全文検索します
                            全文検索: Xcode >> Find navigator（左上の横に並んだボタン列の左から4番目）>> 貼り付け >> Enter キー
                        パスと行番号方式:
                            ファイルのパスをコピーします:  #keyword: Xcode copy path
                                コピーする内容の例:  #ref: ${GitHub}/ToDoSwitcher/Shared/SessionCommands.swift:31
                                操作方法 A:
                                    Inspectors を表示します:
                                        XCode >> Hide or show the inspectors（右上端）
                                    パスをコピーします:
                                        Inspectors >> (Identity and Type) Full Path（を選択してコピー）                   
                                操作方法 B:
                                    フォルダー ボタン（Show the Project navigator）（左上）>>
                                    選択されているファイルを右クリック >>
                                    Show in Finder >>
                                    VSCode の Terminal にドラッグ＆ドロップ >> （ドラッグして選択）>> 右クリック >> Copy
                            端末（シェル）から指定したパスのファイルを Xcode で開きます:  #keyword: Xcode xed
                                （初回のみ）設定を変更します:
                                    シェル: |
                                        sudo xcode-select -s /Applications/Xcode.app/Contents/Developer
                                        Password: （mac ユーザーのパスワード）
                                    参考: https://stackoverflow.com/questions/25187133/where-to-set-my-xcode-path
                                xed コマンド:
                                    xed __FilePath__
                                メモ:
                                    行番号を指定する方法は不明:
                                        __LineNum__ ではありません:
                                        -l オプションは動きません:
                                            https://stackoverflow.com/questions/63573436/xed-cant-jump-line-when-xcode-is-opened
                                            man xed  https://www.unix.com/man-page/osx/1/xed/
                    ブックマーク: #// ブレークポイントでブックマークを代用します  #search: Xcode breakpoint
                    ハイパーリンク:
                        ヘルプ >> シンボルに対するヘルプを表示します: option + クリック
                        定義 >> 定義にジャンプします: control + command + クリック >>（行番号が大きい方）
                        戻る >> ジャンプ元へ戻ります: control + command + ←  #// タッチパッドの二本指操作は不正確です
                        進む >> ジャンプ先に進みます: control + command + →
                    ツリー >> 開いているファイルを選択します:
                        開いた状態で Xcode >> Project navigator（左上の横に並んだボタン列の最も左）
                        ジャンプ元に戻るとツリーの選択も追従します
                    フォルダー構成: #search: SwiftUI App folder
                プロジェクト エディター: #keyword: Xcode project editor
                    （開く）: Project navigator のツリーのルートにあるプロジェクト名をクリック
                    （主なもの）:
                        アプリ名: #keyword: Xcode display name,  Xcode App name
                            Xcode: Project Navigator >> (root) >> General（タブ）>>（Identity グループ）>> Display Name
                            App Store Connect 内:  #search: App Store Connect display name
                        バンドル ID:  #// アプリケーションやエクステンションを識別するID  #keyword: Xcode bundle ID, Xcode bundle identifier, Xcode バンドルID
                            メニュー: Xcode >> Project navigator（左上）>>（ツリーのルート）>> General（タブ）>>
                                TARGETS（のどれか）
                            アプリの場合: Signing & Capabilities タブ >> Bundle Identifier
                            ウォッチ アプリの場合:  #// 以下のいずれか
                                - Signing & Capabilities タブ >> Bundle Identifier
                                - Identity（グループ）>> Bundle Identifier
                            サンプル: com.example.apple-samplecode.SimpleWatchConnectivity
                                #// 自分のドメインである必要はありません
                            App Store Connect 内:  #search: App Store Connect bundle ID
                        App ID: #keyword: Apple Developer App ID
                            ハンドルID と同じ
                        SKU: #keyword: Apple Developer SKU, Stock Keeping Unit 在庫管理単位
                            たとえば、Bundle ID が com.example.MyApp なら SKU は ComExampleMyApp にします
                        ターゲット表示名: #keyword: Xcode ターゲット表示名, Xcode target display name
                            #// アプリケーションやエクステンションの表示名
                    PROJECT:  #// 同じ項目が TARGETS にもあるときは、TARGETS の設定が優先されます
                        Info:
                            Deployment Target:
                            Configurations:
                            Localizations:
                        Build Settings:
                            Architectures:
                            Build Options:
                            Deployment:
                            Packaging:
                            Search Paths:
                            Apple Clang - ____:
                            Statis Analysis - ____:
                            Swift Compiler - ____:
                            User-Defined:
                        Package Dependencies:
                    TARGETS:
                        （ここに表示されるもの）:
                            アプリ, テスト, ウォッチ アプリ, （エクステンション？）, フレームワーク, ウィジェット
                        （追加, エクステンションの追加）: #keyword: add Xcode extension
                            既存のプロジェクトの Xcode >> File >> New >> Target
                                または
                            ＋（TARGETSの下端）
                            #search: Xcode extension
                        General:
                            Supported Destinations:
                            Minimum Deployments:  #keyword: Xcode target iOS version 
                                iOS 16.1   #// 例
                            Identity: #keyword: Xcode target identity
                                App Category: ____
                                Display Name: ____
                                Bundle Identifier: _____
                                Version: ____
                                Build: ____
                            Deployment Info:
                            App Icons and Launch Screen:
                            Supported Intents:
                            Frameworks, Libraries, and Embedded Content:
                            Development Assets:
                        Signing & Capabilities:
                            Signing:
                        Resource Tags:
                        Info: #search: Info.plist
                        Build Settings:
                            Deployment:
                            Info.plist Values:
                            Linking:
                            Localization:
                            Packaging:
                            Signing:
                            Versioning:
                            Asset Catalog Compiler - Options:
                            Swift Compiler - Language:
                            User-Defined:
                        Build Phases:
                            Copy Bundle Resources: #keyword: Xcode copy bundle resources
                                追加:
                                    プロジェクトにファイルを追加します:
                                        #search: Xcode add files to project
                                    バンドルするように設定します:
                                        Copy Bundle Resources の左下の ＋
                                    コードから参照します: |  #// ファイル名が __Name__.__Extension__ の場合
                                        import UIKit
                                        class ViewController: UIViewController {
                                            let imagePath = Bundle.main.path(forResource: "__Name__", ofType: "__Extension__")
                        Build Rules:
                Info.plist: #keyword: Xcode Info.plist screen  #// XML でも編集できます  #search: Info.plist
                    メニュー: Xcode >> __Project__（をクリック）>> Info タブ
                    Custom iOS Target Properties: #keyword:
                        追加:
                            Xcode14: 任意のキーを右クリック >> Add Row >>（キー名 または XML フィールド名）
                            キー名 と XML フィールド名 のサンプル:
                                Supports opening documents in place, LSSupportsOpeningDocumentsInPlace
                        削除:
                            キー名に マウス カーソル を合わせて(-)をクリック
                Quick Help:
                    command + クリック >> Show Quick Help >> Open in Developer Documentation >>
                    背景を右クリック >> Reveal in Navigator >> （別のページをクリック）>>（元のページをクリック）>>
                    ↑（右上端）>> Copy Link
                コードと GUI 部品の対応関係:  #keyword: Xcode browse GUI code
                    ボタンやラベル:  #// アプリケーションで継承していないクラス
                        コードから GUI 部品を探します:
                            (SwiftUI):
                                - 画面分割モードにします  #search: Xcode Assistant Editor
                                - コードの行番号の部分に表示される黒丸にカーソルを合わせます
                        GUI 部品からコードを探します:
                            (SwiftUI):
                                Connections Inspector:  #search: Xcode Connections Inspector
                                    Referencing Outlets:
                                        (属性名)-(クラス名)
                            (UIKit):  #keyword: Storyboard UIKit
                                .storyboard ファイルを開きます:
                                対象の GUI 部品をクリックします:
                                クラス:
                                    Identity Inspactor >> class
                                メソッド:  #// 関連するメソッド名またはプロパティ名を表示します
                                    Connections Inspector:  #search: Xcode Connections Inspector
                                    Sent Actions: 関連するメソッド
                                    Referencing Outlets: 関連するプロパティ
                                メソッド名またはプロパティ名のコードを表示します:
                                    画面分割(Assistant Editor)モードを開きます:
                                        Xcode >> Editor（メニュー）>> Assistant（上から 2つ目）
                                    開いた .swift ファイルの中を、メソッド名またはプロパティ名で検索します:
                                        command + F, func __MethodName__ または var __PropertyName__
                    ビュー:  #// アプリケーションで継承したクラス
                        コードから GUI 部品を探します:
                            (SwiftUI):
                                Find Navigator:  #search: Xcode Find Navigator
                                    入力: クラス名
                                    出力:
                                        ___.storyboard ファイル:
                                            クラス名をクリックすると GUI 部品が選択されます
                        GUI 部品からコードを探します:
                            (SwiftUI):
                                Identity Inspector:  #search: Xcode Identity Inspector
                                    Custom Class:
                                        Class: クラス名
                                Assistant ビューから探します:
                                    Assistant ビューを表示します:
                                        ____.storyboard ファイルを開きます:
                                        メニュー: Editor >> Assistant
                                    画面に対応する View（コード）のファイルを Assistant ビューに表示します:
                                        デザイン表示中の画面: をクリック
                                    GUI 部品とコードの対応関係を表示します:
                                        コードの行番号の部分に表示される黒丸にカーソルを合わせます
                            (UIKit):
                                .storyboard ファイルを開きます:
                                画面分割(Assistant Editor)モードを開きます:
                                    Xcode >> Editor（メニュー）>> Assistant（上から 2つ目）
                                または:
                                    Identity Inspector:  #search: Xcode Identity Inspector
                                        Custom Class:
                                            Class: （ビューに関連づけられたクラス）
                Interface Builder:  #search: Storyboard
                デバッガー(LLDB): #keyword: LLDB,  Xcode debugger  #// ブレークポイント
                    ブレーク ポイント:  #keyword: Xcode breakpoint
                        設定: 行番号をクリックします
                        一覧: Breakpoint navigator（左上の横に並んだボタン列の右から2番目） または
                            Xcode >> View（メニュー）>> Navigators >> Breakpoints
                        削除: 青いブレークポイントをコードの中央のドラッグ＆ドロップします。 または
                            行番号を右クリック >> Delete Breakpoint
                    Variables view, 変数ビュー: #keyword: Xcode Variable View,  Xcode debug watch view
                        変数追加: 右クリック >> Add Expression  #// 表示されないとき、変数を選択しているときは空欄をクリックしてから
                    ウォッチ ポイント:  #keyword: Xcode watch point
                    値の変更:
                        LLDB で po i = 100 のように入力します
                Playground:  #keyword: Xcode Playground  #// グラフを表示します(Xcode12.3):
                    開きます:  #keyword: open Xcode Playground
                        新規:
                            Xcode >> File >> New >> Playground >> Next >> Create >> (２回目以降）Replace >>
                            Ready to continue MyPlayground と表示されるまで待つ（ファイル名の上に表示されます）
                        既存のプロジェクト: #glossary:  #ref: ${GitHub}/MyPrivateCode/Swift/Playground
                            （操作）:
                                - 既存の playground ファイルをコピーします  #// コピーしないと自動的に編集内容が保存されてしまいます
                                - コピーした playground ファイルをダブルクリックします
                            Simple.playground:  #ref: ${GitHub}/MyPrivateCode/Swift/Playground/Simple.playground
                            UIView.playground:  #ref: ${GitHub}/MyPrivateCode/Swift/Playground/UIView.playground
                            CAShapeLayer.playground:  #ref: ${GitHub}/MyPrivateCode/Swift/Playground/CAShapeLayer.playground
                            DownloadButton.playground:  #ref: ${GitHub}/MyPrivateCode/Swift/Playground/DownloadButton.playground
                    最初から再実行します:  #// 2回目以降の実行
                        最後まで実行する場合: 四角いボタン（下：で停止）>> 再生ボタン（同じ場所）
                        途中まで実行する場合: 四角いボタン（下：で停止）>> 行番号に表示される再生ボタン
                    表示:  #// 実行結果を表示します
                        右のビューにマウスを合わせます
                    保存します:
                        File メニュー >> Save
                    入力した式を実行します:
                        - 式の例： let a=1+2
                        - 行番号の上にマウスカーソルを移動させて表示される再生ボタンをクリックします
                            （Enterキーでは実行されません）
                        - Live View (右半分) に実行結果が表示されます
                        - クリックした行より前の行も実行します
                    変数の型を調べます:
                        - 調べる変数をクリックします
                        - Hide or show the inspector ボタン（ウィンドウの右上端）>>
                            Show quick help inspector ボタン（？マーク）
                    UIView のサンプルを動かします:
                        #search: Xcode Live View example
                    グラフを表示します:
                        - ループの中の Live View (右半分) に表示された (____times) の右にある
                            目玉アイコンまたは四角いアイコンを押します
                        - グラフの値は分からないので、print してください
                        - サンプル: |
                            import UIKit

                            for x in 0 ..< 360*2 {
                                let radian  Double(x) * Double.pi/180
                                let y = sin(radian)
                                print(x,y)
                            }
            Git, Source Control 関連:  #keyword: Xcode Git
                #// git コマンドは Xcode をインストールすると使えます
                GitHub と連携するプロジェクトを作成します:  #search: Xcode GitHub
                ブランチのログやタグを表示します:
                    Xcode >> Source Control navigator（左上の横に並んだボタン列の左から2番目）>>
                    コミット（の行をダブルクリック）でコミットにおけるファイルの差分が表示されます
                git status 相当 >> 前回のコミットから変更した部分を表示します:
                    変更した部分を一覧します:
                        メニュー: Xcode >> Source Control >> Commit（コミットする前に一覧されます）
                        表示内容:
                            左のツリー: 変更したファイルの一覧
                            差分の左側: 現在のワークの内容
                            差分の右側: 前回のコミットの内容
                            下半分: コミットメッセージ
                    ファイルやフォルダーに変更があるかどうかを表示します:
                        リポジトリと同期します: Source Control（メニュー）>> Refresh File Status（中）
                        変更箇所を探します: Project navigator のファイルの右に M(変更) や A(追加) が表示されます。
                            ファイルを開き、minimap を表示すると変更箇所に色が付きます。
                            #search: Xcode Project navigator
                            #search: Xcode minimap
                pull, push します:
                    - Xcode >> Source Control（メニュー）>> Pull
                    - Xcode >> Source Control（メニュー）>> Commit:
                        Enter commit message here: ____
                        Push to remote: オン
                        Commit Files and Push ボタン:
                    - Xcode >> Source Control（メニュー）>> Push
                stash pop します:
                    - Xcode >> Source control navigator >> #search: Xcode Source control navigator
                    - Repository（タブ）>> __Project__ master >> Stashed Changes >> (stash ID)（を右クリック）>>
                        Apply Stashed Changes
        デバッガー:
            ウォッチ: #keyword: Xcode watch
                下やや左のエリアを右クリック >> Add Expression
        シミュレーター: #keyword: Xcode simulator,  iPhone iPad simulator
            起動:  #search: start Xcode simulator
            リセット:
                Simulator >> Device メニュー >> Erase All Content and Settings
            キーボード:
                #search: Xcode toggle software keyboard
            シミュレーター内ファイル: #keyword: Xcode simulator file
                追加:  #// シミュレーター内にコピーします
                    - コピー元のファイルを mac の Finder で開きます
                    - シミュレーターの ファイル アプリ を開いて、ファイルをアプリへドラッグ＆ドロップします
                    - 保存 >> 完了（右上）
                    - （アプリに戻ります）  #// 自動的に ファイル アプリ に移動していました
                    - ブラウズ（右下）
                削除:
                    - アプリからファイルを選ぶ画面を開きます、または、ファイル アプリ を開きます
                    - 削除するファイル（長押し）>> 削除
                mac で開く場合:  #ref: https://stackoverflow.com/questions/6480607/is-there-any-way-to-see-the-file-system-on-the-ios-simulator
                    新しい方法:
                        cd ~/Library/Developer/CoreSimulator
                        find .  |  grep __FileName__
                        open "__FolderFullPath__"
                    古い方法:  #// 正しくない
                        swift ファイル に下記を書きます:
                            print(NSHomeDirectory())
                        シミュレーターを動作させて print したパスをメモします:
                        mac の Finder でパスを開きます:
                            Finder >> shift + command + G >> （パス）  #// ホームは ~。$HOME は使えません
                            #search: mac open
                    注意: アプリケーションを再起動するとパスが変わります
        iPhone: #ref: ${my_images}/2022/Xcode.html
    構成:
        プロジェクト:
            サンプル:  #search: Xcode projects
            画面:  #search: Xcode screen
            プロジェクト エディター:  #search: Xcode project editor
    Apple Watch:  #search: watchOS
    設定ファイル, フォルダー構成: #keyword: SwiftUI App folder,  Xcode folders,  Xcode files
        ファイル構成:
            __Project__:  #// ____.xcodeproj ファイルがあるフォルダー  #keyword: ____.xcodeproj
                __Project__.xcodeproj/: パッケージ フォルダー  #search: .xcodeproj
                __Target__:  #// __Project__ の直下はターゲット（フォルダー） #keyword: Xcode target
                    （設定上のターゲット）: Xcode >> Project navigator（左上）>>（ツリーのルート）>> General（タブ）>> TARGETS（右）
                    （Target Membership）:  #// 参照元ターゲット  #keyword: Xcode Target Membership
                        概要: 他のターゲットから参照されることをできるようにします。参照先ではなく参照元を指定します
                        #search: Swift Cannot find in scope
                        Target Membership を設定します:
                            定義がある ソース ファイル（を右クリック）>> Show File Inspector（やや上）>>
                            Target Membership（の中の参照元ターゲットにチェック）
                    Assets.xcassets:  #search: Xcode assets
        .swift ファイル:  #// プログラミング言語で書かれたコード
            新規作成:  #search: Xcode new file
        .xcodeproj ファイル: #keyword: .xcodeproj
            #search: Xcode project editor
        Info.plist, Information Property List: #keyword: Info.plist, Information Property List, Xcode info
            公式:  #ref: https://developer.apple.com/documentation/bundleresources/information_property_list
            #// config ごとに分かれていません
            ファイルの場所:
                Xcode15:
                    Xcode >> __Project__ >> __App__ >> (____.info ファイルの拡張子なし)
                Xcode13:
                    ビューの場合:
                        Xcode >> __Project__（をクリック）>> Info タブ
                    ファイルの場合:
                        Xcode >> __Project__ >> __App__ >> Info
                Xcode12 以下: Target > Build Settings > Packaging - Info.plist File
            Xcode で編集する場合:  #search: Xcode Info.plist screen
            XML で編集する場合:
                Xcode >> __Project__ >> __App__ >> Info >>
                ←→（右上：Enable Code Review） >>（XML を編集）>> File メニュー >> Save >> ←→
                #// Xcode >> __Project__ >> Info タブ の表示を更新するには、Xcode を再起動します
            プロパティ: #ref: https://iphone-tora.sakura.ne.jp/iphone_infoplist.html
                Document Type:
                    追加: Xcode >> __Project__（をクリック）>> Info タブ >>（Document Types）>>
                        ＋（＋は展開したら表示されます）
                    削除: Xcode >>（__Project__ >> __App__ >>）Info >>（Information Property List）>>
                        Document Types >>（削除する項目にカーソルを合わせる）>> (-)
                        #ref: https://developer.apple.com/forums/thread/682862
                Privacy - Reminders Full Access Usage Description:
                    概要: このキーがあれば、リマインダーへの Read Write アクセス をユーザーに要求します
                    値: __Description__  #// 確認メッセージの最後の表示内容  #keyword: Xcode 目的文字列, Xcode Purpose Strings
                    表示される確認メッセージ: __App__ がリマインダーへのアクセスを求めています __Description__
                    目的文字列として必要な情報: ユーザーのどのデータを、アプリ固有の何に使っているか
                        #ref: ${my_images}/2024/目的文字列.png
                        #ref: https://developer.apple.com/jp/design/human-interface-guidelines/privacy
                        #ref: https://developer.apple.com/jp/videos/play/tech-talks/110152/
            ユーザーの許可: #keyword: iOS Xcode privacy permission
                アプリ初回起動時: 
                    表示サンプル: __App__ がリマインダーへのアクセスを求めています __Description__
                    #search: Privacy - Reminders Full Access Usage Description
                許可の状況:
                    iPhone:
                        設定 >> プライバシーとセキュリティ >>（データを持つアプリ名）
                    Apple Watch:  #// 表示のみできます。設定は iPhone で
                        設定 >> プライバシーとセキュリティ >>（データを持つアプリ名）
                許可のリセット:
                    アプリを削除してください
            補足: Configureによらない定数は、Info.plistに直接書いてもいい #ref: https://qiita.com/WisteriaWave/items/e72eab4b167a63d911ee
        Build Settings: #keyword: Xcode Build Settings
            #// config ごとに分かれています
            #ref: https://medium.com/@abhishek1nacc/user-defined-build-setting-f4bba59a5d6c
        XIBファイル: #keyword: XIB  #// ジブ と読む
            UIKit で UIを部品化したものを表現するファイル。SwiftUI では不要になる
            #ref: https://qiita.com/uhooi/items/ce1b8f56fe7d3eaca325
        関連:
            メイン クラス:  #search: Xcode main class
    コード, フレームワーク, Life cycle:  #keyword: Xcode project Life cycle,  iOS iPhone framework
        既存のプロジェクトが使っているフレームワーク:  #// どのフレームワークを使っているかを調べます
            メイン クラス:  #keyword: Xcode main class
                SwiftUI:  #// App(@main)があるプロジェクト
                    メイン ビュー: App から継承した構造体の中で メイン ビュー のオブジェクトを生成します
                    __Project__/__AppName__/__AppName__App.swift: |  #ref: ${GitHub}/ToDoSwitcher/To Do Switcher/To_Do_SwitcherApp.swift:11
                        @main
                        struct To_Do_SwitcherApp: App {
                            var body: some Scene {
                                WindowGroup {
                                    ContentView()  // メインのビュー
                UIKit:  #// UIApplicationDelegate(@UIApplicationMain)があり、Main.storyboard ファイルがないプロジェクト
                    メイン ビュー: window 変数への代入はアプリケーションのコードで行われます
                    __Project__/__AppName__/__AppName__App.swift: |  #ref: ${GitHub}/MyPrivateCode/Swift/watch/UsingWatchConnectivity/SimpleWatchConnectivity/AppDelegate.swift:12
                        @UIApplicationMain
                        class AppDelegate: UIResponder, UIApplicationDelegate {
                            func application(____
                Storyboard UIKit:  #// Main.storyboard ファイルがあるプロジェクト
                    メイン ビュー: window 変数への代入はライブラリ内で行われます。Initial View に設定します  #search: Xcode Initial View Controller tutorial
                    __Project__/__AppName__/AppDelegate.swift: |  #ref: ${GitHub}/MyPrivateCode/Swift/1st/FirstUIKit-14-1/FirstUIKit-14-1/AppDelegate.swift
                        import UIKit

                        @main
                        class AppDelegate: UIResponder, UIApplicationDelegate {
                            var window: UIWindow?
            両方のフレームワークを使う:  #search: SwiftUI UIView
            どちらをメインに使うか:
                UIKit のサンプルになっているビューを使うときは、（SwiftUIより）UIKit をメインにしたほうが良さそう。
                なぜなら SwiftUI に対応していない機能が UIKit のメインで必要になるようだから。
        SwiftUI: #keyword:  #// 新しいフレームワーク
            概要: Apple のすべてのプラットフォームで動作します。 #ref: https://developer.apple.com/documentation/appkit
            チュートリアル:  #search: Xcode SwiftUI tutorial
            プロジェクト:
                SwiftUI シンプル プロジェクト:
                    first-14-1: #keyword:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/first-14-1
            ファイル, 主なクラス:
                ContentView.swift ファイル, View クラス:
                    View: #keyword: SwiftUI View  #ref: https://developer.apple.com/documentation/swiftui/view/
                        サンプル: |  #focus: View  #ref: https://developer.apple.com/documentation/swiftui/view/
                            struct MyView: View {
                                var body: some View {
                                    Text("Hello, World!")
                                }
                            }
                    PreviewProvider:  #// Xcode のプレビュー画面に表示する対象
                        サンプル: |  #focus: PreviewProvider, MyView  #ref: ${GitHub}/MyPrivateCode/Swift/1st/first-14-1/first-14-1/ContentView.swift
                            struct MyView: View {
                                var body: some View {
                                    Text("Hello, World!")
                                }
                            }
                            struct MyView_Previews: PreviewProvider {
                                static var previews: some View {
                                    MyView()
                                }
                            }
                ExampleApp.swift ファイル, App クラス:
                    App:  #// メイン view
                        サンプル: | #focus: App, MyView   #ref: ${GitHub}/MyPrivateCode/Swift/1st/first-14-1/first-14-1/first_14_1App.swift
                            import SwiftUI

                            @main
                            struct first_14_1App: App {
                                var body: some Scene {
                                    WindowGroup {
                                        MyView()
                                    }
                                }
                            }
            Binding: #keyword: SwiftUI Binding
                #ref: https://developer.apple.com/documentation/swiftui/binding/
                #// ビューに、親など他の場所にある変数の値を表示させるための接続
                クラスとして使うサンプル: #ref: https://github.com/Takakiriy/MyPrivateCode/blob/master/Swift/DocumentBasedApp/ref/naritaseiji-DocumentBasedApp-2022-11-09/DocumentBasedApp/DocumentView.swift
        Storyboard, UIKit: #keyword: UIKit,  Xcode Storyboard UIKit,  Storyboard,  Interface Builder  #// これまでのフレームワーク
            チュートリアル:  #search: Xcode Storyboard official tutorial
            プロジェクト:
                UIKit の シンプル プロジェクト:
                    #search: UIKit simple projects
                    FirstUIKit-14-1 など
            MVC:  #// Model-View-Controller  #keyword: Swift MVC
                View:
                    視覚的表現の要素
                Model:
                    データとビジネスロジック  #search: Swift MVC Model
                ViewController: #keyword:
                    ビューとモデルをブリッジします
                    詳細は  #search: UIViewController
                関連:  #search: MVVM
            クラス構成: #keyword: UIKit class structure  #focus: rootViewController
                AppDelegate:UIApplicationDelegate:  #search: AppDelegate.swift ファイル
                    # func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
                    #     self.window = window
                #// または
                SceneDelegate:UIWindowSceneDelegate:  #search: SceneDelegate.swift ファイル
                    # func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
                    #     self.window = window
                    #     window.rootViewController = ViewController()
                    .window:UIWindow:
                        .rootViewController:ViewController:UIViewController:  #search: ViewController.swift ファイル
            メイン ビュー コントローラー:
                #search: Xcode Initial View Controller tutorial
                #search: ViewController.swift ファイル
                #search: Xcode delegate
            ライフサイクル: #keyword: Xcode UIKit application life cycle  #// アプリケーションのステータス、ライフサイクル、非アクティブ
                #search: Xcode app state
                #ref: https://qiita.com/KenNagami/items/766d5f95940c76a8c3cd
                viewDidLoad:  #search:
                バックグラウンドになったときに呼ばれるメソッド:
                    UIApplication:
                        applicationDidEnterBackground: |
                            func applicationDidEnterBackground(_ application: UIApplication)
                    UIWindowSceneDelegate:
                        sceneDidEnterBackground: | #keyword: Xcode sceneDidEnterBackground
                            class SceneDelegate: UIResponder, UIWindowSceneDelegate {
                                func sceneDidEnterBackground(_ scene: UIScene) {
                        #ref: ${GitHub}/MyPrivateCode/Swift/CommingSoonNotification/FirstUIKit-14-1/SceneDelegate.swift#sceneDidEnterBackground
            コードと GUI 部品の対応関係:
                Storyboard を使っていない場合:  #search: Xcode delegate
                Storyboard を使っている場合:  #search: Storyboard UIKit
            接続: #// アクション, アウトレット, UIControl  #search: Xcode connect example
                アウトレット: Storyboard 内のオブジェクトからコードへの参照  #search: Xcode outlet example  #keyword: Xcode outlet
                アクション: アクション メソッド  #search: Xcode action example  #keyword: Xcode action
                UIControl: ボタンは UIControl から継承しており、UIControl はアクションと接続できます
                参考: #search: Xcode connect example
            ソース ファイル, 主なクラス:
                AppDelegate.swift ファイル: #keyword:  #// UIKit に必ずある ソース ファイル の 1つ  UIApplicationDelegate
                    概要: アプリケーションがアクティブになった時などの処理を AppDelegate に書くことができます
                    注意: 最新版ではコールバック関数は SceneDelegate.swift ファイル に書くらしい。
                        WatchOS では WKExtensionDelegate です
                    サンプル: |
                        import UIKit

                        @UIApplicationMain
                        class AppDelegate: UIResponder, UIApplicationDelegate {
                            var window: UIWindow?  // #keyword: UIApplicationDelegate window
                                // Main.storyboard を使うときは自動的に設定されます

                            func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
                                // 以下は Main.storyboard を使わない場合のみ必要。 #focus: window
                                    // 実装例1 #ref: https://qiita.com/KosukeOhmura/items/a3dd4f4678291ddb8a6a#uiwindow-が消えた原因
                                    // 実装例2 #ref: http://swift-salaryman.com/uiwindow.php
                                    let  window = UIWindow()  // ここのコードは未確認。SceneDelegate.swift の該当ファイルを参照

                                    self.window = window
                                    window.backgroundColor = .green  // #ref: https://stackoverflow.com/questions/54049202/how-to-fix-cannot-call-value-of-non-function-type-uicolor
                                    window.rootViewController = ViewController()

                                    window.makeKeyAndVisible()  // window を前面に表示します
                                // 以下は常に必要
                                    return true
                                // SceneDelegate.swift ファイルについては #search: delete Main.storyboard
                            }

                            func applicationWillResignActive(application: UIApplication) {
                                println("アプリ閉じそうな時に呼ばれる")
                            }

                            func applicationDidEnterBackground(application: UIApplication) {
                                println("アプリを閉じた時に呼ばれる")
                            }

                            func applicationWillEnterForeground(application: UIApplication) {
                                println("アプリを開きそうな時に呼ばれる")
                            }

                            func applicationDidBecomeActive(application: UIApplication) {
                                println("アプリを開いた時に呼ばれる")
                            }

                            func applicationWillTerminate(application: UIApplication) {
                                println("フリックしてアプリを終了させた時に呼ばれる")
                            }
                        }
                    コール ツリー:
                        アプリ起動:
                            UIApplicationMain:  #// ライブラリ
                                application(willFinishLaunchingWithOptions):  #// 開始直後
                                    #ref: https://qiita.com/omochimetaru/items/31df103ef98a9d84ae6b
                                application(didFinishLaunchingWithOptions):  #// 開始後
                                applicationWillEnterForeground:  #// 開く前
                                applicationDidBecomeActive:  #// 開いた後
                        終了?:
                            applicationWillResignActive:  #// 閉じる前
                            applicationDidEnterBackground:  #// 閉じた後
                            applicationWillTerminate:  #// 終了前。iOS16 ではアプリ一覧からフリックして終了した場合
                    UIWindow: #keyword:
                        概要: UIApplicationDelegate.window に代入するオブジェクトのクラス
                        コード:  #search: UIWindow simple example
                    #ref: https://qiita.com/penkopenko/items/cc8f48af792c353cd9f3
                    関連 >> WatchOS:  #search: WKExtensionDelegate
                SceneDelegate.swift ファイル: #keyword: SceneDelegate.swift ファイル  #// UIWindowSceneDelegate
                    概要: シーンの親クラス。iPad で分割表示するときは、1つのアプリで複数のシーンが表示されています。
                        Info.plist の Requires full screen や Supports multiple windows をオンにすると必要になります。
                        UIWindowSceneの場合は、その1つのSceneに対して1つのUIScreenと複数のUIWindowが紐付けられます。
                    #ref: https://qiita.com/omochimetaru/items/31df103ef98a9d84ae6b
                    サンプル: |  #ref: ${GitHub}/MyPrivateCode/Swift/1st/FirstUIKitCode-14-1/FirstUIKit-14-1/SceneDelegate.swift#func scene
                        import UIKit

                        class SceneDelegate: UIResponder, UIWindowSceneDelegate {  #keyword: UIWindowSceneDelegate
                            var window: UIWindow?

                            func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
                                // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
                                // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
                                // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
                                // このメソッドを使用して、オプションで UIWindow `window` を構成し、提供された UIWindowScene `scene` にアタッチします。
                                // ストーリーボードを使用している場合、`window` プロパティが自動的に初期化され、シーンにアタッチされます。
                                // このデリゲートは、接続中のシーンまたはセッションが新しいことを意味するものではありません 
                                // (代わりに、`application:configurationForConnectingSceneSession` を参照してください)。

                                // UIWindowのインスタンスつくり、viewControllerを設定し、このウィンドウをメインのウィンドウをとします。
                                // #ref: https://qiita.com/tanaka-tt/items/5df779a5b847a887e3e6
                                // #keyword: UIWindow simple example
                                guard let windowScene = (scene as? UIWindowScene) else { return }
                                let  window = UIWindow(windowScene: windowScene)

                                self.window = window
                                window.backgroundColor = .green  // #ref: https://stackoverflow.com/questions/54049202/how-to-fix-cannot-call-value-of-non-function-type-uicolor
                                window.rootViewController = ViewController()

                                window.makeKeyAndVisible()  // window を前面に表示します
                            }

                            func sceneDidDisconnect(_ scene: UIScene) {
                                // Called as the scene is being released by the system.
                                // This occurs shortly after the scene enters the background, or when its session is discarded.
                                // Release any resources associated with this scene that can be re-created the next time the scene connects.
                                // The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead).
                            }

                            func sceneDidBecomeActive(_ scene: UIScene) {
                                // Called when the scene has moved from an inactive state to an active state.
                                // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
                            }

                            func sceneWillResignActive(_ scene: UIScene) {
                                // Called when the scene will move from an active state to an inactive state.
                                // This may occur due to temporary interruptions (ex. an incoming phone call).
                            }

                            func sceneWillEnterForeground(_ scene: UIScene) {
                                // Called as the scene transitions from the background to the foreground.
                                // Use this method to undo the changes made on entering the background.
                            }

                            func sceneDidEnterBackground(_ scene: UIScene) {
                                // Called as the scene transitions from the foreground to the background.
                                // Use this method to save data, release shared resources, and store enough scene-specific state information
                                // to restore the scene back to its current state.
                            }
                        }
                    コール ツリー: #keyword: UIWindowSceneDelegate callbacks 
                        アプリ起動:
                            scene:
                        フォアグランドに変更:
                            sceneWillEnterForeground:
                        アクティブ状態に変更:
                            sceneDidBecomeActive:
                        非アクティブ状態に変更:
                            sceneWillResignActive:  #// 着信など
                        バックグラウンドに変更:
                            sceneDidEnterBackground:  #search: Xcode sceneDidEnterBackground
                                #// データの保存など
                        アプリ終了?:
                            sceneDidDisconnect:
                        参考 >> 状態遷移図:
                            #search: Xcode app state
                    #ref: https://qiita.com/tanaka-tt/items/5df779a5b847a887e3e6
                ViewController.swift ファイル: #keyword:  #// UIViewController
                    メイン ビュー コントローラー:  #search: Xcode Initial View Controller tutorial
                    UIViewController: #keyword: UIViewController,  Xcode View Controller
                        概要:
                            #ref: https://developer.apple.com/documentation/uikit/uiviewcontroller
                            UIKitアプリのビュー階層を管理するオブジェクト。
                            UIViewクラスは、すべてのビューコントローラーに共通する共有動作を定義します。
                            UIViewクラスのインスタンスを直接作成することはめったにありません。
                            代わりに、UIViewControllerサブクラス化し、ビューコントローラのビュー階層を管理するために
                            必要なメソッドとプロパティを追加します。
                        構造:
                            ViewController: #search:
                                Root View:
                                    View1:
                                    View2:
                            parent: #keyword: Xcode parent view controller
                                1つ親:
                                    (self.parent as! __ParentViewControllerClass__).__Property__
                                2つ親:
                                    (self.parent?.parent as! __ParentViewControllerClass__).__Property__
                        コード:  #// 文字のビューを追加します
                            追加前: |  #ref: ${GitHub}/MyPrivateCode/Swift/1st/FirstUIKit-14-1/FirstUIKit-14-1/ViewController.swift
                                import UIKit

                                class ViewController: UIViewController {
                                    override func viewDidLoad() {
                                        super.viewDidLoad()
                                        // Do any additional setup after loading the view.
                                    }
                                }
                            追加後 背景色だけの場合: |  #focus: label  #ref: ${GitHub}/MyPrivateCode/Swift/1st/FirstUIKitCode-14-1/FirstUIKit-14-1/ViewController.swift#viewDidLoad
                                import UIKit

                                class ViewController: UIViewController {
                                    let label = UILabel()

                                    override func viewDidLoad() {
                                        super.viewDidLoad()
                                        self.view.backgroundColor = .blue
                                    }
                                }
                            追加後 文字の場合: |  #focus: label  #ref: https://tech.amefure.com/swift-uikit-uiviewcontroller#head6
                                import UIKit

                                class ViewController: UIViewController {
                                    let label = UILabel()

                                    override func viewDidLoad() {
                                        super.viewDidLoad()
                                        let screenWidth = self.view.frame.width
                                        let screenHeight = self.view.frame.height

                                        label.text = "Hello World!!"
                                        label.frame = CGRect(x:screenWidth/3, y:screenHeight/2,width:screenWidth/2, height:30)
                                        self.view.addSubview(label)
                                    }
                                }
                        コール ツリー:
                            UIViewController のライフサイクル、イベント:
                                loadView:  #keyword:
                                    loadView イベントに応答するコード: |
                                        override func loadView() {
                                            super.loadView()
                                        }
                                # ... ロード
                                viewDidLoad:  #keyword:
                                viewWillAppear:  #keyword:
                                viewWillLayoutSubviews:  #keyword:
                                # ... サブのビューを表示
                                viewDidLayoutSubviews:  #keyword:
                                # ... 表示
                                viewDidAppear:  #keyword:
                                # ... ユーザーからの操作を待っている状態
                                非表示にするとき:
                                    viewWillDisappear:  #keyword:
                                    # ... 非表示
                                    viewDidDisappear:  #keyword:
                                メモリー不足になったとき:
                                    didReceiveMemoryWarning:  #keyword:
                                    viewDidUnload:  #keyword:
                    UICollectionViewController: #search:
                Main.storyboard ファイル: #keyword:  #// GUI データ。SwiftUI では使いません
                    メイン window:
                        Main.storyboard ファイルを開いて、Storyboard Entry Point がある View が、
                        UIApplicationDelegate.window に設定されます #search: UIApplicationDelegate window
                    コードと GUI 部品の対応関係:  #search: Storyboard UIKit
                    Main.storyboard ファイルをなくします:  #keyword: delete Main.storyboard
                        プロジェクトを新規作成します:
                            #search: FirstUIKit-14-1
                        ファイルを削除します:
                            - Main.storyboard
                            - LaunchScreen.storyboard
                        設定を削除します:
                            Main storyboard file base name の設定を削除します:
                                .xcodeproj >> Info >> Main storyboard file base name
                                を削除
                            Storyboard Name の設定を削除します:
                                .xcodeproj >> Info >> Application Scene Manifest >> Scene Configuration >> item 0 >> Storyboard Name
                                を削除
                            #ref: https://teratail.com/questions/214822
                        window 変数に代入します:
                            SceneDelegate.swift: |
                                func scene(___) {
                                    guard let windowScene = (scene as? UIWindowScene) else { return }
                                    self.window = UIWindow(windowScene: windowScene)
                                    self.window!.rootViewController = ViewController()
                                    self.window!.backgroundColor = .white  // or green and so on
                                    self.window!.makeKeyAndVisible()
                            #ref: https://teratail.com/questions/214822
                        動作確認します:
            ビュー コントローラー: #keyword: Storyboard view controller
                (Playground):  #search: Xcode Live View example
                基本形, UIViewController: #search:  #// ユーザーコードと継承関係があるクラス
                    概要:
                        UIViewクラスのインスタンスを直接作成することはめったにありません。
                        代わりに、UIViewControllerサブクラス化し、ビューコントローラのビュー階層を管理するために
                        必要なメソッドとプロパティを追加します。
                        #search: Swift MVC
                    参照:
                        #search: UIViewController
                    UIView: #keyword:  #// ユーザーコードと所有関係があるクラス
                        親: #search: UIViewController
                        SwiftUI でも実装可能らしい:  #ref: https://medium.com/@kitasuke/uikitで積極的にswiftuiを使う-2ee98853179a >> SwiftUIで実装
                        init: #keyword: UIView init
                            2つの init を定義してください: |  #// しないとエラーになります
                                class Label: UILabel {
                                    required init(coder: NSCoder) {
                                        super.init(coder: coder)!
                                    }
                                    override init(frame: CGRect) {
                                        super.init(frame: frame)

                                        // override attributes
                                        self.frame = CGRect(x: 100, y: 100, width: 100, height: 100)
                                        self.textColor = UIColor.black
                                        self.backgroundColor = UIColor.lightGray
                                    }
                                }
                            トラブルシューティング: |
                                    class AA: UIView {
                                        init() {  // Error: 'required' initializer 'init(coder:)' must be provided by subclass of 'UIView'
                                        }
                                    }
                                #ref: https://stackoverflow.com/questions/26081287/required-initializer-initcoder-must-be-provided-by-subclass-of-uitablevi
                        layoutSubviews: #keyword: UIView layoutSubviews  #// 再描画
                            定義: |
                                class __CustomView__: UIView {
                                    override func layoutSubviews() {
                                        super.layoutSubviews()

                                        // サブビューのレイアウトロジックをここに追加する
                                    }
                                }
                            再描画:  #// layoutSubviews メソッド を直接呼び出してはいけません
                                __UIView__.setNeedsLayout()
                        Playground:  #search: Xcode Live View example
                UITableViewController: #keyword:  #// UICollectionViewController よりシンプル
                    UITableView: #keyword:
                        表示します:  #search: Xcode UITableViewController cellForRowAt
                        スクロールします: |
                            table: UITableViewController
                            table.tableView.scrollToRow(
                                at: IndexPath(row: 10 - 1, section: 0),
                                at: .bottom,
                                animated: true)
                        一部を太字にします: |  #keyword: UITableView bold  #focus: cellTextA,  boldRange
                            let cellText = "これは太字のテキストです"
                            let boldRange = (cellText as NSString).range(of: "太字")
                            let cellTextA = NSMutableAttributedString(string: cellText)
                            cellTextA.addAttribute(.font, value: UIFont.boldSystemFont(ofSize: 17), range: boldRange)
                            cellTextA.addAttribute(.foregroundColor, value: UIColor.red, range: boldRange)

                            cell.textLabel?.attributedText = cellTextA
                        関連 >> SwiftUI List: #search: Xcode SwiftUI List
                    UITableViewDataSource:
                        tableView(_, numberOfRowsInSection, ...) を UITableViewController から分離させるときに使う
                        tableView.dataSource = dataSource
                    プロジェクト:  #search: UITableView-14-1
                    表示を更新する: |
                        tableViewController: __SubClassOfUITableViewController__?
                        self.tableViewController!.tableView.reloadData()
                    イベント:
                        タップしたとき: |  #keyword: Xcode didSelectRowAt UITableViewController  #// 触ってそのまま離したとき
                            override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
                                print("\(indexPath.row)番目の行がタップされました。")
                                tableView.deselectRow(at: indexPath, animated: true)  // すぐに選択の解除
                            }
                        スクロールを始めたとき: |
                            override func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {
                    公式チュートリアル: #search: Xcode Initial View Controller tutorial
                UICollectionViewController: #keyword:
                    関連 >> UITableViewController との違い:
                        #ref: https://qiita.com/MaShunzhe/items/3d98fa897aa1bcffc74b#uicollectionview-と-uitableview-の違い
                    Storyboard の操作方法:  #search: Xcode Storyboard official tutorial
                        追加: Collection View Controller を追加します
                        GUI 部品とコード(View)を接続するアウトレットとアクションを追加します:  #search: Xcode connect example
                        Collection View Controller を追加します:
                            Collection View と Collection View Cell も追加されます
                    UICollectionView, Collection View: #keyword:  #// Collection View Cell を集めたもの
                        #ref: https://grandbig.github.io/blog/2017/08/06/custome-collectionview/
                        collectionView(numberOfItemsInSection):  #// コレクションの数を返すコールバック関数
                            #ref: https://qiita.com/sasao3/items/581b3f1bb9da0d4c4d89
                        collectionView(cellForItemAt):  #// コレクションの要素を1つ返すコールバック関数
                            #ref: https://qiita.com/sasao3/items/581b3f1bb9da0d4c4d89
                    UICollectionViewCell, Collection View Cell: #keyword:  #// Collection View に入れるもの
                        親: #search: UICollectionView
                        #ref: https://developer.apple.com/documentation/uikit/uicollectionviewcell
                        #ref: https://grandbig.github.io/blog/2017/08/06/custome-collectionview/
                UIStackView: #keyword:
                    プロジェクト:  #search: UIStackView-14-1
                        #ref: ${GitHub}/MyPrivateCode/Swift/1st/UIStackView-14-1/image_UIStackView.png
            デリゲート メソッド:  #search: UIKit delegate method, UIKit に見られるプロトコルを実装するメソッドの形
        AppKit: #keyword:  #ref: https://developer.apple.com/documentation/appkit
            概要: AppKitはSwiftUIでも動作します
        DocumentBasedApp: #keyword: Xcode DocumentBasedApp  #ref: ${GitHub}/MyPrivateCode/Swift/DocumentBasedApp  #ref: ~/Desktop/DocumentBasedApp
            参考: #keyword: naritaseiji-DocumentBasedApp-2022-11-09
                #ref: ${GitHub}/MyPrivateCode/Swift/DocumentBasedApp/ref/naritaseiji-DocumentBasedApp-2022-11-09
                今からはじめるドキュメントベースApp: #ref: https://qiita.com/naritaseiji/items/b5a7839cb53eb34415d2
            サンプル:  #search: DocumentBrowser-14-1
            データ構造:
                DocumentView:
                    #ref: ${GitHub}/MyPrivateCode/Swift/DocumentBasedApp/ref/naritaseiji-DocumentBasedApp-2022-11-09/DocumentBasedApp/DocumentView.swift
                    TextView:
                    ImagePicker:
                    bind:
            コール ツリー:
                #// ベース  #ref: ${GitHub}/MyPrivateCode/Swift/DocumentBasedApp/ref/naritaseiji-DocumentBasedApp-2022-11-09/
                #// アプリを開くとき
                    UIApplicationMain:
                        application:  #// UIApplicationDelegate  application(_:didFinishLaunchingWithOptions:):
                            #ref: ${GitHub}/MyPrivateCode/Swift/DocumentBasedApp/ref/naritaseiji-DocumentBasedApp-2022-11-09/DocumentBasedApp/DocumentBasedApp/AppDelegate.swift
                        viewDidLoad:  #// UIDocumentBrowserViewControllerDelegate  viewDidLoad:
                            #ref: ${GitHub}/MyPrivateCode/Swift/DocumentBasedApp/ref/naritaseiji-DocumentBasedApp-2022-11-09/DocumentBasedApp/DocumentBasedApp/AppDelegate.swift
                        applicationDidBecomeActive:  #// UIApplicationDelegate  applicationDidBecomeActive:
                #// 新規 document をタップしたとき
                    documentBrowser:
                        #// UIDocumentBrowserViewControllerDelegate  documentBrowser(_:didRequestDocumentCreationWithHandler:):
                            #ref: ${GitHub}/MyPrivateCode/Swift/DocumentBasedApp/ref/naritaseiji-DocumentBasedApp-2022-11-09/DocumentBasedApp/DocumentBrowserViewController.swift#didRequestDocumentCreationWithHandler
                            #ref: https://developer.apple.com/documentation/uikit/uidocumentbrowserviewcontrollerdelegate/2874199-documentbrowser
                    presentDocument:  #// DocumentBrowserViewController  presentDocument
                        #ref: ${GitHub}/MyPrivateCode/Swift/DocumentBasedApp/ref/naritaseiji-DocumentBasedApp-2022-11-09/DocumentBasedApp/DocumentBrowserViewController.swift#func presentDocument
                #// ドキュメントをタップしたとき  #keyword: documentBrowser(_:didPickDocumentsAt:):
                    documentBrowser(_:didPickDocumentsAt:):
                        #ref: ${GitHub}/MyPrivateCode/Swift/1st/DocumentBrowser-14-1/FirstUIKit-14-1/ViewController.swift#didPickDocumentsAt
                        #search: Xcode SMB
                #// ドキュメントを閉じるボタン をタップしたとき
                    closeDocument:
                        #ref: ${GitHub}/MyPrivateCode/Swift/DocumentBasedApp/ref/naritaseiji-DocumentBasedApp-2022-11-09/DocumentBasedApp/DocumentBrowserViewController.swift#func closeDocument
        Extension: #keyword: Xcode extension
            （追加）:  #search: add Xcode extension
            WatchKit Extension: #keyword: WatchKit Extension,  WatchKit App,  WKExtension
                #ref: https://developer.apple.com/documentation/watchkit/wkextension
                Xcode 14から WatchKit Extension は WatchKit App にまとめられています
                    #ref: https://stackoverflow.com/questions/74162287/missing-watchkit-extension-in-xcode-14
        始めに実行する処理:
            init:  #// SwiftUI App
                サンプル: |
                    @main
                    struct TestApp: App {
                        init() {  // init の定義が無いことがあります  //#keyword: SwiftUI App init
                            // 起動時の処理
                参考: SwiftUI App ライフサイクル https://qiita.com/surfinhamster/items/830e760e441d040c1a10
            application:  #keyword: UIKit UIApplicationDelegate
                サンプル: |
                    @UIApplicationMain
                    class AppDelegate: UIResponder, UIApplicationDelegate, WCSessionDelegate {
                        ...
                        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
                            // 起動時の処理
                #search: AppDelegate.swift ファイル
        状態遷移, ライフサイクル:  #keyword: Xcode app state,  Xcode application Life cycle
            共通:
                Unattached, Background, Foreground Inactive, Foreground Active, Suspended
                #ref: https://qiita.com/yutosa3/items/89d6295196d24965bb49
                #ref: https://developer.apple.com/documentation/uikit/app_and_environment/managing_your_app_s_life_cycle
            UIKit:  #search: Xcode UIKit application life cycle
            Storyboard:
                awakeFromNib:  #keyword:
        参考: #// 書籍 iOSアプリ開発デザインパターン入門, 千葉 大志 (Japanese Edition):  #keyword: iOSデザパタ本 2018年, Xcode books
            #ref: ${GoogleDriveDownload}/takakiriy/books/2018_iOSデザパタ
            #// Kindle 2012-06-20 購入済み
        SwiftUI の View クラスと UIKit の UIView/UIViewController:  #keyword: SwiftUI UIView, SwiftUI View, UIKit UIView/UIViewController
            概要: SwiftUI のフレームワークは新しいため OS のすべての機能が揃っていません。
                SwiftUI と UIKit を連携するときは、UIHostingController と UIViewRepresentable
                を経由します
            参考:
                - https://qiita.com/owen/items/73473cd2206afda3c5d4
                - https://note.com/kaigian/n/n3fb2ee271cad
            SwiftUI:  #// ビューとコントローラーは分かれていません。2019年登場。
                #search: SwiftUI
                サンプル:  #search: SwiftApp1
            UIKit:  #// UIView, UIViewController
                #search: UIKit
                概要: ビュー（UIView）とコントローラー（UIViewController）が連携するような構造です
                サンプル:  #search: StoryboardApp1
                #search: UIView, UIViewController, UICollectionView, UICollectionViewCell, UITableView
            SwiftUI { UIKit } 構成: #keyword:  #// View の中で UIViewを使うとき
                フレームワークが SwiftUI のときに UIKit を使う:
                    #ref: https://www.google.com/search?client=safari&rls=en&q=swiftui+uikit&ie=UTF-8&oe=UTF-8
                    #ref: https://tech.nri-net.com/entry/display_uiview_created_with_uikit_on_swiftui
                UIViewRepresentable:  #keyword:  #ref: https://developer.apple.com/documentation/swiftui/uiviewrepresentable
                    サンプル:
                        ContentView.swift: |  #// SwiftApp1 をベースに ContentView.swift だけ変更します  #search: SwiftApp1
                            import SwiftUI

                            struct ContentView: View {
                                @State var  message:String = "(message)"
                                @State var  count:Int = 0

                                var body: some View {
                                    ZStack {

                                        BackgroundView()
                                        VStack {
                                            Text("This text is a View.")
                                            Text("The background is a UIView.")
                                        }
                                    }
                                }
                            }

                            struct BackgroundView: UIViewRepresentable {
                                let view: UIView = UIView()
                                let count: Int = 0;

                                func makeUIView(context: Context) -> UIView {
                                    view.backgroundColor = UIColor(
                                        red: 0.1, green: 0.9, blue: 0.9, alpha: 1.0)
                                    return view
                                }

                                func updateUIView(_ uiView: UIView, context: Context) {
                                    view.backgroundColor = UIColor(
                                        red: 0.9, green: 0.9, blue: 0.1, alpha: 1.0)
                                }
                            }

                            struct ContentView_Previews: PreviewProvider {
                                static var previews: some View {
                                    ContentView()
                                }
                            }
            UIKit { SwiftUI } 構成: #keyword:  #// UIView/UIViewController の中で View を使うとき
                サンプル: #ref: https://github.com/Takakiriy/MyPrivateCode/blob/master/Swift/DocumentBasedApp/ref/naritaseiji-DocumentBasedApp-2022-11-09/DocumentBasedApp/DocumentView.swift
                UIHostingController:  #keyword:
                UIHostingConfiguration:  #keyword:  #// SwiftUI の View を内包する UIViewController。WWDC2022 で発表された
                    概要:
                        #ref: https://developer.apple.com/documentation/SwiftUI/UIHostingConfiguration
                        -   UIHostingConfiguration オブジェクトは、
                            UICollectionViewCell または UITableViewCell の contentConfiguration プロパティ
                            （UIContentConfiguration プロトコル）に代入します。
                        #ref: https://www.fuwamaki.com/article/362
                        -   画面遷移ができます
                        #ref: https://blog.zaim.co.jp/n/nd040ed2bc2e6
                        -   表示先は限定されるものの、従来の UIHostingViewController を使った方法よりも少ないコードで SwiftUI を取り入れられます
                    公式:
                        #ref: https://developer.apple.com/videos/play/wwdc2022/10072/
                        #ref: https://developer.apple.com/documentation/SwiftUI/UIHostingConfiguration
                    UIViewController の中:
                        #search: UIViewController
                        サンプル（複雑）:
                            #keyword: UIHostingConfiguration UIViewController huge-example
                            #focus: createHostingConfiguration
                            コード: |  #ref: https://swiftsenpai.com/development/uihostingconfiguration-cell-interactions/
                                // MARK: - The custom cell
                                struct UserInteractionCell: View {
                                    var item: SFSymbolItem
                                    var body: some View {
                                        HStack(alignment: .center, spacing: 8) {
                                            Image(systemName: item.name)
                                            Text(item.name)
                                            Spacer()
                                        }
                                    }
                                }

                                // MARK: - The implementation
                                class UserInteractionViewController: UIViewController {
                                    var collectionView: UICollectionView!
                                    let dataModel = [
                                        SFSymbolItem(name: "applelogo"),
                                        SFSymbolItem(name: "iphone"),
                                        SFSymbolItem(name: "icloud"),
                                    ]
                                    private var userInteractionCellRegistration: UICollectionView.CellRegistration<UICollectionViewListCell, SFSymbolItem>!

                                    override func viewDidLoad() {
                                        super.viewDidLoad()

                                        // Create cell registration
                                        userInteractionCellRegistration = .init { [unowned self] cell, indexPath, item in
                                            cell.contentConfiguration = createHostingConfiguration(for: item)
                                        }

                                        // Configure collection view using list layout
                                        let layoutConfig = UICollectionLayoutListConfiguration(appearance: .insetGrouped)
                                        let listLayout = UICollectionViewCompositionalLayout.list(using: layoutConfig)
                                        collectionView = UICollectionView(frame: .zero, collectionViewLayout: listLayout)
                                        collectionView.dataSource = self
                                        view = collectionView
                                    }

                                    /// Create a content configuration that host the `UserInteractionCell`
                                    private func createHostingConfiguration(for item: SFSymbolItem) -> UIHostingConfiguration<UserInteractionCell, EmptyView> {
                                        return UIHostingConfiguration {
                                            // Create SwiftUI view
                                            UserInteractionCell(item: item)
                                        }
                                    }
                                }

                                extension UserInteractionViewController: UICollectionViewDataSource {

                                    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
                                        return dataModel.count
                                    }

                                    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
                                        let item = dataModel[indexPath.row]
                                        let cell = collectionView.dequeueConfiguredReusableCell(
                                            using: userInteractionCellRegistration,
                                            for: indexPath,  item: item)
                                        return cell
                                    }
                                }
                    UICollectionViewController の中:
                        #search: UICollectionViewController
                        #ref: https://qiita.com/MaShunzhe/items/3d98fa897aa1bcffc74b#コレクションビューのコード
                        サンプル:
                            contentConfiguration = UIHostingConfiguration
                            #ref: https://zenn.dev/woxtu/articles/build-custom-cell-with-uicontentconfiguration
    テスト: #keyword: Xcode test
        サンプル: |
            class MyUnitTestTests: XCTestCase {

                override func setUp() {
                }

                override func tearDown() {
                }
            
                func testHi() {
                    let p = Person("Taro", 160, 50)
                    let ret = p.hi()
                    XCTAssertEqual(ret, "Hi. I'm \(p.name).")
                }
            
                func testBmi() {
                    let p = Person("Hanako", 140, 40)
                    let ret = p.bmi()
                    XCTAssertEqual(ret, 20.41)
                }
            }
        プロジェクトに登録:
            新規の場合:  #// 新規のプロジェクトに テスト メソッド が呼ばれるようにする場合
                新規プロジェクトの内容のウィンドウ >> Include Unit Tests にチェック
            既存の場合:
                Xcode >> File >> New >> Target... >> iOS タブ >>（Test グループ）>> iOS Unit Testing Bundle
        コールバック:
            test____:  #// テスト メソッド。メソッド名は test から始めること
            setUpWithError:  #// それぞれの テスト メソッド を実行する前に呼ばれます
            tearDownWithError:  #// それぞれの テスト メソッド を実行した後に呼ばれます
        チェック, assertion:
            XCTAssertEqual:
                XCTAssertEqual(__Output__, __Answer__)
        内部メソッドのテスト:
            import __TargetName__
                の代わりに
            @testable import __TargetName__
        テスト リリース:  #search: App Store Connect TestFlight
        参考:
            公式:
                XCTest:  #ref: https://developer.apple.com/documentation/xctest
                XCTestCase:  #ref: https://developer.apple.com/documentation/xctest/xctestcase
            その他:
                #ref: https://qiita.com/nsuhara/items/bc06c07ff30a5b78696d
    デバイス: #keyword: Xcode devices
        接続: #keyword: Xcode connect  #search: Xcode connect device,  Xcode デバイス 接続
            #search: Xcode device trouble
    トラブル シューティング（Xcode）: #keyword: Xcode trouble shooting,  Xcode debug
        - Swift 関連:  #search: Swift trouble shooting
        - Tips:  command + B でビルドし直します
        - print: #keyword: Xcode print,  Xcode log
            書式: print( __Value__ )  // コンソールに表示します
            ビュー階層内の場合: |
                .onAppear {
                    print("\( __Variable__ )")
                }
            コンソールを表示します: #keyword: Xcode debug console,  Xcode debug output
                Xcode >> View >> Debug Area >> Active Console
            デバッグエリア（コンソールなど）を非表示します: Xcode >> View >> Debug Area >> Hide Debug Area
        - #// self を書くと動かなくなる  #keyword: Xcode self object problem,  /*self.*/
            self. を書かないときに、実行中の関数の引数を指している場合:
                対処:
                    self. を書きません。
                サンプル: |  #focus: textField
                    func textFieldDidBeginEditing(_ textField: UITextField) {
                        textField.selectAll(self.textField.text)
                原因:
                    編集モードに入ったテキストフィールドと一致しない可能性があるらしい（ChatGPT-GPT4)
                #// エラー メッセージ
        - デバイスの接続関連: #keyword: Xcode device trouble  #search: Xcode devices
            #keyword: troube Apple Watch iPhone connection
            関連:
                #search: Xcode run on device for Watch
            手順: Xcode から実行開始
            症状:
                - 接続待ちのままになる
                - The operation couldn't be completed. (com.apple.dt.deviceprep error -25.)
                    The operation timed out. Try again.
                    （Devices and Simulators に一瞬だけ表示されるので、動画でキャプチャして確認します）
                - Devices and Simulators の左に Apple Watch が表示されない
            （開始手順）:
                Xcode を終了します
                mac の ~/Library/Developer/Xcode/iOS DeviceSupport/ を削除します
                mac や iPhone のディスクの空き容量が十分にあるか調べます。
                mac や iPhone の電源を落として、起動します。
                iPhone と mac を USB ケーブルで接続して、iPhone 側に表示された「信頼」を押します
                Xcode を開きます
            対処A:  #// iPhone だけの場合
                macOS, iOS, watchOS, Xcode を最新にします:
                Devices and Simulators を開きます:
                    Xcode >> Window >> Devices and Simulators（やや下）>> Devices（左上）
                iPhone, AppleWatch, Mac すべてを再起動します:
                iPhone の接続を確認します:
                    Xcode >> Window >> Devices and Simulators（やや下）>> Devices（左上）>> iPhone
                        #// シンボルのアップロードが実行されることがあります
                        #// Copying shared cache symbols from ____ Apple Watch (0% completed) 
            対処B:  #// Apple Watch の場合
                #// 対処A の後で
                Devices and Simulators:
                    Apple Watch（を右クリック）>> Unpair >>
                    iPhone（を右クリック）>> Unpair >>
                しばらく使わず、mac OS, Xcode, Watch OS の更新があった:
                Wi-Fi プライベート接続？をオフ:  #// Bluetooth で接続しているようですが
                ペアリング解除:
                ペアリング:
                iPhone と mac を USB ケーブルで接続 >> 信頼する:
                Apple Watch と mac を Bluetooth で接続 >> 信頼する:
                mac に電源を繋ぎます:
                mac を再起動します:  #// Xcode再起動では不十分
                Xcode を起動:  #// プロジェクトを起動
                Device & Siulator ウィンドウを開く:
                Disconnected に　〜の Apple Watch が表示される:
                    Apple Watch をクリック  #// 接続が始まります
                #// Developer mode disabled と表示された
                デベロッパモードをオンにする:  #// 2024-08-31
                    設定 >> デベロッパモード = オン
                Device & Siulator ウィンドウを開く (2):
                デベロッパモードにします:
                    iPhone: 設定 >> プライバシーとセキュリティ >> デベロッパモード（下から2番目）>> オン
                    Apple Watch: 設定 >> プライバシーとセキュリティ >> デベロッパー（最も下）>> オン >>（再起動）
            対処C:
                #// 対処C の後で
                iPhone, AppleWatch, Mac, Xcode すべてのバージョンを最新に更新して最初からやり直します。
            対処D:
                Xcode のキャッシュをクリアします  #search: clear Xcode cache
            対処E:
                Ensure the device is unlocked and attached with a cable or associated with the same local area network as this Mac.
                The device must be opted into Developer Mode to connect wirelessly.
                iPhone と mac を USB ケーブルで接続して、iPhone 側に表示された「信頼」を押します 
            対処F:
                もう一度ペアリングからやり直します。リセットするかバックアップから復帰します
                    #search: Apple Watch pairing process again
            対処G:
                XCode Cloud の Testflight を使う
            参考:
                10.4アップグレード後、Apple WatchはXcodeのデバイスリストに表示されません:
                    https://developer.apple.com/forums/thread/748139
                    私の現在の回避策は、Xcode Cloud を使用し、Testflight（内部テスト）を使用することです。このようにして、アプリを構築し、テストフライトでインストールし、アップルウォッチでテストすることができます。
                Apple Watch Missing Developer Mode Option:
                    https://developer.apple.com/forums/thread/718634
        #↓ エラー メッセージ があるもの
        - #// dyld_shared_cache_extract_dylibs failed
            手順: Xcode (mac) と iPhone を接続するとき
            ログ: |
                dyld_shared_cache_extract_dylibs failed
                    Domain: DVTDeviceSymbolsCoordinatorErrorDomain
                    Code: 908
                    User Info: {
                        DVTErrorCreationDateKey = "2025-04-17 14:32:58 +0000";
                        DVTRadarComponentKey = 487927;
                        NSLocalizedFailureReason = "";
                        NSLocalizedRecoverySuggestion = "";
                        "com.apple.dt.DVTCoreDevice.operationName" = dscExtractor;
                    }
            対処:
                mac のディスクの空き容量を増やします
        - #// App record with bundle identifier "__BundleID__" was previously removed
            手順: Xcode >> Project メニュー >> Archive
            エラー: |
                App record with bundle identifier "__BundleID__" was previously removed from App Store Connect for team "__TeamName__". Go to App Store Connect to restore the app.
            対処:
                復元するしかないようです
                #ref: https://forums.developer.apple.com/forums/thread/114421
                #search: restore App in App Store Connect
        - #// Upgrade Apple Watch’s watchOS version or lower __App__ Watch App.app’s deployment target.
            手順: Xcode から実行開始
            エラー: |
                Upgrade Apple Watch’s watchOS version or lower __App__ Watch App.app’s deployment target.
            対処:
                ターゲットとするバージョンを下げてください。
                ただし、デバイスにインストールされているバージョンよりさらに下げる必要がある場合もあります。
                プロジェクト エディター >>（TARGET）Watch App (?) >> version(?)
        - #// Unable to process request - PLA Update available
            手順: ビルド
            エラー:
                Unable to process request - PLA Update available
                You currently don't have access to this membership resource. To resolve this issue, agree to the latest Program License Agreement in your developer account.
            対処:
                App Store Connect  https://appstoreconnect.apple.com/
                Apple Developer Programの使用許諾契約が更新されました（上）>> 契約を確認
        - #// Failed to register bundle identifier.
            手順: Xcode >> Start the active scheme
            エラー:
                iOS: |
                    Failed to register bundle identifier.
                    The app identifier "__Team__.__App__" cannot be registered to your development team
                    because it is not available. Change your bundle identifier to a unique string to try again.
            対処:
                #// (Xcode14) エラー メッセージ が表示されている場所のすぐ上にある「Bundle identifier」を変更します。
                Bundle identifier: com.example.apple-samplecode.__App__
                Try again ボタン:
                #search: Xcode bundle ID
        - #// Escaping closure captures mutating 'self' parameter
            手順: ビルド
            エラー: |
                Escaping closure captures mutating 'self' parameter
            対処:
                init に非同期クロージャーを入れることはできませんが、
                所有の子の ObservableObject のメソッドに非同期クロージャーを入れて init から呼び出すことはできます
            サンプル: |  #ref: ${GitHub}/ToDoSwitcher/To Do Switcher Watch Extension/To_Do_SwitcherApp.swift#init2
                View <>-- ObservableObject
                    self.sub = To_Do_SwitcherAppSub()
                    self.sub.init2(parent: self)
            参考: #ref: https://stackoverflow.com/questions/60520208/how-can-i-use-async-call-closure-to-init-parameter-under-swiftui?rq=1
        - #// Cannot override which has been marked unavailable
            手順: ビルド
            エラー: |
                Cannot override 'sessionDidDeactivate' which has been marked unavailable
            原因:
                watchOS 用などでは使えないというマークが付いています
            対処:
                #if os(iOS)
                #endif
                でエラーが発生しているメソッドの定義を囲みます。
            参考: https://stackoverflow.com/questions/39513461/wcsessiondelegate-sessiondidbecomeinactive-and-sessiondiddeactivate-have-been-m
        - #// tool 'xed' requires Xcode
            手順: xed __Path__
            エラー: |
                xcode-select: error: tool 'xed' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance
            対処:
                xed を使えるようにするコマンドと同じです #search: Xcode xed
        - #// 表示内容が変わらない（変数に変わった後の値が入っている場合）
            エラー: 変数に変わった後の値が入っているのに表示内容が変わらない
            対処:
                - (@State)または(@ObservedObject)などをプロパティに付けます  #search: @State
        - #// Generic struct 'ObservedObject' requires that '[____]' conform to 'ObservableObject'
            手順: ビルド
            エラー: |
                Generic struct 'ObservedObject' requires that '[____]' conform to 'ObservableObject'
            原因:
                View プロトコルを持つ構造体のインスタンス変数に配列型を指定できないのが SwiftUI の仕様のようです
            対処: |
                // Model 構造体を作り、その中に配列型の変数を定義します

                class  Model: ObservableObject {
                    @Published var
                        listItems: [ListItem] = initialItems

                struct  ContentView: View {
                    @ObservedObject var
                        model = Model()
            参考:
                - https://stackoverflow.com/questions/59787507/how-do-i-create-array-conformed-to-observableobject
                - https://stackoverflow.com/questions/63326784/issue-with-observableobject  
        - #// Thread __: Fatal error: Index out of range
            手順: 実行時例外
            エラー: |
                Thread __: Fatal error: Index out of range
            対処:
                デバッガーではなく print で配列の要素数を確認してください
        - #// Cannot find '__Symbol__' in scope  #keyword: Swift Cannot find in scope
            手順: Xcode でビルドしたとき
            エラー: Cannot find '__Symbol__' in scope
            対処:
                __Symbol__ がアプリケーションのプロジェクトで定義している場合:
                    ターゲットのフォルダーの外のフォルダーの中のファイルで定義されたシンボルが見つからない場合:
                        Target Membership を設定します  #search: Xcode Target Membership
                    extension の中で定義されたシンボルが見つからない場合:
                        extension の中の func は extension のクラスの関連がないときは参照できません。
                        extension の外に func を移動してください。
                __Symbol__ がライブラリで定義している場合:
                    __Symbol__ が使えているプロジェクトを開きます:
                    定義を開きます:
                        __Symbol__ をエディター内で右クリック >> Jump to Definition
                    モジュール名を確認します:
                        エディターの上にあるパンくずリストの最も左
                    モジュールをインポートします:
                        エラーが発生するファイルを開き、import 文を追加します。
        - #// WatchKit App doesn't contain any WatchKit Extensions
            手順: Xcode でビルドしたとき
            エラー: |
                WatchKit App doesn't contain any WatchKit Extensions whose WKAppBundleIdentifier
                matches "____". Verify that the value of WKAppBundleIdentifier
                in your WatchKit Extension's Info.plist matches the value of
                CFBundleIdentifier in your WatchKit App's Info.plist.
            対処:
                WatchKit App と WatchKit Extensions の Info.plist を修正します:
                    WatchKit App:
                        正しい値がある場所: iPhone アプリのバンドルID  #search: Xcode バンドルID
                        正しい値を入れる場所: Xcode >> Project navigator（左上）>> __App__Watch（WatchKit App）>>
                            Info.plist >> WKAppBundleIdentifier
                    WatchKit Extensions:
                        正しい値がある場所: WatchKit App のバンドルID  #search: Xcode バンドルID
                        正しい値を入れる場所: Xcode >> Project navigator（左上）>> __App__Watch Extension（WatchKit Extensions）>>
                            Info.plist >> NSExtension >> NSExtensionAttributes >> WKAppBundleIdentifier
        - #// Your maximum App ID limit has been reached
            手順: Xcode でビルドしたとき
            エラー: |
                Communication with Apple failed. Your maximum App ID limit has been reached.
                You may create up to 10 App IDs every 7 days.
            対処:
                7日に10バンドルIDという制限があるまで、既存のバンドルIDに置き換えます
                #serach: Xcode バンドルID
        - #// An Application Group with Identifier '____' is not available
            手順: Xcode ビルド
            エラー: An Application Group with Identifier '____' is not available. Please enter a different string.
            対処:
                メニュー: Xcode >> Project navigator >>（ツリーのルート要素）>> Singing & Capabilities（タブ）>>
                    TARGETSのどれか >> App Groups（グループ）>> App Groups
                group.com.example.apple-: チェックを外します
                ＋ ボタン（下）:
                new container: group.com.____.apple-
        - #// XML Parse Error
            手順:  Xcode >> Project navigator（左）>> ____.plist
            エラー: |
                Failed to open proerty list: XML Parse Error on line __N__:
                XML declaration allowed only at the start of the document
            対処:
                テキスト エディター でエラーになるファイルを開き、XML ファイルの先頭の
                空白や空行を削除します
        - #// Singing & Capabilities may not function correctly
            手順: Xcode からプログラムを実機で動かそうとしたとき  #search: Xcode run on device
            エラー:  #keyword: Xcode error select a development team
                Capabilities for Singing & Capabilities may not function correctly
                because its entitlements use a placeholder team ID.
                To solve this, select a development team in the __Application__ editor.
            対処:
                Xcode >> Project navigator >>（ツリーのルート要素）>> Singing & Capabilities（タブ）>> Team >>
                （自分の名前）>> 以上を全ての TARGETS に設定します
        - #// Finderを終了できません
            操作: mac のシャットダウン
            エラー: iOSデバイスでの処理がまだ進行中のため、Finderを終了できません。
            対処法: 強制終了させる？
        - #// Failed to create provisioning profile.
            エラー:
                - Failed to create provisioning profile.
                - No profiles for '____' were found
            対処法: 上記「実機と開発用 mac を USB ケーブルで接続します」
CocoaPods: #keyword:  #// npm のような Swift のライブラリ管理ツール
    公式:
        #ref: https://guides.cocoapods.org/using/using-cocoapods.html
    インストール:  #keyword: install CocoaPods
        インストール済み サンプル プロジェクト:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/UITextViewAttribute-14-1/
        CocoaPods 本体をインストールします:
            M1 Mac:  #// 未確認  #ref: https://stackoverflow.com/questions/65445365/cocoapods-installation-fails-on-macbook-pro-m1-apple-silicon-mac
                - arch -arm64 brew install cocoapods  #// 進捗表示が始まるまで3分かかります。表示されてから 1分半で完了します
                - pod --version  #// 1.12.1
        プロジェクトを CocoaPods 対応に変えます:
            bash:
                - cd  __XcodeProject__  #// ____.xcodeproj があるフォルダー
                - pod init  #// Podfile が作られます
            .gitignore:  #// 下記を追加します
                Pods/
        プロジェクトにパッケージを追加します:
            Podfile ファイルを編集します: |  #focus: pod  #ref: ${GitHub}/MyPrivateCode/Swift/1st/UITextViewAttribute-14-1/Podfile
                target 'FirstUIKit-14-1' do
                    use_frameworks!
                    pod '__PackageName__'
                end
            Xcode プロジェクトが開いていたら閉じます:
            パッケージをダウンロード＆インストールします:
                pod install
            Podfile ファイル を テキスト エディター で開いて platform を有効にします:
                #// 警告が右記の場合: [!] Automatically assigning platform `iOS` with version `16.1` on target
                platform :ios, '16.1'
            インストールされたことを確認します:
                Podfile.lock ファイル: |
                    PODS:
                      - __PackageName__ (__Version__)
                パッケージ本体:
                    __Project__/Pods/__PackageName__
            プロジェクトを開きます:
                .xcodeproj ファイルではなく .xcworkspace ファイルを開きます
    コマンド:  #ref: https://guides.cocoapods.org/terminal/commands.html
    ファイル:
        Podfile: #keyword:  #// 設定ファイル
            #search: install CocoaPods
        Pod.lock:  #// 全パッケージとそのバージョンが書かれたファイル
    Pods, パッケージ カタログ:
        #search: Highlightr CocoaPods
    トラブルシューティング (CocoaPods):
        - #// Xcode でビルドしたら File not found libarclite_iphonesimulator.a
            手順: Xcode プロジェクトを開いてビルド
            エラー: |
                File not found: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/arc/libarclite_iphonesimulator.a
            対処:
                Xcode >> Project Navigator >> Pods >>（ターゲット）>> Minimum Deployments を 11 以上に設定します。
                #ref: https://zenn.dev/ischca/articles/a00c3adf626ea0
        - #// import で No such module エラー
            手順: Xcode プロジェクトを開いて import __PackageName__ でエラー
            エラー: No such module
            対処:
                プロジェクトを開くときは .xcodeproj ファイルではなく .xcworkspace ファイルを開きます
Apple Account: #keyword: Apple Account,  Apple ID は古い名前です  #ref: https://support.apple.com/ja-jp/109353
    公式情報:  #ref: https://support.apple.com/ja-jp/apple-id
    設定:
        Apple Account ページ, 各種設定変更:
            メニュー:
                WebUI の場合: https://appleid.apple.com  >> サインイン >>（パスキーを使います）
                iPhone の場合: 設定 >>（自分の名前）Apple ID >> サインインとセキュリティ
            #// 下記 W=WebUI, P=iPhone
            メールと電話番号 (W,P):
            パスワード (W,P):
            アカウント セキュリティ (W):
            通知用 メール アドレス (W):
            アカウントの復旧 (W,P):
            故人アカウント管理連絡先 (W,P):
            Apple でサインイン (W,P):
            アプリ用パスワード (W):
            自動認証 (P):
        プライマリ メール アドレス の変更:  #ref: https://support.apple.com/ja-jp/109353
    メールを見ます: #search: iCould mail
Apple Developer: #keyword: Apple Developer Program,  Xcode ライセンス,  Apple developer support
    アカウント, メンバーシップ, 審査登録:  #// ライセンス
        Account Holder: #keyword: Apple Developer Program Account Holder
        アカウント:  #// Apple Developer のアカウントの設定ページ  #ref: https://developer.apple.com/account
        連絡先（自分）メール: Apple ID の設定が使われます
        期間: 2025年1月29日 - 2026年1月30日
            30日前に更新可能  #search: update Apple Developer Program
        更新: #keyword: update Apple Developer Program  #ref: https://developer.apple.com/jp/support/renewal/
            手動更新:
                30日前から手続きできます
            自動更新:  #// 表示されない
                https://developer.apple.com/account  >> メンバーシップの詳細 タブ >> 自動更新
                    #ref: https://developer.apple.com/jp/support/renewal/
        合意文書:
            2026-01:  #ref: ${typrm_files}/2026/Apple_Developer_Program_License_Agreement_TF9M42S8SS.pdf
        EU デジタルサービス法への対応: #keyword: App Store Connect EU デジタルサービス法
            _: 住所氏名などを入力します
            メニュー: App Store Connect のアプリ >> アプリ情報（左）>> デジタルサービス法
            「氏名を確認できるビジネス文書または裁判所文書のコピーをアップロードします」:
                OK:
                    - 住民票、住民基本台帳カード
                    - マイナンバーカードまたは個人番号カード
                    - 在留カード
                    - 政府発行の写真付き身分証明書 (例：パスポートや運転免許証)
                NG:
                    - 健康保険証
                #ref: https://studio.beatnix.co.jp/diary/apple/dsa/
    手順: #keyword: Apple Developer Program steps  #// サポート
        公開: #keyword: アプリ 公開,  iOS アプリ 提出  #// アプリを公開する手順
            準備 >> Apple Developer Program を購入します:
                公式:
                    一般:  #ref: https://developer.apple.com/jp/programs/enroll/
                    Apple Watch:  #ref: https://developer.apple.com/jp/watchos/submit/
                参考:  #ref: https://tech.amefure.com/swift-apple-developer-program
            無料アプリの場合:
                公式情報:
                    App Store Connect:  #search: App Store Connect  #ref: https://appstoreconnect.apple.com/login
                    プロダクトページの作成: #keyword: Apple Developer プロダクトページの作成  #ref: https://developer.apple.com/jp/app-store/product-page/
                        メニューの場合:
                            https://developer.apple.com/jp/develop/ （開発タブ）>>
                            App Store Connect >> プロダクトページについてさらに詳しく
                    App Store Connect ヘルプ: #keyword:  #ref: https://help.apple.com/app-store-connect/?lang=ja#/
                        メニューの場合:
                            https://developer.apple.com/jp/develop/ （開発タブ）>>
                            App Store Connect >> プロダクトページについてさらに詳しく >>
                            提出 >> iOS >>（提出）「App Store Connectヘルプ」を確認する
                手順:  #// App Store Connect
                    サイン イン します:
                        Mac Web 版:  #ref: https://appstoreconnect.apple.com/login
                            メニューの場合:
                                App Store Connect ヘルプ >> App Store Connect を始める >>
                                App Store Connect へのサインイン >> App Store Connect（文中）>>
                                続いて App を追加します  #search: register to Apple Store Connect
                        アプリ版:  #// Apple Store Connect アプリ
                    （サインイン済みなら）:  #ref: https://appstoreconnect.apple.com/apps
                    App を追加します: #keyword: register to Apple Store Connect  #ref: https://help.apple.com/app-store-connect/ja.lproj/static.html
                        #↓ 画面構成
                        アイコン:  #// 左上にあるアプリのアイコン（App Store Connect のアイコン）の登録は #search: register to Apple Store Connect build
                        提出準備中（など）:
                            準備:
                                アプリのアイコンを設定します。設定しないとエラーになります  #search: Xcode App icon
                            Xcode の場合:
                                アップロードします: #keyword: upload to Apple Developer
                                    メニュー:
                                        - Xcode >>（ターゲット=）Any iOS Device (arm64) >>
                                        - Product メニュー >> Archive
                                        - もし Account Authentication Failure が表示されたら、もう一度 Archive します。
                                            成功したら Archive ウィンドウが開きます
                                        - Distribute App（右上）>> App Store Connect >> Distribute（右下）>> Upload >> Next（右下）
                                            #// 2回目以降？→ Distribute App（右上）>> App Store Connect >> Distribute（右下）
                                    以下は初回のみ？:
                                        Upload your app's symbols: チェック
                                        Manage Version and Build Number: チェック
                                        Next ボタン（右下）:
                                        Re-sign: Automatically manage signing
                                        Next ボタン(2)（右下）:
                                        Uploadボタン（右下）:
                                        #// iPad 対応なのに iPad のスクショがないなどのチェックが行われます
                                アップロードを確認します: #keyword: Apple Developer build number  #// アップロードしたアーカイブのビルド番号を調べます
                                    アップロード日が一致するビルドを探し、ビルド番号を確認します:  #// アップロードして数分後
                                        https://appstoreconnect.apple.com/apps >>（アプリ名）>> TestFlight タブ >>
                                        （括弧の中のビルド番号）>> ビルドのメタデータ タブ >> アップロード日
                                        #// アイコンが反映されるまで時間がかかります。30分以下
                            Web UI の場合:  #// 非推奨。App 追加画面。ID などが違うとアップロード時に使い物にならなくなります
                                メニュー: App Store Connect >> マイApp >> App を追加
                                プラットフォーム: iOS  #// watchOS 専用 App の場合も iOS を選びます
                                    #ref: https://developer.apple.com/jp/help/app-store-connect/create-an-app-record/add-watchos-app-information/
                                名前: ____
                                プライマリ言語: ____
                                バンドルID: プルダウンから選びます  #search: Xcode bundle ID
                                SKU: Bundle ID が com.example.MyApp なら SKU は ComExampleMyApp  #search: Apple Developer SKU
                                追加 ボタン:
                            （スクショ）プレビューとスクリーンショット:
                                （枠）:
                                    スクショを撮ります:
                                        #search: Apple Developer screen shot
                                    登録します:
                                        iPhone タブ（など）>>（画像ファイルを枠の中へドラッグ＆ドロップ）
                                    トラブルシューティング:
                                        #// 以下の警告は対処できません。1種類しか登録できません。
                                        現在、最新のウォッチビルドとしてApple Watch Series 6のスクリーンショットを使用しています。
                                        最新のデバイスのスクリーンショットを追加すると、App Storeでのアプリのユーザ体験をより正確に表すのに役立ちます。
                                プロモーション用テキスト:  #ref: https://developer.apple.com/jp/app-store/product-page/  >> プロモーション用テキスト
                                    #search: プロダクトページの作成
                                概要:  #ref: https://developer.apple.com/jp/app-store/product-page/  >> 説明
                            ビルド（下からやや上）:  #keyword: register to Apple Store Connect build
                                ビルドを追加 >> ビルド（番号）>> 完了（右下）>> 保存（右上）
                                #// ビルドを登録すると、App Store Connect の左上にあるアプリのアイコンが更新されます
                            キーワード: ____, ____, ...
                            サポートURL: ____
                            ルーティングAppカバレッジファイル: #// 不要
                        アプリ情報:
                            アプリ名:
                            サブタイトル:  #ref: https://developer.apple.com/jp/app-store/product-page/  >> サブタイトル
                            カテゴリ: ____
                            コンテンツ配信権: ____
                            年齢制限指定: ____
                            保存 ボタン（右上）:
                        価格および配信状況:
                            価格表: ____
                            保存 ボタン（右上）:
                        アプリのプライバシー:
                            はじめに ボタン:
                            データ収集: なし  #// 例
                            プライバシー ポリシー URL: 入力しないと審査用に追加ボタンを押すと警告されます  #ref: https://developer.apple.com/jp/app-store/app-privacy-details/
                            公開 ボタン（右上）:
                        暗号使用の設定:  #// Xcode のプロジェクトに設定します
                            （暗号を使っていない場合）:
                                Xcode に暗号を使わない宣言を設定します:
                                    #ref: https://help.apple.com/app-store-connect/#/dev63c95e436
                                    #ref: https://developer.apple.com/documentation/security/complying_with_encryption_export_regulations
                                    プロパティを追加します:
                                        Xcode >> Project Navigator >> Info.plist >>
                                        （Information Property List の）＋ >> App Uses Non-Exempt Encryption
                                    値を設定します:
                                        No
                                アップロードします: #search: upload to Apple Developer
                                App Store Connect に暗号を使わない宣言を設定します:
                                    TestFlight タブ >>（ビルド >> ステータスの）管理 >> 上記のアルゴリズムのどれでもない >> 保存
                        アップロードします: #search: upload to Apple Developer
                        ビルドに追加します:
                            提出準備中（左上）>>（少し下へスクロールして）ビルドを追加 ボタン >>（ビルド番号を選択）
                            #// ビルド番号は #search: Apple Developer build number
                            #// 更新する場合は、既存のビルド番号にマウスを合わせて(-)（赤）
                        App Reviewに関する情報:
                            メニュー: 提出準備中（左上）>>（少し下へスクロールして）App Reviewに関する情報
                            サインイン情報:
                                （サインインが不要なアプリの場合）:
                                    チェックを外します
                            連絡先情報:  #// 氏名、電話番号、メールアドレス
                                電話番号: +819011112222 形式  #// 090-1111-2222 の場合
                        保存 ボタン（右上）:
                        審査用に追加 ボタン（右上）:
                            #// 最も上にスクロールして、エラーが発生していないか確認します
                        App Review に提出 ボタン（右上）:
                        #// 「審査待ち」と表示されます
                        審査が終わるまで待ちます:
                            App Store Connect の表示:
                                iOSアプリ バージョン 1.0 などに
                                配信準備完了 または 却下済み と表示されます
                                提出物を表示 で対応方法が表示されます
                            メールの件名: |  #// ts や tz には届きません
                                App Store Connect: Version 1.0 (1) for MyApp has completed processing.
                                アップロードした日時は 2023-02-05 11:58
                        AppStore から削除済み、との返事:  #// 配信する範囲を選択してください
                            ログ: このアプリはApp Storeの配信から削除されました。価格および配信状況に移動して、App Storeに再度追加してください。
                            価格および配信状況: mac, vision pro のチェックを外した
                            アプリの配信状況: 配信状況の設定 >> 特定の国または地域 >> 日本（配信可能を処理中）
                        配信準備完了（緑）:
                            配信されました
                        バッジを作ります: #keyword: AppStore badge  #// ダウンロードするページへのリンク
                            #ref: https://developer.apple.com/jp/app-store/marketing/guidelines/#section-badges
                            #ref: https://toolbox.marketingtools.apple.com/ja-jp/app-store/us
                            Apple ID: App Store Connect >> アプリ タブ >>（アプリ）>> アプリ情報 >> Apple ID
                            URL: #keyword: アプリ URL
                                https://itunes.apple.com/jp/app/id__AppleID__
                            もうすぐ通知: #ref: https://itunes.apple.com/jp/app/id1669937755
                            5mint Timer: #ref: https://itunes.apple.com/jp/app/id6504078117
                    App を削除します: #keyword: remove App in App Store Connect,  delete App  #ref: https://developer.apple.com/help/app-store-connect/create-an-app-record/remove-an-app
                        App Store Connect >> アプリ >>（アプリ）>> アプリ情報（左）>>（最も下へスクロール）>> アプリを削除
                    削除済み App 一覧:
                        App Store Connect >> アプリ >> 配信準備完了（右上）→ 削除済みアプリ
                    App を復元します: #keyword: restore App in App Store Connect  #ref: https://developer.apple.com/help/app-store-connect/create-an-app-record/remove-an-app
                        復元する バンドル ID を確認します:
                            Xcode 内:  #search: Xcode bundle ID
                            App Store Connect 内:  #search: App Store Connect bundle ID
                        復元します:
                            App Store Connect >> アプリ >>（アプリ）>> アプリ情報（左）>>（最も下へスクロール）>> アプリを復元
                参考手順:  #ref: https://zenn.dev/moutend/articles/feebf0120dce6e6426fa
                    スクショを撮ります: #keyword: Apple Developer screen shot
                        シミュレーターの言語を日本語に設定します:
                            ホーム >> Settings >> General >> Language >> Japanese
                        アプリをシミュレーターで動かしてスクショを撮ります:
                            解像度: アップロード先にあるそれぞれの解像度
                            解像度とシミュレーターの種類の対応関係: #ref: https://help.apple.com/app-store-connect/?lang=ja-jp#/devd274dd925
                            操作: Command + S キー
                        画像をアップロードします:
                            編集を押して、画像をフォルダーからブラウザーへドラッグ＆ドロップします
                    App ID を作ります:  #// アプリ固有の ID
                    アプリを AppStore Connect に登録します:
                    アプリの各種情報を編集します:
                        一般情報:
                        App Information:
                        Pricing and Availability:
                        App Privacy:
                    アプリをアップロードします:
                    メールが届くまで待ちます:
                    ビルド情報を編集します:
                    アプリを申請します:
                    公開されるまで待ちます:
                    参考: #ref: https://zenn.dev/moutend/articles/feebf0120dce6e6426fa
                トラブルシューティング（Apple Store Connect）:
                    手順: 審査用に追加 ボタン を押したとき
                    ログ: |
                        追加するアプリの著作権情報を入力してください。
                    対処:
                        -   提出準備中（など）>> 著作権
                        -   提出準備中（など）>> App Reviewに関する情報（をページ内検索）
        更新: #keyword: update Apple Developer Program  #// Apple Developer Program の契約を更新します
            注意: お金払えなくなると、登録してたアプリも消えてしまいます
            更新: https://developer.apple.com/account >> メンバーシップを更新（青）  #// 青いボタンが表示されないときは、ブラウザーをリロードしてください
            注文履歴, 注文内容を見る:
                mac >> https://www.apple.com/jp/ >>（最も下へスクロール）>>（アカウント）Apple Storeアカウント >>
                （少し下へスクロールして真ん中）（注文内容）注文内容を見る >>
                （小さい文字で Apple Developer Program - 1年間のメンバーシップ）登録完了
            領収書: メールで後日来る？
        テスト リリース:  #search: App Store Connect TestFlight
        インプレッション数の確認:  #ref: https://appstoreconnect.apple.com/analytics/apps/d30
        サポート:  #search: Apple Developer support
    構成:
        App Store Connect: #keyword:  #// 公開手順に使う加入者用のページ  #ref: https://appstoreconnect.apple.com/login
            公式情報:  #ref: https://appstoreconnect.apple.com
            手順:  #search: Apple Developer Program steps
            画面:
                (iPhone web版):  #ref: ${GitHub}/MyPrivateCode/typrm_images/2024/AppStoreConnect-iPhone.jpeg
                アプリ タブ:  #search: App Store Connect applications
                    配信 タブ:
                        一般 グループ（左）:
                            App Review: #keyword:
                                目的:
                                    ベータ テスト 開始: App Review の承認が必要です
                                審査結果 2024-05-01: #keyword:  #ref: https://appstoreconnect.apple.com/apps/6499565557/distribution/reviewsubmissions/threads/f276b335-780e-33c3-b260-fc4d875a027d
                                    審査ステータス: 却下（再提出）
                                    ビルドバージョンレビュー: 1.0 (2)
                                        ガイドライン2.1 - 必要な情報
                                        アプリのレビューを開始しましたが、物理的なwatchOSデバイスで使用されているアプリの現在のバージョンを示すビデオにアクセスする必要があるため、続行できません。
                                        提供するビデオが物理デバイス(シミュレーターではない)を示していることを確認してください。
                                    次のステップ:
                                        アプリのレビューを進めるために、App Store Connectのベータアプリレビュー情報セクションにあるデモビデオへのリンクを提供し、App Store Connectでこのメッセージに返信してください。
                                    デモビデオへのリンクを提供するには:
                                        - App Store Connectにログインする
                                        - 「マイアプリ」をクリックします。
                                        - アプリを選択してください
                                        - 「TestFlight」タブに移動します
                                        - 「テスト情報」を選択
                                        - 「ベータアプリレビュー情報」までスクロールします。
                                        - 「レビューノート」セクションでデモビデオアクセスの詳細を提供する
                                        - 「保存」をクリック
                                        - App Store Connectでこのメッセージに返信する
                                        - この情報が利用可能になったら、アプリのレビューを続けることができます。
                                    サポート:
                                        - サポートが必要な場合は、お好みの言語でこのメッセージに返信してください。追加のサポートが必要な場合は、お問い合わせモジュールを使用してください。
                                        - Apple Developer Forumsで仲間の開発者やAppleエンジニアに相談してください。
                                        - ガイドラインの変更を提案することで、レビュープロセスを改善したり、ポリシーを明確にする必要性を特定したりするのに役立ちます。
                        （アプリ）: #search: App Store Connect applications
                    TestFlight タブ:  #search: App Store Connect TestFlight
                アナリティクス タブ:  #// インプレッション数
                    アプリ名をクリックすると詳細が表示されます
                トレンド タブ: #keyword: Apple Store Connect トレンド  #// 分析？
                    セッション数:
                    ユニット数:
                レポート タブ:  #// 支払いと財務報告
                ビジネス タブ:  #// オーナーや法人
                ユーザーとアクセス タブ: #keyword: App Store Connect users  #// アカウント
        サイド ローディング:  #ref: https://japan.cnet.com/article/35214419/
            欧州のみ。公証を受けることを求める。100万インストールからアップル税が発生。
        アプリ: #keyword: App Store Connect applications
            （操作）:
                一覧: App Store Connect >> アプリ
                追加登録:  #search: register to Apple Store Connect
                削除:  #search: remove App in App Store Connect
            アプリ名: #keyword: App Store Connect display name  #// アプリの一覧に表示される名前。実機のアプリのアイコンに添えられる名前
                メニュー: App Store Connect >> アプリ >>（アプリ）>> 配信 タブ（デフォルト）>> アプリ情報（左）>>
                    ローカライズ可能な情報 グループ >> 名前
            バンドル ID: #keyword: App Store Connect bundle ID
                メニュー: App Store Connect >> アプリ >>（アプリ）>> 配信 タブ（デフォルト）>> アプリ情報（左）>>
                    一般情報 グループ >> バンドルID
                Xcode 内:  #search: Xcode bundle ID
        TestFlight タブ: #keyword: App Store Connect TestFlight
            手順:  #keyword: start App Store Connect TestFlight
                公開するアプリをテストします:  #// Xcode Cloud を使っても公開できます
                    （親）: #search: アプリ 公開
                    App Review を依頼します:  #// レビューを通らないと テスト リリース できません
                        開始: 登録すると自動的にレビューが開始されます
                        結果のサンプル:  #search: 審査結果 2024-05-01
                    テスト リリース をします:  #// 正式公開前に一部の人に配り、レビューを受けられるようにします
                        #// 未確認
                        Account Holder の手順:  #search: Apple Developer Program Account Holder
                            #↓テストの実施者が
                            内部テスターの場合:
                                ユーザーを追加します:  #// テスターのアカウントが無ければ、グループに所属する前のユーザーのアカウントを追加します
                                    注意:
                                        アカウントの種類:
                                            内部テスターは Apple ID を持っている人しかなれません。
                                        複数の メール アドレス:
                                            持てません。ユーザーが持てる メール アドレス の数は 1つだけです。
                                            Apple ID の連絡先メールアドレスもダメみたい。
                                        追加したとき:
                                            招待メールが発信されます。
                                        #search: Apple ID
                                    手順:
                                        ユーザーとアクセス タブ: #search: App Store Connect users
                                            App Store Connect >> ユーザーとアクセス タブ
                                        ＋ ボタン:
                                テスターのグループを作る場合:
                                    TestFlight タブを開きます: #search: App Store Connect TestFlight
                                        App Store Connect >> TestFlight タブ
                                    グループを追加します:
                                        ビルド（左）>>（警告文章内の）グループを作成 >> tester1（などを入力）>> 作成 ボタン
                                            または
                                        テスター（左）>>（内部テスト）＋ tester1（などを入力）>> 作成 ボタン
                                    ユーザーをグループに所属させます:
                                        TestFlight タブ >> テスター（のグループ名）>>（テスターの）＋ >>（チェック）>> 追加 ボタン
                                ビルド バージョン にテスターを設定します:
                                    TestFlight タブを開きます: #search: App Store Connect TestFlight
                                        App Store Connect >> TestFlight タブ
                                    テスターを追加します:
                                        ビルド（左）>>（ビルド番号）>> グループ または 個人テスター の ＋
                            外部テスターの場合:
                                事前にアップルの審査が必要です。1〜2営業日かかります
                        テスターの手順:
                            TestFlight アプリをインストールします:
                                AppStore で検索
                            招待メールを受信したら受け入れます:
                                メールの中の Accept invitation をタップすると追加が完了します  #// 未確認
                Xcode Cloud でテストします:  #keyword: start Xcode Cloud TestFlight
                    Xcode でプロジェクトを作成し、GitHub に git push します:
                        - 後で CI（ビルド等）をトリガーするブランチを選ぶ必要があるためです
                        - GitHub の Xcode プロジェクトと、後で Xcode Cloud にアプリ（プロジェクト）を作るときの Xcode で
                            bundle identifier が違うと、ビルドのワークフローの最後で次のエラーが発生するようです
                            This bundle is invalid. The bundle identifier cannot be changed from the current value, 'sage-p.FiveMint2'. If you want to change your bundle identifier, you will need to create a new application in App Store Connect.
                    Xcode Cloud の Welcome ウィンドウ を開きます:  #// Xcode で
                        手順:
                            - ネットワークに接続していなかったら、接続し直して、接続できたら Xcode を再起動します
                            - Xcode のビルドのステータス（上）の右に雲と青丸が表示されて Apple ID にサインインが必要ならサインインします
                            - Apple ID にサインインする手順を実施した場合、Xcode を終了して（ウィンドウを閉じるだけでなく）再起動します
                            - Integrate メニュー >> Create Workflows または Manage Workflows  #ref: https://developer.apple.com/documentation/xcode/developing-a-workflow-strategy-for-xcode-cloud
                            - Welcome ウィンドウ が開きます  #// 以下はこれが開いた場合の手順です
                        （開始できないとき）:  #// This operation could not be completed.
                            mac を再起動します
                        #// Welcome ウィンドウ が開いたら
                        Next ボタン:
                        Select a Product: ____  #// ____.watchkitapp が表示されたとき、それではないほうを選びます
                    最初のビルドをします:
                        Xcode:
                            Welcome ウィンドウ(?) >> Edit Workflow...（左下）>> Branch Changes（左）>> Source Branch（を編集）>> Save（右下）>>
                            Next（右下）>> Grant Access（右上）>>  #// Grant Access ボタンがない場合は以下へ
                        Grant Access ボタンがある場合:
                            ブラウザー:
                                （サインイン）>>
                                GitHub でステップ1を完了（右下）>> Authorize Xcode Cloud（緑：右下）>>
                                （ステップ2に書いてあるようにリポジトリを選びます）>> Install（緑：左下）>>（承認します）>>
                                Xcode で続ける >>
                            Xcode (2):
                                （緑のチェックが付いていることを確認）>> Next ボタン（右下）>>
                                Primary Language = Japanese >> Complete（右下）>>
                                Choose the branch = develop >> Start Build（右下）>>
                                App Store Connect（右上）>> Close（右下）
                        Grant Access ボタンがない場合:
                            手順:
                                Next ボタン（右下）
                                Complete ボタン（右下）
                            エラー:
                                - すでに同じ Bundle Identifier のアプリがあるとエラーになります。
                                - 削除しても解決しません  #search: remove App in App Store Connect
                                - 新しい ID に変更します（未確認） #search: Xcode bundle ID
                        ブラウザー (2):
                            （ビルド完了まで待ちます）
                    自動で配信するように設定します: Xcode Cloud タブ >> ワークフローの管理 >> Default（ワークフロー名）>>
                        （アクション グループ）>> 配信準備 >> TestFlight（内部テストのみ）>> 保存（右上）
                    すぐ配信する場合: Xcode Cloud タブ >> ビルド >> ビルドを開始（右上）>>（ワークフロー名）>> 次へ（右下）>> 自分のもの = オフ >>
                        （ブランチ名）>> ビルドを開始（右下）
            構成:
                App:
                    ビルド バージョン の削除:
                        削除はできません。期限切れにして隠すことはできます
                テスター:
                    グループ:  #keyword: App Store Connect TestFlight group
                        追加:  #search: start App Store Connect TestFlight
            トラブルシューティング（TestFlight）:
                招待メールが来ない:
                    - リンクは Safari で開くこと
                    - 外部テスターに登録されていないこと
                        #ref: https://koshian.hatenablog.com/entry/2015/03/03/135058
                    - 個人テスターの電話番号は +81 から始めること
                「利用可能なビルドなし」:
                    - 輸出コンプライアンスを設定します
                    - 新規でアプリを登録し、一回もAppleの審査を行なっていないアプリの場合、1 〜2日以内に審査が行われるため、TestFlightでの共有が行えないようです  #ref: https://develop.hateblo.jp/entry/2022/12/09/173242
                    #ref: https://develop.hateblo.jp/entry/2022/12/09/173242
                    #search: App Review
                EU デジタルサービス法への対応:  #search: App Store Connect デジタルサービス法
        Xcode Cloud タブ: #keyword: App Store Connect Xcode Cloud,  Xcode Cloud,  Xcode Cloud タブ
            概要:  #ref: https://developer.apple.com/jp/xcode-cloud/get-started/
                - 毎月25時間のコンピューティング時間を無料でご利用いただけます。
                - TestFlight との連携があります  #search: TestFlight
                - 対象ProjectがGitリポジトリにpushしてあること  #ref: https://creators.videomarket.co.jp/entry/2022/06/09/100000
                - Homebrewが含まれています  #ref: https://developer.apple.com/documentation/xcode/making-dependencies-available-to-xcode-cloud
                - プライベート依存関係へのXcode Cloudアクセスの許可が必要  #ref: https://developer.apple.com/documentation/xcode/making-dependencies-available-to-xcode-cloud
                - Product->Xcode Cloud->Create WorkflowからWorkflowの作成を開始します。
                - Integrate メニュー >> Create Workflows または Manage Workflows  #ref: https://developer.apple.com/documentation/xcode/developing-a-workflow-strategy-for-xcode-cloud
            手順: #search: start Xcode Cloud TestFlight
            画面:
                ワークフローの管理:  #// 初期状態の名前は Default
                    アクション >> 配信準備: TestFlight  #search: start Xcode Cloud TestFlight
        （iPhone Web 版 でタブを選ぶ）:  #ref: https://appstoreconnect.apple.com/login
            メニュー: アプリ >>（対象アプリ）>> 配信（など：右上）>> Xcode Cloud（など）>>
                （以下はさらに深く選ぶとき）>> ビルド（など：左上）>> ワークフローの管理（など）
    サポート: #keyword: Apple Developer support
        チケット, TSI, Technical Support Incidents: #keyword: Apple TSI  #ref: https://developer.apple.com/account#CodeLevelSupportCard  >> コード レベル のサポート
            年度中に利用できるのは 2件
            リクエストしたら、確認Eメールを受け取るまで待つ。メールは Apple ID に登録した全部に来る？
        フォーラム:  #ref: https://developer.apple.com/forums/
        電話によるサポート:
            時間: 月〜金 9:00-17:00
            メニュー:
                App Store Connect ヘルプ https://developer.apple.com/jp/help/app-store-connect/  >>
                さらにサポートが必要な場合（最も下へスクロール）
iPhone:
    写真のバックアップ、取り出し:  #keyword: iPhone back up pick up, iPhone 容量不足
        動画: #keyword: iPhone 動画 バックアップ  #ref: ${smart_phone_movies}  #search: NAS
            RLFiles を使う:
                初期設定:
                    iPhone の自動ロックを無効にします: #// ロックされてアップロードが中断されないようにします
                        iPhone >> 設定 >> 画面表示と明るさ（3つ目のグループ）>> 自動ロック >> なし
                    RLFiles アプリ をインストールします:
                動画をアップロードします: #keyword: RLFiles upload
                    #// iPhone で 16:9 にトリミングした動画も OK。iPhone で新しい動画に保存しなくてもバックアップは 16:9 になります。
                    動画のサムネイル（見た目）と年を確認します:
                        iPhone >> 写真 >> アルバム（左上）>>（下にスクロールして）ビデオ >>（最も上にスクロールして）対象のサムネイル
                    アップロードします:
                        RLFiles（アプリ）>>（アップロード先のフォルダーを開く）>> 選択（右上）>> ＋（左下）>>
                        フォトライブラリから取り込み >> ビデオ（など）>> 対象のサムネイル >> 完了（右上）
                    アップロードしたファイルを確認して、削除します: #keyword: iPhone 動画 back up check  #// 確認は RLFiles ではできません（不安定）
                        - iPhone >> 写真 >> ビデオ >> アップロードしたビデオの日時を確認します
                        - mac で NAS のフォルダーを開きます  #ref: ${smart_phone_movies}  #search: NAS
                            #// mac では絵文字が含まれると表示できません
                        - アップロードした年のフォルダーを mac で開き、詳細形式（表形式）でファイルを一覧します
                        - 動画が再生できることを確認します
                        - iPhone の写真に同じ日時の動画があったら、iPhone の動画を削除します
                        - もし、回転が必要だったら
                            iPhone で回転させ、NAS の動画を削除して、後で動画を再度バックアップします。
                    ミラーリングします: #keyword: iPhone 動画 バックアップ ミラー
                        BunBackUp で NAS から 外付けHDD へ:
                            #// 前回 2023-09-21
                            GPD3 >> デスクトップ NAS back up >> smart_phone_movie.lbk
                            #ref: ${GitHub}/MyPrivateCode/typrm_files/back_up/NAS/smart_phone_movie.lbk
                            #search: NAS バックアップ
                            #// 期間指定は不要です（全体をバックアップします）
                自動ロックの設定を元に戻します:
                関連:  #search: iPhone 動画 バックアップ
            取り出した後、iPhone から削除:
                バックアップに動画ファイルがあること  #search: iPhone 動画 back up check
            観る:  #search: NAS
        静止画: #keyword: iPhone 写真 バックアップ
            M1 mac, mac mini 経由:
                #ref: ${programming}/ユーザインターフェイス/iPhone/iPhone.svg#picture
                進捗:
                    M1 mac の場合: 2020-12 までコピー完了 2020-06 まで削除完了
                    mac mini の場合: バックアップがまだ
                場所:  #// バックアップの場所
                    M1 mac の場合:  #// 2018年途中～現在
                        - NAS/Fotoclip_000
                        - M1 mac/Desktop/iPhoneキャプチャー
                    mac mini の場合:  #// 2014年～2018年途中
                        - LaCie HDD/iPhoneキャプチャー  #// mac mini と接続します
                        - mac mini HDD/Desktop/iPhoneキャプチャー
                手順:  #// イメージキャプチャを使った取り出し手順  #keyword: mac image capture iPhone
                    #// iPhone のキャプションに付けた内容は、mac のタグやコメントには入りません
                    M1 mac の場合:
                        iPhone >> M1 mac >> NAS へ移動します
                        #// 以下に続きます
                        #// M1 mac では LaCie HDD を認識できません  #search: mac external HDD
                    mac mini の場合:
                        注意 2025-08-30:
                            iPhone と接続できません（ケーブルが壊れた？）
                            mac mini にある写真を NAS に移動するか？
                        mac mini を起動します:
                            #search: my mac mini
                        LaCie HDD を USB ケーブルで mac mini につないでアイコンが出るまで3分待ちます:  #keyword: mac external HDD
                            LaCie HDD と mac mini を USB ケーブルで接続します >> Finder でコンピューターを開きます >> LaCie の中を表示します
                            #// M1 mac では認識できません。電力不足？電源ケーブルを繋いでも同じ
                            #// 最初のフォルダーが表示できても、数分のうちにビジー状態のままになってしまいます。
                        #// 以下に続きます
                    イメージキャプチャを開きます:
                        iPhone を再起動します:
                            アプリを全て終了してから再起動します
                        iPhone を USB ケーブルで mac につないで、イメージキャプチャで開きます:
                            iPhone と mac を USB ケーブルで接続します >> iPhone のロックを解除します >> 信頼 ボタン
                        イメージキャプチャを起動します:
                            - mac >> Launchpad >> イメージキャプチャ（と入力）
                            - イメージキャプチャ >> __UserName__ の iPhone（イメージキャプチャの左上）
                        イメージキャプチャの待ちから戻らない場合:
                            iPhone 写真 >> 最近の項目 の数 99656 で読み込めた。もしくは写真アプリを動かすことで何か改善したのかもしれない。
                            戻らないときは、再起動します  #search: restart mac image capture
                    mac がスリープに入らないようにします: #keyword: mac sleep time,  mac 電源 スリープ カバー
                        メニュー: 🍎（左上）>> システム設定 >>（左半分を下へスクロールして）ロック画面（黒）
                        電源アダプタ接続時〜ディスプレイをオフにする: しない
                        スクリーンセーバの〜パスワードを要求: しない
                        （ボツ）:
                            🍎（左上）>> システム設定 >>（左半分を下へスクロールして）バッテリー（緑）>> オプション（右下）>>
                            電源アダプタ使用時〜スリープさせない＝オン
                    画像の範囲を選びます:
                        注意: よく止まるので 1か月以下の範囲を選びます
                        再起動します: #keyword: restart mac image capture
                            イメージキャプチャを終了 >> iPhone USB ケーブルを抜く >> 挿す >> イメージキャプチャを起動
                            #// 読み込みエラーのとき、mac のストレージ不足の可能性があります。ストレージを空けたら mac を再起動します
                        （レアケース）動画を優先的に取り出す場合:  #// 通常、動画は事前に移動済みです
                            種類と日付でソートします:  #// 動画を優先的に取り出すためです。第 1キーは種類、第 2キーは日付
                                イメージキャプチャ >> 日付をクリック（表のタイトル）>> 種類をクリック（表のタイトル）
                            #// 動画は MOV か MP4、画像は JPG か PNG
                        古いすべての種類のファイルから取り出す場合:
                            日付でソートします:
                                イメージキャプチャ >> 日付をクリック（表のタイトル）
                        コピーする範囲を選びます:
                            イメージキャプチャ >> 範囲のうち最も古い写真（行）をクリック >>（画像の内容が表示されていなかったら表示されるまで待ちます）>>
                            スクロール バー でスクロール　>> 範囲のうち最も新しい写真（行）をシフトキーを押しながらクリック
                        画像の内容が表示されていなかったら待ちます:
                    mac 本体と HDD にコピーします:
                        （無いなら）種類と年別のフォルダーを mac 本体と HDD に作ります:
                        新しい一時フォルダーを mac 本体に作ります:
                            名前の例: iPhoneキャプチャー/2021/01
                            すでにある場合: iPhoneキャプチャー/2021/01_new  #// コピーできた数を確認するための一時的な置き場所
                        イメージキャプチャから mac の中の一時フォルダーへドラッグ&ドロップします:
                        #// 削除はまだ行いません
                        一時フォルダーの内容をを HDD の中の種類と年別のフォルダーにコピーします:
                            #// 207項目 / 178GB　/ 60分
                            #// コピー中に削除やケーブルを抜くこと（下記）も並行して行うことができます。
                        一時フォルダーの内容をを mac 本体の中の種類と年別のフォルダーに移動します:
                            名前の例: iPhoneキャプチャー/2021/01
                    iPhone の中にあるバックアップ済みの写真を削除します:
                        iPhone 本体で削除します:
                            新しい写真アプリの場合:
                                - フィルタ >> 写真  #// 動画を除くため。他の項目を同時にチェックしても AND 条件 または OR 条件のどちらかバラバラで不明
                                - 古い写真を覚えます  #// 削除する範囲の中で、日付（左上）を参考にながら、最も古い写真を探し（日付は写真を全面表示すると上に表示されます））、写真の内容を覚えておきます
                                - 新しい写真を探します  #// 削除する範囲の中で、日付（左上）を参考にながら、最も新しい写真を探します。
                                - 選択 ボタン（右上）
                                - 範囲をドラッグします  #// 削除する範囲の中で、最も新しい写真から、最も古い写真へ、ドラッグする。その際、日付（左上）を参考にする。
                                - ゴミ箱 ボタン（右下）
                            古い写真アプリの場合:
                                簡易説明:
                                    画像を縮小表示する >> 選択（右上）>>（ドラッグ）>> ゴミ箱（右下）
                                詳細説明:
                                    #// 以下の手順は月末から月初までの方向で選ぶほうが分かりやすいためこうしています。月初めの前の写真が変わらないため。
                                    iPhone >> 写真 >> ライブラリ（左下）>>
                                    （現在の日付が遠い場合）
                                        月別 >>（バックアップした月の最初の写真をタップ）>> すべての写真（右下）>>
                                    （開始地点：バックアップした月の前の写真を確認する）>>
                                    （終了地点：左上の日付を見ながらスクロールして月末を探す）>>
                                    選択（右上）>>（選択範囲をドラッグ）>>
                                    （開始地点：選択枚数（下）がイメージキャプチャの選択数と合っているかチェック）>>
                                    ゴミ箱（右下） #// 間違えたらゴミ箱から復活させます
                        ❗注意 >> イメージキャプチャでは削除できなくなりました:  #// とても遅い
                            （イメージキャプチャの続き、またはそこで写真を複数選択）>>
                            選択状態のいずれかの行を右クリック >> ____項目を削除
                                #// 207項目 2分
                    NAS へ移動した後、NAS のバックアップ:
                        #ref: ${NAS}/写真
                        #search: NAS バックアップ
        以下は非推奨:
            （ボツ）Remote Link Files for iOS を使って NAS にアップロードする:
                #ref: https://www.iodata.jp/lib/manual/rlf-ios/index.html
            すべてアップロードする場合:
                #// 2022-12-01 バックアップがほとんどできていない。抜けだらけ
                #search: iPhone back up pick up, iPhone 容量不足
                Fotoclip（アプリ）
                    #// size 180MB | disk 15.1GB | 16000 files と非常に非効率なサムネイルを作るため非推奨
                #// 動画は対象外です。対象は JPEG, PNG, HEIF, WebP
                #// 年月ごとのフォルダーに分けてアップロードします
                #// アプリの画面を表示しなくなったらアップロードは中断してしまい、一部のファイルはアップロードされなくなります
            #// アップロードしたファイルのタイムスタンプは iPhone が写真に保存した日時になります
            （中断されたとき）:  #// アプリの画面を表示しなくなったらアップロードは中断してしまいます
                アップロードを中断したファイルの一部が、末尾が .upload で終わるファイル名で残りますが使えないので
                削除してください
    共有フォルダー: #// iPhone から HDD などのファイルにアクセスします
        準備:
            HDD を mac mini に USB ケーブルで接続する場合:
                LaCie HDD を USB ケーブルで mac mini につないでアイコンが出るまで3分待ちます:  #search: mac external HDD
                    LaCie HDD と mac mini を USB ケーブルで接続します >> Finder でコンピューターを開きます >> LaCie の中を表示します
                    #// M1 mac では認識できません。電力不足？
            mac の内容を見る場合、または HDD を mac mini に USB ケーブルで接続する場合:
                mac のファイル共有を有効にします:
                    mac りんご（左上）>> システム環境設定 >> 共有（下）>>（右下のエリアに何か表示されるまで待つ）>>
                    ファイル共有（左の上から 2番目）>> smb://192.168.___.___ をメモします
            iPhone から共有フォルダーを開きます:
                iPhone >> ファイル >> …（右上）>> サーバーへ接続 >> メモした 192.168.___.___ >> 接続 >>
                登録ユーザー >> 名前＝ mac のユーザー名 >> パスワード＝ mac のパスワード >> 次へ >> （対象の共有フォルダー）>>
        ファイルを開きます:
            ファイル アプリ >>（開くファイル）（シングル タップして 5秒待ちます）
        表示を回転させます:
            （注意：右上のボタンは押さないこと。編集してしまうので）
            回転ロックを解除して、本体を回転させます
        ファイル名を変更します:
            対象のファイルを長押し >> 名称変更（中央下） #// 既存の動画ファイル名（ハッシュ値）は削除できます
        ダウンロードします: #// 表示をスムーズにするために本体に動画ファイルをコピーします
            ファイルを開きます:
                シングル タップして 5秒待ちます
            ダウンロードします:
                共有↑（左下）（タップして 2秒待ちます）>> "ファイル"に保存 >>
                （このiPhone内）iPhone キャプチャー（無ければ作ります：右上の右から 2番目）>>
                保存（100MB / 16秒）
            ダウンロードしたファイルを検索します:
                最近使った項目（左下）
                #// 共有フォルダーの中は、最近使った項目の対象外です
        アクセスできなくなったら:
            mac を再起動します >> iPhone の電源を一度切ります >>
            mac りんご（左上）>> システム環境設定 >> 共有（下）>>（右下のエリアに何か表示されるまで待つ）>>
            iPhone から共有フォルダーを開きます（上記）
    購入履歴: #search: iPhone 購入履歴
    ショートカット: #keyword: iPhone shortcut,  iPhone オートメーション  #ref: https://support.apple.com/ja-jp/guide/shortcuts/welcome/ios
        サンプル:  #search: edit iPhone URL
        手順:
            #↓ 基本操作
            ショートカット アプリ を開きます:
                iPhone ホーム >> 検索（下）>> ショートカット（と入力）
            ショートカットの新規作成: #keyword: create iPhone ショートカット
                #// ショートカットは自動で実行開始しません
                _: 戻る（左上、戻るがあれば）>> すべてのショートカット >> +（右上）
            ショートカットの削除:
                ショートカット（を長押し）>> 削除
            オートメーションの新規作成: #keyword: create iPhone オートメーション
                #// ショートカットは自動で実行開始します
                iOS18 ショートカット アプリ >> オートメーション（下）>> 新規オートメーション（または）+（右上）>>（開始条件、試すときは時刻）>> 次へ（右上）>>（動かすアプリ、または）新規の空のオートメーション）  #search: ショートカット アクションを検索
            オートメーションの削除:
                オートメーションを左にフリック >> 削除
            #↓ 応用
            アプリを開いたらメッセージを表示させます: #keyword: create iPhone アプリ 開く オートメーション
                新規作成します:  #search: create iPhone オートメーション
                    iOS18 ショートカット アプリ >> オートメーション（下）>> 新規オートメーション（または）+（右上）
                起動条件を選びます:
                    アプリ（少し下へスクロール）>>（アプリ）選択 >>（表示するメッセージを関連するアプリ）>> 完了（右上）>> 開いている >> すぐに実行 >> 実行時に通知 = オフ >> 次へ（右上）
                メッセージを登録します:
                    新規の空のオートメーション（左）>> スクリプティング（中央左）>> アラートを表示 >>（中央）>> アラート __Message__ を表示（の）__Message__ >>（表示するメッセージ）
                動作条件を選びます:
                    アクション（アラート __Message__ を表示）の末尾の (>) >>
                    キャンセル ボタンを表示 = オフ >> 完了（右上）
        構成:
            （構成概要）:  #// 一覧するときは、ショートカットとオートメーションのそれぞれを一覧します
                ショートカット:
                オートメーション:
            ショートカット:
            オートメーション:
                起動を自動にできます。起動条件「いつ」を設定します
            起動条件:
                アプリを開いたとき:  #search: create iPhone アプリ 開く オートメーション
                アプリを開いてから数分後に通知:
                    オートメーション、開いたら、タイマー開始、残り時間を取得、次の時間（299秒）より小さい場合、タイマーをキャンセル
                バッテリーが少なくなったとき:
                その他:  #search: create iPhone オートメーション
            アクション: #keyword: ショートカット アクション
                #// 以下は《アクションを追加>> すべてのアクション》に表示されるメニューと同じ配置です
                #// よく使う項目に登録しておくとよいでしょう
                #// 検索もできます
                （検索）: #keyword: ショートカット アクションを検索
                    画面構成:
                        - 検索キーワードの入力項目
                        - 種類
                        - よく使うアクション、最近編集した種類のアクション
                        - アプリ
                （アクション共通）:
                    アイコン:
                        情報を表示: アクションのヘルプ
                        複製:
                        削除:
                    青い文字: タップすると入力できます
                    (>): 詳細設定
                    （次のアクションを入力します）:
                        #search: ショートカット アクションを検索
                （汎用項目）: #glossary: shortcut
                    __Contents__:
                        リテラル文字列と変数などを結合した文字列を指定できます
                    __Media__:
                        このiPhone内, iCloud Drive などを選びます。
                        このiPhone内などを開いた後、開く（右上）で選択します
                #↓ （種類）>> キーワード
                （スクリプティング）:  #// UI, 変数
                    アプリを開く:
                    （ユーザー インターフェース）:
                        アラートを表示:  #ref: https://support.apple.com/ja-jp/guide/shortcuts/apdb9661c761/ios
                        メニューから選択:
                    （変数）:
                        テキスト:
                        日付:
                            現在の日付: YYYY/MM/DD HH:MM 形式
                            指定日:
                （書類）:  #// ファイル
                    テキストファイルに追加:
                        文: __Contents__ を __Media__ へ __At__
                        __Contents__:  #search: shortcut __Contents__
                        __Media__:  #search: shortcut __Media__
                        __At__:
                            先頭に追加: 新規作成のみ。すでにあれば何も書かない。上書きしない
                            追加: 追記
                        ファイルパス: ____
                        新しい行を作成:
                            オン: 最終行に追記します
                            オフ: 同じ行の末尾に追記します
                        ▶︎（右下）: ファイルに出力せず、次のアクションの位置に __Contents__ を表示します
            スイッチコントロール:  #ref: https://rezv.net/iphone/58126/  #// 自動でタップします
                動画解説:  #ref: https://www.youtube.com/watch?v=y1Zz7vxGmco
            変数:  #ref: https://support.apple.com/ja-jp/guide/shortcuts/apdb5506f698/ios
                スコープ: 1つのオートメーションの中  #// オートメーション間で変数を共有する場合、iCloud に変数を保存するといいらしい
        参考:
            LABOホンテン:  #ref: https://rezv.net/iphone/58126/
Apple Watch, watchOS: #keyword: watchOS
    バージョン: watchOS 7 は Apple Watch Series 3 以降。watchOS 7 以降は Storyboard を使用した UI の設計は非推奨に
        なったので Swift UI で開発を行う必要があります。       
    関連: #// 操作方法  #search: Apple Watch
    手順:
        開発:  #search: Xcode watchOS
        公開: #keyword: watchOS 公開 提出
            watchOS 単体アプリでも、プラットフォームは iOS を選びます  #search: アプリ 公開
        デバイスの接続関連:  #search: Xcode device trouble
    通信:
        WCSession:  #// Apple Watch と iPhone 間で通信します  #keyword:
            サンプル:  #search: WCSession example
            コードの説明:  #keyword: WCSession code
                iPhone コマンド >> iPhone アプリの下半分のボタンを押した時の処理:
                    CommandsViewController.swift: |
                        override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)
                WCManager:  #// ❗書きかけ  #// ユーザーが書くクラス
                    参考:  #// SwiftUI App ライフサイクル で Watch Connectivity  https://qiita.com/surfinhamster/items/830e760e441d040c1a10
                    init:  #search: SwiftUI App init
                        サンプル:  #ref: ${GitHub}/MyPrivateCode/Swift/watch/UsingWatchConnectivity/SimpleWatchConnectivity/AppDelegate.swift#activate
                        iPhone 側:
                            __Project__/__App__/__App__App.swift : |
                                @main
                                struct __App__App: App {
                                    init() {
                                        WCManager.default.activate()
                        Apple Watch 側:
                            __Project__/__App__ Watch Extension.swift : |
                                @main
                                struct __App__App: App {
                                    init() {
                                        WCManager.default.activate()
                    static インスタンス:  #keyword: Swift class static
                    WCManager クラス:
                        __Project__/Shared/WCManager.swift ファイル: |
                            import Foundation
                            import WatchConnectivity

                            class WCManager: NSObject, WCSessionDelegate {
                                static let `default` = WCManager()

                                func activate() {
                                    if (WCSession.isSupported()) {
                                        let session = WCSession.default
                                        session.delegate = self
                                        session.activate()
                                    } else {
                                        print("WCSession is NOT Supported")
                                    }
                                }

                                func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {
                                    //
                                }

                                #if os(iOS)
                                func sessionDidBecomeInactive(_ session: WCSession) {
                                    //
                                }
                                #endif

                                #if os(iOS)
                                func sessionDidDeactivate(_ session: WCSession) {
                                    //
                                }
                                #endif
                            }
                        Target Membership を設定します:
                            - __App__
                            - __App__ Watch Extension
                            #// 参考:  #search: Xcode Target Membership
                    iPhone から送信します:
                        サンプル:  #ref: ${GitHub}/ToDoSwitcher/Shared/SessionCommands.swift#default.sendMessage
                        主なコード: |
                            guard WCSession.default.activationState == .activated else {
                                // ____
                            }
                                
                            WCSession.default.sendMessage( message,
                                replyHandler: { replyMessage in
                                    // ____
                                },
                                errorHandler: { error in
                                    // ____
                                })
                    Apple Watch で受信します:
                        未調査
            解析中: #search: WCSession learning
    用語: #glossary:
        Circular Small: Family (Complication) の１つ
        Complication, コンプリケーション: #keyword:  #// 時計の画面の１つ以上の一部にアプリを表示すること。自動翻訳では「合併症」。
            #ref: https://developer.apple.com/design/human-interface-guidelines/watchos/overview/complications/
            #ref: https://www.phileweb.com/review/column/202005/22/1047.html
            ユーザー向け:
                コンプリケーションの候補に表示されるようにします:  #// 対応アプリのみ
                    Apple Watch >> 設定 >> 画面表示と明るさ >> 常にオン >>
                    コンプリケーションのデータの表示（対応アプリのみ一覧されます）
            Xcode:
                WidgetKit: #keyword:  #// watchOS 10以降  #ref: https://developer.apple.com/documentation/widgetkit
                    概要:
                        SwiftUI で実装できる:
                        ターゲット名: Widget Extension
                        WidgetKitになったComplicationsにフルカラーの画像を設定する際に困ったこと:
                            #ref: https://qiita.com/MilanistaDev/items/f70e91cc16349e5586f6
                    新規プロジェクト:
                        作成済み:
                            #ref: ${GitHub}/MyPrivateCode/Swift/watch/2nd/Complication-15.3
                        手動:
                            Widget Extension を追加します:  #search: add Xcode extension
                                メニュー: ＋ >> Widget Extension（右上）>> Next ボタン（右下）
                                Product Name: ____
                                Include Configuration Intent: 外す
                                Finish ボタン:
                                Activate WatchComplicationsExtension scheme?: Activate
                CLKComplicationDataSource: #// watchOS 9以前
                    Deprecated: #ref: https://developer.apple.com/documentation/clockkit/deprecated_articles_and_symbols/creating_complications_for_your_watchos_app
                    WatchKit Extension を追加:
                        不要  #search: WatchKit Extension
                    WatchOS Target Properties:
                        https://developer.apple.com/documentation/bundleresources/entitlements
        Family (Complication): コンプリケーションで表示するアプリの領域の１つのサイズ
            Supporting Multiple Complication Families  https://developer.apple.com/design/human-interface-guidelines/watchos/overview/complications/
        Modular Large: Family (Complication) の１つ
        Modular watch face: Apple Watch の「モジュラー」という種類の時計の画面
            時計の画面を強く押して画面が小さくなったらその上に種類の名前が表示されます
        Tall body: コンプリケーションの Modular Large ファミリーの１つ。文字が大きい
        watch face: デジタル クラウン を押してスイッチする２つの画面のうち、時計の画面
        WatchKit App: Apple Watch で動くアプリのこと。 この サンプル プロジェクト によると __AppName__ WatchKit App というターゲット表示名にするらしい
        WatchKit Extension: Apple Watch と連携する iPhone のアプリの サブ モジュール のこと。__AppName__ WatchKit Extension というターゲット表示名にするらしい
            https://noumenon-th.net/webstrategy/2014/12/11/watchkit/
        デジタル クラウン: リューズ
        ホーム画面: デジタル クラウン を押してスイッチする２つの画面のうち、アプリを選ぶ画面
Apple Vision Pro:
    週刊 IT ニュース＆コラム 2023/ 6/12 通巻856号
AppStore: #keyword:
    購入履歴: #keyword: iPhone 購入履歴
        iPhone >> App Store >> アカウント ボタン（右上）>>（自分の名前）（上）>> 購入履歴
    星を上げる:
        評価を求めるプロンプトをつける  #ref: https://gigazine.net/news/20211122-apple-podcasts-review-trust/
    開発:  #search: Apple Developer Program
iCloud: #keyword:
    メール: #keyword: iCould mail
        https://www.icloud.com/ >> サインイン（中央）>> メール
    iCloud Drive: #search:
.dmg ファイル:  #keyword:
    概要: ____.dmg ファイルは、仮想 ディスク イメージ です。
    インストール手順:
        mac Dock >> ダウンロード（右から２番目）>> ____.dmg ファイル >>
        表示されたウィンドウの中にある左のアイコンを右のアイコンにドラッグ＆ドロップ >>
        表示されたウィンドウを閉じます
    起動方法:
        Launchpad >> インストールしたアプリケーション
参考文献:
    SwiftUI iPhone アプリ開発入門ノート[2020]:  #keyword: SwiftUI 2020
トラブルシューティング:
    mac のトラブルシューティング:  #search: mac trouble shooting
    Swift のトラブルシューティング:  #search: Swift trouble shooting
    Xcode のトラブルシューティング:  #search: Xcode trouble shooting
    デバイスの接続関連:  #// Xcode, iPhone, Apple Watch の接続  #search: Xcode device trouble
    Apple コミュニティ:  #keyword: apple community,  apple mac support community
        フォロー リスト:  #ref: https://discussionsjapan.apple.com/profile/Ts_Neko/subscriptions
        #search: Apple Developer Program
