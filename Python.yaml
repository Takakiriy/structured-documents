#keyword: Python.yaml, py,  Python  #ref: ${programming}/スクリプト/Python.svg
公式: #ref: https://docs.python.org/3/
注意:
    リファクタリング: Python はリファクタリングできません。たとえばクラスのメンバーのメソッド名を変えることが一度にできません。
        こっそり内部的なプロパティを参照しているコードは、動かすまで検出できません。
        クラス（import したシンボル）の削除は静的にエラー検出されます。
        #search: pylint no-member
    型チェック:
        注意: 型ヒントを使っても型のチェックは行われません。 
        サンプル: |
            variable: int = 0
            variable = "aaaa"   #// 実行時エラーにならない。VSCode で警告もされない
特殊記号一覧 （python）: #glossary: Python  #ref: ${programming}/スクリプト/Python.svg#sign
    (): タプル
    []: リスト
    {}: 辞書
    (@): デコレーター  #search: Python @
    (*), (**): 引数リスト  #search: Python argument list
    _L: 国際化  #search: Python 国際化
    __attribute: #search: name mangling
    ("""～"""):  #search: Python multi-line
    ('''～'''):  #search: Python multi-line
    f"": 中に変数を含める文字列  #search: f-strings
    r"": エスケープしない文字列  #search: raw-strings  #// \ をエスケープ文字として扱わず、\ 文字として扱います
    ("" % ___):  #search: Python string %  #// %フォーマット
    PEP: #keyword:  #// 拡張仕様, Python Enhancement Proposals
        例: PEP 508
手順, インストール:  #// デバッグ, テスト
    Playground: #keyword: Python playground
        try_Python:  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/try.py
        Online Python IDE:  #ref: https://www.online-python.com/KXmLvup8J6
            #// デバッガーが使えないため、オブジェクトの型などが分かりません
    インストールします, Projects:  #keyword: install Python
        Python だけインストールします:
            Windows:  #// WSL2 ではありません
                - http://www.python.org/ >> Downloads >> Windows >> （例）3.9.1 >> Windows installer (64-bit)
                - ダウンロードしたファイル（例：python-3.9.1-amd64.exe）を開きます
                - インストール オプションはデフォルトを使用
            mac:
                インストールします:
                    - http://www.python.org/ >> Downloads >> macOS >> macOS 64-bit universal2 installer >>
                    - ダウンロードしたファイル（例：python-3.10.7-macos11.pkg）を開きます
                    - インストール オプションはデフォルトを使用
                動作確認とバージョンの確認をします:
                    ターミナル:  #// mac の標準ターミナル
                        /usr/local/bin/python3 --version
                Python に PATH を通します:  #// mac のローカル  #keyword: mac PATH
                    code ~/.bashrc : |
                        export PATH=$PATH:/usr/local/bin
                    VSCode を再起動します:
                    動作確認します:
                        VSCode >> Terminal:
                            python3 --version
                            pip3 --version
                        #// pipenv は 3 が付きません
            Linux: #// Python3 をインストールします
                pyenv:  #// 推奨
                    - 多くの OS で動作確認済みです。yum などによるインストールは、対応しているバージョンが少ないです
                    - yum などによる Python 本体のインストールは不要です
                    #search: pyenv
                CentOS7: #keyword: install CentOS7 Python3
                    Python 3.6:
                        sudo yum install python3 -y
                        python3 --version
                RockyLinux8: #keyword: install RockyLinux8 Python3
                    コマンド: |  #// Python 3.11.7 の場合
                        sudo dnf install tar curl gcc openssl-devel bzip2-devel libffi-devel zlib-devel wget make -y
                        wget https://www.python.org/ftp/python/3.11.7/Python-3.11.7.tar.xz
                        tar -xf Python-3.11.7.tar.xz
                        cd Python-3.11.7
                        ./configure --enable-optimizations
                        nproc
                        make -j 2   #// 数字は Python をコンパイルするときに並列するジョブ数。nproc に合わせると早く完了できます
                        sudo make altinstall  #// 警告（下記）は無視した
                        cd ..
                        sudo rm -rf  Python-3.11.7
                        rm  Python-3.11.7.tar.xz
                        python3.11 --version
                        which python3.11  #// /usr/local/bin/python3.11
                    無視した警告:
                        sudo make altinstall: |
                            WARNING: The script pip3.11 is installed in '/usr/local/bin' which is not on PATH.
                            WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv
                    #ref: https://www.atlantic.net/vps-hosting/how-to-install-python-3-10-on-rocky-linux/
                Ubuntu Docker コンテナー: #keyword: install Python Ubuntu Docker,  install Python3 Ubuntu Docker container
                    ビルドする場合:
                        Dockerfile: |
                            FROM gitlab/gitlab-runner:ubuntu-v16.6.0
                            ARG http_proxy
                            ARG https_proxy

                            RUN  apt-get update
                            RUN \
                                apt-get install -y  python3=3.8.2-0ubuntu2  python3-pip=20.0.2-5ubuntu1.10  && \
                                pip3 install tox==4.13.0
                            RUN  python3 --version  #// 3.8.10
                            RUN  pip3 --version  #// 20.0.2

                            RUN  echo  "export http_proxy=${http_proxy}\nexport https_proxy=${https_proxy}\n" >> /home/gitlab-runner/.bashrc
                        bash: | #keyword: docker build with proxy IP address,  FQDN IP address nslookup dig server name
                            http_proxy_ip="http://$( dig +short  "$( echo  "${http_proxy}"  |  sed -E  's|https?://([^:/]+).*|\1|' )"  |  grep -E '([0-9]{1,3}\.){3}' ):${http_proxy##*:}"
                            echo  "${http_proxy_ip}"
                            https_proxy_ip="http://$( dig +short  "$( echo  "${https_proxy}"  |  sed -E  's|https?://([^:/]+).*|\1|' )"  |  grep -E '([0-9]{1,3}\.){3}' ):${http_proxy##*:}"
                            echo  "${https_proxy_ip}"

                            docker build \
                                --build-arg http_proxy=${http_proxy_ip} \
                                --build-arg https_proxy=${https_proxy_ip} \
                                -t __NewImageName__ "."  --progress=plain
                            docker system prune --all --force  #// docker build を再度動作確認するときは Docker のキャッシュをクリアします
                    ログインする場合: |
                        #search: Docker login
                        apt-get update
                        apt-get install -y  python3  python3-pip
                        python3 --version  #// 3.8.10
                        pip3 --version  #// 20.0.2
                        pip3 install tox
                        tox --version  #// 4.13.0
        Visual Studio Code: #keyword: Python VSCode  #// Python + Visual Studio Code
            拡張機能, 対応 Python バージョン: #keyword: VSCode Python extension
                Python 3.7:
                    - Python 拡張機能は 2023.14 バージョンまでです。 #ref: https://news.mynavi.jp/techplus/article/20231010-2789207/
                    - __Project__/.vscode/launch.json の "type" を "python" にしてください。"debugpy" ではありませｎ
                    - Python Debugger 拡張機能はアンインストールしてください。また、フォルダーを削除してください
                        rm -rf ~/.vscode-server/extensions/python-debugger____
            Flake8 拡張機能: #keyword: VSCode Flake8 extension  #search: Flake8
                Python 3.7: バージョン 2023.6 まで
                一部警告を抑制します:  #// E501 を抑制する場合
                    VSCode >> 歯車アイコン（左下）>> Settings >> Flake8（と入力）>> Flake8:Args >> Add Item >>
                    --ignore=E501（など）
                #search: Flake8
            isort: #keyword: VSCode isort extension  #search: isort
                Python 3.7: バージョン 2023.10.1 まで
                ソートします: Shift + Alt + O
                #search: isort
            venv で Python プロジェクトを新規作成する場合: #keyword: install venv VSCode
                注意:
                    ローカルでは非推奨: pipenv や poertry は仮想環境を変更（pip install コマンドを実行）すると Pipfile や pyproject.toml も同時に更新されますが、
                        requirements.txt は同時に更新されないため。
                    サーバーでは推奨: 少ないパッケージでできるため
                手順 >> 簡易表記版:
                    Install Visual Studio Code and Python extension:
                    Git bash:
                        cd __Project__
                        $HOME/AppData/Local/Programs/Python/Python39/python -m venv .venv
                        code "."
                        #// Close bash
                    Visual Studio Code:
                        F1 key >> Python: Select interpreter >> .venv
                        Reopen Terminal:
                            pipenv install
                手順 >> 完全版:
                    Python 拡張機能をインストールします:  #// Visual Studio Code に
                        Visual Studio Code を開きます:  #// 開くフォルダーの指定は無し
                        Python 拡張機能をインストールします:
                        Visual Studio Code を閉じます:
                    Python の仮想環境を作ります:  #// ここに Jupyter の本体が入ります
                        bash の場合: |  #// Python 3.9 の場合
                            cd __Project__
                            $HOME/AppData/Local/Programs/Python/Python39/python -m venv .venv
                        PowerShell の場合: |  #// Python 3.9 の場合
                            cd __Project__
                            & $HOME/AppData/Local/Programs/Python/Python39/python -m venv .venv
                    Visual Studio Code を開きます:
                        bash または PowerShell:
                            code "."
                        bash または PowerShell を閉じます:
                    仮想環境や PYTHONPATH:  #search: VSCode venv
                    （不要）Python Create Terminal: #keyword:  #// New Terminal メニューなどでターミナルを開くときに自動的に仮想環境をアクティベートします
                            方法1: |  #// ターミナルが開きます。次回以降は New Terminal メニューなどでターミナルを開くときに、自動的に仮想環境をアクティベートします
                                F1 キー >> Python: Create Terminal
                            方法2:
                                Python ファイルを開きます
                                #// これだけで次回以降は New Terminal メニューなどでターミナルを開くときに、自動的に仮想環境をアクティベートします
                    Python パッケージを追加します:  #// プロジェクトが使う仮想環境に追加します
                        Pipfile ファイルがある場合:
                            pipenv install  #search: Pipfile
                        requirements.txt がある場合:
                            pip install -r  requirements.txt
                            #// Linux サーバーの場合: sudo pip3
                        1つずつ指定する場合:
                            pip install jupyter
                    （参考）Visual Studio Code が使う Python 仮想環境:  #keyword: VSCode Python .venv version
                        .venv がある場合:  #// __VSCodeWorkspace__/.venv フォルダーがある場合
                            .venv の仮想環境が使われます
                        .venv がない場合:
                            #search: VSCode Python Select Interpreter
            作成済みのプロジェクト:
                try_Python: #keyword:  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/README.md
                try_pipenv: #keyword:  #ref: ${GitHub}/Trials/try_pipenv
                    手順 >> 初回: #search: install pipenv project
                    手順 >> 2回目以降:
                        Pipfile ファイルを含むプロジェクト フォルダーを任意の場所にコピーします(以後、__Project__ で表現します):
                            コピー元: #ref: ${GitHub}/Trials/try_pipenv
                            コピー先: デスクトップなど
                        仮想環境を作り、パッケージをインストールします:  #// Pipfile.lock に書かれたパッケージの本体を仮想環境に追加します
                            プロジェクトを開きます: #copy: open VSCode
                                Visual Studio Code を右クリック（Windows の タスク バー または mac の Dock）>>
                                New Window >> プロジェクト フォルダー を Visual Studio Code へドラッグ＆ドロップします
                            Terminal を開きます:
                                Visual Studio Code >> Terminal  #// PowerShell が起動すること
                            Git bash を使う場合:
                                - VSCode >> F1 key >> Python Select Interpreter >> Python 3.____ (Global)
                                - export PIPENV_VENV_IN_PROJECT=1
                                - プロキシがある LAN にいるとき:  #// 下記 example.com:8080 の部分は置き換えてください  #keyword: Python proxy
                                    HTTP_PROXY="http://example.com:8080"
                                    HTTPS_PROXY="http://example.com:8080"
                                - pipenv sync --dev
                            PowerShell を使う場合:
                                - ${env:PIPENV_VENV_IN_PROJECT} = 1  #// VSCode が認識するように、仮想環境 .venv をプロジェクトの直下に配置する設定にします
                                - プロキシがある LAN にいるとき:  #// 下記 example.com:8080 の部分は置き換えてください
                                    ${env:HTTP_PROXY}  = "http://example.com:8080"
                                    ${env:HTTPS_PROXY} = "http://example.com:8080"
                                - pipenv sync --dev
                        デバッグします: #// VSCode  #search: VSCode Python Debugger
                            .envrc ファイルがある場合、.envrc ファイルから環境変数を設定している部分だけ .env ファイルにコピーします:  #search: VSCode .env 環境変数
                            ブレークポイントを張ります: .py ファイルの行番号の左をクリック
                            デバッグ開始:
                                - F5 キー
                try_pytest: #keyword:  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/try.py
                    手順: #// try_pipenv の手順を参照
            poetry:  #// poetry を使ったプロジェクトを新しく使う場合  #search: Poetry VSCode
            pipenv:  #// pipenv に対応した Python プロジェクトを新規作成する場合  #search: pipenv projects VSCode
            テスト: #keyword: install Python unittest VSCode  #// Python + Visual Studio Code のユニットテスト環境を構築する場合（仮想環境なし）
                参考:
                    - 開発環境をセットアップする - https://docs.microsoft.com/ja-jp/learn/modules/python-install-vscode/
                    - testing - https://code.visualstudio.com/docs/python/testing
                Python をインストールします:
                    - http://www.python.org/ >> Downloads >> Windows >> （例）3.9.1 >> Windows installer (64-bit)
                    - ダウンロードしたファイル（例：python-3.9.1-amd64.exe）を開きます
                    - インストール オプションはデフォルトを使用
                Visual Studio Code をインストールします:
                    - https://code.visualstudio.com/
                    - ダウンロードしたファイル（例：VSCodeUserSetup-x64-1.50.1.exe）を開きます
                    - インストール オプションはデフォルトを使用
                    - （推奨）VSCode (Visual Studio Code をタスクバーにピン止めします:
                    - （推奨）Ctrl + S キーを押したときに全てのファイルを保存するように設定します: |
                        File >> Preferences >> Keyboard Shortcuts >> save all （と入力） >>
                            File: Save All （をダブルクリック） >> Ctrl + S キー >> Enter キー
                    - 下記の拡張機能をインストールします:
                        - Python
                    - VSCode の右下に下記をインストールするよう勧められたらインストールします（しなくてもよい）:
                        - Linter pylint
                        #// インストールするときに表示されるシェルは、インストール後にゴミ箱ボタンで閉じます
                テスト対象のコードと、テスト コードを作成します:
                    - VSCode >> File >> Open Folder >> （例）デスクトップの新しい python_test1 フォルダー（以後 __Project__ とする）
                        #// テストのファイルがあるフォルダー、または、その親フォルダを開きます（親の親はNG）
                    - Explorer ビューを右クリック >> New File  #// 内容は下記
                    - Hello, world を作る場合:
                        __Project__/main.py: |
                            def main():
                                print("Hello, world")
                        __Project__/main_test.py: |
                            from main import main # The code to test
                            import unittest # The test framework

                            class Test_Main(unittest.TestCase):
                                def test_main(self):
                                    main()

                            if __name__ == '__main__':
                                unittest.main()
                    - テストを作る場合:
                        __Project__/inc_dec.py: |
                            def increment(x):
                                return x + 1

                            def decrement(x):
                                return x - 1
                        __Project__/inc_dec_test.py: |
                            import inc_dec   # The code to test
                            import unittest  # The test framework

                            class Test_TestIncrementDecrement(unittest.TestCase):
                                def test_increment(self):
                                    self.assertEqual(inc_dec.increment(3), 4)

                                def test_decrement(self):
                                    self.assertEqual(inc_dec.decrement(3), 4)

                            if __name__ == '__main__':
                                unittest.main()
                Python の仮想環境を作ります:
                    Visual Studio Code の中で PowerShell を開きます:
                        VSCode >> Terminal（メニュー）>> New Terminal
                    PowerShell:
                        - ${env:PIPENV_VENV_IN_PROJECT} = 1  #// Python 仮想環境に __Project__/.venv を使う設定にします
                        - pipenv --python 3
                    追加するパッケージがある場合:
                        - pipenv install  ____
                Python の仮想環境を選びます:
                    VSCode >> Python __Version__（左下） >> ./.venv/Scripts/python.exe
                        #// ./.venv/___ が表示されないときは、リロード ボタン（右上）を数回押してください
                Visual Studio Code を再起動します:
                テスト環境を構築します:
                    - 'VSCode >> F1 キー >> Python: Configure Tests':
                        Test framework: unittest
                        Directory containing the tests: .   #// . は VSCode が開いているフォルダー
                        Pattern to identiy test files: "*_test.py"
                        #// F1 キー >> Python: Discover Tests コマンドで再スキャン（テスト検出をトリガー）できます
                テストを実行します:
                    古い仕様:
                        テスト関数の上に現れた Run Test | Debug Test を押します:
                    テスト ボタン（左のフラスコ）のボタンで表示されるビューで一度に多くのテストができます:
                        テスト項目にカーソルを合わせて、Run, Debug, Go to のいずれかのボタンを押します
                    テスト ボタン（左のフラスコ）の内容が表示されないとき:
                        import 文など グローバル スコープ でエラーが発生していたら処置すると表示されます
                    #// サブフォルダーにあるテスト コードのファイルは検出できません https://github.com/microsoft/vscode-python/issues/11969
                    #// unittest や Django のテスト実行コマンドを使うとよいでしょう。
            デバッグ: #keyword: install Python VSCode debug  #// Python + Visual Studio Code のデバッグ環境を構築する場合
                参考: VSCodeでdjango(Python)をデバッグ https://freeheroblog.com/vsc-debug/
                関連: #search: Poetry VSCode
                Windows:
                    Visual Studio Code でプロジェクト フォルダーまたは manage.py や *.py ファイルがあるフォルダーを開きます:
                    PowerShell を開き、スクリプトを実行できるようにします:
                        - Visual Studio Code >> Terminal  #// PowerShell が起動すること
                        - Set-ExecutionPolicy  RemoteSigned  -Scope CurrentUser  #// スクリプトを実行できるようになります
                    __Project__/.vscode/settings.json: |  #// 下記 ____ の部分は pipenv --venv コマンドを参考に編集してください
                        {
                            "python.pythonPath": "C:\\Users\\____\\Scripts\\python.exe"
                        }
                    .py ファイルを開きます:
                    launch.json ファイルを作ります: Run アイコン（虫） >> create a launch.json file >> Python file  #search: Python launch.json
                    ブレークポイントを張ります: .py ファイルの行番号の左をクリック
                    デバッグ開始:
                        メニューから選ぶ場合: Run アイコン（虫） >> Start Debugging ボタン（左上の緑色の三角）
                        キーボードのキーを押す場合: F5 キー
                Linux:
                    tox:  #search: tox VSCode debug
                DEBUG CONSOLE ビュー: #keyword: Python VSCode DEBUG CONSOLE
                    ブレーク中に CLI で実行できます。
                    右下のビュー >> DEBUG CONSOLE >>（最も下はプロンプトです）
            launch.json:  #search: Python launch.json
        Django: #keyword: install Django  #// Django プロジェクトを新規作成する（CRUD, Administrator, virtualenv 仮想環境）
            設定: #settings:
                __ProjectName__: django1  #// サイト名を兼ねます
                __Project__: ${HOME}/Desktop/django1  #// POSIX path
                __VirtualEnvName__: django1_env  #// pipenv を使わないときだけ必要
                __PythonVer3__: 3.7.9
                __PythonVer2p__: 3.7
                __PythonVer2__: 37
                __DjangoVersion__: 3.0.8
                __ProtoBufVersion__: 3.12.4
                __AdminAccount__: admin
                __AdminPassword__: password
            Docker コンテナー で起動する場合: #keyword: docker run Django
                docker run -e http_proxy=${http_proxy}  -e https_proxy=${https_proxy} \
                    -it  -p 8000:8000 -v $(pwd):/app -w /app python:3.11-slim sh -c \
                    "pip install django && django-admin startproject myproject . && python manage.py migrate && python manage.py runserver 0.0.0.0:8000"
                #// Quit the server with CONTROL-C. と表示されたら http://127.0.0.1:8000/ を開いてください
            圧縮ファイルからプロジェクトを復元する場合:
                pipenv を使う場合（Pipfile があるプロジェクト）:
                    #// 復元方法は下記「pipenv に対応した Python プロジェクト」を参照してください。
                    #// django のサンプルは、まだ作っていません
                pip を使う場合（Pipfile がないプロジェクト）:
                    #// 復元方法は下記「pip で仮想環境を復元する」を参照してください。
                    #// 例: http://localhost:55580/s/MyDoc/programming/スクリプト/Python.files/django1.tar.gz
            プロジェクトを新しく作る場合:
                WSL2 の場合の簡易コマンド:
                    #// Rocky Linux 9
                    python3 -m venv venv
                    source venv/bin/activate

                    pip install django
                    django-admin startproject myproject
                    cd myproject
                    python manage.py startapp myapp
                    python manage.py migrate
                    DJANGO_SUPERUSER_USERNAME=admin  DJANGO_SUPERUSER_PASSWORD=adminpass123  DJANGO_SUPERUSER_EMAIL=admin@example.com \
                        python manage.py createsuperuser --noinput
                    python manage.py runserver
                        http://127.0.0.1:8000/ を開く
                        Ctrl + C キー
                #↓ 詳細
                Python, virtualenv, git bash をインストールします:
                    https://www.python.org/downloads/windows/ >> Download Windows installer (64-bit) >>
                        python-3.7.9-amd64.exe  #template: python-__PythonVer3__-amd64.exe
                pipenv を使う場合:
                    Python に Path を通します:
                        - PowerShell を起動します:
                            Windows スタート >> PowerShell（と入力）  #// Visual Studio Code の Terminal でも可能
                        - 以下は一度に実行できます（Python37）: |  #template: Python__PythonVer2__
                            ${path} = [System.Environment]::GetEnvironmentVariable("Path", "User");
                            ${path} = "${HOME}\AppData\Local\Programs\Python\Python37\Scripts;${path}";  #template: \Python__PythonVer2__\
                            [System.Environment]::SetEnvironmentVariable("Path", ${path}, "User");
                        - PowerShell を閉じます
                    pipenv 本体をインストールします:
                        PowerShell: |
                            & "${HOME}\AppData\Local\Programs\Python\Python37\Scripts\pip" install pipenv
                                #template: \Python__PythonVer2__\
                        PowerShell を閉じます:
                    Pipfile と仮想環境を新規作成します:
                        #新しい Git bash
                        - mkdir  "${HOME}/Desktop/django1"  #template:  "__Project__"
                        - 以下は一度に実行できます: |
                            cd     "${HOME}/Desktop/django1"  #template:  "__Project__"
                            pipenv --python 3.7  #// Pipfile と仮想環境が作られます  #template: __PythonVer2p__
                            pipenv install  #// Pipfile.lock ファイルができます
                            pipenv --venv   #// 仮想環境があるフォルダーを表示します
                    pip (Pip Installs Package) で Django の Python パッケージを追加します:
                        #Git bash の続き
                        - 以下は一度に実行できます: |
                            cd  "${HOME}/Desktop/django1"  #template:  "__Project__"
                            pipenv install django==3.0.8  #template: __DjangoVersion__
                    プロジェクトを新規作成します:
                        #Git bash の続き
                        - 以下は一度に実行できます: |
                            cd  "${HOME}/Desktop/django1"  #template:  "__Project__"
                            pipenv shell
                            django-admin startproject  django1  "."  #// Create new project  #template: __ProjectName__
                    プロジェクトに CRUD のサンプルを追加します（スキップできます）:
                        #// 下記パッチは、MyDoc\programming\スクリプト\Python.files\django_CRUD_patch.zip にあります
                        #// パッチを当てる方法の例： snote >> git_merge を参照
                        - サイトにパッチを当てます:
                            __OldFolder__: ${HOME}/Desktop/CRUD_patch/site/back_up
                            __SourceFolder__: ${HOME}/Desktop/CRUD_patch/site/patch
                            __DestinationFolder__: ${HOME}/Desktop/django1/django1  #template:  __ProjectName__/__ProjectName__
                        - hello アプリケーションを追加します:
                            - 新規作成します:
                                #新しい Git bash
                                - cd  "${HOME}/Desktop/django1"  #template:  "__Project__"
                                - pipenv shell
                                - django-admin startapp  hello
                            - アプリケーションにパッチを当てます:
                                __OldFolder__: ${HOME}/Desktop/CRUD_patch/app/back_up
                                __SourceFolder__: ${HOME}/Desktop/CRUD_patch/app/patch
                                __DestinationFolder__: ${HOME}/Desktop/django1/hello  #template:  __ProjectName__/
                        - django1/django1/django1/data.json を django1/django1/data.json に移動します
                pipenv を使わない場合:  #keyword: pip Git bash
                    仮想環境(Python)の作成:
                        #Git bash
                        - mkdir  "${HOME}/Desktop/django1"  #template:  "__Project__"
                        - cd     "${HOME}/Desktop/django1"  #template:  "__Project__"
                        - 以下は一度に実行できます: |
                            export PATH=$HOME/AppData/Local/Programs/Python/Python37/Scripts:$PATH
                                #template: $HOME/AppData/Local/Programs/Python/Python__PythonVer2__/Scripts
                            pip install virtualenv
                            virtualenv  "${HOME}/Desktop/django1/django1_env"  #// 仮想環境を新規作成
                                #template: "__Project__/__VirtualEnvName__"
                            ${HOME}/appdata/local/programs/python/python37/python.exe -m pip install --upgrade pip
                                #template: python__PythonVer2__
                    pip (Pip Installs Package) で Python パッケージを追加します:
                        #新しい Git bash
                        - 以下は一度に実行できます: |
                            cd  "${HOME}/Desktop/django1"  #template:  "__Project__"
                            source  django1_env/Scripts/activate  #template: __VirtualEnvName__/Scripts  #keyword: Python activate
                            pip install django==3.0.8  #template: __DjangoVersion__
                            pip install python-dateutil
                            pip install djangorestframework
                            pip install protobuf==3.12.4  #template: __ProtoBufVersion__
                        #Git bash を閉じる
                    プロジェクトを新規作成します:
                        #新しい Git bash
                        - cd  "${HOME}/Desktop/django1"  #template:  "__Project__"
                        - source  django1_env/Scripts/activate  #template: __VirtualEnvName__/Scripts
                        - django-admin startproject  django1  #// Create new project  #template: __ProjectName__
                    プロジェクトに CRUD のサンプルを追加します（スキップできます）:
                        #// 下記パッチは、MyDoc\programming\スクリプト\Python.files\django_CRUD_patch.zip にあります
                        #// パッチを当てる方法の例： snote >> git_merge を参照
                        - サイトにパッチを当てます:
                            old: ${HOME}/Desktop/CRUD_patch/site/back_up
                            src: ${HOME}/Desktop/CRUD_patch/site/patch
                            dst: ${HOME}/Desktop/django1/django1/django1  #template:  __ProjectName__/__ProjectName__/__ProjectName__
                        - hello アプリケーションを追加します:
                            - 新規作成します:
                                - cd  "${HOME}/Desktop/django1"  #template:  "__Project__"
                                - source  django1_env/Scripts/activate  #template: __VirtualEnvName__/Scripts
                                - cd  "django1"  #template:  "__ProjectName__"
                                - django-admin startapp  hello
                            - アプリケーションにパッチを当てます:
                                old: ${HOME}/Desktop/CRUD_patch/app/back_up
                                src: ${HOME}/Desktop/CRUD_patch/app/patch
                                dst: ${HOME}/Desktop/django1/django1/hello  #template:  __ProjectName__/__ProjectName__/
                データベースの作成（スキップできます）:
                    pipenv を使う場合:
                        #新しい Git bash
                        - cd  "${HOME}/Desktop/django1"  #template:  __ProjectName__
                        - pipenv shell
                    pipenv を使わない場合:
                        #新しい Git bash
                        - cd  "${HOME}/Desktop/django1/django1"  #template:  __ProjectName__/__ProjectName__
                        - source  ../django1_env/Scripts/activate  #template: __VirtualEnvName__/Scripts
                    スキーマを作成します:
                        #Git bash の続き
                        - python  manage.py  makemigrations  #// スクリプトを更新します （開発時のみ行えばよい）
                        - python  manage.py  migrate  #// DBを更新します （製品でも行います）
                    データベースのスーパーユーザーを作成します:
                        #Git bash の続き
                        - python  manage.py  shell
                        - Python のインタープリターの中:
                            - from  django.contrib.auth  import  get_user_model
                            - User = get_user_model()
                            - User.objects.create_superuser('admin', 'admin@example.com', 'password')
                                #template: '__AdminAccount__', 'admin@example.com', '__AdminPassword__'
                            - quit()
                    データベースの内容をロードします:
                        - code  ${HOME}/Desktop/django1/django1/django1/data.json: |    #template:  __ProjectName__/__ProjectName__/__ProjectName__
                            [
                                {
                                    "model":     "hello.friend",
                                    "pk":        1,
                                    "fields": {
                                        "name":      "Mario",
                                        "mail":      "mario@example.com",
                                        "gender":    false,
                                        "age":       26,
                                        "birthday":  "2001-09-13"
                                    }
                                },
                                {
                                    "model":     "hello.friend",
                                    "pk":        2,
                                    "fields": {
                                        "name":      "Peach",
                                        "mail":      "peach@example.com",
                                        "gender":    true,
                                        "age":       22,
                                        "birthday":  "2001-03-03"
                                    }
                                }
                            ]
                        #Git bash の続き
                        - python  manage.py  loaddata  django1/data.json  #template: __ProjectName__/data.json
                Web サーバーの起動:
                    manage.py が使えるシェルを起動します:
                        pipenv を使う場合: |
                            #新しい Git bash
                            cd  "${HOME}/Desktop/django1"  #template:  __ProjectName__
                            pipenv shell
                        pipenv を使わない場合: |
                            #新しい Git bash
                            cd  "${HOME}/Desktop/django1/django1"  #template:  __ProjectName__/__ProjectName__
                            source  ../django1_env/Scripts/activate  #template: __VirtualEnvName__/Scripts
                        以下は一度に実行できます:
                            #Git bash の続き
                            export DJANGO_SETTINGS_MODULE=django1.settings  #template: __ProjectName__.settings
                    DB のスキーマと同期をとる:
                        - （必要なら） python  manage.py  makemigrations  #// スクリプトを更新します （開発時のみ行えばよい）
                        - python  manage.py migrate
                    Web サーバーの起動:
                        - python manage.py runserver  #// Watching for file changes with StatReloader と表示されるまで待つ
                        - または python manage.py runserver 0.0.0.0:8011
                ブラウザーで hello アプリケーションを開く:
                    - http://localhost:8000/hello  #// hello アプリケーションを追加したとき
                    - http://localhost:8000/  #// hello アプリケーションを追加していない
                    - http://localhost:8011/hello  #// python manage.py runserver 0.0.0.0:8011 で起動したとき
                ブラウザーで Administration ページを開く:
                    URL: http://localhost:8000/admin
                    URL(2): http://localhost:8011/admin  #// python manage.py runserver 0.0.0.0:8011 で起動したとき
                    Username: admin  #template: __AdminAccount__
                    Password: password  #template: __AdminPassword__
                Web サーバーの終了:
                    python manage.py runserver を実行したシェルで Ctrl + C
            トラブルシューティング:
                - ケース:
                    コマンド: python ./manage.py  migrate 
                    エラー: |
                        sqlite3.OperationalError: unable to open database file
                    対処法:
                        データベースのファイルを作ろうとしているフォルダーを作ります:
                            データベースの設定を参照します: #keyword: Django DATABASES
                                shell:
                                    grep -rn DATABASES *
                                見つかった内容の例: |
                                    DATABASES = {
                                        'default': {
                                            'NAME': os.path.join(BASE_DIR, 'data', 'db.sqlite3'),
                                BASE_DIR の例:    #// BASE_DIR の定義は通常同じファイルの中にあります
                                    BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
                            フォルダーを作ります:
                                mkdir -p  "__Folder__"
        Flask: #keyword:
        FastAPI: #keyword:
            Web フレームワーク比較: #ref: https://twitter.com/tatsu_engineer1/status/1642382711708086272
        pyenv, poetry など:
            #search: pyenv
            #search: install poetry
            #search: Python venv tools
        pipenv:  #// pipenv を使った Python プロジェクト  #keyword: pipenv projects VSCode
            pipenv だけインストールします:
                Windows:
                    pip install pipenv
                Linux:
                    pip3 install pipenv
                mac:
                    pip3 install pipenv
                    pipenv --version
                pipenv 一般: #search: pipenv
            pipenv に対応した Python プロジェクトを新規作成します:  #keyword: Python VSCode pipenv
                （作成済みのプロジェクト）:
                    #search: try_pipenv
                Python と pipenv をインストールします:
                    #search: pipenv install
                Pipfile と仮想環境を新規作成します: #keyword: Pipfile
                    #PowerShell
                    - cd     "__Desktop__"  #// 例： C:\Users\__User__\Desktop
                    - mkdir  "__Project__"  #// 例： try_pipenv
                    - cd     "__Project__"
                    - ${env:PIPENV_VENV_IN_PROJECT} = 1  #// VSCode が認識するように、仮想環境 .venv をプロジェクトの直下に配置する設定にします
                    - pipenv --python 3  #// Pipfile と仮想環境が作られます。小数の指定も可能（例 --python 3.7）
                    - pipenv --venv   #// 仮想環境があるフォルダーを表示します
                    - pipenv install  #// Pipfile.lock ファイルができます
                    - code "."  #// VSCode で カレント フォルダー を開きます
                （必要なら）パッケージを追加します:
                    リリースに含める場合:
                        - pipenv install  __Package__  #// __Package__ の例: pillow
                    リリースに含めない場合:
                        - pipenv install --dev  __Package__  #// リリースに含めないパッケージを追加します
                    一覧にあるパッケージを追加する場合:
                        - pipenv install -r ./requirements.txt  #// requirements.txt は pip freeze の出力
                VSCode の Terminal を開いて、自動的に下記 source コマンドが実行されるまで、Terminal を再起動します:
                    source __Project__/.venv/Scripts/activate  または
                    & c:/Users/____/Desktop/try_pipenv/.venv/Scripts/Activate.ps1
                __Project__/hello.py: |  #// サンプル コード  #keyword: Python main
                    def main():
                        print('Hello, world!')

                    if __name__ == '__main__':
                        main()
                （必要なら） __Project__/rectangle.py: |  #// pillow を使った サンプル コード
                    from PIL import Image, ImageDraw
                    width, height = 120, 90

                    image = Image.new("RGB", (width, height), "#f9f980")
                    draw = ImageDraw.Draw(image)

                    draw.rectangle(
                        [(10, 10), (width - 10, height - 10)],
                        fill="#ddddff", outline="blue")
                    del  draw

                    image.save("rectangle.png")
                デバッグします:
                    launch.json ファイルを作ります:  #// __Project__/.vscode/launch.json
                        - Run アイコン（虫） >> create a launch.json file >> Python file
                        - 必要なら "program" の右をデバッグ開始する Python ファイルのパスに置き換えます。${file} は開いているファイルになります
                    ブレークポイントを張ります: .py ファイルの行番号の左をクリック
                    デバッグ開始:
                        #// 下記のどちらかを行います
                        - F5 キー
                        - Run アイコン（虫） >> Start Debugging ボタン（左上の緑色の三角）
            pipenv に対応した Python プロジェクトを新しい PC で使います: #keyword: install pipenv project  #// ${env:PIPENV_VENV_IN_PROJECT} = 1;  pipenv sync --dev
                （作成済みのプロジェクト）:  #search: try_pipenv
                Pipfile ファイルを含むプロジェクト フォルダーを任意の場所に配置します(以後、__Project__ で表現します):
                （初回のみ）:  #// PC で pipenv のプロジェクトを初めて動かす場合
                    設定: #settings:
                        __PythonVer2p__: 3.9  #// 下記手順で決定
                        __PythonVer2__: 39  #// 下記手順で決定
                    Visual Studio Code をインストールします:
                        - https://code.visualstudio.com/
                        - ダウンロードしたファイル（例：VSCodeUserSetup-x64-1.54.3.exe）を開きます
                        - インストール オプションはデフォルトを使用
                        - （推奨）VSCode (Visual Studio Code をタスクバーにピン止めします:
                        - （推奨）Ctrl + S キーを押したときに全てのファイルを保存するように設定します: |
                            File >> Preferences >> Keyboard Shortcuts >> save all （と入力） >>
                                File: Save All （をダブルクリック） >> Ctrl + S キー >> Enter キー
                        - 下記の拡張機能(Extensions)をインストールします:
                            - Python
                            - Copy Relative Path Posix  #// Copy Relative Path (POSIX) というメニューが追加されます
                        - VSCode の右下に下記をインストールするよう勧められたらインストールします:
                            - Linter pylint
                        - PowerShell を開き、スクリプトを実行できるようにします:  #// 一度もしたことがないときだけ行います
                            - Visual Studio Code >> Terminal  #// PowerShell が起動すること
                            - Set-ExecutionPolicy  RemoteSigned  -Scope CurrentUser  #// スクリプトを実行できるようになります
                    プロジェクトが使う Python のバージョンをメモします:
                        __Project__/Pipfile の中の python_version をメモします:
                            __PythonVer2p__: 3.9  #template: __PythonVer2p__
                            __PythonVer2__: 39  #// 3.9 なら 39  #template: __PythonVer2__
                    Visual Studio Code を閉じます:
                    Python と pipenv をインストールします:  #keyword: install Windows pipenv  #// pipenv は「ピップエンブ」と呼びます
                        使う Python のバージョンを Windows にインストールします:
                            最新版の場合:
                                https://www.python.org/ >> Python 3.9.0（など）
                                    #template: Python __PythonVer2p__.0
                            古いバージョンの場合:
                                https://www.python.org/ >> Downloads >> Windows >>「Python 3.7」などでページ内を検索 >>
                                Download Windows x86-64 executable installer （が表示されるまでバージョンを戻る）
                            ダウンロードしたファイルを開きます:
                                例：python-3.9.x-amd64.exe
                            インストール オプションはデフォルトを使用:
                                #template-at(-2): __PythonVer2p__
                        PowerShell を開きます:
                            #// 以下のどちらかを行います
                            - Windows キーを押してから、 PowerShell と入力し、PowerShell を起動します
                            - Visual Studio Code >> Terminal >> New Terminal
                        Python に Path を通します:
                            以下は一度に実行できます（Python39）: |
                                ${path} = [System.Environment]::GetEnvironmentVariable("Path", "User");
                                ${path} = "${HOME}\AppData\Local\Programs\Python\Python39\Scripts;${path}";  #template: \Python__PythonVer2__\
                                [System.Environment]::SetEnvironmentVariable("Path", ${path}, "User");

                                （以上）
                                #template-at(-6): Python__PythonVer2__
                                #template-at(-5): \Python__PythonVer2__\Scripts
                        pipenv 本体をインストールします: |
                            & "${HOME}\AppData\Local\Programs\Python\Python39\Scripts\pip" install pipenv

                                （以上）
                                #template-at(-3): \Python__PythonVer2__\Scripts
                                プロキシがある LAN にいるときは、pip に --proxy http://example.com:8080 のようなオプションを付けます 
                                環境変数 HTTP_PROXY を設定しても無視されます
                        PowerShell と Visual Studio Code を閉じます:
                    仮想環境を使うように設定します: #keyword: pipenv sync --dev
                        仮想環境を作り、Pipfile.lock に書かれたパッケージの本体を仮想環境に追加します:
                            - プロジェクトを開きます: #copy: open VSCode
                                Visual Studio Code を右クリック（Windows の タスク バー または mac の Dock）>>
                                New Window >> プロジェクト フォルダー を Visual Studio Code へドラッグ＆ドロップします
                            - Visual Studio Code >> Terminal  #// PowerShell が起動すること
                            - PowerShell in VSCode:
                                - ${env:PIPENV_VENV_IN_PROJECT} = 1  #// VSCode が認識するように、仮想環境 .venv をプロジェクトの直下に配置する設定にします
                                - プロキシがある LAN にいるとき:  #// 下記 example.com:8080 の部分は置き換えてください
                                    ${env:HTTP_PROXY}  = "http://example.com:8080"
                                    ${env:HTTPS_PROXY} = "http://example.com:8080"
                                - pipenv sync --dev
                            - 仮想環境のパスを設定します:  #// 以下のいずれか
                                - #search: VSCode Python Select Interpreter
                                - #search: PYTHONPATH
                （2回目以降）:
                    VSCode でプロジェクトを開きます:
                        code  __Project__
                    __Project__/.venv を作ります:
                        VSCode の Terminal を開きます:
                            pipenv sync --dev
                        VSCode の Terminal を閉じます:
                    VSCode の Terminal を開きます:
                        #// 開くと .venv が activate されます
                    起動します:
                        python  ____.py
                デバッグします: #// VSCode  #keyword: VSCode Python Debugger
                    デバッグする *.py ファイルを開きます:
                    launch.json ファイルを作ります:  #// __Project__/.vscode/launch.json
                        - Run アイコン（虫） >> create a launch.json file >> Python file
                        - 必要なら "program" の右をデバッグ開始する Python ファイルのパスに置き換えます。${file} は開いているファイルになります
                    .envrc ファイルがある場合、.envrc ファイルから環境変数を設定している部分だけ .env ファイルにコピーします:  #search: VSCode .env 環境変数
                    ブレークポイントを張ります: .py ファイルの行番号の左をクリック
                    デバッグ開始:
                        #// 下記のどちらかを行います
                        - F5 キー
                        - Run アイコン（虫） >> Start Debugging ボタン（左上の緑色の三角）
                    （ライブラリの中にブレークポイントを張る場合）:
                        __Project__/.vscode/launch.json: |
                            {
                                "configurations": [{
                                    "justMyCode": false,
                        #ref: https://code.visualstudio.com/docs/python/debugging#_justmycode
            pipenv に対応した Python プロジェクトを EC2 にデプロイします:
                下記「EC2, Python3, pipenv, Django, Apache, MySQL 環境を構築する」を参照  #search: EC2 Python3 pipenv
            現在使っている仮想環境を削除します:
                - cd __Project__
                - pipenv --rm
            Python のバージョンを変える（pipenv を使っている場合）:
                - Pipfile の中の python_version を変更します
                - cd __Project__
                - pipenv --rm
                - rm Pipfile.lock
                - pipenv install
            CentOS に pyenv と pipenv をインストールする場合: #keyword: CentOS pipenv
                参考: https://git-scm.com/
                pyenv 本体をインストールします:  #keyword: install pyenv,  ~/.pyenv
                    手動の場合:
                        - git --version に失敗したら、 sudo yum install git  #search: Linux CentOS7 Git
                        - git clone https://github.com/pyenv/pyenv.git ~/.pyenv  #keyword: .pyenv
                        - cat ~/.bashrc | grep PYENV_ROOT
                        - 上記コマンドを実行して何も表示されなかったら:
                            echo 'export PYENV_ROOT="$HOME/.pyenv"' >> ~/.bashrc
                            echo 'export PATH="$PYENV_ROOT/bin:$PATH"' >> ~/.bashrc
                            echo 'eval "$(pyenv init -)"' >> ~/.bashrc
                            source ~/.bashrc
                        - sudo yum -y install zlib-devel bzip2 bzip2-devel readline-devel sqlite3 sqlite-devel openssl-devel libffi-devel
                        #// まだ Python はインストールされていません。続く
                    自動の場合:  #ref: ${GitHub}/MyPrivateCode/ansible_vagrant/single_vm_ansible/GoCD/playbooks/python_pyenv.yml
                pyenv 環境に Python 3.7.1 をインストールします:  #keyword: install pyenv Python
                    手動の場合:
                        - pyenv install -v 3.7.1  #// 約3分
                        - pyenv versions
                        - pyenv global 3.7.1
                        - pyenv versions
                    自動の場合:  #ref: ${GitHub}/MyPrivateCode/ansible_vagrant/single_vm_ansible/GoCD/playbooks/python_pyenv.yml
                pipenv をインストールします:
                    - pip install pipenv
                    - pipenv --version
            （旧 pip版）Python の開発環境のシェルの起動、Python 仮想環境の復元:
                設定: #settings:
                    __Projects__: ${HOME}/Desktop/django1  #// 各自自由に設定できます
                    __VirtualEnvironment__: ${HOME}/Desktop/django1/django1_env  #// 各自自由に設定できます
                    __Project__: django1  #// Git リポジトリ名に合わせます
                    __PythonVersion2__: 39  #// 下記 requirements_python__PythonVersion2__.txt ファイルがあれば、それに合わせます
                Python の仮想環境をアクティブにする場合（シェルから Python スクリプトを実行できるようにする）:
                    #新しい Git bash
                    - source  ${HOME}/Desktop/django1/django1_env/Scripts/activate  #template: __VirtualEnvironment__/Scripts
                        #// ${HOME}/Desktop/django1/django1_env が存在しないときは、下記「仮想環境を復元する」を参照
                            #template: __VirtualEnvironment__
                    #// アクティブにする方法はもはや ベスト プラクティス ではない。 https://github.com/pypa/pipenv/issues/21
                Django の manage.py を使えるようにする場合:
                    #新しい Git bash
                    - source  ${HOME}/Desktop/django1/django1_env/Scripts/activate  #template: __VirtualEnvironment__/Scripts
                    - cd  "${HOME}/Desktop/django1/django1"  #template: "__Projects__/__Project__"
                        #// manage.py があるフォルダー
                    - settings_local.py ファイルがある場合:
                        - （必要なら）settings_local.py ファイルが存在するかどうかを調べる:
                            - find . | grep "settings_local.py"  #// settings_local.py の相対パスが表示されたら存在します
                        - export DJANGO_SETTINGS_MODULE=__SiteName__.settings_local  #// __SiteName__ は settings_local があるフォルダー
                    #// 以上で manage.py が使えます。以下はサンプル
                    - python manage.py runserver  #// http://localhost:8000 や http://localhost:8000/hello など
                pipenv で仮想環境を復元できるようにする場合:
                    #// 未確認
                pip で仮想環境を復元できるようにする場合（ただし、pip install などを使うたびに再実施が必要）:
                    - 参考: https://pip.pypa.io/en/stable/reference/pip_freeze/
                    - 仮想環境のフォルダーを調べて、 __VirtualEnvironment__ の値を設定します:
                    - 使っている Python のバージョンを調べて、 __PythonVersion2__ の値を設定します:
                        ${HOME}/Desktop/django1/django1_env/pyvenv.cfg ファイルの version_info を確認します  #template: __VirtualEnvironment__/pyvenv.cfg
                    - 上記「Python の仮想環境をアクティブにする」を実行します:
                    - pip freeze > "${HOME}/Desktop/django1/django1/requirements_python39.txt"
                        #template: "__Projects__/__Project__/requirements_python__PythonVersion2__.txt"
                        #// パッケージとバージョンの一覧が保存されます
                        #// 一般的には、requirements.txt というファイル名が付けられます。
                        #//（メモ）requirements_____.txt ファイルにコメントを書くこともできるようです
                        #//     https://pip.pypa.io/en/latest/reference/pip_install/#requirements-file-format
                    #// 以上で ${HOME}/Desktop/django1/django1_env を削除しても復元できます  #template: __VirtualEnvironment__
                pip で仮想環境を復元する場合:
                    各種ツールをインストールします:
                        Git for Windows をインストールします:
                            - https://git-scm.com/ >> Downloads >> Windows
                            - ダウンロードしたファイル（例：Git-2.24.1.2-64-bit.exe）を開く
                            - Next を8回押す
                            - Configuring the line ending conversions: Checkout as-is, commit as-is
                            - 他のインストール オプションはデフォルトを使用
                            - 使えるかテストします:
                                - デスクトップを右クリック >> Git Bash Here
                                - git clone  "https://github.com/githubtraining/hellogitworld.git"
                                - 成功したら、デスクトップにある hellogitworld フォルダーを削除する ( rm -rf hellogitworld )
                            - Git の更新ログ(git log)に記録されるユーザー名を設定します:
                                #// ダウンロード（クローン）するリポジトリにコミットする可能性があるとき
                                - git config --global user.email "you@example.com"
                                - git config --global user.name  "Your Name"
                        Python をインストールします:
                            - http://www.python.org/ >> Downloads >> Windows >> （例）3.9.1 >> Windows installer (64-bit)
                            - ダウンロードしたファイル（例：python-3.9.1-amd64.exe）を開きます
                            - インストール オプションはデフォルトを使用
                        （必要なら）Visual Studio Code をインストールします:
                            - https://code.visualstudio.com/
                            - ダウンロードしたファイル（例：VSCodeUserSetup-x64-1.50.1.exe）を開きます
                            - インストール オプションはデフォルトを使用
                            - （推奨）VSCode (Visual Studio Code をタスクバーにピン止めします:
                            - （推奨）Ctrl + S キーを押したときに全てのファイルを保存するように設定します: |
                                File >> Preferences >> Keyboard Shortcuts >> save all （と入力） >>
                                    File: Save All （をダブルクリック） >> Ctrl + S キー >> Enter キー
                            - 下記の拡張機能をインストールします:
                                - Python, Django(Baptiste Darthenay)
                            - VSCode の右下に下記をインストールするよう勧められたらインストールします（しなくてもよい）:
                                - Linter pylint
                                #// インストールするときに表示されるシェルは、インストール後にゴミ箱ボタンで閉じます
                    プロジェクト フォルダーを復元します:
                        git clone する場合:
                            - git clone https://github.com/__RepositoryGroup__/django1.git  #template: /__Project__.git
                        圧縮ファイル(*.tar.gz)を展開する場合:
                            - cd  "__ParentOfTarGzFile__"
                            - mkdir -p "${HOME}/Desktop/django1/django1"  #// ここに復元されます  #template: "__Projects__/__Project__"
                            - tar xvf   "django1.tar.gz"  --directory  "${HOME}/Desktop/django1/django1"
                                #template: "__Project__.tar.gz"  --directory  "__Projects__/__Project__"
                    仮想環境を復元します:
                        - #// "${HOME}/Desktop/django1/django1/requirements_python39.txt" #// があるものとします
                            #template: "__Projects__/__Project__/requirements_python__PythonVersion2__.txt"
                        - 新しい Git bash で:
                            - cd  "${HOME}/Desktop/django1"  #template:  "__Projects__"
                            - 以下は一度に実行できます: |
                                export PATH=$HOME/AppData/Local/Programs/Python/Python39/Scripts:$PATH
                                    #template: $HOME/AppData/Local/Programs/Python/Python__PythonVersion2__/Scripts
                                pip install virtualenv
                                virtualenv  "${HOME}/Desktop/django1/django1_env"  #// 仮想環境を新規作成
                                    #template: "__VirtualEnvironment__"
                            - Git bash を閉じます
                        - 新しい Git bash で:
                            - 以下は一度に実行できます: |
                                source  ${HOME}/Desktop/django1/django1_env/Scripts/activate  #template: __VirtualEnvironment__/Scripts
                                python.exe -m pip install --upgrade pip
                                pip install -r "${HOME}/Desktop/django1/django1/requirements_python39.txt"
                                    #template: "__Projects__/__Project__/requirements_python__PythonVersion2__.txt"
                            - Git bash を閉じます
                    以上で復元は完了です。続いて:
                        - 上記「Python の仮想環境をアクティブにする」、
                            または、上記「Django の manage.py を使えるようにする」
        Jupyter: #search: install Jupyter
        PyCharm: #keyword: install PyCharm
            Windows:  #// 未確認
                Toolbox をインストールします:
                    #search: install JetBrains Toolbox Windows
                PyCharm をインストールします:
                    Windows 通知領域 >> JetBrains Toolbox（赤い立方体アイコン）>>
                    （PyCharm Community Edition の）インストール
                PyCharm を開きます:
                    Windows 通知領域 >> JetBrains Toolbox（赤い立方体アイコン）>>
                    PyCharm Community Edition
                初期設定をします:
                    Do not import settings >> OK
                （必要なら）プロキシを PyCharm に設定します:
                    メニュー: PyCharm >> カスタマイズ（左）>> すべての設定（最後）>>
                        （外観＆振る舞い：左上）>> システム設定（3つ目）>> HTTP プロキシ（2つ目）>> 手動プロキシ構成
                    ホスト名: __ProxyServer__
                    ポート番号: __Port__
                    OK ボタン（下）:
        scikit-learn: #// Miniforge3 を使って scikit-learn をインストールします: #keyword: install Minforge scikit-learn
            参考:
                #ref: https://blog.amedama.jp/entry/apple-silicon-python-miniforge
                #ref: https://github.com/conda-forge/miniforge#download
            準備:
                ベース環境から Minforge の種類名を調べます:
                    Minforge3
                    #search: Minforge bases
                アーキテクチャー名を調べます:
                    arm64
                    #ref: https://github.com/conda-forge/miniforge#download
                ダウンロード スクリプト のファイル名を調べます:
                    Miniforge3-4.12.0-0-MacOSX-arm64.sh  #template_: __MinforgeType__-[__Version__-]__OS__-__Architecture__.sh
                    #ref: https://github.com/conda-forge/miniforge/releases
            Minforge をダウンロードします:
                新しい zsh:
                    script="Miniforge3-4.12.0-0-MacOSX-arm64.sh"
                    cd  ~/Downloads
                    curl -L -O "https://github.com/conda-forge/miniforge/releases/latest/download/${script}"
                    bash ${script}
                スクリプト実行中に入力する内容:
                    please review the license agreement: (Enter)
                    Do you accept the license terms?: yes
                    /Users/totadashi/miniforge3: (Enter)
                    Do you wish the installer to initialize Miniforge3 by running conda init? [yes|no]: yes
                デフォルトでは conda 環境をオフにします:
                    conda config --set auto_activate_base false
                    conda deactivate
                    #// シェルのプロンプトの行頭に (base) が無くなります
                conda 環境をオンにします:
                    conda activate
                    #// シェルのプロンプトの行頭に (base) が表示されます
            scikit-learn をインストールする場合:  #// scikit-learn = サイキット ラーン
                公式: #ref: https://scikit-learn.org/stable/
                参考: #ref: https://techacademy.jp/magazine/17375
                新しい zsh: |
                    conda install -y scikit-learn matplotlib
                    mkdir -p ~/scikit-learn
                    cd       ~/scikit-learn
                    code  digits.py
                ~/scikit-learn/digits.py : |
                    from sklearn import datasets, svm, metrics
                    import matplotlib.pyplot as plt

                    digits = datasets.load_digits()

                    print("画像のウィンドウが開いたら閉じてください")
                    plt.matshow(digits.images[0], cmap="Greys")
                    plt.show()

                    training_data  = digits.data[0::2]  #// 偶数要素
                    training_label = digits.target[0::2]  #// 偶数要素
                    test_data  = digits.data[1::2]  #// 奇数要素
                    test_label = digits.target[1::2]  #// 奇数要素

                    clf = svm.SVC(gamma=0.001)
                    clf.fit(training_data, training_label)
                    accuracy = clf.score(test_data, test_label)
                    print(f"\n正解率{accuracy}")

                    predicted = clf.predict(test_data)
                    print(metrics.classification_report(test_label, predicted))
                    print("""precision(適合率): 選択した正解/選択した集合
                    recall(再現率) : 選択した正解/全体の正解
                    F-score(F値) : 適合率と再現率はトレードオフの関係にあるため#""")
                実行:
                    conda activate
                    python digits.py
                    #// 画像のウィンドウが開いたら閉じてください
                出力: |
                    (base) MacBook-Air scikit-learn % python digits.py
                    画像のウィンドウが開いたら閉じてください

                    正解率0.9866369710467706
                                precision    recall  f1-score   support

                            0       1.00      0.99      0.99        88
                            1       0.98      1.00      0.99        89
                            2       1.00      1.00      1.00        91
                            3       1.00      0.98      0.99        93
                            4       0.99      1.00      0.99        88
                            5       0.98      0.97      0.97        91
                            6       0.99      1.00      0.99        90
                            7       0.99      1.00      0.99        91
                            8       0.97      0.97      0.97        86
                            9       0.98      0.97      0.97        91

                        accuracy                           0.99       898
                    macro avg          0.99      0.99      0.99       898
                    weighted avg       0.99      0.99      0.99       898
                説明:
                    precision(適合率): 選択した正解/選択した集合
                    recall(再現率) : 選択した正解/全体の正解
                    F-score(F値) : 適合率と再現率はトレードオフの関係にあるため
                プロジェクトを削除します:
                    cd ~
                    rm -rf ~/scikit-learn
            アンインストールします:
                rc ファイルを削除します:
                    conda init --reverse --dry-run
                    conda init --reverse
                Minforge をアンインストールします:
                    アンインストールするフォルダーを取得します:
                        CONDA_BASE_ENVIRONMENT=$(conda info --base)
                        echo The next command will delete all files in ${CONDA_BASE_ENVIRONMENT}
                    Minforge　のフォルダーとファイルを削除します:
                        rm -rf ${CONDA_BASE_ENVIRONMENT}
                        rm -f "${HOME}/.condarc"
        TreeView:
            Django プロジェクトに TreeView を追加する:
                #// Bootstrap を使った TreeView を組み込みます
                #// GitHub\Trials\try_Bootstrap_tree_jonmiles が必要です
                設定: #settings:
                    __ProjectName__: django1  #// サイト名を兼ねます
                    __Application__: hello  #// TreeView を使うときだけ必要
                CSS と JavaScript ファイルを static に配置します: |
                    #Git bash  下記は一度に実行できます
                    cd  "${HOME}/Desktop/django1"  #template:  /__ProjectName__"
                    export  src_="${HOME}/Desktop/try_Bootstrap_tree_jonmiles"
                    export  dst_="django1/hello/static/hello"  #template: "__ProjectName__/__Application__/static/__Application__"
                        export  file_="css/bootstrap.min"               &&  mkdir -p `dirname ${dst_}/${file_}` && cp -f  "${src_}/${file_}"  "${dst_}/${file_}"
                        export  file_="css/bootstrap-treeview.min.css"  &&  mkdir -p `dirname ${dst_}/${file_}` && cp -f  "${src_}/${file_}"  "${dst_}/${file_}"
                        export  file_="js/bootstrap-treeview.min.js"    &&  mkdir -p `dirname ${dst_}/${file_}` && cp -f  "${src_}/${file_}"  "${dst_}/${file_}"
                        export  file_="js/bootstrap.bundle.min.js"      &&  mkdir -p `dirname ${dst_}/${file_}` && cp -f  "${src_}/${file_}"  "${dst_}/${file_}"
                        export  file_="js/jquery-3.5.1.min.js"          &&  mkdir -p `dirname ${dst_}/${file_}` && cp -f  "${src_}/${file_}"  "${dst_}/${file_}"
                        export  file_="background.jpg"                  &&  mkdir -p `dirname ${dst_}/${file_}` && cp -f  "${src_}/${file_}"  "${dst_}/${file_}"
                    unset  src_  dst_  file_  folder_  src_file_  dst_file_
                Django template に TreeView を追加します:
                    編集対象: "django1/hello/templates/hello/index.html"  #template: "__ProjectName__/__Application__/templates/__Application__/index.html"
                    参照元: "${HOME}/Desktop/try_Bootstrap_tree_jonmiles/try_Bootstrap_tree_jonmiles.html"
        Django + MySQL docker:  #// Django + MySQL docker プロジェクトをローカルで実行する（既存のプロジェクト）
            設定: #settings:
                __HOME__: /c/Users/user1
                __Project__: /c/Users/user1/Desktop/project1
                __PythonVer3__: 3.8.6
                __PythonVer2__: 38  #// 3.8.2 なら 38
                __DjangoVersion__: 3.0.8
                __ProtoBufVersion__: 3.12.4
                __ProjectName__: project1
                __ApplicationName__: app1
                __VirtualEnv__: project1_env
                __DB_Name__: db1
                __DB_User__: db_user
                __DB_Password__: db_pass
            Python3.8.6, git bash, virtualenv, Docker for Windows をインストール:
                https://www.python.org/downloads/windows/ >> python-3.8.6-amd64.exe  #template: python-__PythonVer3__-amd64.exe
            Git clone でプロジェクトを入手:
                以下のファイルが別途必要です:
                    __Application__/settings_local.py
                    docker-compose.yml
                    docker/mysql
            仮想環境(Python)の作成:
                #Git bash
                - mkdir  "/c/Users/user1/Desktop/project1"  #template:  "__Project__"
                - cd  "/c/Users/user1/Desktop/project1"  #template:  "__Project__"
                - mkdir  project1_env  #template: __VirtualEnv__
                - cd     project1_env  #template: __VirtualEnv__
                - export PATH=/c/Users/user1/AppData/Local/Programs/Python/Python38/Scripts:$PATH
                    #template: __HOME__/AppData/Local/Programs/Python/Python__PythonVer2__/Scripts
                - pip install virtualenv
                - virtualenv  "/c/Users/user1/Desktop/project1/project1_env"  #// 仮想環境を新規作成
                    #template: "__Project__/__VirtualEnv__"
                - ${HOME}/appdata/local/programs/python/python38/python.exe -m pip install --upgrade pip
                    #template: python__PythonVer2__
            MySQL のインストール:
                Wheel を使用:
                    （初回のみ）MySQL Client の Wheel をダウンロード:
                        https://pypi.org/project/mysqlclient/#files
                            mysqlclient-2.0.1-cp38-cp38-win_amd64.whl
                                #template: cp__PythonVer2__-cp__PythonVer2__
                    （Python の仮想環境ごとに）pip:
                        pip install ${HOME}/Download/mysqlclient-2.0.1-cp38-cp38-win_amd64.whl
                            #template: cp__PythonVer2__-cp__PythonVer2__
                （成功していない）正式な方法:
                    Oracleプロファイル: Oracleプロファイル, 大ベルフル1
                    Visual C++ Build Tool のインストール:
                    MySQL C-API のインストール:
                        https://dev.mysql.com/downloads/c-api/ >> Windows Installer
                        mysql-installer-web-community-8.0.22.0.msi >> Client only >> Next
                        Connector/Python >> Next >> Yes >> (download) Execute >> Next >> (install) Execute >>
                        Next >> Finish >> 開いた Workbench とシェルを閉じます
                        Windows (x86, 64-bit), MSI Installer  https://dev.mysql.com/downloads/connector/cpp/
                    参考:
                        - pip install mysqlclient でハマった
                            https://qiita.com/HyunwookPark/items/5f60cc1fce2779d7b917
                        - Cコンパイラのインストール
                            https://www.python.jp/install/windows/install_vstools2017.html
            pip (Pip Installs Package):
                #新しい Git bash
                - cd  "__Project__"
                - source  project1_env/Scripts/activate  #template: __VirtualEnv__/Scripts
                - pip install django==3.0.8  #template: __DjangoVersion__
                - pip install mysqlclient
                - pip install python-dateutil
                - pip install djangorestframework
                - pip install protobuf==3.12.4  #template: __ProtoBufVersion__
                #Git bash を閉じる
            MySQL サーバーの起動:
                #新しい Git bash
                - cd  "__Project__"
                - source  project1_env/Scripts/activate  #template: __VirtualEnv__/Scripts
                - docker-compose up --build
            HTTP サーバーの起動:
                #新しい Git bash
                - cd  "__Project__"
                - source  project1_env/Scripts/activate  #template: __VirtualEnv__/Scripts
                - cd  "project1"  #template: "__ProjectName__"
                - export DJANGO_SETTINGS_MODULE=app1.settings_local  #template: __ApplicationName__.settings_local
                - python manage.py migrate
                - python manage.py runserver  #// Watching for file changes with StatReloader と表示されるまで待つ
            ブラウザーで開く場合:
                http://localhost:8000
            Django shell で Python のメソッドを実行する場合:  #keyword: Django shell,  python ./manage.py shell
                Django shell の起動: #keyword: start Django shell
                    #新しい Git bash
                    - cd  "__Project__"
                    - cd  "project1"  #template: "__ProjectName__"
                    - source  ../project1_env/Scripts/activate  #template: __VirtualEnv__/Scripts
                    - export DJANGO_SETTINGS_MODULE=app1.settings_local  #template: __ApplicationName__.settings_local
                    - python manage.py migrate  #// docker-compose.yml の設定のロードも行います
                    - python manage.py shell  #// Git bash 付属のターミナルの場合は、winpty python manage.py shell
                Python ファイル: #keyword: Django shell .py  #// Django shell で入力して実行する内容を、Python ファイルから実行します
                    コマンド:
                        cd  __DjandoProject__
                        echo  "print(123)"  >  ~/_in.py
                        echo  "print(456)"  >> ~/_in.py
                        python ./manage.py  shell  <  ~/_in.py
                        #// _in.py の最後に exit() が無くても python プロセスは自動的に終了します
                    出力:
                        123
                        456
                    #ref: https://stackoverflow.com/questions/16853649/how-to-execute-a-python-script-from-the-django-shell
                シェル スクリプト: #keyword: Django shell script,  Django shell .sh  #// Django shell で入力して実行する Python コードを、シェル スクリプト から実行します
                    サンプル:  #// print() は Python のコード です
                        echo  "print(123)"  |  poetry run ./manage.py shell
                Django shell の実行例:
                    #// 以下はすべて Django shell を開いてから  #search: start Django shell
                    キャッシュのクリア:  #search: Django cache clear
                        from django.core.cache import cache;  cache.clear()
                    ユーザーの追加:
                        入力例:
                            from accounts.models  import  User
                            User.objects.create_user('id', 'name', 'pass')
                        User.objects.create_user:
                            #ref: https://docs.djangoproject.com/en/3.1/topics/auth/default/
                #ref: https://python.keicode.com/django/django-manage-shell.php
            コードを変更した後で Django + MySQL docker プロジェクトをビルドする:
                - Django shell で Ctrl + Z, Ctrl + Z, Enter (で終了)
                - python manage.py runserver コマンドを実行したシェルで Ctrl + C
                - docker-compose up --build コマンドを実行したシェルで Ctrl + C
                - docker-compose up --build コマンドを再実行
                - python manage.py migrate コマンドを再実行
                - python manage.py runserver コマンドを再実行
                - Django shell を再起動
            mysql コマンドライン ツール(Docker 内 MySQLに入る):  #keyword: mysql shell in docker
                #新しい Git bash
                - cd  "__FolderHavingDockerComposeYML__"
                - docker ps -a  #// __ContainerName__ を調べる
                - winpty docker exec -it __ContainerName__  //bin/bash  #// winpty は Windows の Git bash の場合のみ必要
                - mysql  -p db1  --user "db_user" --password=db_pass
                    #template: mysql  -p __DB_Name__  --user "__DB_User__" --password=__DB_Password__
                #// 以下は終了するとき
                - quit;
                - exit
            データベースのスキーマを更新する:
                - cd  "__Project__"
                - cd  "project1"  #template: "__ProjectName__"
                - source  ../project1_env/Scripts/activate  #template: __VirtualEnv__/Scripts
                - export DJANGO_SETTINGS_MODULE=app1.settings_local  #template: __ApplicationName__.settings_local
                - python manage.py makemigrations
                - python manage.py migrate  #// docker-compose.yml の設定のロードも行います
                #// 更新したら Docker MySQL 起動時のスキーマを更新すること
            トラブルシューティング:
                - ケース:
                    コマンド: python manage.py loaddata
                    エラーメッセージ: |
                        KeyError: '__Key__'
                        LookupError: App '____' doesn't have a '____' model.
                        manage.py Problem installing fixture '____': Invalid model identifier: '____'
                    原因: __Key__ が見つかりません
                    対処: |
                        JSON の "model": "__Application__.__Model__" の __Model__ はクラス名にしてください。
                        テーブル名ではありません。例： クラス名＝ UserGroup、テーブル名 user_group なら UserGroup を指定します。
                    補足: __Key__ が外部キーのときは、loaddata に指定する JSON ファイルのキーの末尾に _id を付けないでください
                - ケース:
                    コマンド: Django サーバー（非ローカル）にアクセス
                    エラーメッセージ: |
                        django.urls.exceptions.NoReverseMatch: Reverse for '____' not found. '____' is not a valid view function or pattern name.
                    原因: urls.py の path(____, ____, name='__Name__') の __Name__ が重複しています
                - ケース:
                    コマンド: Django サーバー（非ローカル）にアクセス
                    エラーメッセージ: Internal Server Error
                    原因: 多岐に渡ります。そのため下記の対策では直らない可能性もあります
                    対処A: settings.py の DATABASES に指定したデータベースの種類を正しくします
                - ケース:
                    コマンド: Django サーバー（非ローカル）にアクセス
                    エラーメッセージ: Bad Request (400)
                    対処: settings.py >> Debug = True に設定すると原因が表示されます
                - ケース:
                    コマンド: Django サーバー（非ローカル）にアクセス
                    エラーメッセージ: because its MIME type ('text/html') is not a supported stylesheet MIME type, and strict MIME checking is enabled.
                    原因: MIME の問題ではなく、指定したパスにファイルが見つからないのが原因です
                    対処A: <link rel="stylesheet" type="text/css" href="{% static 'hello/css/style.css' %}"/>
                        のパスが正しいこと
                    対処B: Apache の .conf ファイルに /static/ に関する Alias と grant の設定があること
                    対処C: ローカルでサーバーを立ち上げるとき settings_local.py (settings.py) を DEBUG=True にします。
                        DEBUG=False にできない状況については、snote「静的ファイルをローカルでもサーバーでも使えるようにする設定」を検索。
                - ケース:
                    コマンド: Model オブジェクトの save() メソッド
                    エラーメッセージ: |
                        エラーThe database backend does not accept 0 as a value for AutoField.
                    対処:
                        save しようとしている Model の外部キーを設定してください
                - ケース:
                    コマンド: Model オブジェクトの save() メソッド
                    エラーメッセージ: |
                        エラー(1062, "Duplicate entry '____' for key '____'")
                    対処:
                        エラーメッセージにあるフィールドの値が他のレコードの値と重複しています。
                        もしくは、id フィールドの値が間違っているために更新しようとしているレコードと
                        別のレコードを更新しようとしています。
                - ケース: #keyword: Python 相互 import,  Python circular import
                    コマンド: Python のコンパイル時
                    エラーメッセージ: |
                        ImportError: cannot import name '__Class__' from partially initialized module '__Application__.__Folder__' (most likely due to a circular import) 
                    対処A:
                        from a.b import C を from a.b.c import C に修正する
                        from a.b import c as D
                    対処B:
                        メソッド(def)内で import する
                        #ref: https://qiita.com/puriketu99/items/a1347bf5200f095e486e
                    対処C:
                        循環 import
                        インポートの順番はエラーメッセージに表示されます。コールスタックに似た表示です。
                        __all__ = ( __Symbol__ ) にたどり着く前に循環するのでエラーになります。
                        （？）
                            __Parent__.py
                                from __Path__ import __FolderName__ as __Symbol__
                            __FolderName__/__init__.py
                                from .__RelativePath__ import *
                            があるため、import C の C より親の位置にある必要があります
                        B → C （import C を含む B) を新規に作ったとき
                            C/a → C/b の間に入ろうとすると、
                                C → B → C という循環になることがあります。
                            A → B → C → A という循環になることがあります。
                        #ref: https://stackoverflow.com/questions/59762996/how-to-fix-attributeerror-partially-initialized-module
                        #search: import 循環参照
                    対処D: #keyword: Python typing.TYPE_CHECKING mutual
                        型だけインポートする場合:
                            コード: |  #// 実行時は __Class__ = None を実行し、その型を参照するときは、文字列 '__Class__' で参照します
                                if typing.TYPE_CHECKING:
                                    import __Class__
                                else: #// Type information for runtime
                                    __Class__ = None
                        TYPE_CHECKING: mypy や PyCharm などの静的型チェッカーが解析する際にはTrueとして扱われます。
                        関連 >> TypeScript の場合:  #search: TypeScript import type 
                - ケース:
                    コマンド: python manage.py loaddata
                    エラーメッセージ: |
                        RuntimeWarning: DateTimeField User.created_at received a naive datetime (2020-12-14 10:20:39.070000) while time zone support is active.
                    対処:                        
                        JSON の datetime 型の値が naive のときにこの警告が表示されます。
                        とりあえず無視してもいいかもしれません。
                        #search: Python タイムゾーン naive aware
                - ケース:
                    コマンド: Django Web アプリの表示（HTTP の GET メソッド）
                    エラーメッセージ: |
                        Could not parse the remainder: '  __Parameter__' from '__Tag__  __Parameter__'
                    対処: |
                        {{ __Tag__  __Parameter__ }} と書いてあるときは、
                        {% __Tag__  __Parameter__ %} に変更します。
                - ケース:
                    コマンド: Django Web アプリの表示（HTTP の GET メソッド）
                    エラーメッセージ: |
                        Invalid field name(s) given in select_related: '__Field__'. Choices are: __Field___id
                    対処: |
                        ブラウザーに表示されたエラー画面の Traceback に表示された views.py に対応する HTML テンプレートを開き、
                        .objects.select_related('__Field__') を検索して __Field___id に変更します
                - ケース:
                    コマンド: Django Web アプリの表示（HTTP の GET メソッド）
                    エラーメッセージ: |
                        Reverse for '__SymbolName__' not found. '__SymbolName__' is not a valid view function or pattern name.
                    対処A: |
                        ブラウザーに表示されたエラー画面の Traceback に表示された views.py に対応する HTML テンプレートを開き、
                        __SymbolName__ を検索して、views.py の render に渡す辞書のキーに合わせてください
                    対処B: |
                        表示しようとしている HTML テンプレートの中の
                            {% url '__ApplicationName__:__SymbolName__' %}
                        の __SymbolName__ が urls.py の urlpatterns >> path >> name にある名前を設定してください。
                - ケース:
                    コマンド: Django Web アプリの表示（HTTP の GET メソッド）
                    エラーメッセージ: |
                        Reverse for '__PathName__' with no arguments not found. 1 pattern(s) tried: ['__Pattern__']
                    対処: |
                        表示しようとしている HTML テンプレートの中の
                            {% url '__ApplicationName__:__PathName__'  __PathParameter__ %}
                        に __PathParameter__ の記述がありません。
                        __PathName__ は urlpatterns >> path >> name。
                        __PathParameter__ の指定方法は、snote で {% url を検索してください。
                - ケース:
                    コマンド: python manage.py ...
                    エラーメッセージ: |
                        bash: /c/Users/__User__/AppData/Local/Microsoft/WindowsApps/python: Permission denied
                    対処:
                        source  ../__Appllication___env/Scripts/activate 
                    参考:
                        #search: Python Select interpreter
                - ケース:
                    コマンド: python manage.py migrate
                    エラーメッセージ: |
                        ModuleNotFoundError: No module named '____'
                    対処: settings_local.py の INSTALLED_APPS をチェック。settings.py との整合性をチェック
                - ケース:
                    コマンド: python manage.py migrate
                    エラーメッセージ: |
                        django.db.utils.OperationalError: (1045, "Access denied for user 'root'@'172.20.0.1' (using password: YES)")
                    対処:
                        - settings_local.py の DATABASES の USER で MySQL サーバーにログインしようとしているので、USER をチェック
                        - export DJANGO_SETTINGS_MODULE=app1.settings_local  #template: __ApplicationName__
                - ケース:
                    コマンド: python manage.py migrate
                    エラーメッセージ: |
                        django.template.library.InvalidTemplateLibrary: Invalid template library specified. 
                        ImportError raised when trying to load 'accounts.templatetags.paginate': 
                        No module named 'accounts'
                    対処:
                        __Application__/settings[_local].py の中にある accounts.templatetags.paginate が正しいことをチェック
                - ケース:
                    コマンド: python manage.py migrate
                    エラーメッセージ: |
                        lib\site-packages\django\template\utils.py", line 66, in __getitem__
                            return self._engines[alias]
                        KeyError: 'django'
                    対処:
                        根本原因のエラーではないようです。他に表示されたエラーメッセージを対処してください
                - ケース:
                    コマンド: python manage.py makemigrations
                    エラーメッセージ: |
                        You are trying to add a non-nullable field '__Field__' to __Table__ without a default
                        1) Provide a one-off default now (will be set on all existing rows with a null value for this column)
                        2) Quit, and let me add a default in models.py
                    対処:
                        テーブルのスキーマにフィールドを追加しようとしていて、既存のレコードに入れるべき値を聞かれています。
                        ただし、レコードが無くてもこのエラーは発生します。その場合 '' や 0 などを入れればよいでしょう。
                        1. は今ここで値を入力します
                        2. はmodel.py にデフォルト値を書くために makemigrations を中断します
                            例： models.IntegerField(default=0)
                    参考:
                        https://tech.pjin.jp/blog/2017/06/29/python-primer-26-django-12/
                - ケース:
                    症状:
                        - 継承（{% extends %}）があるテンプレートで {% block %} に書いた位置と違う位置に埋め込まれる
                        - <head> の前に記述した {% block %} が <head> の後に埋め込まれてしまう
                        - <link> が参照しているファイルの内容が埋め込まれてしまう
                    対処:
                        説明: |
                            {% block %} の中にある <link> の後に / があれば、/ を削除します
                        修正前: |
                            <link ...>/
                            <link ...>
                        修正後: |
                            <link ...>
                            <link ...>
                - ケース:
                    症状:
                        python3 manage.py migrate で、外部キーに切り替えるとき
                    エラーメッセージ: |
                        django.db.utils.OperationalError: (1054, "Unknown column 'employee' in 'accounts_order_info'")
                    対処:
                        mysql コマンドラインで外部キーに切り替え、manage.py migrate は --fake します
        EC2, Python3, pipenv, Django, Apache, MySQL 環境を構築する:  #keyword: EC2 Python3 pipenv
            #// 注意 MySQL との接続は未確認
            #// pipenv はありなしを選べます
            設定: #settings:
                __SiteName__: django1
                __EC2_PublicIPAddress__: 13.114.60.187
                __EC2_KeyPairFile__: ${HOME}\Downloads\EC2-YYYYMMDD.pem
                __MySQL_RootPassword__: Pass55!!
                __PythonVersion2p__: 3.7  #// 手順内でメモする値
            aws EC2 に初期状態の Django サーバーを構築します:
                参考:
                    https://tsukasa-blog.com/programming/django-ec2-apache/
                EC2 インスタンスを作成し SSH 接続でログインします:
                    参考:
                        - snote >> AWS マネジメント コンソールへサインイン
                        - snote >> EC2サーバーを作成する
                    __EC2_PublicIPAddress__ を確認します:
                    __EC2_KeyPairFile__ を確認します:
                    ログイン コマンド: ssh  ec2-user@13.114.60.187  -i "${HOME}\Downloads\EC2-YYYYMMDD.pem"
                        #template: ssh  ec2-user@__EC2_PublicIPAddress__  -i "__EC2_KeyPairFile__"
                Apache をインストールして起動します:
                    Apache をインストールします:
                        #EC2 SSH
                        - sudo yum update -y
                        - sudo yum install -y httpd httpd-devel  #// Apache のインストール
                        - httpd -v  #// Apache のバージョンを表示
                        - sudo service httpd start  #// Apache を起動します
                    EC2 のポート 80（HTTPサーバー）を開きます:
                        参考: snote >> インバウンドで開くポートの追加(aws)
                    Apache によるホームページが開けるか確認します:
                        - ブラウザーに EC2 のパブリック IPv4 アドレス（13.114.60.187）を入力します  #template: __EC2_PublicIPAddress__
                    （参考）Apache の設定ファイルの場所:
                        /etc/httpd/conf/httpd.conf とその中にある Include と IncludeOptional #// HTML の置き場所はここに書いてあります
                MySQL をインストールして起動します:
                    MySQL をインストールします:
                        #EC2 SSH
                        - sudo yum install -y https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm
                        - sudo yum install --enablerepo=mysql80-community mysql-community-server -y
                        - mysql --version  #// mysql  Ver 8.0.23 for Linux on x86_64 (MySQL Community Server - GPL)
                    MySQL を起動します:
                        - sudo systemctl start mysqld.service
                        - systemctl status mysqld.service  #// 起動してるか確認 active (running) なら OK
                    サーバー起動時にMySQL自動起動するように設定します:
                        - sudo systemctl enable mysqld.service
                    MySQL の root ユーザーの仮パスワードを確認します:
                        - sudo cat /var/log/mysqld.log | grep password  #// すぐ下で入力するのでメモは不要です
                    安全な設定をします:
                        #EC2 SSH
                        - mysql_secure_installation:  #// 最後の : は入力不要
                            Enter password for user root: ____  #// 上記で確認した仮パスワード
                            New password: Pass55!!  #template: __MySQL_RootPassword__
                            Change the password for root ?: y
                            New password(2): Pass55!!  #template: __MySQL_RootPassword__
                            Do you wish to continue with the password provided?: y
                            Remove anonymous users?: y
                            Disallow root login remotely?: y
                            Remove test database and access to it?: y
                            Reload privilege tables now?: y
                Python3 をインストールします:
                    Python3 本体をインストールします:
                        #EC2 SSH
                        - sudo yum install -y httpd-devel python3-devel gcc gcc-c++
                        - sudo yum install -y python3
                        - python3 --version  #// 3.7.9
                        - __PythonVersion2p__ の値をメモします（例：3.7）
                pip3 環境の場合（pipenvを使わない場合）:
                    pip3 環境の Django プロジェクトを新規作成する:
                        - sudo pip3 install  "django"
                        - python3:   #// 最後の : は入力不要
                            - import django
                            - django.get_version()  #// 3.1.6  #// バージョンを表示します
                            - exit()
                        - sudo pip3 install  "mod_wsgi"  #keyword: mod_wsgi
                        - django-admin startproject  "django1"  #template: "__SiteName__"
                        - cd  "django1"       #template: "__SiteName__"
                        - sudo chmod 755 $HOME  #// Apache がアクセスできるようにするため
                        - nano  "django1/settings.py" : |  #template: __SiteName__/settings.py
                            :
                            ALLOWED_HOSTS = ['13.114.60.187']  #template: '__EC2_PublicIPAddress__'
                            :
                            DATABASES = {
                                'default': {
                                    'ENGINE': 'django.db.backends.mysql',
                                    'NAME': 'test',
                                    'USER': 'root',
                                    'PASSWORD': 'Pass55!!',  #template: __MySQL_RootPassword__
                                    'HOST': 'localhost',
                                    'PORT': '3306',
                                }
                            }
                            :
                            STATIC_URL = '/static/'
                            STATIC_ROOT = os.path.join(BASE_DIR, 'static')
                            :
                        #// settings.py の補足
                            #// ALLOWED_HOSTS = ['*'] もできます
                    mysqlclientをインストールします:  #// Djangoプロジェクトでmysqlを扱うため
                        - cd  "django1"  #// プロジェクトの外のときのみ実行  #template: "__SiteName__"
                        - sudo yum install -y mysql-devel
                        - sudo pip3 install  "mysqlclient"
                    Apache と Django サーバーを接続します:
                        下記のテンプレートをコピーして一部を置き換え /etc/httpd/conf.d/django1.conf に保存します:  #template: __SiteName__.conf
                            テンプレート: |
                                LoadModule wsgi_module __WSGI_SO__

                                ServerName __EC2_PublicIPAddress__

                                WSGIScriptAlias / /var/www/__SiteName__/__SiteName__/wsgi.py
                                WSGIPythonPath /var/www/__SiteName__:__Python3Path__:__SitePackages__:__SitePackages64__

                                <Directory /var/www/__SiteName__/__SiteName__>
                                <Files wsgi.py>
                                Require all granted
                                </Files>
                                </Directory>
                            置き換える部分:
                                __WSGI_SO__: find /usr/local/lib64/python3.7/site-packages | grep mod_wsgi-py  #// mod_wsgi のパスを表示します  #template: __PythonVersion2p__/
                                    #// 例： /usr/local/lib64/python3.7/site-packages/mod_wsgi/server/mod_wsgi-py37.cpython-37m-x86_64-linux-gnu.so
                                __EC2_PublicIPAddress__: 13.114.60.187  #template: __EC2_PublicIPAddress__
                                __SiteName__: django1  #template: __SiteName__
                                __SitePackages64__: /usr/local/lib64/python3.7/site-packages  #// site-packages のパスを表示します  #template: __PythonVersion2p__/
                                __SitePackages__: /usr/local/lib/python3.7/site-packages  #template: __PythonVersion2p__/
                                __Python3Path__: /usr/bin/python3
                            django1.conf を開いて編集して保存します:  #template: __SiteName__.conf
                                sudo nano /etc/httpd/conf.d/django1.conf  #template: __SiteName__.conf
                                    #// 開いたエディターに貼り付けます。Ctrl+X でエディターを閉じます
                    Django プロジェクトの内容を Django サーバーが参照するフォルダーに展開します:
                        #Git bash SSH の続き
                        - sudo mkdir -p  "/var/www/django1"  #template: /__SiteName__"
                        - sudo rm -rf "/var/www/django1"/*  #template: /__SiteName__"
                        - sudo cp -rapT  "$HOME/django1/"  "/var/www/django1"  #template: "$HOME/__SiteName__/"  "/var/www/__SiteName__"
                        - （必要なら）DEBUG = False に設定します:
                            - nano /var/www/try_django/try_django/settings.py :
                                DEBUG = False
                            #// False に設定すると Django プロジェクトのデフォルトの初期画面は表示されません
                pipenv 環境の場合:
                    pipenv 環境の Django プロジェクトを新規作成する:
                        #EC2 SSH
                        - sudo pip3 install pipenv
                        - mkdir  "django1"  #template: "__SiteName__"
                        - cd     "django1"  #template: "__SiteName__"
                        - pipenv --python 3
                        - pipenv install  "django"
                        - pipenv shell  #// 次の行からプロンプトの行頭に (django1) が付きます  #template: (__SiteName__)
                        - python3:   #// 最後の : は入力不要
                            - import django
                            - django.get_version()  #// 3.1.6  #// バージョンを表示します
                            - exit()
                        - pipenv install  "mod_wsgi"
                        - 未確認:
                            - django-admin startproject  "django1"  "."  #template: "__SiteName__"
                        - 古い方法？:
                            - cd ..
                            - mv  "django1"  "django1_0"         #template: "__SiteName__"  "__SiteName___0"
                            - django-admin startproject  "django1"  #template: "__SiteName__"
                            - mv  "django1_0"/*  "django1"       #template: "__SiteName___0"/*  "__SiteName__"
                            - rm -r  "django1_0"  #template: "__SiteName___0"
                            - cd  "django1"       #template: "__SiteName__"
                        - sudo chmod 755 $HOME  #// Apache がアクセスできるようにするため
                        - nano  "django1/settings.py" : |  #template: __SiteName__/settings.py
                            :
                            ALLOWED_HOSTS = ['13.114.60.187']  #template: '__EC2_PublicIPAddress__'
                            :
                            DATABASES = {
                                'default': {
                                    'ENGINE': 'django.db.backends.mysql',
                                    'NAME': 'test',
                                    'USER': 'root',
                                    'PASSWORD': 'Pass55!!',  #template: __MySQL_RootPassword__
                                    'HOST': 'localhost',
                                    'PORT': '3306',
                                }
                            }
                            :
                            STATIC_URL = '/static/'
                            STATIC_ROOT = os.path.join(BASE_DIR, 'static')
                            :
                        #// settings.py の補足
                            #// ALLOWED_HOSTS = ['*'] もできます
                            #// HOST, PORT は要らないかも
                    mysqlclientをインストールします:  #// Djangoプロジェクトでmysqlを扱うため
                        - cd  "django1"  #// プロジェクトの外のときのみ実行  #template: "__SiteName__"
                        - sudo yum install -y mysql-devel
                        - pipenv install  "mysqlclient"
                    Apache と Django サーバーを接続します:
                        プロンプトの行頭に (django1) が付いていないとき:  #template: (__SiteName__)
                            - pipenv shell
                        下記のテンプレートをコピーして一部を置き換え /etc/httpd/conf.d/django1.conf に保存します:  #template: __SiteName__.conf
                            テンプレート: |
                                LoadModule wsgi_module __WSGI_SO__

                                ServerName __EC2_PublicIPAddress__

                                WSGIScriptAlias / __Home__/__SiteName__/__SiteName__/wsgi.py
                                WSGIPythonPath __Home__/__SiteName__:__Python3Path__:__SitePackages__:__SitePackages64__
                                ErrorLog  "__Log__/error_log"
                                CustomLog "__Log__/access_log" combined

                                <Directory __Home__/__SiteName__/__SiteName__>
                                <Files wsgi.py>
                                Require all granted
                                </Files>
                                </Directory>
                            置き換える部分:
                                __WSGI_SO__: find ${HOME} | grep mod_wsgi-py  #// mod_wsgi のパスを表示します
                                    #// 例： /home/ec2-user/.local/share/virtualenvs/try_django-M90dKb7R/lib64/python3.7/site-packages/mod_wsgi/server/mod_wsgi-py37.cpython-37m-x86_64-linux-gnu.so
                                __EC2_PublicIPAddress__: 13.114.60.187  #template: __EC2_PublicIPAddress__
                                __Home__: #// ${HOME} の値
                                __SiteName__: django1  #template: __SiteName__
                                __SitePackages64__: find ${HOME} | grep site-packages$  #// site-packages のパスを表示します
                                    #// 例： /home/ec2-user/.local/share/virtualenvs/try_django-M90dKb7R/lib64/python3.7/site-packages
                                __SitePackages__: find ${HOME} | grep site-packages$  #// site-packages のパスを表示します
                                    #// 例： /home/ec2-user/.local/share/virtualenvs/try_django-M90dKb7R/lib/python3.7/site-packages
                                __Python3Path__: which python3  #// Phthon3 のパスを表示します。 ~ は HOME 環境変数の値に置き換えること
                                    #// 例： /home/ec2-user/.local/share/virtualenvs/try_django-M90dKb7R/bin/python3
                                __Log__:  #// ログ ファイルを入れるフォルダーのパス。例：/home/ec2-user/django1_log  #template: __SiteName___log
                            django1.conf を開いて編集して保存します:  #template: __SiteName__.conf
                                sudo nano /etc/httpd/conf.d/django1.conf  #template: __SiteName__.conf
                                    #// 開いたエディターに貼り付けます。Ctrl+X でエディターを閉じます
                        ログ ファイルを入れるフォルダーを作ります:
                            - mkdir -p  "/home/ec2-user/django1_log"  #// 上記 __Log__  #template: __SiteName___log
                HTTP サーバーを再起動して設定を有効にします:
                    - sudo service httpd restart
                Django の初期状態のホームページを確認します:
                    ブラウザーのアドレスバーに入力: 13.114.60.187  #template: __EC2_PublicIPAddress__
            EC2を再起動する:
                #// 上記の設定では自動的に Web サーバーは起動しません。
                EC2 を再起動してから 50秒待ちます:
                ログイン コマンド:
                    #Git bash または PowerShell
                    ssh  ec2-user@13.114.60.187  -i "${HOME}\Downloads\EC2-YYYYMMDD.pem"
                        #template: ssh  ec2-user@__EC2_PublicIPAddress__  -i "__EC2_KeyPairFile__"
                Web サーバーを起動します:
                    #Git bash または PowerShell の続き
                    sudo service httpd start
                    #// すぐにアクセスできるようになります
            Django プロジェクトをデプロイします（pipenv 環境のプロジェクトと pipenv なしサーバーの場合）:
                参考: snote >> 静的ファイルをローカルでもサーバーでも使えるようにする設定
                .zip ファイルを作成します:
                    Windows で圧縮フォルダーを作る場合:
                        manage.py があるフォルダーを開きます:
                        すべてのファイルとフォルダーを選択します:
                        メニュー: 右クリック >> 送る >> 圧縮(zip形式)フォルダー
                        .zip ファイルを親フォルダーへ移動:
                    Git のワークの場合: |
                        cd  "django1"  #template: "__SiteName__"
                        git archive develop "." -o "../django1.zip"  #template: __SiteName__.zip
                .zip ファイルを EC2 サーバーにアップロードします:
                    PowerShell (または Visual Studio Code >> Terminal ): |
                        cd  "django1"  #template: "__SiteName__"
                        scp -i "${HOME}\Downloads\EC2-YYYYMMDD.pem"  "../django1.zip"  ec2-user@13.114.60.187:/home/ec2-user/
                            #template: scp -i "__EC2_KeyPairFile__"  "../__SiteName__.zip"  ec2-user@__EC2_PublicIPAddress__:/home/ec2-user/
                ログイン コマンド:
                    #PowerShell の続き
                    ssh  ec2-user@13.114.60.187  -i "${HOME}\Downloads\EC2-YYYYMMDD.pem"
                        #template: ssh  ec2-user@__EC2_PublicIPAddress__  -i "__EC2_KeyPairFile__"
                現在の Django サーバーの内容をバックアップします:
                    #SSH の続き
                    - pushd  "/var/www/django1"  #template: /__SiteName__"
                    - rm -f  "$HOME/www_before.zip"
                    - zip -r  "$HOME/www_before" "."
                    - popd
                    - （.zip ファイルをサーバーからローカルへ取り出すとき）:
                        #新しい PowerShell または Git bash
                        - cd  "django1"  #template: "__SiteName__"
                        - scp -i "${HOME}\Downloads\EC2-YYYYMMDD.pem"  "ec2-user@13.114.60.187:/home/ec2-user/www_before.zip"  ".."
                            #template: scp -i "__EC2_KeyPairFile__"  "ec2-user@__EC2_PublicIPAddress__:/
                zip ファイルの内容を Django サーバーが参照するフォルダーに展開します:
                    #SSH の続き
                    - sudo rm -rf "/var/www/django1"  #template: /__SiteName__"
                    - sudo unzip  "$HOME/django1.zip"  -d "/var/www/django1"
                        #template: "$HOME/__SiteName__.zip"  -d "/var/www/__SiteName__"
                （プロジェクトの直下の static フォルダー以外にも static フォルダーがあるとき）:
                    #// settings.py の STATIC_ROOT の値の static フォルダーにファイルやフォルダ―をコピーします
                    #SSH の続き
                    - pushd  "/var/www/django1"  #template: /__SiteName__"
                    - sudo python3 manage.py collectstatic
                    - popd
                （__SiteName__を変える場合）Apache と Django サーバーの接続を修正します:
                    /etc/httpd/conf.d/django1.conf をバックアップします:  #template: __SiteName__.conf
                        #SSH の続き
                        sudo mv /etc/httpd/conf.d/django1.conf  "${HOME}"  #template: __SiteName__.conf
                    下記のテンプレートをコピーして一部を置き換え /etc/httpd/conf.d/django1.conf に保存します:  #template: __SiteName__.conf
                        テンプレート: |
                            LoadModule wsgi_module __WSGI_SO__

                            ServerName __EC2_PublicIPAddress__

                            WSGIScriptAlias / /var/www/__SiteName__/__SiteName__/wsgi.py
                            WSGIPythonPath /var/www/__SiteName__:__Python3Path__:__SitePackages__:__SitePackages64__

                            <Directory /var/www/__SiteName__/__SiteName__>
                            <Files wsgi.py>
                            Require all granted
                            </Files>
                            </Directory>

                            Alias /static/ /var/www/__SiteName__/static/

                            <Directory /var/www/__SiteName__/static>
                            Require all granted
                            </Directory>
                        置き換える部分:
                            __WSGI_SO__: find /usr/local/lib64/python3.7/site-packages | grep mod_wsgi-py  #// mod_wsgi のパスを表示します  #template: __PythonVersion2p__/
                                #// 例： /usr/local/lib64/python3.7/site-packages/mod_wsgi/server/mod_wsgi-py37.cpython-37m-x86_64-linux-gnu.so
                            __EC2_PublicIPAddress__: 13.114.60.187  #template: __EC2_PublicIPAddress__
                            __SiteName__: django1  #template: __SiteName__
                            __SitePackages64__: /usr/local/lib64/python3.7/site-packages  #// site-packages のパスを表示します  #template: __PythonVersion2p__/
                            __SitePackages__: /usr/local/lib/python3.7/site-packages  #template: __PythonVersion2p__/
                            __Python3Path__: /usr/bin/python3
                        django1.conf を開いて編集して保存します:  #template: __SiteName__.conf
                            sudo nano /etc/httpd/conf.d/django1.conf  #template: __SiteName__.conf
                                #// 開いたエディターに貼り付けます。Ctrl+X でエディターを閉じます
                （開発環境で使ったDB（データベース）が MySQL ではなかった場合）:
                    MySQL を使うように変更します:
                        sudo nano  "/var/www/django1/django1/settings.py" : |  #template: /__SiteName__/__SiteName__/
                            :
                            ALLOWED_HOSTS = ['13.114.60.187']  #template: '__EC2_PublicIPAddress__'
                            :
                            DATABASES = {
                                'default': {
                                    'ENGINE': 'django.db.backends.mysql',
                                    'NAME': 'test',
                                    'USER': 'root',
                                    'PASSWORD': 'Pass55!!',  #template: __MySQL_RootPassword__
                                }
                            }
                            :
                            STATIC_URL = '/static/'
                            STATIC_ROOT = os.path.join(BASE_DIR, 'static')
                            :
                        #// settings.py の補足
                            #// ALLOWED_HOSTS = ['*'] もできます
                    DB を作成します:
                        #SSH の続き
                        - mysql  --user "root"  --password
                        - Pass55!!  #template: __MySQL_RootPassword__
                        - create database  test;
                            #// /var/www/django1/django1/settings.py に設定した名前と合わせます
                （migrations フォルダーにファイルが追加されていたら）MySQL のスキーマを更新します:
                    #SSH の続き
                    - pushd  "/var/www/django1"  #template: /__SiteName__"
                    - sudo python3 manage.py showmigrations
                    - sudo python3 manage.py migrate
                    - popd
                （Pipfile が更新されていたら）開発環境で使っている Python パッケージを Django サーバーに追加します:
                    #// 不足していると、どの Web ページでも（Python の import 文で） Server Error になります
                    開発環境で使っている Python パッケージを一覧します:
                        新しい Git bash または PowerShell: |
                            cd  "django1"  #// Pipfile があるフォルダー  #template: "__SiteName__"
                            pipenv lock -r  #// pipenv 版 pip3 freeze
                    現在のサーバーに入っている Python パッケージを一覧します:
                        SSH の続き: |
                            sudo pip3 freeze > "$HOME/requirement_before.txt"
                    Python パッケージを開発環境に合わせます:  #// 開発環境で使っていない Pyhton パッケージはそのまま存在させます
                        SSH の続き: |
                            nano  "$HOME/django1.txt"  #template: /__SiteName__.txt
                                #// 内容は、開発環境で使っている Python パッケージの一覧（pipenv lock -r の出力）にします
                            sudo pip3 install -r  "$HOME/django1.txt"  #template: /__SiteName__.txt
                Django サーバーを再起動します:
                    #SSH の続き
                    - sudo systemctl restart httpd
                Django サーバーの動作確認をします:
                    - http://13.114.60.187  #template: __EC2_PublicIPAddress__
                    - Ctrl + F5 を押します  #// スーパーリロードします
                戻すとき:
                    - バックアップ "$HOME/www_before.zip" を戻します
                    - MySQL のスキーマを戻します python3 manage.py migrate  __Schema__  __TargetMigrationNumber__
                    - Python パッケージのバージョンを pip3 install -r で戻します
        コマンドをインストールします:  #// Python モジュールで提供される実行ファイルをインストールします
            ~/bin/pipenv に Python プロジェクトを作ります:
                上記「pipenv に対応した Python プロジェクトを新規作成する」
            cd  ~/bin/pipenv :
            pipenv install ____ :
            echo "$(pipenv --venv)/bin/__Command__ \"\$@\"" > ~/bin/__Command__ :
            chmod +x ~/bin/__Command__ :
    バージョン番号: #keyword: Python version
        使えるバージョン番号:  #ref: https://www.python.org/downloads/  >> Release Schedules
            期限:  #ref: https://devguide.python.org/versions/
        シェル:
            python --version
        sys.version_info: |  #// 実行する／している Python のバージョン番号
                import sys
                print(sys.version_info)  #// 3.10.1
            #ref: https://stackoverflow.com/questions/30320265/find-out-python-version-from-source-code-or-heroku
        platform.python_version(): |
            import platform
            platform.python_version()  #// 2.7.8
        VSCode:
            右下または左下に表示
        バージョン番号の処理:  #search: Python semantic versioning
    デバッグ実行:  #keyword: Python debug
        pdb.set_trace:  #// シェルから Python を起動する環境なら SSH でも使えます。要ソース ファイル  #keyword: pdb.set_trace()
            スニペット: import  pdb;  pdb.set_trace()
            #snote: %programming%\スクリプト\Python.svg#pdb_set_trace
            コードの途中にブレークする場合:
                ブレークしたいところに pdb.set_trace を呼び出すコードを書きます:
                    ### debug
                        import  pdb;  pdb.set_trace()
                    ###
                Python や pytest などを実行します:
                    pdb.set_trace() が呼び出されると、(Pdb) プロンプトが表示されます
            コードの最初でブレークする場合:
                -m pdb オプションを付けて起動します: #keyword: Python -m pdb  #// コードの変更は不要です
                    python  -m pdb  example.py
            PDB の主なコマンド:
                p: #// 変数の値を表示します
                    p __VariableName__
                    p vars(__Object__)  #// Visual Studio Code ではもっと詳細に表示できます
                w: #// コール スタック を表示します
                c: #// 実行を再開します
                n: #// ステップ オーバー
                s: #// ステップ イン
            エラー発生でブレーク:
                -   Traceback で表示された場所のコードに、エラーの条件になったら
                    import  pdb;  pdb.set_trace() を呼び出すコードを追加します。
                -   Python を起動するコマンドや設定をデバッグ用に変更する必要はありません
            print:  #keyword: Python debug print,  py print
                注意:
                    環境によっては print では出力されません。logging.getLogger した logger.warn などに変えてください。  #search: Django logger
                コード:
                    import json
                    watch = json.dumps(public_dict(result), indent=4, sort_keys=True)
                    print(watch)
                public_dict: #keyword:
                    コード:  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/dict/public_dict/dict.py#public_dict
                    循環参照する場合:
                        public_dict から public_dict_debug を呼び出すコードのコメントアウトを外します
        Visual Studio Code デバッガー:
            プロジェクト内:  #search: install Python VSCode debug
            pipenv を使うプロジェクト内:  #search: install Python unittest VSCode
            Poetry を使うプロジェクト内:  #search: Poetry VSCode
            pytest を使うプロジェクト内:  #search: VSCode debug pytest
            .py ファイル:  #// 単独の .py ファイルをデバッガーに接続して実行します  #keyword: .py file debugger
                ~/_tmp.py: |
                    print('Hello, world')
                Visual Studio Code で任意のフォルダーを開きます:
                __Project__/.vscode/launch.json : |
                    {
                        "version": "0.2.0",
                        "configurations": [
                            {
                                "name": "Python: tmp.py debug",
                                "type": "debugpy",
                                "request": "launch",
                                "console": "integratedTerminal",
                                "cwd": "${workspaceFolder}",
                                "program": "~/_tmp.py",
                                "args": []
                            }
                        ]
                    }
                F5 キーを押します:
            debugpy:  #keyword: debugpy,  VSCode remote network debugger
                公式:
                    GitHub: #ref: https://github.com/microsoft/debugpy
                    VSCode: #ref: https://code.visualstudio.com/docs/python/debugging#_debugging-by-attaching-over-a-network-connection
                    PyPI:  #ref: https://pypi.org/project/debugpy/
                注意:
                    ポートの ACL が許可になっていなければ使えません
                    #search: Linux telnet port
                    #search: SSH port forwarding
                    #search; iptables
                debugpy をコードに埋め込む場合:  #ref: https://code.visualstudio.com/docs/python/debugging#_debugging-by-attaching-over-a-network-connection
                    デバッグ対象のコードを作ります:
                        基本の場合:
                            examples/debugpy/target.py : |  #keyword: debugpy first example
                                import debugpy

                                debugpy.listen(5678)
                                print("Waiting for debugger attach")
                                debugpy.wait_for_client()
                                debugpy.breakpoint()
                                print('break on this line')
                        ループする場合:
                            examples/debugpy/target.py : |  #keyword: debugpy loop example
                                def break_point():
                                    port = 5678
                                    import debugpy
                                    global debugpy_listen_was_called
                                    if not debugpy_listen_was_called:
                                        debugpy_listen_was_called = True
                                        debugpy.listen(port)
                                        print("debugpy listening")
                                    debugpy.breakpoint()
                                    print('after breakpoint')
                                debugpy_listen_was_called = False

                                def main():
                                    while True:
                                        break_point()
                                        import time;
                                        time.sleep(3)
                                main()
                    仮想環境に debugpy を追加します:  #// ローカルにあるプロジェクトが使う仮想環境に追加します
                        python -m pip install --upgrade debugpy
                    デバッグ対象を普通に起動します:
                        python  "examples/debugpy/target.py"
                        #// debugpy.wait_for_client() のコードで実行は止まります
                    __Project__/.vscode/launch.json : | #keyword: launch.json Python attach  #ref: https://code.visualstudio.com/docs/python/debugging#_command-line-debugging
                        {
                            "version": "0.2.0",
                            "configurations": [
                                {
                                    "name": "Python: Attach",
                                    "type": "debugpy",
                                    "request": "attach",
                                    "connect": {
                                        "host": "localhost",
                                        "port": 5678
                                ...
                    デバッガーを起動します: |
                        VSCode >> Run and Debug（右）>> Python: Attach >> F5 キー
                        #// debugpy.breakpoint() の次の行でブレークします
                プロセスにアタッチする場合:
                    注意: PID が変わります
                    #ref: https://github.com/microsoft/debugpy/#attaching-to-a-running-process-by-id
                メソッド:
                    debugpy.listen: #keyword:  #// ポートのリッスンを開始します
                        概要:
                            - ポートのリッスンを開始して、VSCode と接続できるようにします
                            - VSCode のデフォルトでは、アドレス 127.0.0.1、ポート番号 5678 を使います
                            - 実行中は接続を開始できませんが、debugpy.wait_for_client や debugpy.breakpoint が
                                呼び出されたタイミングで接続を開始できます
                            - 1回しか呼び出すことはできません。ポートがすでに使われているというエラーになります
                        サンプル:  #search: debugpy example
                            import debugpy
                            debugpy.listen(5678)
                    debugpy.wait_for_client: #keyword:  #// VSCode と接続されるまで待ちます
                        概要:
                            - VSCode と接続されるまで待ちます
                            - このメソッドを呼び出さずに、debugpy.breakpoint メソッドを呼び出しても接続を開始できます
                            - 接続中なら何もせず通過します
                            - デバッガーを終了して呼び出されると待ちます
                            - 再接続できます
                        サンプル:  #search: debugpy example
                            debugpy.wait_for_client()
                    debugpy.breakpoint: #keyword:  #// VSCode と接続していたらブレークします
                        概要:
                            - 接続していたら次の行でブレークします
                            - 接続していなかったら何もせず通過します
                            - ブレーク中にデバッガーの接続を切ったらプログラムを再開します
                            - 再接続したときでも breakpoint が呼ばれたらブレークします
                        サンプル:  #search: debugpy example
                            debugpy.breakpoint()
                    #// 他にもあります
            ウォッチ:
                クラス名（最上）の表示内容:
                    <__ClassName__>: インスタンス オブジェクト
                    <class __ClassName__>: クラス オブジェクト
                    <function __MethodName__>: 関数
                インスタンス:  #// インスタンス オブジェクトに表示される属性
                    ___ClassName______HiddenAttributeName__:  #// 例: _Class__Attr  #// プライベート変数  #search: 名前マングリング
                    special variables:  __new__ など
                クラス:  #// クラス オブジェクト に必ず表示される属性
                    ._type_args.class variables: ジェネリック クラス のパラメーターであるクラス
        インタープリターを実行します:  #// python コマンド。デバッガーなし
            シェル: |
                $ python3
                >>> print('Hello, world')
                Hello, world
                >>> exit()
                $
        シェルから実行します: #keyword: try Python,  python3 -c
            1行:
                python -c 'print("Hi")'
            複数行: |  #search: Linux here document
                #// 実行するときはインデントをカットしてください
                python <<- __HERE_DOCUMENT__
                import sys
                for p in sys.path:
                    print(p)
                __HERE_DOCUMENT__
            1行複数命令:
                curl -X GET  http://localhost:8080/__admin/scenarios | python3 -c "import sys, json; print(list(x['state'] for x in json.load(sys.stdin)['scenarios'] if x['name']=='ToDo'))"
        .py ファイルを実行します:  #// python コマンド。デバッガーなし
            ~/_tmp.py: |
                print('Hello, world')
            シェル: |
                $ python ~/_tmp.py
                Hello, world
                $
            関連:
                デバッガーに接続します:  #search: .py file debugger
        print:  #search: Python debug print
        lambda のデバッグ:  #keyword: LambdaDebugTracer for Python  #ref: ${GitHub}/Trials/Python/LambdaDebugTracer/_debug.py
            使い方:  #ref: ${GitHub}/Trials/Python/LambdaDebugTracer/_debug.py#最もシンプルな使い方
                __Project__/_debug.py:
                    #ref: ${GitHub}/Trials/Python/LambdaDebugTracer/_debug.py
                ____.py: |
                    from _debug import LambdaDebugTracer
                出力例: |
                    [debug] LambdaDebugTracer.TRACE_ERROR ERROR at element #7 (index 6)
                        Input value: 48929
                        Error type: TypeError
                        Error message: expected string or bytes-like object
        例外の内容:  #keyword: Python exception print
            コールスタックを表示します:  #keyword: Python call stack,  Python call tree,  traceback.format_exc,  traceback.print_exc
                関連 >> ログ:  #search: Python logging
                例外発生時: |
                    try:
                        :
                    except Exception, e:  #// except (Error1, Error2) as exception:
                        import traceback
                        call_stack = traceback.format_exc()
                        print(call_stack)
                        #// logger.error("%s %s", str(exception), call_stack)
                        sys.exit(1)
                デバッグ時: |  #// コールスタックを公開するのは基本的に NG
                    import traceback

                    debug = True
                    if debug:
                        call_stack = ' > ' + traceback.format_exc()
                    else:
                        call_stack = ''
                    return self.error_response('500', '失敗しました'+ call_stack)
                #ref: ${programming}/スクリプト/Python.svg#traceback_print_exc
                コマンド実行時:
                    poetry などのエラーの原因を調べるときは、
                    .pyenv/versions/__Version__/bin/poetry から
                    pdb.set_trace でステップ実行しながら except ブロックを探し、
                    traceback.format_exc のコードを埋めて再実行します。
            シンプルな表示のサンプル: |
                try:
                    raise ValueError('The value must set')
                except Exception as exception:
                    watch = str(exception)
                    print(watch)
                    raise exception
        通過回数:  #search: Python debug counter
    テスト:  #keyword: Python test
        定数を置き換えます:
            参考: https://stackoverflow.com/questions/50048080/py-test-patch-on-fixture
            サンプル コード: |
                import pytest
                from unittest.mock import patch

                @pytest.fixture(autouse=True)
                def no_delay():
                    with patch('ConstantsModule.ConstantsClass.DELAY_TIME', 10):
                        yield
        関数をモックに置き換えます:
            #search  mock.patch
        インスタンスをモックに置き換えます:
            #search  フィクスチャ, mock.create-autospec,  Mock
        呼び出し履歴をチェックします:
            #search  call_list,  call_args,  mock.call
        表形式のテストデータ:
            #search  pytest.mark.parametrize
        tox: #keyword: tox,  Python CI  #// 仮想環境の構築と、テスト等の実行。主に CI環境でも使えるようにします
            公式: #ref: https://tox.wiki/en/latest/
            手順:
                インストール:  #keyword: install tox
                    pyenv 環境: #keyword: install tox pyenv  #// ~/.pyenv にインストールする場合:
                        使う Python のバージョンを調べます:
                            tox.ini: |  #// 下記は Python 3.7
                                basepython = py37
                        ~/.pyenv に、使うバージョンの Python をインストールします:
                            #search: .pyenv
                            #keyword: install pyenv Python
                        tox をインストールします:
                            - which pip
                            - pip install tox  #// which pip で表示された仮想環境に tox をインストールします
                            - tox --version
                    poetry 環境: #keyword: install tox poetry project.toml  #// 既存の pyproject.toml に追加インストールする場合:
                        pyproject.toml を使ったプロジェクトを入手するか新規作成します:
                            #search: install poetry
                        tox.ini のサンプル: |  #// tox が poetry の仮想環境を使います
                            [tox]
                            envlist = py39, py310
                            isolated_build = true

                            [testenv]
                            whitelist_externals = poetry
                            commands_pre = 
                                poetry install --with dev
                            commands = 
                                poetry run pytest {posargs}
                            skip_install = true
                        tox を追加します:
                            poetry add  tox  -D   #// -D オプションはリリースに含めないで開発時だけインストールします
                        仮想環境をアクティベートします:
                            poetry shell
                    pip 環境: #keyword: install tox pytest  #// Pip で tox, pytest をインストールして試す場合
                        参考: https://tox.readthedocs.io/en/latest/
                        bash:
                            - mkdir ~/try-tox
                            - cd    ~/try-tox
                            - pip install tox
                            - nano "inc_dec.py" : |
                                def increment(x):
                                    return x + 1

                                def decrement(x):
                                    return x - 1
                            - nano "inc_dec_test.py" : |
                                import inc_dec    # The code to test

                                def test_increment():
                                    assert inc_dec.increment(3) == 4

                                def test_decrement():
                                    assert inc_dec.decrement(3) == 4
                            - nano "setup.py" : |
                                from setuptools import setup

                                setup(
                                    name="try-tox",
                                    version="1.0.0"
                                )
                            - nano "tox.ini" : |  #keyword: tox.ini example  #// setup.py と同じフォルダーに tox.ini を書きます
                                # content of: tox.ini , put in same dir as setup.py
                                [tox]
                                envlist = py37

                                [testenv]
                                # install pytest in the virtualenv where commands will be executed
                                deps = pytest
                                commands =
                                    # NOTE: you can run any command line tool here - not just tests
                                    pytest
                            - tox  #// インストールと tox.ini/commands の実行をします
                            - エラーを修正します:
                                nano "inc_dec_test.py" :
                                    assert inc_dec.decrement(3) == 2
                            - tox  #// テストがパスします
                VSCode デバッグ: #keyword: tox VSCode debug  #// Visual Studio Code デバッガー と接続して実行します:
                    フォルダーを開きます:  #// tox.ini があるフォルダーを直接 VSCode で開きます
                        #search: VSCode open folder
                    python または pytest などの実行環境を調べます:  #// python または pytest のパスと、環境変数を調べます
                        setenv: #search: tox.ini setenv
                        passenv: #search: tox.ini passenv
                        commands: #search: tox.ini commands
                        poetry run task: #search: poetry run task
                    __Project__/.vscode/launch.json: |
                        "program": "${workspaceFolder}/.tox/__Python__/bin/__PythonOrPytest__",
                        "args": ["__Parameter__"],
                        "env": {
                            "__Name__": "__Value__",
                            "__Name__": "__Value__",
                        },
                    Python Select Interpreter を実行します:
                        #search: VSCode Python Select Interpreter
                    F5 キー:  #// デバッグ開始
            コマンド:
                サンプル:
                    tox
                tox: #ref: https://tox.wiki/en/latest/config.html#cli
            設定ファイル: #// tox.ini または pyproject.toml または setup.cfg
                公式: #ref: https://tox.wiki/en/latest/config.html
                サンプル: |
                        [tox]
                        envlist = py37

                        [testenv]
                        commands =
                            pytest
                        deps = pytest
                    #search: tox.ini example
                tox.ini: #keyword:
                    tox: #// [tox] グローバル設定  #ref: https://tox.wiki/en/latest/config.html#tox-global-settings
                        envlist: #keyword: tox.ini envlist  #// インストールする Python のバージョン
                            公式: #ref: https://tox.wiki/en/latest/config.html#generating-environments-conditional-settings
                            サンプル:
                                envlist = py37
                            サンプル (2):
                                envlist = py27, py39
                            サンプル (3):
                                envlist =
                                    py27
                                    py39
                            basepython: #keyword: tox.ini basepython  #// 設定できる値
                                py37, python3, pypy3, jython3, py36-django15, py36-flake など
                                #// py37 の場合の python の場所は $HOME/.pyenv/versions/3.7.1/bin/python3.7
                                #// python のパスは指定できません
                            その他 公式:
                                #ref: https://tox.wiki/en/latest/config.html#conf-envlist
                                #ref: https://tox.wiki/en/latest/config.html#conf-basepython
                                #ref: https://tox.wiki/en/latest/config.html#tox-environments
                        skipsdist: #keyword: tox.ini skipsdist  #ref: https://tox.wiki/en/latest/config.html#conf-skipsdist
                            実行ファイルのプロジェクトの場合: true
                            ライブラリのプロジェクトの場合: false （デフォルト）
                    testenv: #// [testenv]  #// 共通設定。それぞれの testenv:__Name__ に継承されます  #ref: https://tox.wiki/en/latest/config.html#tox-environments
                        #search: tox.ini testenv
                        設定できる項目は testenv:__Name__ と同じです。
                        tox.ini に testenv:__Name__ が無く、testenv だけ書かれていても問題ありません。
                    testenv:__Name__: #keyword: tox.ini testenv  #// [testenv:__Name__]  #ref: https://tox.wiki/en/latest/config.html#tox-environment-settings
                        起動時の __Name__ 指定:
                            tox -e py37
                        commands, commands_pre, commands_post: #keyword: tox.ini commands  #// テストを起動するコマンド  #ref: https://tox.wiki/en/latest/config.html#conf-commands
                            サンプル (1): |
                                commands =
                                    echo "in tox"
                            サンプル (2): |
                                commands =
                                    echo "DJANGO_ENVIRONMENT = {env:DJANGO_ENVIRONMENT}"
                                    poetry install --remove-untracked
                                    mkdir -p {toxinidir}/data
                                    poetry run python {toxinidir}/manage.py compilemessages -l ja
                                    poetry run task test
                            書式:
                                - 1行1コマンド。1コマンドを複数行にする場合は行末に \。
                                - エラーが発生した行より後の行は実行されません 
                                - エラーを無視する場合はコマンドの行頭に - を付けます
                                - commands_pre, commands_post は [testenv] から継承するように使われることがあります
                            変数参照:
                                環境変数:
                                    書式: |
                                        {env:__Name__}
                                    サンプル: |
                                        echo "DJANGO_ENVIRONMENT = {env:DJANGO_ENVIRONMENT}"
                                定義済み変数:
                                    toxinidir:  #keyword: {toxinidir}
                                    posargs:  #keyword: {posargs}
                                        tox.ini: |
                                            [testenv]
                                            commands = pytest {posargs}
                                        コマンド: |
                                            tox -e py39
                                                # → pytest が実行される
                                            tox -e py39 -- tests/test_models.py -v
                                                # → pytest tests/test_models.py -v が実行される
                        allowlist_externals:  #// tox の commands で使う UNIX コマンド  #keyword: tox.ini allowlist_externals,  tox.ini whitelist_externals  #ref: https://tox.wiki/en/latest/config.html#conf-allowlist_externals
                            _:
                                - ここに指定しない UNIX コマンドは警告されます  #search: tox.ini commands
                                - PATH が通ったコマンド、または、フルパスで指定します。相対パスでは無視されます
                                - deps に指定したコマンドは allowlist_externals に書かなくてもよいです
                            サンプル: |
                                allowlist_externals =
                                    echo
                                    poetry
                                    mkdir
                        deps: #keyword: tox.ini deps  #ref: https://tox.wiki/en/latest/config.html#conf-deps
                            _: 依存するパッケージ。通常 pyproject.toml に依存するパッケージを指定しますが、
                                tox の commands を実行するときに不足するパッケージを deps に記述するようです。
                                インストールしない場合は allowlist_externals にコマンドを指定します。
                            サンプル: |
                                deps = pytest
                            サンプル (2): |
                                deps =
                                    -r{toxinidir}/tools/requirements.txt
                                    -c{toxinidir}/tools/constraints.txt
                            サンプル (3): |
                                deps = pytest -r{toxinidir}/requirements.txt
                        setenv: #keyword: tox.ini setenv  #// 環境変数  #ref: https://tox.wiki/en/latest/config.html#conf-setenv
                            サンプル: |
                                setenv =
                                    DJANGO_SETTINGS_MODULE = website.settings
                                    DJANGO_ENVIRONMENT = testing
                            command で参照する:  #search: tox.ini commands
                                echo "DJANGO_ENVIRONMENT = {env:DJANGO_ENVIRONMENT}"
                                #ref: https://splunktool.com/how-to-set-the-environment-variable-in-tox
                        passenv: #keyword: tox.ini passenv  #// tox の起動環境から継承する環境変数  #ref: https://tox.wiki/en/latest/config.html#conf-passenv
                            _: 大文字と小文字を区別しません。大文字と小文字の両方にマッチする場合、両方とも継承します
                            サンプル: |
                                passenv =
                                    http_proxy
                                    https_proxy
                                    no_proxy
                        skip_install: #keyword: tox.ini skip_install  #ref: https://tox.wiki/en/latest/config.html#conf-skip_install
                            true: 仮想環境を作りません（別で用意する？）
                            false: 仮想環境を作ります（デフォルト）
                        install_command: #keyword: tox.ini install_command  #ref: https://tox.wiki/en/latest/config.html#conf-install_command
                            パッケージをインストールするときに実行するコマンド。
                            省略時は pip
                        platform: #keyword: tox.ini platform
                            linux2|darwin
                    flake8: #// [flake8] Python の静的解析ツール  #search: flake8
                        CI環境でも静的解析によるチェックを行う場合に設定します
                requirements.txt:  #// 依存関係。package.json 相当
                    deps の -r オプションにパスを書きます（不要かも） #search: tox.ini deps
                constraints.txt: #keyword: tox constraints.txt  #// 子孫も含んだバージョン。package-lock.json 相当
                    deps の -c オプションにパスを書きます（不要かも） #search: tox.ini deps
            トラブルシューティング:
                - #// ERROR:   py37: commands failed
                    手順: tox
                    エラー: |  #focus: msgfmt
                        ...
                        • Installing python-memcached (1.59)
                        • Installing rfc5424-logging-handler (1.4.3)
                        • Installing sqlalchemy-stubs (0.3)
                        • Installing sqlalchemy-utc (0.10.0)
                        • Installing sqlalchemy-utils (0.36.3)
                        • Installing taskipy (1.7.0)
                        py37 run-test: commands[1] | mkdir -p /home/user1/proj/api/log
                        py37 run-test: commands[2] | mkdir -p /home/user1/proj/api/data
                        py37 run-test: commands[3] | poetry run python /home/user1/proj/api/manage.py compilemessages -l ja
                        /home/user1/proj/api/extensions/dependency_injection/v1_compat.py:11: UserWarning: Using next version of dependency injection library
                        warnings.warn("Using next version of dependency injection library")
                        CommandError: Can't find msgfmt. Make sure you have GNU gettext tools 0.15 or newer installed.
                        ERROR: InvocationError for command /home/github-runner/.local/bin/poetry run python manage.py compilemessages -l ja (exited with code 1)
                        ______________________________________________________________ summary _______________________________________________________________
                        ERROR:   py37: commands failed
                    対処:
                        msgfmt コマンドが見つかっていません。
                        sudo dnf install gettext
                - #// allowlist_externals に登録されていない
                    手順: tox
                    エラー: |
                        WARNING: test command found but not installed in testenv
                            cmd: /usr/bin/__Command__
                            env: __Project__/.tox/__EnvironmentName__
                        Maybe you forgot to specify a dependency? See also the allowlist_externals envconfig setting.
                    対処:
                        deps または allowlist_externals に使うコマンドを登録します
                        ただし、allowlist_externals にはフルパスまたは PATH が通ったパスである必要があります
                        #search: tox.ini allowlist_externals
                - #// index.rst の内容（左）が更新されない
                    手順: ブラウザーのリロード
                    問題: index.rst の内容（左）が更新されない
                    対処: tox --recreate または tox -r でリビルドします
                - #// exception: No module named '__Module__'
                    手順: tox
                    エラー: |
                        Extension error:
                        __Module__ import  (exception: No module named '__Module__')
                    対処:
                        tox --recreate または tox -r でリビルドします
        unittest:
            手順 >> デバッグ:  #// Visual Studio Code  #search: install Python unittest VSCode
            assertListEqual:  #keyword: Python unittest assertListEqual
                サンプル: |  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s04_assert/s4_test.py#assertListEqual
                    import unittest
                    t = unittest.TestCase()
                    def test():
                        t.assertListEqual([1,2,3], [1,2,3])  #// Failed, if 1,2,3 => 1,2 | 2,1,3 | 1,2,3,4
                参考:
                    #ref: https://docs.python.org/3.5/library/unittest.html#unittest.TestCase.assertListEqual
                    #ref: https://docs.python.org/3.5/library/unittest.html#unittest.TestCase.addTypeEqualityFunc
            unittest.mock:  #keyword: Python unittest.mock
                参考:
                    - https://docs.python.org/ja/3/library/unittest.mock.html
                    - https://dev.classmethod.jp/articles/python_unittest_mock-trial/
                #↓ メソッド。モックを定義または操作するメソッド
                mock.patch: #keyword: pytest mock.patch  #// モックに置き換えます
                    #↓ メソッドを置き換えます
                    #keyword: replace method Python mock
                    値を返すだけのメソッド: #keyword: pytest return mock.patch  #// 指定の値を返すだけのメソッド（モック）に置き換えます
                        メソッドをモックにする場合:
                            fixture にしない場合: #keyword: call pytest mock.patch.object   #// 返す値を明示する場合  #// メソッドをモックに置き換える場合（フィクスチャ不使用）
                                mock.patch.object を使う場合:  #// Test クラスの定義は不要です
                                    test.py: |  #focus: test_with_mock,  get,  mock.patch.object,  test_without_mock
                                        from unittest import mock
                                        import module1
                                        import module2

                                        #// test_without_mock
                                        #focus: module1
                                        def test_without_mock():
                                            object2 = module2.MyClass()
                                            assert object2.get() == 'module2(module1)'

                                        #// test_with_mock
                                        #focus: mock.patch.object,  mock_get
                                        def test_with_mock():
                                            with mock.patch.object(module1.MyClass, 'get_sub', return_value='mock_get') as method_mock:  #// get メソッドをモックに置き換えます
                                                object2 = module2.MyClass()
                                                assert object2.get() == 'module2(mock_get)'
                                                assert method_mock.call_args_list == [mock.call()]
                                    module1.py: |
                                        class MyClass:
                                            def get_sub(self) -> str:
                                                return "module1"
                                    module2.py: |
                                        import module1

                                        class MyClass:
                                            def __init__(self):
                                                self.child = module1.MyClass()

                                            def get(self) -> str:
                                                return f"module2({self.child.get_sub()})"
                                mock.patch を使う場合: | #keyword: pytest mock.patch
                                    with patch("__Module__.__Function__") as mock:
                                (@mock.patch)を使う場合:  #keyword: pytest @mock.patch
                                    サンプル コード: |  #focus: @mock.patch,  mock_read_books
                                        from unittest import mock

                                        @mock.patch("book.book._read_books")   #// モックに置き換える対象となる関数。import と同じ指定方法
                                        def test_mock(self, mock_read_books):  #// mock_read_books がモック
                                            mock_read_books.return_value = ____  #// モックの返り値を設定します
                            fixture でモックにする場合: #keyword: mock.patch.object pytest fixture  #// メソッドをフィクスチャでモックに置き換える場合
                                サンプル コード:  #// module2.MyClass.get メソッドのテストで module1.MyClass.get_sub メソッドをモックにします
                                    #// 確認済み → #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s22_patch_mock/s22_test.py#@patch(
                                    test.py: |  #focus: get_sub,  module1,  mock_get_sub,  module1_MyClass_get_sub_mock,  module2,  get
                                        from unittest import mock
                                        import pytest
                                        import module1, module2

                                        class TestMethodMockPatchFixture:
                                            def test1(self, module1_MyClass_get_sub_mock):
                                                module1_MyClass_get_sub_mock.return_value = 'mock_get_sub'

                                                object2 = module2.MyClass()
                                                assert object2.get() == 'module2(mock_get_sub)'
                                                assert module1_MyClass_get_sub_mock.call_args_list == [mock.call()]

                                            @pytest.fixture
                                            def module1_MyClass_get_sub_mock(self):
                                                with mock.patch.object(module1.MyClass, 'get_sub') as method_mock:
                                                    yield method_mock
                                    module1.py: |  #// モックにされるメソッド
                                        class MyClass:
                                            def get_sub(self) -> str:
                                                return "module1"
                                    module2.py: |  #// テスト対象
                                        import module1

                                        class MyClass:
                                            def __init__(self):
                                                self.child = module1.MyClass()

                                            def get(self)-> str:
                                                return f"module2({self.child.get_sub()})"
                                呼び出し履歴のチェック:  #search: call_list
                            autouse を使う場合:  #// モックを明示しない場合（基本的に非推奨）
                                test.py: |  #focus: module2_MyClass_get_mock,  module2,  get,  mock_get,  autouse
                                    from unittest import mock
                                    import pytest
                                    import module2

                                    class TestMethodMockPatchFixture:
                                        def test1(self):
                                            object2 = module2.MyClass()
                                            assert object2.get() == 'mock_get'

                                        @pytest.fixture(autouse=True)
                                        def module2_MyClass_get_mock(self):
                                            with mock.patch.object(module2.MyClass, 'get', return_value='mock_get') as method_mock:
                                                yield method_mock
                        クラスを fixture でモックにする場合: #keyword: Python class mock
                            注意: パッケージに関連するクラスを置き換えるため、パッケージの指定が必要です。
                                それができない場合は、メソッドにモックをアタッチします
                            サンプル コード: #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s22_patch_mock/s22_test.py#TestClassMockFixture
                                test.py: |  #focus: mock.patch.object,  module1,  module2,  customized,  autouse,  module1_MyClass_mock
                                    from unittest import mock
                                    import pytest
                                    import module1, module2

                                    def test_without_mock():
                                        object2 = module2.MyClass()
                                        assert object2.get() == 'module2(module1)'

                                    class TestClassMockFixture:
                                        class LocalMock:
                                            customized = 'yes'

                                        @pytest.fixture(autouse=True)
                                        def module1_MyClass_mock(self):
                                            with mock.patch.object(module1, 'MyClass', return_value=self.LocalMock()) as class_mock:
                                                yield class_mock

                                        def test1(self):  #// This test is patched by an "autouse" option
                                            object2 = module2.MyClass()
                                            assert object2.child.customized == 'yes'

                                        def test2(self, module1_MyClass_mock):
                                            mock = self.LocalMock()
                                            mock.customized = 'ok'
                                            module1_MyClass_mock.return_value = mock

                                            object2 = module2.MyClass()
                                            assert object2.child.customized == 'ok'
                                module1.py: |
                                    class MyClass:
                                        def get(self) -> str:
                                            return "module1"
                                module2.py: |
                                    import module1

                                    class MyClass:
                                        def __init__(self):
                                            self.child = module1.MyClass()  #// module1.MyClass ではなく MyClass で生成するとモックになりません

                                        def get(self)-> str:
                                            return f"module2({self.child.get()})"
                        return_value: #keyword: Python unittest  return_value
                            設定:
                                クラス対するメソッドに設定する場合:
                                    サンプル: |
                                        class TestMockPatchFixture:
                                            @pytest.fixture(autouse=True)
                                            def module1_MyClass_get_mock(self):
                                                with mock.patch.object(module1.MyClass, 'get', return_value='mock_get') as method_mock:
                                                    yield method_mock
                                    #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s22_patch_mock/s22_test.py:csv#class TestMockPatchFixture, mock.patch.object
                                インスタンスに対するメソッド設定する場合:
                                    object.method = MagicMock(return_value=9)
                                    #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s41_assert_calls/s41_test.py#return_value=
                                モックにメソッドの返り値を設定する場合:
                                    mock = create_autospec(SomeClass)
                                    mock.some_method.return_value = "モックの返り値"
                            設定しなかったとき:
                                返り値はモックオブジェクトになります
                            参照:
                                メソッド __Method__ の返り値を設定します: |
                                    r = create_autospec(__Class__, instance=True, spec_set=True)  #search: create_autospec
                                    r.__Method__.return_value = 1
                    何もしないメソッド: #keyword: pytest no operation method  #// 何もしないメソッドまたは関数（モック）に置き換えます
                        _: return_value を設定しないようにモックを定義します
                        fixture にしない場合:  #search: call pytest mock.patch.object   #// 返す値を明示する場合
                        fixture でモックにする場合: #keyword: pytest mock fixture  #focus: user_defined_function  #search: mock.patch.object pytest fixture  #// メソッドをフィクスチャで何もしないモックに置き換える場合
                            #// __Function__ 関数を置き換えるフィクスチャ
                            #↓ Python ファイル
                            test.py ファイル: |  #focus: function_mock_fixture,  __Function__
                                from unittest.mock import patch

                                class Test:
                                    def test(self, function_mock_fixture):
                                        __Function__()

                                    @pytest.fixture
                                    def function_mock_fixture(self):    #// 関数の場合（メソッドではない場合）self を書きません
                                        with patch("__Modlue__.__Function__") as mock:    #search: pytest return mock.patch
                                            yield mock
                            __Modlue__.py ファイル: |
                                def __Function__():
                                    ____   #// 呼ばれません
                            #↓ 補足
                            __Modlue__:
                                from A import B の A と同じ書式。ただし文字列  #search: Python import from
                            __Function__:
                                モックに置き換える前の関数
                        その他:  #search: pytest return mock.patch
                    テストで定義したメソッド:  #// テストの中で実行する関数を、テスト コードが定義した関数（モック）に置き換えます
                        クラスメソッドを関数に置き換えます: |  #focus: mock.patch.object, mock_function
                            class TesteeClass:
                                @classmethod
                                def method(cls, argument):
                                    ____

                            mock.patch.object(TesteeClass, 'method', side_effect=mock_function)

                            def mock_function(argument):
                                ____
                        (@mock.patch):
                            サンプル コード: |
                                from unittest import mock

                                @mock.patch("json.dumps", new=non_ascii_json_dumps)
                                        #// 第1引数はモックに置き換える対象となる関数。import と同じ指定方法
                                        #// new 引数は テスト コード が定義した関数（モック）、呼ばれる関数
                                def test_mock(self):
                                    :
                                def non_ascii_json_dumps():
                                    return dumps(*args, **{"ensure_ascii": False, **kwargs})
                    例外を発生させる場合:
                    メソッドを置き換える場合:
                        テスト関数に @patch.object デコレーターを書きます: |  #focus: __MethodNameA__,  side_effect
                            class Test_get_site:
                                @patch.object(__ClassB__, '__MethodNameB__')
                                @patch.object(__ClassA__, '__MethodNameA__')
                                def test(self, mock___MethodNameA__, mock___MethodNameB__, __Fixtures__):  #// 引数名は自由です。引数 は、指定したメソッドを置き換えたモックを指しています。
                                    mock___MethodNameA__.side_effect = (lambda x: x)  #// モックのシステムは lambda に self を渡しません
                        インスタンスのメソッドを置き換えるとエラーになります: |
                            controller.assemble = (lambda self, x: x)  #// AttributeError: 'Controller' object attribute 'assemble' is read-only
                        旧）side_effect: #keyword: Python unittest side_effect
                            サンプル:
                                target_object = create_autospec(__Class__, instance=True)
                                target_object.target_method.side_effect =  [4, 5, 6]
                                target_object.target_method() == 4
                                target_object.target_method() == 5
                                target_object.target_method() == 6
                            #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s14_side_effect/s14_test_deprecated_request.py#side_effect
                            トラブルシューティング:
                                - #// side_effect StopIteration
                                    手順: pytest 実行
                                    ログ: | #keyword: StopIteration
                                        def _mock_call(_mock_self, *args, **kwargs):
                                            StopIteration
                                    対処:
                                        side_effect に指定した配列の要素数を増やしてください  #search: Python unittest side_effect
                        関連:
                            ファクトリ フィクスチャ:  #search: pytest factory fixture
                    #↓ 属性を置き換えます
                    ネストした属性をモックの値に設定します: |  #// obj.a.b.c = "モックの値"
                        mock_obj = MagicMock()
                        mock_obj.a.b.c = "モックの値"

                        object.obj = mock_obj
                        object.obj.a.b.c == "モックの値"
                    #↓ オブジェクトを置き換えます
                    オブジェクトをモックに置き換えます: |  #search: Python SSH mock  #keyword: mock.patch.object
                        def  enable_mock():
                            mock.patch.object(OriginalClass, 'connect', new=OneMock.connect).__enter__()

                        class OneMock:
                            def connect(originalObject, name: str):
                                OneMock.__sub(originalObject, name)
                            def __sub(originalObject, name: str):
                                logger.info('OneMock.connect')
                    モック オブジェクト を渡します:  #search: unittest  create_autospec
                    #↓ その他
                    トラブルシューティング:
                        - #// クラスがモックに置き換わらない
                            手順: pytest 実行時
                            コード:
                                テスト側: |
                                    mock.patch.object(minio.api, 'Minio', return_value=MinioMock()) as class_mock
                                モジュール側: |
                                    from minio.api import Minio
                                    def  function():
                                        return  Minio()   #// MinioMock ではなくオリジナル Minio になる
                            原因:
                                mock.patch(.object) はプロパティをモックに置き換えるため、
                                直接クラス（上記 Minio）を参照しているコードはモックに置き換わりません。
                            対処:
                                モジュール側: |  #focus: api
                                    from minio import api
                                    def  function():
                                        return  api.Minio()
                            参考:
                                #ref: https://docs.python.org/ja/3/library/unittest.mock.html#where-to-patch >> どこにパッチするか
                                #ref: https://note.crohaco.net/2015/python-mock/ >> from importを使ったオブジェクトを Patch する
                mock.patch.object:  #search: call pytest mock.patch.object
                mock.create-autospec: #keyword: unittest  create_autospec
                    参考: https://docs.python.org/ja/3/library/unittest.mock.html#create-autospec
                    インスタンスをモックにします:
                        インスタンスを、fixture にする場合（推奨）:
                            サンプル コード: |
                                import @pytest
                                from unittest.mock import create_autospec

                                @pytest.fixture
                                def class_A_instance(self):
                                    mock_A = create_autospec(ClassA, instance=True, spec_set=True)
                                    return  mock_A
                        インスタンスを、fixture にしない場合:
                            サンプル コード: |
                                from unittest.mock import create_autospec

                                mock_A = create_autospec(ClassA, instance=True, spec_set=True)
                        #// 下記「詳細」を参考
                    属性を含むインスタンスをモックにします:
                        create_autospec の第1引数を ClassA(__Parameters__) に変えます。
                        mock_A = create_autospec(ClassA(__Parameters__), instance=True, spec_set=True)
                    メソッドが返す値を設定します:
                        mock_A.method1.return_value = "mocked value"
                    詳細:
                        instance:
                            -   インスタンスをモックにするとき、create_autospec() の第1引数をクラス、instance=True にします
                            -   この設定でインスタスをモックにすると、そのインスタンスのすべてのメソッドもモックになりますが、
                                属性（__init__ の中で動的に追加される属性）はインスタンスのモックに含まれません。
                                spec_set=False に設定して、動的に属性を追加する必要があります。
                        spec_set:  #// 属性の動的追加の許可。メソッドは、インスタンスにメソッドが追加された後で、追加禁止になります
                            -   通常、spec_set=True にします
                            -   create_autospec は、指定したクラスの __init__ を呼び出しません
                            -   spec_set=False にすると、create_autospec() の返り値のインスタンスモックに代入による属性の追加ができます
                                mock_A = create_autospec(ClassA, instance=True, spec_set=False)
                                mock_A.attr = 2
                        メソッドの返り値:
                            必要に応じてメソッドの返り値のデフォルトを設定します: #search: Python unittest  return_value
                mock.Mock: |  #keyword: Python Mock  #// モックの型。 生成すると、対象のない（任意のインスタンスの）モックを生成します
                    from unittest.mock import Mock
                    my_mock = Mock()
                autospec:
                    通常、autospec は有効にします:
                    参考: https://docs.python.org/ja/3/library/unittest.mock.html#autospeccing
                #↓ 手順や構成
                メソッドの置き換え:  #search: replace method Python mock
                呼び出し履歴: #keyword: unittest.mock call
                    呼び出し内容をチェックする場合:
                        call_args_list:
                            コード: |  #keyword:
                                assert method_mock.call_args_list == [
                                    mock.call(EqClass(1,2,3)),
                                    mock.call(EqClass(1,2,3)),
                                    ]
                            デバッガーでの表示:
                                method_mock.call_args_list[i][0]: 位置引数の配列
                                method_mock.call_args_list[i][1]: キーワード引数の辞書
                            #// エラーメッセージに「At index 0 diff」が含まれています
                        クラスとデータクラスの判定方法の違い:
                            - 引数にデータクラスではないクラスのオブジェクトを渡したときは、test_object_ID を比較します
                            - __eq__ メソッドが定義されたクラスのオブジェクトを渡したときは、__eq__ メソッドが True を返したときに成功します
                            - 引数にデータクラスのオブジェクトを渡したときは、すべての属性を比較します  #search: Python @dataclass
                            #search: Python ==
                            #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s41_assert_calls/s41_test.py#Test_Equal
                        assert_has_calls: #keyword:  #// 呼び出し履歴をチェックします
                            関連 >> 推奨: #search: call_args_list
                            サンプル:
                                object.method.assert_has_calls([mock.call(3, 4, key=DataClass('aaa', 'bbb'))], any_order=False)
                                #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s41_assert_calls/s41_test.py#test_call_order
                            サンプル 複数呼び出し: |
                                    method_mock.call_count == 2
                                    method_mock.assert_has_calls([
                                        mock.call(self.DataClass(1,2,3)),
                                        mock.call(self.DataClass(1,2,3)),
                                        ], any_order=False)
                                #// エラー メッセージ に比較したデータがすべて表示されます
                                #// どこに違いがあるかは表示されません
                            補足:
                                - 複数回呼ばれるうちのどこかで期待通りの引数が渡ったら成功します
                                - any_order=False を指定しない場合、呼び出しの順番は問わなくなります
                                - キーワード引数を位置引数に変えて書くと失敗します
                                    #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s41_assert_calls/s41_test.py#Test_KeywordArgument
                            一部の引数をチェックしない場合: #keyword: Python unittest.mock.ANY
                                object.method.assert_has_calls([mock.call(3, 4, mock.ANY))], any_order=False)
                                    #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s41_assert_calls/s41_test.py#test_no_check_argument
                            公式: #ref: https://docs.python.org/3/library/unittest.mock.html?highlight=assert_has_calls#unittest.mock.Mock.assert_has_calls
                        call_count: #keyword:  #// 呼び出された回数をチェックします
                            assert object.method.call_count == 2
                    デバッグ:
                        __eq__ による比較が失敗したとき:
                            debugEqMethodInCallArgsList:  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s41_assert_calls/s41_test.py#def debugEqMethodInCallArgsList
                        dataclass の比較が失敗したとき:
                            debugDataClassInCallArgsList:  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s41_assert_calls/s41_test.py#def debugDataClassInCallArgsList
                    その他:
                        call_list():  #keyword: call_list
                            参考: https://docs.python.org/ja/3/library/unittest.mock.html#call
                            内容: 呼び出し履歴 (call_list())
                        call_args: #// 非推奨  #keyword: call_args
                            注意: 非推奨。assert_has_calls を推奨します。エラーメッセージが不親切なため  #search: assert_called_with
                            参考: #ref: https://docs.python.org/ja/3/library/unittest.mock.html#unittest.mock.Mock.call_args
                            サンプル コード:
                                0 を渡して呼ばれた: |
                                    assert method_mock.call_args == call(0)
                                引数なしで呼ばれた: |
                                    assert method_mock.call_args == call()
                                呼ばれなかった: |
                                    assert method_mock.call_args == None
                            トラブルシューティング (call_args):
                                エラー メッセージ を解読します:
                                    オブジェクトを渡さない場合:  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s43_call_args/s43_test.py#test_call_with_string
                                        テスト コード: |
                                            assert method_mock.call_args == mock.call()
                                        エラー メッセージ: |
                                            >   assert method_mock.call_args == mock.call()
                                            E   AssertionError: assert call('aaa') == call()
                                            E       (pytest_assertion plugin: representation of details failed: __Path__:__LineNum__: ValueError: too many values to unpack (expected 2).
                                            E       Probably an object has a faulty __repr__.)
                                        解読結果:
                                            期待:
                                                object1.get()
                                            呼ばれた内容:
                                                object1.get('aaa')
                                            期待を修正する場合:
                                                変更前: assert method_mock.call_args == mock.call()
                                                変更後: assert method_mock.call_args == mock.call('aaa')
                                    オブジェクトを渡す場合:  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s43_call_args/s43_test.py#test_call_with_object
                                        assert_has_calls を使う場合:
                                            テスト コード: |
                                                method_mock.assert_has_calls([DataClass('ccc', 'bbb')])
                                            エラー メッセージ: |
                                                >   method_mock.assert_has_calls([DataClass('ccc', 'bbb')])
                                                ...
                                                E       AssertionError: Calls not found.
                                                E       Expected: [DataClass(attribute1='ccc', attribute2='bbb')]
                                                E       Actual: [call(DataClass(attribute1='aaa', attribute2='bbb'))]
                                        解読結果:
                                            期待, Expected:
                                                object1.get(DataClass('ccc', 'bbb'))
                                            呼ばれた内容, Actual:
                                                object1.get(DataClass('aaa', 'bbb'))
                                            期待を修正する場合:
                                                変更前: method_mock.assert_has_calls([DataClass('ccc', 'bbb')])
                                                変更後: method_mock.assert_has_calls([DataClass('aaa', 'bbb')])
                                        call_args を使う場合:  #// 非推奨。エラー メッセージ が不親切なので
                                            テスト コード: |
                                                assert method_mock.call_args == mock.call(DataClass('ccc', 'bbb'))
                                            エラー メッセージ: |
                                                >   assert method_mock.call_args == mock.call(DataClass('ccc', 'bbb'))
                                                E   AssertionError: assert call(DataClas...ibute2='bbb')) == call(DataClas...ibute2='bbb'))
                                                E       (pytest_assertion plugin: representation of details failed: __Path__:__LineNum__: ValueError: too many values to unpack (expected 2).
                                                E       Probably an object has a faulty __repr__.)
                                            解読結果:
                                                エラー メッセージ からどの属性に問題があるかは分かりません
                                            実際の動き:
                                                期待:
                                                    object1.get(DataClass('ccc', 'bbb'))
                                                呼ばれた内容:
                                                    object1.get(DataClass('aaa', 'bbb'))
                        assert_called_with: #// 非推奨  #keyword:
                            注意: 非推奨。assert_called_with を推奨します。複数回呼び出されたときは最後の呼び出ししかチェックしないため
                                #ref: https://stackoverflow.com/questions/7242433/asserting-successive-calls-to-a-mock-method
                            チェック:  #// 行頭に assert は不要です
                                object.method.assert_called_with(3, 4, key='value')
                                #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s41_assert_calls/s41_test.py#.assert_called_with(
                        mock.call:  #keyword: call
                            参考: https://docs.python.org/ja/3/library/unittest.mock.html#call
                            内容: call_args と比較するオブジェクト
                            call は不要？: https://docs.python.org/ja/3/library/unittest.mock.html#unittest.mock.Mock.call_args
        pytest:  #keyword: pytest
            関連: #search: "tox, pytest をインストールして試します", #search: pytest launch.json
            公式: #ref: https://docs.pytest.org/
            手順:  #keyword: install pytest
                インストール:
                    #// 以下のいずれか
                    pytest + poetry + VSCode + CentOS7 + vagrant をインストールします:
                    pytest + pipenv + VSCode をインストールします:
                        作成済みのプロジェクト: #keyword: try_pytest  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest
                            #search: pipenv sync
                        pipenv を使う VSCode のプロジェクトを作ります:
                            #search: install pipenv project
                        pytest をインストールします:
                            必要なパッケージ: pytest
                            pipenv を使う場合:
                                pipenv install --dev  pytest
                            VSCode のターミナルを再起動します:
                            pytest コマンドの動作確認をします:
                                pytest --version
                        テストとテスト対象のコードを作ります:
                            #search: pytest test_increment
                        テストを実行します:
                            #search: VSCode debug pytest
                        Testing ビューにテスト項目が一覧されない場合:
                            #search: VSCode debug pytest
                    pytest + tox をインストールします:  #search: install tox pytest
                    環境構築 >> Testing ビューにテスト項目が一覧されない場合:  #search: VSCode debug pytest
                テストを一覧します:
                    テスト実行時にテスト名も一覧します:
                        pytest コマンドの -vv オプション  #search: pytest options
                テストのデバッグ:  #keyword: pytest debug
                    テストを実行します, Testing ビュー使用:  #keyword: VSCode testing debug UI
                        Testing ビューを表示します:  #keyword: start Python testing view
                            VSCode >> Testing（フラスコ ボタン：左）
                            #search: testing view trouble
                        コードから:  #// test メソッドがあるファイルを開いているとき
                            早く実行する場合:
                                ソース ファイル に表示されている、テスト用のアイコンをクリックします（test メソッドの左）
                            print や例外の出力結果を見る場合:  #keyword: pytest print
                                テストの最後でエラーになるようにします:
                                    raise ValueError()
                                pytest コマンドを実行します:  #search: pytest command  #search: pytest options
                                    bash:  #// in api-integtest project in VSCode
                                        -   pytest __Options__ __TestCodeFileOrFolderRelativePath__ __Options__
                                        #// または
                                        -   pytest --setup-show  __TestCodeFileOrFolderRelativePath__  -k __TestNamePattern__
                                表示されない場合:
                                    logger を使っている場合: #keyword: pytest logger trouble
                                        #// サービスをテストする場合、サービスを起動していなくても、DJANGO_SETTINGS_MODULE 環境変数によって LOGGING 変数の設定が有効になるようです  #search: Django LOGGING
                                        #// デバッグ用途であれば print を代わりに使うことができます
                                        ログのコードに ステップ イン します: #keyword: pytest logger code,  Django logger code
                                            コール ツリー のサンプル:
                                                ファイルに出力している場合:  #focus: stream.name, record
                                                    # logger.error("__DummyMessage__")
                                                    error:
                                                        # def error(self, msg, *args, **kwargs):
                                                        #     self._log(ERROR, msg, args, **kwargs)
                                                        _log:
                                                            # def _log(self, level, msg, args, exc_info=None, extra=None, stack_info=False):
                                                            #     self.handle(record)
                                                            handle:
                                                                # def handle(self, record):
                                                                #     self.callHandlers(record)
                                                                callHandlers:
                                                                    # def callHandlers(self, record):
                                                                    #     hdlr.handle(record)
                                                                    handle:
                                                                        # def handle(self, record):
                                                                        #     self.emit(record)
                                                                        emit (WatchedFileHandler):
                                                                            # class WatchedFileHandler(logging.FileHandler):
                                                                            #     def emit(self, record):
                                                                            #         logging.FileHandler.emit(self, record)
                                                                            emit (FileHandler):
                                                                                # class FileHandler(StreamHandler):
                                                                                #     def emit(self, record):
                                                                                #         StreamHandler.emit(self, record)
                                                                                emit (StreamHandler):
                                                                                    # class StreamHandler(Handler):
                                                                                    #     def emit(self, record):
                                                                                                stream.write(msg)
                                                                                    #// stream.name に出力先のファイルのパスが書いてあります
                                    print を使っている場合:
                                        表示されないことはなさそう
                            デバッガーに接続して実行する場合:
                                ブレークポイントを張ります:
                                １つのテストを実行します:  #// テスト用のアイコンはテスト関数だけに表示されます。クラスには表示されません。
                                    テスト用のアイコンを右クリック >> Debug Test
                                    または
                                    テスト用のアイコンを右クリック >> Reveal in Test Explorer >> Debug Test 虫▽
                                    または
                                    ファイル名で検索（Testing ビューの上にある検索ボックス）>>（テストを選択）>> Debug Test 虫▽
                            複数のテストを一度に実行する場合:
                                テスト用のアイコンを右クリック >> Reveal in Test Explorer >>
                                （ツリーの親方向にあるテスト対象をクリック）>> Run Test ▽
                        Testing ビューから:  #// （フラスコ ボタン：左）
                            早く実行する場合:  #// エラーメッセージを確認します
                                VSCode Testing（左）>>（テスト対象をクリック）>> Run Test ▽
                            デバッガーに接続して実行する場合:
                                VSCode Testing（左）>>（テスト対象をクリック）>> Debug Test 虫▽
                        シェルから:  #search: pytest print
                        デバッガーから:  #search: pytest launch.json
                    テストする関数を指定します:  #search: pytest command
                    メッセージを詳細に表示します:
                        -v: 詳細モード
                        -s: 出力をキャプチャしない  --capture=no と同じです
                    エラーメッセージの読み方:
                        エラーメッセージ全体を表示します:
                            コード中に赤く表示されたエラーメッセージをクリック
                        エラーメッセージを新しいファイル（保存しない）にコピーします:
                        エラーメッセージの書式: |  #// 注目すべきは __Code__ と __ErrorMessage__
                            ./____/test_____.py::__Class__::test Failed: __ErrorMessage__
                            __Variables__
                            __Variables__
                            __Variables__

                                __Code__
                            E       __ErrorMessage__

                            ./____/test_____.py:__LineNum__: __ErrorMessage__
                    テストの内容: #search: pytest test.py
                    テストのスキップ:  #keyword: pytest skip
                        公式: #ref: https://docs.pytest.org/en/6.2.x/skipping.html
                        デコレーターを使って関数やクラスをスキップします:  #// @pytest.mark.skip
                            メソッドをスキップします: |  #focus: @pytest.mark.skip
                                @pytest.mark.skip(reason="no way of currently testing this")
                                def test_the_unknown():
                                    ...
                            クラスをスキップします: |
                                @pytest.mark.skip(reason="no way of currently testing this")
                                class TestPosixCalls:
                                    def test_function(self):
                            条件によってスキップします: |  #focus: @pytest.mark.skipif
                                @pytest.mark.skipif(
                                    '__HostName__' in socket.gethostname(), reason="not supported on __HostName__"
                                )
                            結果表示:
                                テスト結果(VSCode の拡張機能）にスキップしたことは表示されます
                        関数を呼び出してスキップします: |  #focus: pytest.skip
                            pytest.skip("unsupported configuration")
                        ファイルやフォルダーをスキップします:
                            手順: collect_ignore 配列変数にスキップするファイルのパスを設定します
                            結果表示:
                                テスト結果(VSCode の拡張機能）にスキップしたことは表示されません。
                                テスト結果にスキップしたフォルダーやファイルは表示されません。
                            サンプル:
                                ___/network/test_connect.py をスキップする場合:
                                    ___/network/conftest.py : |
                                        collect_ignore = ["test_connect.py"]
                        xfail:  #// 失敗するテストをパスしたと偽ります。公式には予期された失敗と書かれていますが、その場合通常スキップします  #search: pytest skip
                            公式: #ref: https://docs.pytest.org/en/6.2.x/skipping.html#xfail-mark-test-functions-as-expected-to-fail
                            (@pytest.mark.xfail): |  #keyword:
                                import pytest

                                @pytest.mark.xfail                  #TypeError: setup_method() missing 1 required positional argument: 'test_fixture'
                                def test_will_be_failed(self):
                                    __Code__
                            #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s09_setup/s9_setup_and_fixture_test.py:csv#class TestOfSetUpAndFixture, @pytest.mark.xfail
                    デバッガーを動かします:  #search: pytest launch.json
                性能解析:  #// 遅い処理を見つけます
                    各テストの実行時間: pytest コマンド --durations オプション  #search: pytest options
                    プロファイリング:  #keyword: pytest-profiling
                        pytest + pytest-profiling + Poetry の場合:
                            Graphviz をインストールします:
                                - sudo yum install graphviz
                                - poetry add graphviz -D
                                #search: Graphviz
                            pytest-profiling をインストールします:
                                - poetry add pytest-profiling -D
                            テストを実行します:
                                pytest コマンドに --profile-svg オプションを追加指定します:
                                    pytest tests/test_sample.py --profile-svg
            画面:
                Testing ビュー (VSCode):  #search: start Python testing view
            コマンド: #keyword: pytest command
                公式: #ref: https://docs.pytest.org/en/7.1.x/reference/reference.html?highlight=command#command-line-flags
                書式:
                    -   pytest __TestCodeFileOrFolderRelativePath__
                    -   pytest __Options__ __TestCodeFileOrFolderRelativePath__ __Options__
                    #// __TestCodeFileOrFolderRelativePath__ は Windows でもフォルダーの区切りは / にしてください。 複数指定でき、指定順に実行します
                実行します: pytest -sqvv --setup-show  __TestCodeFileOrFolderRelativePath__  -k __TestNamePattern__
                    #// pytest.ini の addopts に指定したオプションは、コマンドに指定しなくても有効です
                デバッグします: #search: pytest debug
                オプション:  #keyword: pytest options  #ref: https://docs.pytest.org/en/6.2.x/reference.html#command-line-flags
                    実行関係:
                        -v, --verbose:  #// 詳細表示しながらテストを実行します。 v を2つ指定すると、実行したテスト関数名も表示されます
                        -k __TestNamePattern__:  #// テスト対象を指定します  #keyword: pytest -k
                            - テストの対象とする クラス名、メソッド名、またはモジュール名（フォルダー名）、拡張子なしファイル名。
                            - and で複合条件を指定できます。
                            - my_module_x/file.py::Test_example の場合、 -k "module_x and _example" はマッチします。
                        --setup-show:  #// Fixture の作成・削除したタイミングを表示します
                        -sq:  #// 標準出力や詳細を表示します
                            #search: pytest print
                        --capture=____:  #// 標準出力をキャプチャーするかどうか
                            デフォルト: |  #// キャプチャーして、失敗したときだけ後でまとめて表示されます。テストの最後で例外を発生させれば表示できます。
                                >       raise ValueError()
                                E       ValueError
                                services/test.py:96: ValueError
                                ------------------------------------------------------------- Captured stdout setup -------------------------------------------------------------
                                print in fixture
                                ------------------------------------------------------------- Captured stdout call --------------------------------------------------------------
                                print in test
                                print in test
                            --capture=no: #// 標準出力の内容が即時表示されます。 ただし、一部表示されないことがあります
                            #search: pytest print
                        --durations=____: 通常 --durations=0 を指定します。 =5 で遅いテストのワースト5を表示します。
                            一瞬(0.01秒以下)で終わるテストも表示する場合、-vv オプションも指定します。
                    フィクスチャ関係:
                        --fixtures-per-test, --fixtures:  #search: pytest --fixtures-per-test
                    testinfra, Ansible 関係:
                        --hosts オプション:  #search: pytest --hosts  #// testinfra v3 では使えます
                            #snip:
                                --hosts=ansible://__AnsibleHostGroup__?ansible_inventory=__InventoryFolderPath__
                        --inventory-file オプション:  #// testinfra v3 では使えません
                    追加オプション, pytest_addoption: #keyword: pytest_addoption
                        コマンド:
                            pytest --fruit banana
                        コード: |
                            def pytest_addoption(parser):
                                parser.addoption('--fruit', action='store', default='ham', help='fruit name: apple, grape, banana, etc')
                                parser.addoption('--season', action='store_true', help='fruit season now')
                Use -v to get the full diff の対処法:  #// ...Full output truncated (7 lines hidden), use '-vv' to show も同じ
                    VSCode の Testing ビューの場合:
                        __Project__/pytest.ini : |
                            [pytest]
                            addopts = -vv
                    コマンドラインの場合:
                        pytest -vv __TestCodeFileOrFolderRelativePath__  -k __TestNamePattern__
                テストのスキップ:  #search: pytest skip
            概念:
                プラグイン: #keyword: pytest plug in
                    一覧: |  #focus: plugins
                        $ pytest --version
                        pytest 6.2.5
                        pluggy 0.13.1
                        plugins: xdist-2.2.1, forked-1.3.0, hypothesis-6.14.0, ...
                    インストール:
                        sudo pip install pytest-xdist または sudo pip install xdist
                    プラグインではなくなったパッケージ:  #// pytest --version で表示されなくても pip show __Package__ で表示されれば使えます
                        - testinfra  #search: Python testinfra
                built-in pytest fixture:
                    monkeypatch: #keyword: Python monkeypatch  #ref: https://stackoverflow.com/questions/37193992/how-do-i-import-the-pytest-monkeypatch-plugin
                        built-in pytest fixture のモック
                pytest-testinfra: #search:
            ファイル:
                test.py ファイル, テスト コード:  #keyword: pytest test.py  #// _____test.py ファイル または test_____.py ファイル
                    ファイル名と関数名の制限: #keyword: pytest test function
                        #// 以下を満たす必要があります
                        ファイル名: #// 以下のいずれか
                            - __Project__/__TestRootPath__/__TestGroupName___test.py
                            - __Project__/__TestRootPath__/test___TestGroupName__.py
                            - __Project__/__TestRootPath__/__SubFolders__/__TestGroupName___test.py
                            - __Project__/__TestRootPath__/__SubFolders__/test___TestGroupName__.py
                            #// ファイル名 test.py はテストコードになりません。
                        関数名: #// 以下のいずれか
                            - test
                            - test___TestName__
                            #// __TestName___test はできません
                        __Project__/.vscode/settings.json :
                            サンプル: |
                                    {
                                        "python.testing.pytestArgs": [
                                            "__TestRootPath__"
                                #// "__TestRootPath__" はコンマ区切りで複数指定できます
                            __TestRootPath__ の例:
                                - .
                                - test
                                - example/test
                        引数:  #search: pytest test function argument
                    テスト コード の基本:  #// テストが関数の場合
                        test_increment:  #keyword: pytest test_increment
                            inc_dec_test.py : |  #focus: test_increment,  increment  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s01_test_function/inc_dec_test.py
                                import inc_dec    # The code to test

                                def test_increment():
                                    assert inc_dec.increment(3) == 4

                                def test_decrement():
                                    assert inc_dec.decrement(3) == 4
                            inc_dec.py : |  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s01_test_function/inc_dec.py
                                def increment(x):
                                    return x + 1

                                def decrement(x):
                                    return x - 1
                    各種 テスト コード のサンプル:  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s01_test_function
                    assertion, チェック:  #keyword: Python pytest assertion
                        辞書や配列の比較: #// assert に書いた == は、内容も比較します
                            辞書: |
                                dic1 = {'a':1, 'b':2}
                                dic2 = {'a':1, 'b':2}
                                dic3 = {'a':1, 'b':3}

                                assert dic1 == dic2  #// OK
                                assert dic1 != dic3  #// OK
                                assert dic1 == dic3  #// NG
                            配列: |
                                arr1 = [1,2]
                                arr2 = [1,2]
                                arr3 = [2,1]

                                assert arr1 == arr2  #// OK
                                assert arr1 != arr3  #// OK
                                assert arr1 == arr3  #// NG
                        関数呼び出しのチェック: #keyword: unittest call,  pytest call
                            object.method.assert_has_calls( [mock.call(3, 4, key=DataClass('aaa', 'bbb')) ], any_order=False)
                            #search: assert_has_calls
                        公式: #ref: https://docs.pytest.org/en/7.1.x/how-to/assert.html?highlight=assert
                    引数: #keyword: pytest test function argument  #// テスト関数の引数の意味
                        #↓ 以下は場合分けされていますが、定義が見つかる前にどの場合にマッチするか分からないので、最悪の場合すべて試すことになります
                        parametrize の場合:  #search: pytest.mark.parametrize
                            引数の定義を探すには、関数定義があるファイルの上方向に検索します
                        ユーザー定義フィクスチャの場合:  #search: pytest fixture  #// 処理だけが行われる可能性があります
                            フィクスチャを探します:
                                - 引数名に一致する何かが関数の外のどこかに定義されています。 def __ArgumentName__ で grep すると見つかります
                                - 検索ノイズ（違うものにヒットすること）を少なくするため、長い名前を付けるとよいでしょう
                                        #ref: ${typrm_files}/ref/Python-AI.yaml#label: fixture name
                            特定のフィクスチャ:
                                静的に探す場合 >> fixture コマンドを使う場合: #keyword: Python fixture command script
                                    #ref: https://qiita.com/Takakiri/items/59b32f63d5e6b6b8f0b9
                                静的に探す場合 >> grep を使う場合:  #// fixture シェルスクリプト
                                    fixture シェルスクリプト: #keyword: fixture shell script,  FindPytestFixture
                                        使い方:
                                            fixture __Symbol__  __TestSourceFilePath__
                                        出力例: |  #focus: conftest.py:40
                                            $ fixture fixture_example  /home/user1/project/tests/db/test.py
                                            /home/user1/project/tests/db/test.py
                                            /home/user1/project/tests/db/conftest.py: Not found the file
                                            /home/user1/project/tests/conftest.py
                                            /home/user1/project/tests/conftest.py:40:    def fixture_example():
                                            /home/user1/project/conftest.py: Not found the file
                                            /home/user1/conftest.py: Not found the file
                                            /home/conftest.py: Not found the file
                                        コード:
                                            #ref: ${GitHub}/MyPrivateCode/typrm_files/Qiita下書き/14_PythonFixture/14_PythonFixture.md#FindPytestFixture
                                    conftest.py:  #keyword:
                                        テストを行う .py ファイルがあるフォルダーの親フォルダー（またはその親フォルダー…）にある
                                        conftest.py ファイルで定義されていることがあります。
                                        他のフォルダーで定義されているフィクスチャは使われません。
                                        conftest.py という名前のファイルに書いたフィクスチャは、import しなくても参照できます。
                                        - project/group/case/test_example.py
                                        - project/group/case/conftest.py
                                        - project/group/conftest.py
                                        - project/conftest.py
                                動的に探す場合 >> pytest --setup-show を使う場合:
                                    概要: 実行時のログにフィクスチャの名前が表示されます。
                                        定義位置に合わせてネストして表示されます
                                    ログのサンプル: |
                                        SETUP    S object
                                            SETUP    F data
                                                SETUP    F answer
                                拡張機能 pytest-fixtures を使う場合:  #// Visual Studio Code の拡張機能
                                    方法:
                                        1. VSCode で test____.py を開き、ファイル内検索をします:
                                        2. pytest-fixtures をインストールして、Ctrl を押しながらテスト関数の引数をクリックします:
                                            #// see-below: pytest-fixtures
                                        3. pdb.set_trace を使ってオブジェクトの Python パッケージを調べます: |
                                            (Pdb) p obj
                                            <testinfra.host.Host object at 0x777777777777>
                                                #// testinfra パッケージです
                                    Visual Studio Code の拡張機能: #// 非推奨：使えるものが見つかっていないため
                                        pytest-fixtures, Pytest IntelliSense:
                                            - conftest.py で定義されたフィクスチャの定義にジャンプすることができます
                                            - 同じファイルで定義したフィクスチャにはジャンプできません
                            フィクスチャの一覧: #keyword: pytest --fixtures-per-test
                                コマンドの場合:
                                    パスを表示します:
                                        pytest --fixtures-per-test  __Parameters__
                                    ドキュメントを表示します:
                                        pytest --fixtures  __Parameters__
                                    参考:
                                        pytest: #// __Parameters__ #search: pytest command
                                設定ファイルの場合:
                                    __Project__/pytest.ini : |
                                        addopts = --setup-show --fixtures -k Test_example
                        pytest 定義の場合:  #search: pytest built-in fixtures
                            pytest が定義したフィクスチャは typrm やネットで検索すると見つかるかもしれません
                        pytest-testinfra 定義の場合:
                        灰色の引数:
                            処理だけ行うフィクスチャは関数内で参照されないので灰色になってしまいますが、その引数は必要です
                    前処理と後処理:  #// テスト環境を設定します
                        前処理:  #// テスト環境を設定します
                            setup_method: #keyword:  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s09_setup/s9_test.py
                                書式:
                                    - def setup_method(self):
                                    - def setup_method(self, method):  #// method 引数が必要な場合
                                実行順序:
                                    複数の test メソッドがある場合:
                                        コード: |
                                            class Test:
                                                def setup_method(self, method):
                                                def test_1_1(self):
                                                def test_1_2(self):
                                        実行順序:
                                            setup_method
                                            test_1_1
                                            setup_method
                                            test_1_2
                                    クラスがネストしている場合:  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s09_setup/s9_test.py#class TestOfNestedSetUp
                                        コード: |
                                            class Test1:
                                                def setup_method(self, method):
                                                class Test2:
                                                    def setup_method(self, method):
                                                    def test_1_1(self):
                                        実行順序:
                                            setup_method (Test1)
                                            setup_method (Test2)
                                            test_1_1
                                注意 >> setup_method の引数にフィクスチャを渡すことはできません:
                                    サンプル: |  #focus: test_fixture
                                        @pytest.fixture(autouse=True)
                                        def test_fixture(self):
                                            ＿＿＿

                                        def setup_method(self, method, test_fixture):  #// test_fixture is the error
                                            ＿＿＿
                                    #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s09_setup/s9_setup_and_fixture_test.py:csv#class TestOfSetUpAndFixture, def setup_method
                            フィクスチャ:  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s05_fixture/s5_test.py
                        後処理（終了処理）:
                            teardown_method: #keyword:  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s09_setup/s9_test.py#def teardown_method
                            フィクスチャ:
                                #search: pytest fixture yield
                                #search: @pytest.mark.usefixtures
                    フィクスチャ: #keyword: pytest fixture,  Python fixture,  @pytest.fixture
                        公式:
                            #ref: https://docs.pytest.org/en/latest/explanation/fixtures.html
                            #ref: https://docs.pytest.org/en/latest/how-to/fixtures.html
                        必要性, 注意点:
                            必要性:
                                - フィクスチャを使う必要性は、「複数のテストのグループで使うデータ」かつ「複数のグループで異なるデータ」に関してのみ
                            定義の参照:
                                - VSCode の定義へのジャンプができません  #ref: https://github.com/microsoft/pylance-release/issues/5718
                                    #ref: https://github.com/microsoft/pyright/discussions/2117
                                    #ref: https://github.com/microsoft/pylance-release/issues/3727
                            関数の外の処理:
                                - フィクスチャは変数（データ）の参照だけでなく、初期化処理や終了処理も含まれることがあります。get 関数に相当します
                                - シングルトンを返す get に比べて、終了処理も行われる点がフィクスチャの優位点です
                                - 処理のフィクスチャ（返り値が無い）が、淡色表示されてしまいます  #ref: https://github.com/microsoft/pylance-release/issues/1059
                                - conftest.py ファイルにある定義を見つけるのが難しい #ref: https://stackoverflow.com/questions/78256995/any-automated-way-to-view-a-network-of-pytest-fixtures-functions-defined-in-the
                        手順:
                            定義します:  #search: 
                            フィクスチャを探します:  #search: pytest test function argument
                            デバッグします:  #search: mock debug
                        機能:
                            後処理（終了処理）:  #keyword: pytest fixture yield
                                関連:  #search: teardown_method
                                サンプル: |  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s10_setup_by_fixture/conftest.py#yield
                                    import pytest

                                    @pytest.fixture
                                    def db():
                                        users = Users()
                                        yield users

                                        #// yield より下がテスト実行後に実行されます。オブジェクトが参照されなくなったタイミング？
                                        print()
                                例外発生時も実行されます:
                                addfinalizer を使う方法もあります:
                            前処理と後処理をするフィクスチャ:
                                autouse: #keyword: pytest autouse
                                    サンプル: |  #ref: c:\Users\m-toda\GitProjects\GitHub\MyPrivateCode\Python\try_pytest\s10_setup_by_fixture\s10_test.py#autouse
                                        class TestEachClass():
                                            @pytest.fixture(scope='function', autouse=True)
                                            def before_after_each(self):
                                                print("(beforeEach)")
                                                yield
                                                print("(afterEach)")

                                            def test_method_1(self):
                                                print("test_method_1")

                                            def test_method_2(self):
                                                print("test_method_2")
                                    scope='function' の場合の実行結果:
                                        (beforeEach)
                                        test_method_1
                                        (afterEach)
                                        (beforeEach)
                                        test_method_2
                                        (afterEach)
                                        #// class TestEachClass(): のサブクラスがあるときも、そのクラスのメソッドが呼ばれるたびに beforeEach afterEach します
                                    scope='class' の場合の実行結果:
                                        (beforeEach)
                                        test_method_1
                                        test_method_2
                                        (afterEach)
                                インスタンスを返さないフィクスチャ:
                                    関連:  #search: setup_method
                                    pytest.mark.usefixtures: #keyword: @pytest.mark.usefixtures
                                        参考: https://qiita.com/_akiyama_/items/9ead227227d669b0564e
                                        サンプル コード:
                                            それぞれのテスト(test_1, test_2)を呼び出す前に chdir します:  #focus: @pytest.mark.usefixtures, chdir
                                                conftest.py: |
                                                    import tempfile

                                                    @pytest.fixture
                                                    def cd_temporary():
                                                        with tempfile.TemporaryDirectory() as path:
                                                            os.chdir(path)
                                                            yield
                                                test.py: |
                                                    import pytest

                                                    @pytest.mark.usefixtures('cd_temporary')
                                                    class Test:

                                                        def test_1(self):

                                                        def test_2(self):
                        #↓ 概念, 構成
                        ユーザー定義のフィクスチャ: #keyword: define pytest fixture
                            基本サンプル: |  #focus: @pytest.fixture,  data
                                    import pytest

                                    @pytest.fixture
                                    def data():
                                        return {'a': 1, 'b': 2}

                                    def test(data):
                                        assert data['a'] == 1
                                        assert data['b'] == 2
                                #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/pytest
                                #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s05_fixture/s5_test.py
                            #↓ テストで定義するオブジェクト
                            インスタンスを返すフィクスチャ:
                                参考: #ref: https://qiita.com/_akiyama_/items/9ead227227d669b0564e
                                関連 >> モック: #search: return_value
                                前処理:
                                    pytest のフィクスチャはテストの前処理(DBのセットアップ、モックの作成など)をする関数です:
                                    テスト関数の引数（self以外）は、おそらくフィクスチャです:
                                    サンプル: |  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s05_fixture/s5_test.py#@pytest.fixture
                                        import pytest
                                        class Test_case:

                                            @pytest.fixture
                                            def db():
                                                users = Users()
                                                return users

                                            def test(db):  #// db メソッドの返り値が渡ります。引数名はメソッド名に合わせます
                                                assert db.get(1)['name'] == 'Bob'
                                    スコープ内のとき、フィクスチャの返り値は、pytest 内部でメモ化されます:  #search: fixture.スコープ
                                    スコープ外のとき、フィクスチャが毎回呼び出されます。たとえば返り値のオブジェクトは初期状態になります:
                            クラスを返すフィクスチャ:  #focus: @pytest.fixture, MySuper
                                サンプル: |
                                    import pytest

                                    @pytest.fixture
                                    def MySuper():
                                        return MySuper_
                                    class MySuper_:
                                        ____

                                    def local(self, MySuper):
                                        class Local(MySuper):
                                トラブルシューティング:
                                    - #// class fixtures not supported
                                        手順: pytest 実行時
                                        エラー: |
                                            ERROR  - ValueError: class fixtures not supported (maybe in the future)
                                        対処:
                                            クラスを返す関数をフィクスチャにします（上記）
                            #↓ モック
                            関数をモックに置き換えるフィクスチャ:
                                #search: pytest mock fixture
                                #search: mock.patch.object pytest fixture
                            クラスをモックに置き換えるフィクスチャ:
                                #search: Python class mock
                            #↓ 補足的に定義するもの
                            ファクトリ フィクスチャ: #keyword: pytest factory fixture  #// 引数を持つフィクスチャ。関数のフィクスチャ
                                概要: 引数を持つフィクスチャ。 引数はテストコードが指定します
                                サンプル プロジェクト:  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s13_factory_fixture/s13_test.py
                                関連: #search: Python unittest side_effect
                            パラメタライズド フィクスチャ:  #keyword: pytest params fixture
                                パラメーターはフィクスチャが指定します:
                                サンプル: |  #focus: params
                                    import pytest

                                    @pytest.fixture(params=[('Tom', 10), ('Bob', 15), ('Alice', 12)])
                                    def student(request):
                                        return Student(request.param[0], request.param[1])
                                関連:
                                    (@pytest.mark.parametrize):  #search: pytest.mark.parametrize
                                    parametrize を受け取るフィクスチャ:  #search: pytest parametrize fixture
                        組み込みフィクスチャ: #keyword: pytest built-in fixtures  #// capfd, tmpdir, patch
                            request: #keyword: pytest request fixture  #// pytest が定義
                                config:
                                    コマンドのオプションを取得します:
                                        path = request.config.getoption('--rpm-versions')
                            pytestconfig:
                            capfd, tmpdir など: https://docs.pytest.org/en/6.2.x/fixture.html#fixtures
                            patch フィクスチャ:  #keyword: Python pytest patch mock fixture
                                #search: pytest mock.patch
                            monkeypatch:
                            capsys:
                            tmp_path:
                        スコープ:  #keyword: fixture.スコープ  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s10_setup_by_fixture/conftest.py#scope
                            pytest のスコープによって、メモ化される粒度を function, class, module(file), session に設定できます: |
                                @pytest.fixture(scope='module')  #// デフォルトは function
                        conftest.py: #search: conftest.py
                        オーバーライド:  #keyword: pytest fixture override
                            親フォルダーにあるフィクスチャを少し変更したフィクスチャを定義します:
                                #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s23_override/1_based_on_parent
                                #focus: class_A_instance
                                ../conftest.py: |  #search conftest.py
                                    import @pytest
                                    from unittest.mock import create_autospec

                                    @pytest.fixture
                                    def class_A_instance(self):
                                        mock_A = create_autospec(ClassA, instance=True, spec_set=True)
                                        return  mock_A
                                ./test.py: |
                                    class Test_A:

                                        @pytest.fixture
                                        def class_A_instance(self, class_A_instance):
                                            class_A_instance.method.return_value = 1
                                            return class_A_instance
                            親フォルダーのフィクスチャの引数に、子フォルダーのフィクスチャを渡します:
                                #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s23_override/2_replace_child
                                #focus: my_dish,  my_food
                                conftest.py: |  #search conftest.py
                                    import pytest

                                    @pytest.fixture
                                    def my_food() -> str:
                                        return "beaf"

                                    @pytest.fixture
                                    def my_dish(my_food) -> str:
                                        return "roast " + my_food
                                ./test.py: |
                                    import pytest

                                    @pytest.fixture
                                    def my_food() -> str:
                                        return "pork"

                                    def test(my_dish: str):
                                        assert  my_dish == "roast pork"
                    表形式データ:
                        parametrize:  #// パラメトライズ。表形式データを使って複数回テスト関数を呼び出します  #keyword: @pytest.mark.parametrize
                            関連:
                                parametrize と parameterize:
                                    どちらも辞書に載っているか載っていません:
                                        Weblio: #ref: https://ejje.weblio.jp/content/parametrize
                                        Oxford: #ref: https://www.google.com/search?q=site%3A+oxfordlearnersdictionaries.com+%22parametrize%22
                                パラメタライズド フィクスチャ:  #search: pytest params fixture
                            教科書的基本形:
                                サンプル コード: |  #focus: parametrize, expect  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s07_parametrizing_fixtures/1_parametrize/s7_test.py#mark.parametrize
                                    import pytest

                                    @pytest.mark.parametrize(
                                        "a, b, expect", [
                                        (2, 5, 10),
                                        (3, 6, 18)
                                    ])
                                    def test(a, b, expect):
                                        #// a = 2,  b = 5,  expect = 10
                                        #// a = 3,  b = 6,  expect = 18
                                        #// 以上の引数が渡ります。 test は複数回呼ばれます
                            オブジェクトにする場合: #🌟 #keyword: @pytest.mark.parametrize object  #// インテリセンスが使えます  #search: Python @dataclass
                                サンプル コード: |  #focus: parametrize, expect
                                    from dataclasses import dataclass
                                    import pytest

                                    class Test_Example:
                                        @dataclass
                                        class _example_test_data:
                                            a: int
                                            b: int
                                            c_answer: int
                                        @pytest.mark.parametrize(
                                            "example_test_data", [
                                                {"a": 2, "b": 5, "c_answer": 10},
                                                {"a": 3, "b": 6, "c_answer": 18},
                                            ])

                                        def test(self, example_test_data):
                                            test_data = self._example_test_data(**example_test_data)
                                            #// test_data.a = 2,  test_data.b = 5,  test_data.c_answer = 10
                                            #// test_data.a = 3,  test_data.b = 6,  test_data.c_answer = 18
                                            #// 以上の引数が渡ります。 test は複数回呼ばれます
                            １つの引数にまとめます:
                                辞書を使う場合:  #search: @pytest.mark.parametrize object
                                fixture を使う場合:  #// 分かりにくい
                                    サンプル コード: |  #focus: test, parameters, name, parametrize
                                        import pytest

                                        class Test:
                                            @pytest.fixture
                                            def parameters(self, name: str, number: int):
                                                return {
                                                    'name': name,
                                                    'number': number,
                                                }
                                            @pytest.mark.parametrize('name, number', [
                                                ('Mario', 22),
                                                ('Taro', 34),
                                            ])

                                            def test(self, parameters):
                                                print(parameters)
                            ケース名, 第3引数: |
                                import pytest

                                @pytest.mark.parametrize(
                                    "input,expected",  # 第1引数: パラメータ名
                                    [(1, 2), (2, 4), (3, 6)],  # 第2引数: テストケース
                                    ids=["case1", "case2", "case3"]  # 第3引数: 各テストケースのID
                                )
                                def test_double(input, expected):
                                    assert input * 2 == expected
                        parametrize を受け取るフィクスチャ: #keyword: pytest parametrize fixture,  pytest parameters fixture
                            サンプル コード: |  #focus: my_food  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s07_parametrizing_fixtures/2_parametrize_factory/s7b_test.py#mark.parametrize
                                import pytest

                                @pytest.fixture
                                def my_dish(my_food) -> str:
                                    return "roast_" + my_food

                                #// parametrize is not parameterize
                                @pytest.mark.parametrize(
                                    "my_food, expected", [
                                    ("beaf", "roast_beaf"),
                                    ("pork", "roast_pork")])
                                def test(my_dish: str, expected: int):
                                    assert my_dish == expected
                        パラメタライズド フィクスチャ:  #search: pytest params fixture
                    例外のテスト: |  #keyword: pytest.raises  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s12_exception/s12_exception_test.py#def test_of_expected_exception()
                        def test_of_expected_exception_with_as():
                            with pytest.raises(ValueError) as e:
                                _ = target(0)  #// This will raise an exception
                            #// 例外が発生したら続きを実行します
                            assert str(e.value) == 'target argument must not be 0'
                    失敗するテスト:  #search: @pytest.mark.xfail
                    参考: #ref: https://docs.pytest.org/en/6.2.x/reference.html?highlight=pytest%20raises#pytest-raises
                    テストのスキップ:  #search: pytest skip
                    その他:  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest
                .ini ファイル: #keyword: pytest.ini  #ref: https://docs.pytest.org/en/6.2.x/customize.html#pytest-ini
                    サンプル: |  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/pytest.ini
                        [pytest]
                        DJANGO_SETTINGS_MODULE = _settings
                        addopts = --setup-show -k Test_exmple
                    説明:
                        DJANGO_SETTINGS_MODULE: Django の settings.py のファイル名（拡張子なし）
                        addopts: pytest コマンドに渡すオプション  #search: pytest options
                settings.json (VSCode): #keyword: pytest settings.json
                    サンプル: |
                        {
                            "python.testing.pytestArgs": [  // pytest コマンド に渡す引数
                                "tests",
                            ],
                            "python.testing.pytestEnabled": true,
                            "python.testing.pytestPath": "poetry run pytest"
                    pytestArgs:
                        テスト対象のフォルダー。複数指定可能
                    pytestPath:
                        テスト実行時のコマンド。 これを書かなくても多くのものはテストを実行できます。
            コード:  #search: pytest test.py
            トラブルシューティング (pytest):  #keyword: pytest Testing error,  VSCode debug pytest
                環境構築 >> Testing ビューにテスト項目が一覧されない場合:
                    Testing ビューのボタンが表示されない場合:  #// VSCode >> Testing（フラスコ ボタン：左）
                        Python 拡張機能をインストールします:
                            VSCode >> Extensions（ボタン：左）
                        pyproject.tomi などのファイルがあるフォルダーを開きます:
                            VS Code >> File >> Open Folder >> pyproject.tomi などのファイルがあるフォルダー
                    Configure Python Tests ボタンが Testing ビューに表示されたままの場合:
                        pytest モジュールを含む仮想環境を設定します:
                            確認方法:
                                VSCode >>（新しいターミナル）>> which pytest
                                    #// 想定する仮想環境の中の pytest が表示されること
                            対処例:
                                __Project__/.venv フォルダーに仮想環境を作って使う場合:
                                    __Project__/.venv フォルダーを作ります:  #search: pipenv sync
                                    VSCode が認識している仮想環境を __Project__/.venv に設定します:  #search: VSCode venv
                        検出されるように テスト ファイル を作ります:
                            サンプル:  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s00_simple/simple_test.py
                            対処:
                                - ファイル名の末尾を _test.py にします
                                - 関数名を test から始めます
                                - クラス名を Test から始めます
                                #search: pytest test function
                        __init__.py を作ります:
                            テストのコードが書かれたファイルがあるフォルダーに __init__.py ファイルを空で作ります
                            #ref: https://code.visualstudio.com/docs/python/testing#_test-discovery
                    エラー「Pytest Discovery Error. Error discovering pytest tests (see Output > Python)」が Testing ビューに表示される場合:
                        settings.json をリセットします:
                            __Project__/.vscode/settings.json の python.testing.____ を削除します。
                            python.testing.____ だけの場合は settings.json ファイルを削除します。
                        Configure Python Tests ボタン:
                            Configure Python Tests >> pytest >> __TestFolder__
                        pyproject.toml ファイルがある場合:
                            テスト対象のフォルダーが複数あるか確認します:  #focus: ./my_test ./services
                                __Project__/pyproject.toml : |
                                    [tool.taskipy.tasks]
                                    test = "pytest ./my_test ./services"
                            テスト対象のフォルダーを複数指定します:
                                __Project__/.vscode/settings.json : |
                                    {
                                        "python.testing.pytestArgs": [
                                            "./my_test", "./services"
                                        ],
                                        "python.testing.unittestEnabled": false,
                                        "python.testing.pytestEnabled": true
                                    }
                        エラーになる場合:  #// Pytest Discovery Error. Error discovering pytest tests (see Output > Python)
                            リロードします:
                                VSCode >> Testing（フラスコ ボタン：左）>> Refresh Tests（TESTING の右上）
                            ルート フォルダー の設定をリセットします:
                                __Project__/.vscode/settings.json の python.testing.____ を削除して、VSCode を再起動します
                            Python の ビルド ログ を表示します:
                                VSCode >> 端末ビュー（右下）>> Output タブ >> Python（端末の右上のプルダウン）>>
                                「=== ERRORS ===」で Python の ビルド ログ を検索
                            settings.py が要求された場合:
                                ログ: |
                                    Requested setting USE_I18N, but settings are not configured.
                                    You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.
                                対処:
                                    __Project__/.envrc ファイルがある場合:  #keyword: .envrc 環境変数
                                        .envrc ファイルで定義されている環境変数を、__Project__/.env にコピーしてください。
                            Error importing plugin "vscode_pytest":
                                ログ: |
                                    ImportError: Error importing plugin "vscode_pytest": cannot import name 'Literal' from 'typing'
                                対処:
                                    VSCode の拡張機能は、Python 3.7 に対応する最後のバージョン 2024.2.1 や 2023.14.0 を使ってください。
                                    それでもまだエラーが出る場合は他を参照。
                                #ref: https://github.com/microsoft/vscode-python/issues/23179
                    __Project__/.envrc ファイルがある場合:
                        .env ファイルを作ります:
                            .envrc ファイルから環境変数を設定している部分だけ .env ファイルにコピーします
                            ただし、変数の左の export は書かないでください。
                    一部 Testing ビューに表示されない場合:
                        全テストをするとき:
                            pytest コマンドで実行してください。-vv オプションを指定すると、テストの一覧を正しく表示できます
                        デバッグするとき:
                            問題がある .py ファイルの中について、周辺のテストを一時的にコメントアウトします
                拡張機能の対応 Python バージョン: #search: VSCode Python extension
                #search: pytest debug
                #search: pytest logger trouble
                Testing ビューに pytest のツリーが表示されない:  #keyword: Python testing view trouble
                    手順: VSCode >> Python Testing 拡張機能（左）>> リロード
                    対処A:
                        __Project__/.vscode/settings.json の pytestArgs の値を修正します。
                        Testing ビューを使わないでテストを実行するコマンドを参考に修正します。
                    対処B:
                        __Project__/.env:
                            PYTHONPATH=${PYTHONPATH}:${PWD}
                    対処C: 一部だけテストしてみます
                    対処D: pytest をコマンドで実行して、エラーメッセージが出たらそれに対処します
                    対処E: VSCode >> F1 キー >> Python Select Interpreter >>（pytest がある仮想環境のパス）
                    対処F: どんなコマンドを実行したらエラーになったかを、Output ビューで確認して、ターミナルで実行します。
                        ./.venv/bin/python ~/.vscode-server/extensions/ms-python.python-2024.14.1-linux-x64/python_files/testing_tools/run_adapter.py discover pytest -- --rootdir . -s --cache-clear .
                        import するモジュールは、__Project__/.venv に入れます。 ../../../.pyenv/ の python を実行したように見えてもです。
                    対処H: 拡張機能がサポートしている Python のバージョンに合わせて、拡張機能をダウングレードします  #search: VSCode Python extension
                    対処I: #search: pytest debug
                テストがスキップされる:  #keyword: pytest skipped warning
                    手順: pytest コマンド
                    エラー: |
                        tests/test.py sssss
                    対処:
                        コマンド:
                            pytest -rs -vv  #// 詳細を表示します
                        got empty parameter が表示される場合:
                            メッセージ サンプル: |
                                SKIPPED [1] tests/test.py: got empty parameter set ['_testinfra_host'], function test_is_installed at
                                    /home/user1/tests/test.py:9
                            対処:  #search: pytest --hosts
                                --hosts オプションに指定した __AnsibleHostGroup__ と __InventoryFolderPath__ が正しいことをチェックしてください。
                                __AnsibleHostGroup__ のハイフンとアンダースコアの違いに注意してください。
                ansible_inventory を参照できない:  #keyword: --hosts=ansible
                    手順: pytest tests  --hosts=ansible://server-?ansible_inventory=/home/user1/hosts/local-1  -p  no:warnings  --inventory-env=local-1 
                    エラー: |
                        ERROR: usage: pytest [options] [file_or_dir] [file_or_dir] [...]
                        pytest: error: unrecognized arguments: --hosts=ansible://server-?ansible_inventory=/home/user1/hosts/local-1
                        unrecognized arguments --hosts
                    対処:
                        pip install testinfra
                Testing ビューの テスト関数名 をクリックしたら The editor could not be opened because file was not found.:
                    手順: VSCode >>（pytest）Testing ボタン（左）>>（テスト関数名）
                    エラー:
                        Editor: |
                            The editor could not be opened because file was not found.
                        DEBUG CONSOLE: |
                            collected 1 item

                            tests-integ/rest/test_rest.py F

                            =================================== FAILURES ===================================
                            ______________________ ApiTest.test_1st_success ______________________

                            self = <test_rest.ApiTest testMethod=test_1st_success>

                            >   ???
                            E   FileNotFoundError: [Errno 2] No such file or directory: 'tests/rest/data/test_1st_success.json'

                            /home/user1/project/tests/rest/test_rest.py:12: FileNotFoundError
                    対処A:
                        Testing ビュー >> テストのクラス名 
                        テストのメソッド名を一時的に変えて、保存します
                        Testing ビューをリロードします
                        テストのメソッド名を戻して、保存します
                        同じ .py ファイルのすべてのメソッド名はこれで直ります
                        他の .py ファイルはその都度必要
                    対処B: | #// 未確認
                        pytest --cache-clear
                        ModuleNotFoundError: No module named エラーになる環境でしか試しておらず、その環境では改善は見られなかった
                    再現:
                        __Project__/tests フォルダーの名前を tests から別の名前に変えます
                        __Project__/.vscode/settings.json の pytestArgs の値を変えます
                        __Project__/pyproject.toml があれば tool.taskipy.tasks の値を変えます
                        Testing ビュー >> リロード
                        Testing ビュー >> テストのメソッド名 >> Go to Test  #// エラー
                Error discovering pytest tests (see Output > Python):
                    手順: VSCode >> Python Testing 拡張機能（左）>> リロード
                    エラー: |
                        Pytest Discovery Error [__Project__]
                        Error discovering pytest tests (see Output > Python)
                    対処:  #search: pytest debug
                AppRegistryNotReady 例外:
                    手順: tox で pytest 実施
                    ログ: |
                        django.core.exceptions.AppRegistryNotReady: The translation infrastructure cannot be initialized before the apps registry is ready. Check that you don't make non-lazy gettext calls at import time.
                    対処:
                        __TestRootFolder__/conftest.py : |
                            import os
                            import django

                            def pytest_configure():
                                os.environ.setdefault('DJANGO_SETTINGS_MODULE', '__DjangoSettingFilePeriodPath__')
                                django.setup()
                        __DjangoSettingFilePeriodPath__:
                            website.settings など  #// __Project__/website/settings.py
                Python:;; Debug All Tests が選べない:
                    手順: |
                        VSCode >> F1 キー >> Python: Debug All Tests と入力
                    症状: |
                        Python: Debug All Tests が選べない
                    対処: |
                        Python: Debug Test Method を選んでみてください
        testinfra:  #keyword: Python testinfra,  pytest-testinfra,  Python SSH ヘルス チェック  #search: ヘルス チェック
            #// pytestフレームワーク上に構築されていますが、独立したプロジェクトです
            操作:
                インストール状態:  #// サーバーのインストール状態をチェックします
                    参考: https://qiita.com/ao_log/items/c7b6eeb292e5a6c26a19
                    サンプル:
                        def test_passwd_file(host):
                            passwd = host.file("/etc/passwd")
                            assert passwd.contains("root")
                            assert passwd.user == "root"
                            assert passwd.group == "root"
                            assert passwd.mode == 0o644

                        def test_nginx_is_installed(host):
                            nginx = host.package("nginx")
                            assert nginx.is_installed
                            assert nginx.version.startswith("1.2")

                        def test_nginx_running_and_enabled(host):
                            nginx = host.service("nginx")
                            assert nginx.is_running
                            assert nginx.is_enabled
                Ansible 対応:  #// Ansible の インベントリー ファイル を参照します
                    pytest tests  --hosts=ansible://server-?ansible_inventory=/home/user1/hosts/local-1
                    #search: Python testinfra --hosts Ansible
            コマンド:  #// pytest コマンド に機能追加がされるようです
                （pytest のオプション）:  #search: pytest options
                --hosts オプション: #keyword: Python testinfra --hosts,  pytest --hosts  #// host 変数で参照できるホスト
                    _: host 変数で参照できるホストがどれであるかをしてします  #search: testinfra host
                    テストを実行するホスト:
                        （省略時）: local
                        SSH が使える指定のサーバー: --hosts=ssh://user@192.168.1.100
                            #// pytestはSSH経由で指定されたホスト（192.168.1.100）にuserというユーザー名で接続し、
                            #// そのホスト上でインフラストラクチャテストを実行します。
                        指定のコンテナー: --hosts=docker://__ContainerName__
                        Ansible インベントリにあるサーバー: #keyword: Python testinfra --hosts Ansible  #search: ansible inventory file
                            #// Ansible のインベントリーに登録してあるホストが host 変数の対象になります
                            グループ:
                                pytest --hosts=ansible://__HostName__?inventory=__PathToInventoryFile__
                            ホスト グループ:
                                pytest --hosts=ansible://__HostGroup__?inventory=__PathToInventoryFile__
                            インベントリ ファイル が不要な環境の場合:
                                pytest --hosts=ansible://__HostName__  など
                            #search: Ansible host group
                            #search: ansible inventory file
                    動作内容:
                        - Pythonテストファイル自体はリモートホストに転送されません
                        - テスト内で使用されるhost.package(), host.service(), host.file()などの各メソッドが、
                            必要に応じてリモートホストでコマンドを実行します。
                            host.package("nginx").is_installed は、リモートで rpm -q nginx や dpkg -l nginx などを実行します
            コード >> モジュール:  #// フィクスチャです  #search: pytest fixture
                host 変数: #keyword: testinfra host  #ref: https://testinfra.readthedocs.io/en/latest/modules.html#host
                    サンプル コード: |
                        def test_example(host):
                            nginx = host.package("nginx")
                            assert nginx.is_installed
                            assert nginx.version.startswith("1.2")  #// ホストにインストールされているパッケージのバージョンをチェックします
                    package: #keyword: host.package  #ref: https://testinfra.readthedocs.io/en/latest/modules.html#testinfra.modules.package.Package
                        version: #keyword: testinfra host package version  #ref: https://testinfra.readthedocs.io/en/latest/modules.html#testinfra.modules.package.Package.version
                            #    return self.check_output('rpm -q --queryformat="%%{VERSION}" %s', self.name)
                                #ref: https://github.com/pytest-dev/pytest-testinfra/blob/main/testinfra/modules/package.py#L179
                            rpm -q:  #search: RPM version list
                        release: #keyword: testinfra host package release  #ref: https://testinfra.readthedocs.io/en/latest/modules.html#testinfra.modules.package.Package.release
                    どのホストか:  #search: Pytest testinfra --hosts
文法・ライブラリ: #keyword: Python library  #// Python  #ref: https://docs.python.org/3.11/reference/index.html
    コメント: #keyword: Python comment
        記号: # comment
        ブロック コメント: ありません  https://stackoverflow.com/questions/675442/how-to-comment-out-a-block-of-code-in-python
        ブロック コメント の代わり:
            三重引用符: |   #// うまくいかないことがあります
                """
                    __Comment__
                """
        docstring: #keyword: Python docstring  #// ドキュメントに出力される部分
            基本: |
                    def hello(whom):
                        """Returns Hello, whom."""
                        return f'Hello, {whom}'
                #ref: https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html
            ファイル:
                ファイルの先頭に三重引用符で囲んで書きます。
                #ref: https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html
                #search: Python __copyright__
            #ref: https://atmarkit.itmedia.co.jp/ait/articles/1912/06/news025.html
        変数: | #keyword: Python __copyright__  #// 著者, ライセンス, バージョンなど
            __author__ = "Rob Knight, Gavin Huttley, and Peter Maxwell"
            __copyright__ = "Copyright 2007, The Cogent Project"
            __credits__ = ["Rob Knight", "Peter Maxwell", "Gavin Huttley",
                                "Matthew Wakefield"]
            __license__ = "GPL"
            __version__ = "1.0.1"
            __maintainer__ = "Rob Knight"
            __email__ = "rob@spot.colorado.edu"
            __status__ = "Production"
            #ref: https://stackoverflow.com/questions/1523427/what-is-the-common-header-format-of-python-files
    データ:
        文字列: #keyword: Python string,  Python str  #ref: ${programming}/スクリプト/Python.svg#str
            (')と(")の違い:  #// ありません  #keyword: python single quote double quote
                \n: ... "\n" も '\n' も改行文字に置き換わります
                参考: https://stackoverflow.com/questions/65758620/are-there-any-differences-in-and-in-python
                方針の参考: https://qiita.com/thimi0412/items/95bd255c84d38ec9a400
            エスケープしない:
                r"\n": "\\n"  #// r を付けます。改行文字に置き換わりません
            f-strings:  #// f'a = {a}'  #keyword: f-strings, フォーマット文字列、フォーマット済み文字列リテラル, f'____', fstrings
                #// Python 3.5 以前は使えません  #search: Python str.format
                基本的な書式: f'a = {a}'  #// 全体を f' ' で囲み、変数参照する部分を { } で囲みます
                基本的な書式 >> サンプル実行: |
                    a = 2
                    print(f'a = {a}')  #// a = 2
                    print(f"a = {a}")  #// ダブルクオーテーションでも同じです
                    print(f'''a = {a}''')  #// トリプルクォートでも同じです
                    print(f"""a = {a}""")  #// トリプルダブルクォートでも同じです
                    print('a = {}'.format(a))  #// 機能的には format と同じです
                エスケープ, { } 文字: |  #// {{ }}
                    n = 123
                    print(f'{{}}-{n}-{{{n}}}')  # {}-123-{123}
                ネストした置換フィールド: |  #// { { } }
                    n = 123
                    i = 8
                    print('{n:0{i}}'.format(n=n, i=i))  # 00000123
                    print(f'{n:0{i}}')  # 00000123
                右寄せ、中央寄せ、左寄せ: |
                    s = 'abc'
                    print(f'right : {s:_>8}')
                    print(f'center: {s:_^8}')
                    print(f'left  : {s:_<8}')
                    # right : _____abc
                    # center: __abc___
                    # left  : abc_____
                ゼロ埋め: |
                    i = 1234
                    print(f'zero padding: {i:08}')
                    # zero padding: 00001234
                桁区切り: |
                    print(f'comma: {i:,}')
                    # comma: 1,234
                2進数、8進数、16進数: |
                    print(f'bin: {i:b}')
                    print(f'oct: {i:o}')
                    print(f'hex: {i:x}')
                    # bin: 10011010010
                    # oct: 2322
                    # hex: 4d2

                    print(f'bin: {i:#b}')
                    print(f'oct: {i:#o}')
                    print(f'hex: {i:#x}')
                    # bin: 0b10011010010
                    # oct: 0o2322
                    # hex: 0x4d2
                小数点以下の桁数、有効桁（有効数字）: |
                    f = 12.3456
                    print(f'digit(decimal): {f:.3f}')
                    print(f'digit(all)    : {f:.3g}')
                    # digit(decimal): 12.346
                    # digit(all)    : 12.3
                指数表記: |
                    print(f'exponent: {f:.3e}')  # exponent: 1.235e+01
                パーセント表記: |
                    f = 0.123
                    print(f'percent: {f:.2%}')  # percent: 12.30%
                str.format: #keyword: Python str.format
                    - |
                        formatted_string = "{} is {} years old.".format(name, age)
                    - |
                        '{cls}.to_representation() must be implemented for field {field_name}.'.format(cls=self.__class__.__name__, field_name=self.field_name)
                    #// Python 3.6以降では f-strings を推奨します
            raw-strings: #keyword: raw-strings  #// r'a\nb'  #// \ をエスケープ文字として扱わず、\ 文字として扱います
            (%フォーマット): | #keyword: Python string %,  Python sprintf  #// 古い f-strings。非推奨。 推奨は  #search: f-strings
                "abc=%s" % abc                #// f"abc={abc}"
                "abc=%s, %s" % (abc1, abc2)   #// f"abc={abc1}, {abc2}"
            複数行: #keyword: Python multi-line  #// """～""",  '''～'''
                複数行の文字列: |  #// 改行は改行文字になります
                    """line1
                    line2"""
                1行の文字列を複数行で書く:
                    s = 'https://ja.wikipedia.org'\
                        '/wiki/'\
                リテラル: #keyword: Python str multi lines literal
                    textwrap.dedent: #keyword: Python textwrap.dedent
                        python triple quote の f-strings の場合: |  #focus: textwrap.dedent
                            $ python3  #// Python 3.6.8
                            >>> import textwrap
                            >>> def  main():
                                    variable_A = "value_A"
                                    text = f'variable_A: {variable_A}\n'
                                    text = textwrap.dedent(f"""\
                                        Hello

                                        variable_A: {variable_A}""")
                                        #// textwrap.dedent はインデントを削除します
                                    print(text)

                            >>> #// 上記の空行で main の定義は終わります
                            >>> main()
                            Hello

                            variable_A: value_A
                            >>> exit()
                    #ref: https://docs.python.org/3/library/textwrap.html#textwrap.dedent
                    #ref: https://stackoverflow.com/questions/1412374/how-to-remove-extra-indentation-of-python-triple-quoted-multi-line-strings
                配列変換:  #// 複数行の文字列を１行ずつの配列に変換します
                    配列⇒複数行の文字列: | #keyword: Python str join
                        "\n".join(["aaa", "bbb", "ccc"]) == "aaa\nbbb\nccc"
                    複数行の文字列⇒配列: | #keyword: Python str split
                        "aaa\nbbb\nccc".split("\n") == ["aaa", "bbb", "ccc"]
                        "aaa\nbbb\nccc\n".split("\n") == ["aaa", "bbb", "ccc", ""]
            Unicode, Ascii: #keyword: Python Unicode,  Python Ascii  #glossary: Python
                encode:  #// 文字列をバイナリ列に変換します  #keyword: Python encode
                    サンプル:
                        a_bytes = "日本語".encode()
                    参考:
                        Unicode HOWTO: https://docs.python.org/ja/3/howto/unicode.html#converting-to-bytes
                        str.encode:  https://docs.python.org/ja/3/library/stdtypes.html#str.encode
                chr:  #// int → str  #// chr = character  #ref: https://docs.python.org/3/library/functions.html#chr
                    chr(65) == 'A'
                ord:  #// str → int  #// ord = ordinal  #ref: https://docs.python.org/3/library/functions.html#ord
                    - ord('A') == 65
                    - hex(ord('A')) == '0x41'
            国際化: #keyword: Python 国際化  #ref: https://stackoverflow.com/questions/57188115/flask-form-l-symbol-meaning/57188189
            bytes: #keyword: Python bytes,  Python binary  #// 変更できないバイト配列  #ref: https://docs.python.org/ja/dev/library/stdtypes.html#text-and-binary-sequence-type-methods-summary
                #// バイト配列の内容が変更できないだけで、既存の bytes 型の変数に別のバイト配列を代入することはできます。
                リテラル:
                    - b'abc'  #// bytes 型 0x61, 0x62, 0x63
                    - b'\xd8\xe1\xb7\xeb\xa8\xe5 \xd2\xb7\xe1'  #// привет мир
                str → bytes: |
                    - 'abc'.encode() == b'abc'
                    - bytes('abc', encoding='utf-8')
                bytes → list:  #// デバッガーでツリー表示になります
                    - list(b'abc')
                bytes → str: |
                    b'abc'.decode() == 'abc'
                open: |
                    with open('file.bin', 'rb') as f:
                        content = f.read()
                BytesIO:  #keyword: Python BytesIO
                    公式:  #ref: https://docs.python.org/3/library/io.html#binary-i-o
                    サンプル: |  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/bytes/bytes_i_o.py
                        from io import BytesIO

                        data: bytes = b'abc'
                        print(data)  #// b'abc'

                        stream: BytesIO = BytesIO(data)
                        print(stream.read())  #// b'abc'
            bytearray: #keyword:  #// 変更可能なバイト配列
                str → bytearray: |
                    bytearray('hello', encoding='utf-8')
            検索:  #ref: ${programming}/スクリプト/Python.svg#str_find
                find, index: |
                    assert  "abcdeabcde".find(  "cd" ) == 2
                    assert  "abcdeabcde".index( "cd" ) == 2

                    assert  "abcdeabcde".find(  "cd", 5 ) == 7
                    assert  "abcdeabcde".index( "cd", 5 ) == 7

                    assert  "abcdeabcde".find(  "xx" ) == -1
                    #//     "abcdeabcde".index( "xx" )  #// raises ValueError

                    assert  "abcdeabcde".rfind(  "cd" ) == 7
                    assert  "abcdeabcde".rindex( "cd" ) == 7
                rfind, rindex:
                    後方から検索します
                in: #keyword: Python in str,  Python include str #// "ab" in "abc" == True
                    assert  "ab" in "abc" == True
                    assert  "b"  in "abc" == True
                    assert  "AB" in "abc" == False
                    assert  "ba" in "abc" == False
                    assert  "ba" not in "abc" == True
                    assert  [1,2] in [1,2,3] == False  #// 配列は部分一致を判定できない
            置き換え:
                文字列の一部を置き換えます: #keyword: Python str replace  #// 正規表現は使いません
                    string1.replace(from, to)
                正規表現で置き換えます:  #search: Python regexp sub
                bytes の一部を置き換えます: #keyword: Python bytes sub
                    サンプル: |  #focus: ab(c, sub, aXc
                        import re
                        line = b'ab(c'
                        print(line)  #// b'ab(c'

                        reg_exp = re.compile(re.escape('b(').encode())  #search: re.escape
                        line = reg_exp.sub(b'X', line)
                        print(line)  #// b'aXc'
                    置き換え前を参照する場合: |  #focus: \1  #// r'\1'。r を付けないとエスケープされてしまうので注意
                        import re
                        pattern = r'(\w+) (\w+)'
                        text = 'Hello World'

                        result = re.sub(pattern, r'\2 \1', text)
                        print(result)  # 出力: 'World Hello'
                複数行と配列の変換:  #search: Python str join 
                大文字小文字: |  #keyword: Python upper lower
                    "abc".upper()
            string.Template: #keyword: Python string.Template,  Python 変数 展開
                基本: |  #// 変数を値に置き換えます。Hello, $name! の中に書かれた name 変数を World に置き換えます
                    template = string.Template('Hello, $name!')
                    print(template.substitute(name='World'))  #// "Hello, World!"
                複数の変数の置き換え:
                    substitute を何度も呼び出します
                変数を表す記号を $ から変える場合: |  #// $ から _$ に変えます。 たとえば _$name が値に置き換わります
                    class _Template(string.Template):
                        delimiter = '_$'
            一部, スライス: #keyword: Python str part
                スライス: | #keyword: Python slice  #// インデックス指定による部分文字列
                    'abcde'[1:3] == 'bc'
                    インデックスが範囲外でもエラーになりません。'abcde'[0:-1] == '',  'abcde'[6:1] == ''
                    数字は 0 が 1つ目の文字の位置。
                    2つ目の数字は部分文字列のすぐ右の文字の位置
                    右から 3 文字  text[-3:]
                ピリオド:  #// FQDN や IP アドレス
                    host_name = fqdn.split('.')[0]
                    (hour, minute) = '8:30'.split(':')  #search: Python return
                両端の空白と改行を削除: | #keyword: Python strip, Python trim
                    "\n the best coffee \n".strip() == "the best coffee"
                数字部分:  #// 文字列の中の最初の数字の部分
                    re.search(r'\d+', digit_and_character).group()
                    #ref: https://stackoverflow.com/questions/11339210/how-to-get-integer-values-from-a-string-in-python
            比較:
                startswith: #keyword: Python startswith
                    - str1.startswith('あいう')
                    - str1.startswith('あいう',1)
                関連 >> 検索:
            正規表現:  #keyword: Python regexp,  Python re  #ref: ${programming}/スクリプト/Python.svg#re
                公式: https://docs.python.org/ja/3/library/re.html
                正規表現を試すサイト: #search: regular expression application
                search:  #keyword: Python regexp search  #// マッチした部分を検索してその情報を返します  #ref: ${programming}/スクリプト/Python.svg#STR_Pattern_search
                    サンプル: |
                        import re
                        match = re.search(r'\d{4}-\d{2}-\d{2}', 'in 2021-01-04')  #// または match = re.compile(r'\d{4}-\d{2}-\d{2}').search('in 2021-01-04')
                        if match:
                            match.group(0)  #// '2021-01-04'   #// マッチした部分。group 以外の分かりやすいメソッド名はありません
                    search の返り値:
                        .group(n):  #keyword: Python capture group  #// n は キャプチャー グループ の番号。1 なら最初の ( ) の中。0 なら正規表現全体
                            サンプル: |  #focus: abc
                                import re
                                match = re.search("(a.c)", "abcdef")
                                if match:
                                    match.group(1)  #// abc
                        .re: search メソッドが所属するオブジェクト
                        .string: 検索対象のテキスト
                        .regs:  #// 見つかった位置
                            - ((__Start1__, __Over1__))
                            - ((__Start1__, __Over1__), (__Start2__, __Over2__), ...)
                        .pos: 0
                        .endpos: 入力データ長
                finditer: |
                    for match in re.finditer(pattern, text):
                        print(match.group())  # '123', '456', '789'
                findall:
                    matches = re.findall(pattern, text)
                    print(matches)  # ['123', '456', '789']
                match:  #// 先頭からマッチした部分の情報を返します。検索はしません。2文字目以降にマッチしても None  #keyword: Python regexp match
                    関連 >> search の返り値:  #search: Python regexp search
                    注意: 先頭にマッチする必要があります
                    サンプル: |  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/regular_expression/re_search.py
                        import re

                        date_re = re.compile('^\d{4}-\d{2}-\d{2}$')
                        print(date_re.match('2021-01-04'))     #// <re.Match object; span=(0, 10), match='2021-01-04'>
                        print(date_re.match('in 2021-01-04'))  #// None
                        print(date_re.match('2021-01-04   '))  #// None

                        #// 正規表現の ^ $ の省略は非推奨。先頭は他の文字を許さないが、末尾は他の文字を許してしまうため
                        date_re = re.compile('\d{4}-\d{2}-\d{2}')
                        print(date_re.match('2021-01-04'))     #// <re.Match object; span=(0, 10), match='2021-01-04'>
                        print(date_re.match('   2021-01-04'))  #// None
                        print(date_re.match('2021-01-04   '))  #// <re.Match object; span=(0, 10), match='2021-01-04'>
                マッチするかどうかだけ確認する方法: 不明。match を使います
                グループ名:  #keyword: Python regular expression group name
                    (?P<group_x>[a-zA-Z]+)  #ref: https://note.nkmk.me/python-re-match-object-span-group/ >> グループに名前を設定
                sub:  #// 置き換えます  #keyword: Python regexp sub,  Python regexp replace
                    基本サンプル: |  #// 少し動作が遅い  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/str_replace/re_sub.py
                        import re
                        text = "abc123def456efg"
                        replace_from = '[a-z]+'   #// 説明変数 replace_from と replace_to を定義すると読みやすくなります
                        replace_to = '_'

                        re.sub(replace_from, replace_to, text)          #// '_123_456_'
                        re.compile(replace_from).sub(replace_to, text)  #// '_123_456_'
                    マッチした文字列を置き換えた後で使う場合: |  #keyword: Python back reference  #focus: \1
                        replace_from = 'b(.*)'
                        replace_to = r' next is \1'     #// r が必要です。¥ があるため

                        re.sub(replace_from, replace_to, "abcde")  #// a next is cde
                re.escape: |  #keyword: re.escape,  Python escapeRegularExpression
                    import re
                    print(re.escape('ab(c'))  #// 'ab\(c'
            キャピタライゼーション:
                __Str__.lower():
                __Str__.upper():
                __Str__.capitalize(): |
                    print("hello python".capitalize())
                    >> Hello python
                    print("MY FAVORITE THINGS".capitalize())
                    >> My favorite things
                __Str__.title(): |
                    print("hello python".title())
                    >> Hello Python
                    print("HelloPython".title())
                    >> Hellopython
                    print("MY FAVORITE THINGS".title())
                    >> My Favorite Things
        数値:  #ref: ${programming}/スクリプト/Python.svg#int_type
            文字列と数値の変換: #keyword: Python str int
                str(1) == "1"
            日付と文字列の変換:
                str, 非可逆:
                    str( datetime.date(2018, 4, 1) ) == "2018-04-12"
                repr, 可逆: #keyword: Python repr  #// repr = representation
                    import datetime
                    repr( datetime.date(2018, 4, 1) ) == "datetime.date(2018, 4, 1)"
                    eval("datetime.date(2018, 4, 1)") == datetime.date(2018, 4, 1)
                参考:  #ref: https://gammasoft.jp/blog/use-diffence-str-and-repr-python/
        バイナリ:  #search: Python binary
        バージョン番号: #keyword: Python semantic versioning
            version.parse:
                サンプル: |
                    from packaging import version
                    version.parse("2.3.1") < version.parse("10.1.2")
                    if version.parse("2.3.1").major >= 1:  #// faster
            version.Version:
                サンプル: |
                    from packaging.version import Version
                    ver = Version("2.3.1")
            Specifiers: #keyword: Python Specifiers
                SpecifierSet:
                    from packaging.specifiers import SpecifierSet
                    spec1 = SpecifierSet("~=1.0")
                in:  #// バージョン番号の比較
                    Version("1.0.0") in SpecifierSet("~=1.0.0") == True
                    Version("1.1.0") in SpecifierSet("~=1.0.0") == True
                    Version("1.0.0") in SpecifierSet("~=1.1.0") == False
                    Version("1.0.0-3") in SpecifierSet("~=1.0.0-3") == True
                    Version("1.0.0-3") in SpecifierSet("~=1.0.0-2") == True
                    Version("1.0.0-3") in SpecifierSet("~=1.0.0-4") == False
            バージョン指定子:  #search: Python version specifiers
            #ref: https://stackoverflow.com/questions/11887762/how-do-i-compare-version-numbers-in-python
        インスタンス ⇒ 型:  #search: Python type typeof
        型ヒント: #keyword: Python typing hint,  型ヒント type  #ref: https://docs.python.org/3/library/typing.html
            変数:  #// dataclass, ジェネリクス
                基本型: |  #focus: :
                    __Variable__: __Type__ = __InitialValue__
                    count: int = 0
                dataclass: #search: Python @dataclass
                辞書: |  #keyword: Python typing hint Dict
                    from typing import Dict
                    variable_1: Dict[str, int] = {}
                配列:
                    from typing import Tuple
                    from typing import List
                関数型: |  #keyword: Python typing hint Callable
                    from typing import Callable
                    lambda_: Callable[[str, str], int] = lambda var1, var2: var1 + var2  #// same operations as function
                ジェネリクス:  #keyword: Python generics  #ref: https://docs.python.org/ja/3/library/typing.html#generics
                    書式:
                        一般的な形: |  #focus: __Type__
                            __Variable__: __GenericType__[__TypeArgument__] = [__InitialValues__]
                        書式の説明:
                            __GenericType__: ジェネリック型、元の型 (origin)
                            __TypeArgument__: 型引数。型を渡します
                        Python3.9 以降:
                            import しない小文字から始まる型を使います: |
                                list[int] = [1,2,3]
                                variable: dict[str, int] = {'size': 12, 'age': 24}
                        Python3.8 まで:
                            import した大文字から始まる型を使います: |
                                from typing import List, Dict
                                list[int] = [1,2,3]
                                variable: Dict[str, int] = {'size': 12, 'age': 24}
                    Typing:  #ref: https://docs.python.org/3/library/typing.html#typing.get_origin
            関数: |  #focus: ->  #keyword: Python function typing hint
                def __FunctionName__(__Argument__: __Type__)-> __ReturnType__:
                def __MethodName__(self, __Argument__: __Type__)-> __ReturnType__:
                def __FunctionName__()-> None:  #ref: https://stackoverflow.com/questions/36797282/python-void-return-type-annotation/56221807
                def __FunctionName__():  #// no arguments and return values
            Any: |  #// 任意の型
                from typing import Any
                def func()-> Any:
                    ____
            異なる型を代入します:  #keyword: Python type cast
                VSCode では int 型として扱われますが、実行時は str 型になります: |
                    b: int = "a"  #// It is no error
                    b += "b"
                    #// b += 2  #// TypeError: can only concatenate str (not "int") to str
                    print(b)  #// "ab"
                配列の要素も同様です: |
                    from typing import List
                    list: List[int] = []
                    list.append('a')
                    print(list)  #// ['a']
                キャストします:
                    from typing import cast
                    cast(Type, object).attribute
                関連 >> ダウン キャスト:  #search: Python isinstance
            型を定義します:
                型エイリアス:  #// 既存の型と混同できます
                    __NewType__ = __Type__
                    MyType1 = int
                    MyType2 = list[int]
                NewType:  #ref: https://docs.python.org/ja/3/library/typing.html#newtype
                    注意: 公式に書かれている通りに動作しません Python 3.9.5
                    サンプル: |
                        from typing import NewType
                        UserId = NewType('UserId', int)
                        def get_user_name(user_id: UserId) -> str:
                            return 'a'

                        def test_a():
                            get_user_name(UserId(13))
                            get_user_name(12)
                            print(2)
                        test_a()
            関数アノテーション: |
                #// : __Type__ の部分のこと
                #ref: https://docs.python.org/ja/3/glossary.html#term-function-annotation
            Optional (None): #keyword: Python Optional
                特定の型 または None を代入できます: |
                    __Variable__: Optional[__Type__] = __NoneOrValue__
            Union: #keyword: Python Union
                サンプル: |
                    from typing import Union
                    Union[int, float]
                    CustomType = Union[str, int]
                    CustomType: TypeAlias = Union[str, int]    Python 3.10以降
                    CustomType = str | int    Python 3.10以降
                注意:
                    .type はエラーになります
                    TypeError 'Cannot instantiate typing.Union'
                        #search: Python dot type
                get_origin: |
                        >> from typing import Union, get_origin, get_args
                        >> x = Union[int, str]
                        >> get_origin(x), get_args(x)
                        (typing.Union, (<class 'int'>, <class 'str'>))
                        >> get_origin(x) is Union
                    #ref: https://stackoverflow.com/questions/45957615/check-a-variable-against-union-type-at-runtime-in-python-3-6
            Final:
                定数: |
                    TABLE_NAME: Final[str] = 'sample'
                    TABLE_NAME = 'A'  #// Error that "TABLE_NAME" is declared as Final and cannot be reassigned
            型情報の取得:  #// ランタイムでの型情報の取得（イントロスペクション）
            参考 >> 型を導入することのメリット:  #search:: type merit
        配列:  #keyword: Python list, Python array  #ref: ${programming}/スクリプト/Python.svg#seq
            list:  #keyword: Python list append
                基本: |
                    from typing import List
                    list: List[int] = [ 10, 11, 12, 13 ]
                    list.append( 14 )
                    list += [ 15, 16 ]  #// list = [ 10, 11, 12, 13, 14, 15, 16 ]
                    list[0]
                    list[3]
                    list[-1]   #// 最後から 1番目
                初期化 default_factory:  #search: Python default_factory field
                応用: |
                    - list: List[int] = [ None ] * 3  #// [ None, None, None ]
                    - list: List[int] = [ ]  #// empty list object
                index: #keyword: Python list index  #// 検索
                    基本: |
                        - [ 10, 11, 12, 13 ].index(12)  #// 2
                    要素数以上のときの値:  #// デフォルト値
                        x = array[5] if len(array) > 5 else "default"
                        #// array.get(5, "default") のような辞書の get は配列に対して使えません
                スライス: |  #keyword: Python slice
                    - [10,11,12,13][2] == 12
                    - [10,11,12,13][2:]  == [12,13]
                    - [10,11,12,13][:2]  == [10,11]
                    - [10,11,12,13][1:3] == [11,12]
                join:  #search: Python str join
                参考:
                    #ref: ${programming}/スクリプト/Python.svg#seq
                    #ref: https://docs.python.org/3/library/typing.html#typing.List
                    #ref: https://docs.python.org/3/library/stdtypes.html#lists
            ループ: #search: Python for in
            for in,  全要素変換 （リストの内包表記）:  #keyword: Python list comprehensions,  Python for array in
                注意: リストではなくジェネレーターを返します。ジェネレーターは一度参照すると2度目は参照できません
                ～ for x in ～:
                    書式: [ __ExpressionWithVariable__ for item in  __Array__ ]
                    サンプル: print( [ x * 2  for  x  in [ 1, 2, 3 ] ] )  #// [ 2, 4, 6 ]
                ～ for x in ～ if ～:  #keyword: Python search dict in list
                    書式: [ __ExpressionWithVariable__ for item in  __Array__ if __Condition__ ]
                    サンプル: |  #focus: for
                        dicts = [
                            { "name": "Tom", "age": 10 },
                            { "name": "Mark", "age": 5 },
                            { "name": "Dick", "age": 12 },
                            { "name": "Mark", "age": 6 },
                        ]

                        marks = (item for item in  dicts if item["name"] == "Mark")
                        mark1 = next(marks, None)
                        print(mark1)  #// {'name': 'Mark', 'age': 5}
                        mark2 = next(marks, None)
                        print(mark2)  #// {'name': 'Mark', 'age': 6}
                        mark3 = next(marks, None)  #// next の第2引数を指定しなかったら例外が発生します
                        print(mark3)  #// None

                        john1 = next((item for item in  dicts if item["name"] == "John"), None)
                        if john1:
                            print(john1)
                        if not john1:
                            print('Not found John.')
                インデックスを取得します: |  #focus: index
                    dicts = [
                        { "name": "Tom", "age": 10 },
                        { "name": "Mark", "age": 5 },
                        { "name": "Dick", "age": 12 },
                        { "name": "Mark", "age": 6 },
                    ]

                    mark_indices = (index  for  index, item  in  enumerate(dicts) if item["name"] == "Mark")
                    print(list(mark_indices))  #// [1, 3]
            in:  #keyword: Python in list  #// 配列の中で完全一致する要素があるかどうかを返します
                == で比較できる場合: |  #// 比較対象が配列要素と == で比較できる場合
                    __Key__ in __List__
                    __Key__ not in __List__
            filter:  #keyword: Python filter
                推奨 >> リスト内包表記:  #search: Python list comprehensions  #// 脇役（lambda）が目立たないため
                    #snip: [ __ExpressionWithVariable__ for item in  __Array__ if __Condition__ ]
                filter:
                    書式: list(filter(__Condition__, __Array__))
                    サンプル: | #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/filter/filter.py
                        frames = [{'http':1}, {'https':2}, {'http':3}]

                        http_frames = list(filter(
                            lambda frame: 'http' in frame,
                            frames))
                        print(http_frames)  #// [{'http': 1}, {'http': 3}]
                    同じ処理: |
                        frames = [{'http':1}, {'https':2}, {'http':3}]

                        http_frames = []
                        for frame in frames:
                            if 'http' in frame:
                                http_frames.append(frame)
                        print(http_frames)  #// [{'http': 1}, {'http': 3}]
                条件の lambda を分ける場合: | #keyword: Python filter lambda   #focus: if_has_key
                    key = 'http'
                    if_has_key: Callable[[Frame], bool] = lambda frame: key in frame
                    http_frame = list(filter(if_has_key, json_data))
                関連:
                    for in:  #search: Python list comprehensions
                    any:  #search: Python any  #// 1つでも存在するか
                        any(p.category == "電化製品" for p in products)
                    next:  #search: Python next
                    リレーション結合: #search: Python object relation
            next: #keyword: Python next,  Python find in list  #// 最初。next でも最初。要素数 0なら None。見つからないなら例外または指定した値
                書式:
                    - next(__Iterator__)
                    - next(__Iterator__, __Default__)
                    - next((__Iterator__), __Default__)
                    - next(____ for ____ in ____ if ____)
                    - next((____ for ____ in ____ if ____), __Default__)
                サンプル1: |  #// デフォルト値を指定するときは、デフォルト値の左を ( ) で囲まないとエラーになります
                    next(user for user in users if user.city == "東京")  # next means first item
                    next((user for user in users if user.city == "東京"), None)  # next means first item
                サンプル2: |
                    first_http_frame = next(filter(
                        lambda frame: 'http' in frame,
                        json_data), None)
                トラブルシューティング:
                    ログ: |
                        Generator expressions must be parenthesized if not sole argument
                    対処:
                        __Iterator__ を ( ) で囲みます
            any: #keyword: Python any  #// 1つでも存在するか確認します。存在したことが分かったら、他の要素は調べません
                サンプル: |  #focus: any
                    numbers = [1, 3, 5, 7, 2, 9]
                    has_even = any(number % 2 == 0 for number in numbers)
                    print(has_even)  # True を出力する、なぜなら 2 が偶数だから
                オブジェクトの場合:
                    any(p.category == "電化製品" for p in products)
            index:
                frames = ['http', 'https', 'http']
                index = frames.index('http')
                print(index)  #// 1
            map: #keyword: Python map  #// 配列のそれぞれの要素を入力して、別の配列を作ります
                map(関数, 配列): #keyword: Python map function
                    推奨 >> リスト内包表記:  #search: Python list comprehensions  #// 脇役（lambda）が目立たないため
                        #snip: [ __ExpressionWithVariable__ for item in  __Array__ ]
                    配列を返す場合: |
                        list(map(lambda x: bin(int(x)), ["20","19","12","25"]))
                        list(map(lambda x: __Expression__, __List__))
                    配列の内容を置き換えるイテレーターを返します: |  #// 型を指定すればコンストラクターとして機能します。
                        map(lambda x: bin(int(x)), ["20","19","12","25"])
                    リレーション結合: #keyword: Python object relation join,  Python object merge  #// オブジェクトの配列とオブジェクトの配列を ID などで結合した配列を取得します
                        コード: |
                            def __join_users_and_points(users: List[User],  points: List[Point]) -> Dict:
                                ok_users = [ user for user in  users if any(user.id == point.id for point in points) ]
                                not_matched_users = [ user for user in  users if user not in ok_users ]
                                if len(not_matched_users) >= 1:
                                    logger.error("__join_users_and_points: Not matched %s", [ x.id for x in  not_matched_users ])

                                return [{
                                    "user": user,
                                    "point": next(point for point in points if point.id == user.id),  # first item
                                } for user in  ok_users ]
                    関連 >> for in if:  #search: Python list comprehensions for in
                map(クラス, 配列): #keyword: Python map class
                    _:
                        __init__(self, item) の item に配列の要素を渡すように __init__ を呼び出し（オブジェクトを生成し）、
                        map 全体としては、生成したオブジェクトの配列を返すイテレーターになります
                    サンプル コード: |
                        history_objects = map(History, history_dicts)
                            // histories = [{'id': '1122', 'value': '100'}, ...]

                        class History:
                            def __init__(self, data):
                                self.__data = data
                            @property
                            def id(self):
                                return int(self.__data['id'])
                            @property
                            def value(self):
                                return self.__data['value']
            文字列へ:  #// 配列から文字列に変換します
                SSV: |
                    " ".join(["aaa", "bbb", "ccc"]) == "aaa bbb ccc"
                CSV:  #search: Python CSV
                複数行:  #search: Python str join
            select_extra_name_index: #keyword:  #// 属性を配列にしたときに、識別する名前がないコードとの互換性
                コード: |
                    from typing import List

                    def select_extra_name_index(names: List[str], name='', error_label='select_extra_name_index') -> int:
                        if not name:
                            if len(names) >= 2:
                                raise ValueError(f"{error_label}: Can not decide from extra names")
                            return 0
                        else:
                            if name not in names:
                                raise ValueError(f"{error_label}: Not find {name} in extra names")
                            return names.index(name)
            MutableSequence: #// List, Array など   #ref: https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types
                set:
                    - s.append(x)
                    - s.insert(i, x)
                    - s.extend(t)
                    - s += t
                    - s[i] = x
                    - s[i:j] = t
                    - s[i:j:k] = t
                    - s.copy()
                    - s *= n
                    - a = s1 & s2  #// 積集合  #ref: https://docs.python.org/3/library/stdtypes.html#frozenset.intersection
                    - s.reverse()
                del:
                    - del s[i:j]
                    - del s[i:j:k]
                    - s.clear()
                    - s.pop()
                    - s.pop(i)
                    - s.remove(x)
                比較:
                    unittest:  #search: Python unittest assertListEqual
            Deque: |  #keyword: Python deque
                from typing import Dict, Deque
                from collections import deque

                d: Dict[type, Deque[int]] = {
                    int: deque([20,22]),
                    str: deque([30]),
                }
                print(d[int].popleft())  #// 20
                print(d[int].popleft())  #// 22
            有無: #keyword: Python in list
                == で比較できる場合: |  #// 比較対象が配列要素と == で比較できる場合
                    key_item in items
                    if key_item not in items:
                    not (key_item in items):
                オブジェクトの属性を比較する場合:
                    #search: Python any
                    #snip: any(p.category == "電化製品" for p in products)
            検索:  #keyword: Python array index,  Python search
                == で比較できる場合: |  #// 比較対象が配列要素と == で比較できる場合
                    基本: |
                        x = ['p','y','t','h','o','n']
                        print(x.index('o'))
                    例外を発生させない場合: |
                        x = ['p','y','t','h','o','n']
                        key = 'o'
                        if key in x:
                            print(x.index(key))
                        else:
                            print(-1)
                オブジェクトの検索:
                    全部: #search: Python filter
                    1つ:  #search: Python next
                    リレーション結合: #search: Python object relation
                有無:  #search: Python in list
            ソート:  #keyword: Python sorted
                List.sort:
                sorted:
                    書式:
                        - sorted(__Array__)
                        - sorted(__Array__, key=__LambdaOfSortKey__, reverse=__Boolean__)
                    公式: #ref: https://docs.python.org/ja/3/library/functions.html#sorted
                参考: #ref: https://note.nkmk.me/python-list-sort-sorted/
            イテレーター, ジェネレーター:  #keyword: Python iterator,  Python generator
                関連 >> ジェネレーター:  #search: Python generator
                手順:
                    for: | #keyword: yield for  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/yield/loop-yield.py
                        #focus: yield, yield_function

                        def main():
                            print('1')
                            for x in yield_function():
                                print('> ' + x)
                            print('9')

                        def yield_function():   #// ループが開始されると、呼ばれます
                            print('2')
                            yield 'AAA'  #// 一度リターンして、ループ変数 x に値 'AAA'  が入ります。 yield_function はジェネレーターを返します
                            print('4')   #// 次のループ回数に変わるときに、続きが実行されます
                            yield 'BBB'
                            print('6')
                            yield 'CCC'
                            print('8')
                            #// 関数から返ると、ループも終了します

                        main()
                        '''
                        上記を実行したときの出力:
                            1
                            2
                            > AAA
                            4
                            > BBB
                            6
                            > CCC
                            8
                            9
                        '''
                    next 複数回: | #keyword: yield next2  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/yield/next-yield.py
                        #focus: iterator,  yield_function

                        def main():
                            iterator = yield_function()
                            print('after calling yield_function')
                            print('> '+ next(iterator))
                            print('> '+ iterator.__next__())
                            print('> '+ next(iterator, 'default'))
                            print('> '+ next(iterator, 'default'))

                        def yield_function():   #// ループが開始されると、呼ばれます
                            print('2')
                            yield 'AAA'  #// 一度リターンして、ループ変数 x に値 'AAA'  が入ります。 yield_function はジェネレーターを返します
                            print('4')   #// 次のループ回数に変わるときに、続きが実行されます
                            yield 'BBB'
                            print('6')
                            yield 'CCC'
                            print('8')
                            #// 関数から返ると、ループも終了します

                        main()
                        '''
                        上記を実行したときの出力:
                            after calling yield_function
                            2
                            > AAA
                            4
                            > BBB
                            6
                            > CCC
                            8
                            > default
                        '''
                    next 1回: #keyword: yield next1  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/yield/yield-finally.py#def main(
                        関連 >> @contextlib.contextmanager:  #search: @contextlib.contextmanager
                        #// 必ず代入すること。理由は右記などを参照  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/yield/yield-finally.py#def main_NG1(
                        サンプル: |
                            #focus: finally, yield_finally_function

                            def main():
                                generator = yield_finally_function()  #// yield finally function return value must let to a variable because of finally operation timing.
                                dictionary = next(generator)
                                use(dictionary)
                            '''
                            main の出力:
                                setup yield
                                yield
                                teardown yield
                            '''

                            def yield_finally_function():
                                try:
                                    dictionary = {'a': 'yield'}
                                    print('setup ' + dictionary['a'])
                                    yield dictionary
                                finally:
                                    print('teardown ' + dictionary['a'])
                    (@contextlib.contextmanager) を使う場合: #keyword: @contextlib.contextmanager  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/yield/contextmanager.py
                        #keyword: finally close 方式
                        #// @contextlib.contextmanager は with に指定する関数の定義を finally に対応することを簡単にします
                        #// @contextlib.contextmanager は オブジェクトの生成と削除を 1つの関数内で定義できるようにします
                        呼び出される側:
                            (@contextlib.contextmanager) を使う場合: |
                                import contextlib

                                @contextlib.contextmanager
                                def reading(filename):
                                    file = open(filename, 'r')
                                    try:
                                        yield file
                                    finally:
                                        file.close()
                            関連 >> @contextlib.contextmanager を使わない場合:  #search: Python __enter__ __exit__
                        呼び出す側:
                            with を使う場合: |
                                with reading('examples/yield/text.txt') as file:
                                    print(file.read())
                            with を使わない場合: |  #// 関数呼び出しがあってもすぐに呼び出されませんが、finally が呼ばれるタイミングと同じライフサイクルのオブジェクトが返ります
                                generator = reading('examples/yield/text.txt')  #// yield finally function return value must let to a variable because of finally operation timing.
                                    #// yield finally function returns "contextlib._GeneratorContextManager" object
                                file = generator.__enter__()  #// __enter__ calls reading()
                                print(file.read())
                                #// finally in yield function is called when generator was deleted.
                        #ref: https://qiita.com/QUANON/items/c5868b6c65f8062f5876
                メソッド:  #// __iter__, __next__, __enter__
                    __iter__ メソッド: #keyword: __iter__  #ref: ${programming}/スクリプト/Python.svg#class_iter
                        概要: 集合が持つメソッドで、イテレーターを返します
                    __next__ メソッド: #keyword: __next__  #ref: ${programming}/スクリプト/Python.svg#class_next
                        概要: イテレーターが持つメソッドで、要素を返します
                        次の要素が無いとき:
                            デフォルトを指定したとき: そのデフォルト値を返します
                            デフォルトを指定しなかったとき: StopIteration 例外が発生します
                            参考: #ref: https://stackoverflow.com/questions/14413969/why-does-next-raise-a-stopiteration-but-for-do-a-normal-return
                    __enter__ メソッド: #keyword: __enter__  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/yield/contextmanager.py#__enter__
                        概要: |
                            @contextlib.contextmanager が付いたメソッドを呼び出そうとすると、ジェネレーターが返り、
                            ジェネレーターから @contextlib.contextmanager が付いたメソッドを実際に呼び出します
                    __exit__ メソッド: #keyword: __exit__  #// __enter__ に対応するもの
                    サンプル:
                        出力: |
                            for in ----------
                            __iter__
                            __next__
                            a
                            __next__
                            b
                            __next__
                            list ----------
                            __iter__
                            __next__
                            __next__
                            __next__
                            [<__main__.MyElementClass object at 0x0000026B6C3B3FA0>, <__main__.MyElementClass object at 0x0000026B6C3B3DC0>]
                            iter next ----------
                            __iter__
                            __next__
                            a
                            __next__
                            b
                            __next__
                            -1
                            __next__
                            Traceback (most recent call last):
                            File "c:\Users\____\Desktop\try_pytest\try.py", line 41, in <module>
                                Main()
                            File "c:\Users\____\Desktop\try_pytest\try.py", line 17, in Main
                                print( next(iterator) )  #// raise  StopIteration
                            File "c:\Users\____\Desktop\try_pytest\try.py", line 34, in __next__
                                raise  StopIteration
                            StopIteration
                        コード: |  #focus: MyListClass, MyElementClass, __iter__, MyIterClass, __next__
                            def  Main() :
                                elements = MyListClass()

                                print( 'for in ----------' )
                                for element  in elements :
                                    print( element.Value )

                                print( 'list ----------' )
                                elements_list = list(elements)  #// イテレーターを指定すると、next() の返り値のリストになります
                                print(elements_list)  #// [ MyElementClass(), MyElementClass() ]

                                print( 'iter next ----------' )
                                iterator = iter(elements)
                                print( next(iterator).Value )  #// a
                                print( next(iterator, MyElementClass(-1)).Value )  #// b
                                print( next(iterator, MyElementClass(-1)).Value )  #// -1
                                print( next(iterator) )  #// raise  StopIteration

                            class  MyListClass :
                                def  __init__( self ) :
                                    self.List = [ MyElementClass("a"), MyElementClass("b") ]
                                def  __iter__( self ) :
                                    print( "__iter__" )
                                    return  MyIterClass( self )

                            class  MyIterClass :
                                def  __init__( self, List ) :
                                    self.List = List
                                    self.IterNum = -1
                                def  __next__( self ) :
                                    print( "__next__" )
                                    self.IterNum += 1
                                    if self.IterNum >= len( self.List.List ) :
                                        raise  StopIteration
                                    return  self.List.List[ self.IterNum ]

                            class  MyElementClass :
                                def  __init__( self, Value ) :
                                    self.Value = Value

                            Main()
                関連:
                    クロージャー: #search: closure
            itertools:  #// 高速なイテレーター  #ref: https://docs.python.org/ja/3/library/itertools.html
                accumulate: |  #keyword: itertools.accumulate
                    import itertools
                    iterator = itertools.accumulate([1, 3, 5, 7, 9])  #// 累積和のイテレーター
                    print(list(iterator))  #// [1, 4, 9, 16, 25] つまり [1, 1+3, 4+5, 9+7, 16+9]
                chain: |  #keyword: itertools.chain
                    import itertools
                    iterator = itertools.chain([1, 3], [5, 7, 9])
                    print(list(iterator))  #// [1, 3, 5, 7, 9]  ネストを展開します

                    iterator = itertools.chain([1, 3], [5, [7, 9]])
                    print(list(iterator))  #// [1, 3, 5, [7, 9]]  展開する深さは 1です
                他にもあります:  #ref: https://docs.python.org/ja/3/library/itertools.html
            reverse, 逆順: #keyword: Python reverse
                サンプル: items[::-1]  #// items.reverse()
                解説: |
                    len(items) == 0 のとき、items.reverse() は例外 TypeError: 'NoneType' object is not iterable を発生します
                #ref: https://stackoverflow.com/questions/5846004/unable-to-reverse-lists-in-python-getting-nonetype-as-list
            削除:
                基本:
                    - list.pop()
                    - スライス  #search: Python slice
                辞書の配列:  #search: Python delete dict array item
                filter:  #search: Python filter
            複数行と配列の変換:  #search: Python str join 
            デフォルト値, default value: #search: Python class default value
        辞書:  #keyword: Python dict
            関連 >> クラス: #search: Python class
            Python3.9 以降:
                import しない小文字から始まる型を使います: |
                    variable: dict[str, int] = {'size': 12, 'age': 24}
            Python3.8 まで:
                import した大文字から始まる型を使います: |
                    from typing import Dict
                    variable: Dict[str, int] = {'size': 12, 'age': 24}
            基本: |  #// Python3.8 まで
                from typing import Dict
                d: Dict[str,int] = {'a':20, 'b':35}
                print(d['b'])  #// 35
            デフォルト:
                キーが必須の場合:  #// キーが無いと例外を発生します
                    d['key']
                キーが無い場合: #keyword: Python dict get
                    - d.get('key', None)
                    - d.get('key')  #// キーが無いと None を返します
                    - d.get('key', '')
                    #// d.get('key', default='') は書けません
                キーが必須で値が None の場合:
                    d['key'] or ''
            関数の引数のデフォルト値:  #search: Python default parameter values
            キーを型にします: |  #// Python3.8 まで
                from typing import Dict
                d: Dict[type,int] = {int:20, str:35}
                print(d[str])  #// 35
            オブジェクトや配列との変換:  #// 辞書を扱いやすくします
                辞書 ⇒ オブジェクト: #keyword: Python dict to object
                    算出プロパティを使う場合:
                        サンプル: |  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/dict/config/config.py
                            class ExampleConfig:
                                def __init__(self, data: dict):
                                    self.__data = data
                                    self.__children = None

                                @property
                                def id(self) -> str:
                                    return self.__data['id']

                                @property
                                def version(self) -> Optional[int]:
                                    return self.__data.get('version', None)

                                @property
                                def child(self) -> Optional['_Child']:
                                    return _Child(self.__data['child'])

                                @property
                                def optional_child(self) -> Optional['_Child']:
                                    return _to_object_or_none(_Child, self.__data.get('child', None))

                                @property
                                def children(self) -> List['_Child']:
                                    if not self.__children:
                                        self.__children = [_Child(x) for x in self.__data.get('child', [])]
                                        #// または  return [Child(x) for x in self.__data['Child']]
                                    return  self.__children

                                @property
                                def services(self) -> Dict[str, '_Service']:
                                    if not self.__services:
                                        self.__services = { k: _Service(v)  for (k, v) in self.__data['services'].items() }
                                    return  self.__services

                                @property
                                def table(self) -> Dict[str, Dict[str, '_TableCell']]:
                                    if not self.__table:
                                        self.__table = dict()
                                        for (k,values) in self.__data['table'].items():
                                            values = values or {}
                                            self.__table[k] = { k2: _TableCell(v)  for (k2, v) in values.items() }
                                    return  self.__table
                    属性を使う場合: #// ネストできません。辞書とは別のオブジェクト（内容のコピー）ができます
                        サンプル: |
                                ClassA(**dic)
                            #// このように書くことで内部では __init__ メソッドに渡します
                        pytest サンプル:  #search: @pytest.mark.parametrize object
                        注意:
                            ネストさせることはできません:
                                サンプル: |
                                    from dataclasses import dataclass, field
                                    from typing import List
                                    
                                    @dataclass
                                    class SampleInfoChild:
                                        """ Sample情報子データクラス
                                        """
                                        childint: int = 0
                                        childstr: str = ''
                                    
                                    @dataclass
                                    class SampleInfoParent:
                                        """ Sample情報親データクラス
                                        """
                                        data1: int = 0
                                        data2: str = ''
                                        data3: float = 0.0
                                        listint: List[int] = field(default_factory=list)
                                        childobj: SampleInfoChild = None
                                    
                                    dict = {'data1':2, 'data2':'abc', 'data3':2.5,
                                            'listint':[123, 234], 'childobj': {'childint':2, 'childstr':'ddd'}}
                                    sample = SampleInfoParent(**dict) # ★
                                    print(sample)
                                結果:
                                    sample の値の型は SampleInfoParent クラスですが
                                    sample.childobj の値の型は辞書です。
                                間違えているホームページ: #ref: https://1kara-hajimeru.com/2021/02/1691/
                辞書 ⇒ 文字列: #keyword: Python dict __str__
                    辞書 ⇒ 文字列: |
                        my_dict = {'apple': 5, 'banana': 3, 'orange': 2}
                        dict_str = str(my_dict)
                        print(dict_str)
                        # 出力: {'apple': 5, 'banana': 3, 'orange': 2}
                    文字列 ⇒ 辞書: |
                        import ast
                        my_dict_str = "{'apple': 5, 'banana': 3, 'orange': 2}"
                        my_dict = ast.literal_eval(my_dict_str)
                        print(type(my_dict))  # <class 'dict'>
                オブジェクト ⇒ 辞書や JSON: #keyword: Python object to dict
                    vars:
                        vars(object)
                        #// このように書くことで内部で __dict__ プロパティに渡します
                        #// 直接 __dict__ プロパティを参照することもできます
                        #ref: https://stackoverflow.com/questions/21297203/use-dict-or-vars
                    asdict: #keyword:  #// @dataclass のオブジェクトを辞書に変換します。
                        from dataclasses import asdict

                        asdict(object)
                        #ref: https://1kara-hajimeru.com/2021/02/1691/
                        #// __dict__ プロパティの定義があっても __dict__ プロパティ（のメソッド）を呼び出しません
                    __dict__: #keyword:
                        関連 >> json_dict:  #search: json_dict
                        __dict__ 未定義の場合の vars や asdict:
                            属性（プライベート変数以外）の名前を値から自動的に作ります。
                            命名スタイルが違うときは json_dict の定義が必要です
                        #// __dict__ を直接呼び出してはいけません。asdict を呼び出してください
                        サンプル: |  #// 未確認
                            from dataclasses import dataclass, asdict

                            @dataclass
                            class ClassA:
                                @property
                                def __dict__(self) -> dict:
                                    return {
                                        "key1": "value",
                                        "key2": "value",
                                        "key3": {
                                            "key3a": "value",
                                        },
                                        "attribute4": asdict(self.attribute4),
                                        "key5": [
                                            {
                                                "key41": "value",
                                            },{
                                                "key42": "value",
                                            }
                                        ],
                                        "attributes": [asdict(x) for x in self.attributes]
                                    }
                    json_dict: #keyword: json_dict  #// JavaScript の命名スタイル（キャメル ケース）の辞書
                        概要:
                            __dict__ とほぼ同じ機能ですが、json_dict が返す辞書を使った ClassA(**dic) はエラーになるため、別のプロパティと考えるべきです
                            json_dict は Python の仕様ではありません。独自仕様です。
                        基本サンプル: |  #focus: json_dict
                            from dataclasses import dataclass

                            @dataclass
                            class ParentA:
                                sub_key: str

                                @property
                                def json_dict(self) -> dict:
                                    return {
                                        "subKey": self.sub_key,
                                    }
                            print(ParentA(sub_key='a').json_dict)  #// {'subKey': 'a'}
                        実用サンプル: |  #// ネストしたオブジェクト  #search: Python nested dataclass object  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/JSON/json_dict.py
                            from dataclasses import dataclass
                            import json

                            @dataclass
                            class ParentA:
                                key: str
                                sub_key: str
                                child: 'ChildA'

                                @property
                                def json_dict(self) -> dict:
                                    return {
                                        "key": self.key,
                                        "subKey": self.sub_key,    #// キー名を キャメル ケース に変更
                                        "chlid": self.child.json_dict,
                                    }

                            @dataclass
                            class ChildA:
                                sub_key: str

                                @property
                                def json_dict(self) -> dict:
                                    return {
                                        "subKey": self.sub_key,    #// キー名を キャメル ケース に変更
                                    }

                            an_object = ParentA(
                                key= "a",
                                sub_key= "b",
                                child= ChildA(
                                    sub_key= "c",
                                ))

                            print(an_object)  #// ParentA(key='a', sub_key='b', child=ChildA(sub_key='c'))

                            print(an_object.json_dict)  #// {'key': 'a', 'subKey': 'b', 'chlid': {'subKey': 'c'}}

                            json_document = json.dumps(an_object.json_dict, indent=2, sort_keys=True)  #// dict => JSON (str)
                            print(json_document)  #// '{\n  "chlid": {\n    "subKey": "c"\n  },\n  "key": "a",\n  "subKey": "b"\n}'
                （型を付けない場合）配列へ変換します:  #// キーの配列, 値の配列
                    list(dic.keys()), list(dic.values()), list(dic.items()) #// items は [ key0, value0, key1, value1, ... ]
                辞書の配列から辞書へ変換します: |  #search: Python dict list to dict
                    customers: Dict[str, Customer] = { x.code: x  for  x  in  customers } 
            キーの有無: |
                    "key"  in  dic
                    "key"  not in  dic
                    dic.get('key', None)  #// キーが無いときは None を返します
                #// dic.get('key', default=None) は書けません
            削除:
                1つのキー, pop: |
                    dic = {'a':1, 'b':2}
                    dic.pop('a')  #// 無いときは例外が発生します
                    dic.pop('c', None)  #// 無いときは第2引数 None を返します
                辞書の配列: #keyword: Python delete dict array item  #// 辞書の配列から、一致する辞書の値がある配列要素を削除します
                    サンプル: |
                        data = [
                            {'id': 1, 'name': 'Alice', 'age': 25},
                            {'id': 2, 'name': 'Bob', 'age': 30},
                            {'id': 3, 'name': 'Charlie', 'age': 25}
                        ]
                        return [item for item in data if item.get('id') != 2]
                            #template__: [__ExpressionWithVariable__ for __Variable__ in __Array__ if __Variable__.get(__Key__, __DefaultValue__) != __Value__]
                            #search: Python search dict in list
                    #search: Python list comprehensions
                辞書の辞書: #keyword: Python delete nested dict item  #// 辞書の辞書から、一致する辞書の値がある辞書要素を削除します
                    サンプル: |
                        data = {
                            1: {'name': 'Alice', 'age': 25},
                            2: {'name': 'Bob', 'age': 30},
                            3: {'name': 'Charlie', 'age': 25}
                        ]
                        return {k:v for (k,v) in  data  if v.get('name') != 'Bob'}
                            #template__: {__KeyExpression__: __ValueExpression__ for (k,v) in  __Dictionary__  if v.get(__Key__, __DefaultValue__) != __Value__]
                    #search: Python dict comprehensions
            配列内の辞書を検索します:  #search: Python search dict in list
            コピー, copy: | #keyword: Python dict copy  #focus: copy
                original_marks = {'Physics':67, 'Maths':87}
                copied_marks = original_marks.copy()
                print('Original Marks:', original_marks)  #// {'Physics': 67, 'Maths': 87}
                print('Copied Marks:', copied_marks)      #// {'Physics': 67, 'Maths': 87}
            マージ: #keyword: Python dict merge,  Python dict assign
                Python 3.9.0 以上:
                    z = x | y
                Python 3.5 以上:
                    z = {**x, **y}
                #ref: https://stackoverflow.com/questions/38987/how-do-i-merge-two-dictionaries-in-a-single-expression
            for in,  辞書の内包表記: #keyword: Python dict comprehensions  #// PEP 274  #ref: ${programming}/スクリプト/Python.svg#dict_comprehensions
                ～ for x in ～:
                    基本: |  #// アイテムの変更
                        dic1 = { k: v  for (k,v) in  [("a", 3), ("b", 2), ("c", 5)] }  # dict comprehensions
                            #template__: { __KeyExpression__: __ValueExpression__  for (k,v) in  __Dictionary__  if __Condition__ }
                        # dic1 == {'b': 2, 'c': 5, 'a': 3}
                    基本2: |  #// アイテムの変更
                        dic1 = { k: v  for  (k, v)  in  dic0.items() }  # dict comprehensions
                    辞書の配列から辞書へ: |  #keyword: Python dict list to dict
                        customers: Dict[str, Customer] = { x.code: x  for  x  in  customers } 
                    キーが重複する場合: |  #// 後勝ち
                        dic1 = { k: v  for  (k, v)  in  [("a", 3), ("b", 2), ("a", 5)] }  # dict comprehensions
                        # dic1 == {'a': 5, 'b': 2}
                ～ for x in ～ if ～: |
                    dic1 = { k: v  for  (k, v)  in  [("a", 3), ("b", 2), ("c", 5)]  if v >= 3 }  # dict comprehensions
                    # dic1 == {'c': 5, 'a': 3}
            ループ: #keyword: Python dict loop  #ref: ${programming}/スクリプト/Python.svg#dict_in
                サンプル: |
                    dic = { "year": 2000, "month": 1 }

                    print( "keys():" )
                    for key  in dic.keys() :
                        print( key )

                    print( "values():" )
                    for value  in dic.values() :
                        print( value )

                    print( "items():" )
                    for key, value  in dic.items() :
                        print( key +" : "+ str( value ) )
            dir: #keyword: Python dir  #// オブジェクトのメンバーのリスト
                サンプル: |
                    class Example:
                        def __init__(self):
                            self.attribute1 = 1
                            self.attribute2 = 2
                            self._private1 = 11
                            self.__private2 = 22
                    object = Example()
                    attributes = dir(object)
                サンプルの出力:
                    attributes: [ '_Example__private2', '__class__', ..., '_private1', 'attribute1', 'attribute2']
                関連: #search: Python deep_equals
            unique: #keyword: Python unique  #// 独自
                使用サンプル: |
                    target_ids: List[str] = unique([1,2,2,3])  #// [1,2,3]
                定義: |
                    def unique(keys: List) -> List:
                        dic: Dict[Any,None] = {}
                        for key in keys:
                            dic[key] = None

                        return list(dic.keys())
        その他コレクション:
            タプル: | #keyword: Python tuple  #// tuple クラス
                タプルによる集合は、( ) で囲みます。
                    tuple = ( "A", "B", "C", "D" )  #// as tuple
                タプルは、要素を変更することを禁止しています。
                    tuple = ( "A", "B", "C", "D" )
                    tuple[1] = "b"  #// error
                それ以外は、list と同じです。
                タプルは、シーケンス・クラスを継承しています。
            Set: #keyword: Python set  #ref: https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset
                Set リテラル:
                    - {'jack', 'sjoerd'}
                    - set(['jack', 'sjoerd'])
                操作:
                    追加: set.add(____)  #ref: https://docs.python.org/3/library/stdtypes.html#frozenset.add
                    その他: 辞書とほぼ同じです。 例 "key" in set  #search: Python dict
                リストから重複した要素を削除します:
                    nums = [1, 2, 1, 2, 3, 2, 4, 5,]
                    nums_unique = list(set(nums))
                set の引き算（list の引き算）: |
                    list の引き算はできませんが set に変換すれば引き算ができます。
                    重複した要素も削除されます。
                        list(set(list2) - set(list1))
                        >>> list2 = ['1', '3', '55']
                        >>> list1 = ['10', '55']
                        >>> list(set(list2) - set(list1))
                        ['1', '3']
                積集合, &: #keyword: Python Set &
                    list({1,2,3} & {3,2}) == [2, 3]  または [3, 2]
        日時:  #// 日付  #keyword: Python datetime  #ref: ${programming}/スクリプト/Python.svg#date
            公式:  #// https://docs.python.org/ja/3/library/datetime.html
                date:  #// datetime を参照
                datetime:  #// datetime.datetime クラス
                    現在の日時: #keyword: Python now
                        JST の場合: | #keyword: Python JST
                            import pytz
                            from datetime import datetime
                            JST = pytz.timezone('Asia/Tokyo')

                            now_jst = datetime.now(JST)
                            print(f"JST: {now_jst}")
                            print(f"タイムゾーン: {now_jst.tzinfo}")  # Asia/Tokyo
                        UTC の場合: |
                            now = datetime.utcnow()
                        引数なしの場合:  #// タイムゾーンの情報が含まれません
                            now_without_time_zone = datetime.now()
                    指定の日時:
                        サンプル >> ISO 8601形式 ⇒ datetime: |
                            >>> import datetime
                            >>> tstr = '2012-12-29T13:49:37+09:00'
                            >>> update_at = datetime.datetime.fromisoformat(tstr.replace('Z', '+00:00'))
                            >>> update_at
                            datetime.datetime(2012, 12, 29, 13, 49, 37, tzinfo=datetime.timezone(datetime.timedelta(seconds=32400)))
                        サンプル >> 日本の形式 ⇒ datetime: |
                            >>> import datetime
                            >>> tstr = '2012/12/29 13:49:37'
                            >>> a_datetime = datetime.datetime.strptime(tstr, '%Y/%m/%d %H:%M:%S')
                            >>> tdate = datetime.date(a_datetime.year, a_datetime.month, a_datetime.day)
                            >>> tdate
                            datetime.date(2012, 12, 29)
                            >>> a_datetime
                            datetime.datetime(2012, 12, 29, 13, 49, 37)
                        サンプル >> アメリカの形式 ⇒ datetime: |
                            >>> import datetime
                            >>> tstr = 'Dec 29 2012'
                            >>> a_datetime = datetime.datetime.strptime(tstr, "%b %d %Y")
                            >>> a_datetime
                            datetime.datetime(2012, 12, 29, 13, 49, 37)
                        任意の形式 ⇒ datetime:  #search: Python datetutil
                    文字列へ:
                        ISO 形式:
                            タイムゾーン付きの datetime の場合:
                                持っているタイムゾーンのままの場合:  #focus: 
                                    from datetime import datetime, timezone
                                    dt_with_tz = datetime.now(timezone.utc)
                                    iso_string = dt_with_tz.isoformat()
                                    print(iso_string)   #// 2025-07-10T12:30:45+00:00
                                UTC に変換する場合: |
                                    from datetime import datetime, timezone
                                    local_time = datetime.now(JST)
                                    utc_time = local_time.astimezone(timezone.utc)
                                    iso_string = utc_time.isoformat()
                                    print(iso_string)   #// 2025-07-10T03:30:45+00:00
                                    print(iso_string.replace('+00:00', 'Z'))   #// 2025-07-10T03:30:45Z
                            datetime.utcnow() で取得した場合:  #// タイムゾーン付きの datetime では正しくなりません
                                from datetime import datetime
                                utc_time = datetime.utcnow()
                                iso_string = utc_time.isoformat() + 'Z'
                                print(iso_string)  # 2025-07-10T12:30:45.123456Z
                    計算:
                        1日前:  #focus: days
                            from datetime import datetime, timedelta
                            now = datetime.now()
                            one_day_ago = now - timedelta(days=1)
                        次の朝8時:
                            関数を定義する場合:
                                使用例:
                                    get_next_time('8:30') == '2025-01-01T23:30:00Z'
                                定義: |   #search: Python JST  #// 下記は動作確認済み
                                    from datetime import datetime, timezone, timedelta

                                    def get_next_time(next_time: str) -> str:
                                        now = datetime.now(JST)
                                        next_hour, next_minute = [int(x) for x in  next_time.split(':')]
                                        if (now.hour < next_hour) or (now.hour == next_hour and now.minute < next_minute):

                                            next_date_time = now.replace(hour=next_hour, minute=next_minute, second=0, microsecond=0)
                                        else:
                                            tomorrow = now + timedelta(days=1)
                                            next_date_time = tomorrow.replace(hour=next_hour, minute=next_minute, second=0, microsecond=0)

                                        return next_date_time.astimezone(timezone.utc).isoformat().replace('+00:00', 'Z')
                            関数無しの場合: |
                                now_jst = datetime.now(JST)  #search: Python now
                                if now.hour < 8:
                                    next_8am = now.replace(hour=8, minute=0, second=0, microsecond=0)
                                else:
                                    tomorrow = now + timedelta(days=1)
                                    next_8am = tomorrow.replace(hour=8, minute=0, second=0, microsecond=0)
                タイムゾーン: #keyword: Python タイムゾーン
                    1つだけの場合:  #// 日本などタイムゾーンが 1つに固定されている場合
                        os.environ['TZ'] = 'Asia/Tokyo'
                        current_time = datetime.now()
                    複数の場合:  #// アメリカでの使用や国際化する場合
                        import pytz
                        from datetime import datetime

                        tz = pytz.timezone('Asia/Tokyo')
                        current_time = datetime.now(tz)
                    naive, aware: #keyword: Python タイムゾーン naive aware  #// native datetime ではない
                        naive datetime: 2024-12-05 10:00:00。タイムゾーン情報を持たない datetime オブジェクト。UTC とは限りません
                        aware datetime: 2024-12-05 10:00:00+00:00。タイムゾーン情報を持った datetime オブジェクト
                    #ref: ${typrm_files}/ref/Python-AI.yaml#label: TZ environment variable vs tz argument
            サードパーティ製:
                datetutil:  #keyword: Python datetutil
                    サンプル: |
                        >>> import dateutil.parser
                        >>> dateutil.parser.parse('Tue Apr 10 04:54:42 JST 2007')
                        datetime.datetime(2007, 4, 10, 4, 54, 42, tzinfo=tzlocal())
            トラブルシューティング:
                エラー, Module cannot be used as a type Pylance:
                    コード: |
                        import datetime
                        date: Optional[datetime]
                    対処:
                        モジュールが指定されているので、クラスを指定します: |
                            from datetime import datetime
                            date: Optional[datetime]
        定数: #keyword: Python const
            const: 使えません
            定数: 定数として扱われませんが、一般的にはクラス属性に定数を設定します
                #search: Python class attribute
            変数: 変数に定数を入れます
        列挙型 (Enum):  #keyword: Python enumeration  #ref: ${programming}/スクリプト/Python.svg#enum
            基本: |  #// 列挙型のメンバーはオブジェクトです
                from enum import Enum
                class Color(Enum):
                    RED = 1
                    GREEN = 2
                    BLUE = 3
                    DEEP_BLUE = 4
            比較: |  #// RED はオブジェクトです
                if Color.RED is Color.RED:  // True
                if Color.RED.value == 1:  // True
            一覧: |
                for name, member in Color.__members__.items():
            文字列から列挙型へ:
                サンプル:
                    Color['RED']
                    #ref: https://stackoverflow.com/questions/41407414/convert-string-to-enum-in-python
                一致しない場合:
                    例外が発生します。一致しないときの値は指定できません。
                    #ref: https://stackoverflow.com/questions/43252708/what-kind-of-exception-to-raise-for-unknown-enum-value
            列挙型から列挙型へ:
                Signal.map_from(ModeEnum.ENABLED)
                #ref:
            (@enum.unique):  #// 重複させない
                値が重複したらエラーにします
            派生属性:  #// 列挙値のグループ化
                定義: |  #// is_active = NOT_START or RUNNING
                    from enum import Enum

                    class Status(Enum):
                        NOT_START = "not_start"
                        RUNNING = "running"
                        FINISHED = "finished"
                        
                        @property
                        def is_active(self):
                            return self in (Status.NOT_START, Status.RUNNING)
                使用例: |
                    status = Status.RUNNING
                    if status.is_active:
            別名: #keyword: Python TypeAlias  #// 列挙型の別名を作ります
                Python 3.9 以前: |
                    __MyStatusEnum__ = __StatusEnum__
                Python 3.10, 3.11: |
                    from typing import TypeAlias
                    __MyStatusEnum__: TypeAlias = __StatusEnum__
                Python 3.12 以降: |
                    type __MyStatusEnum__ = __StatusEnum__
            リテラル型のユニオン:  #keyword: Python リテラル型のユニオン
                Python 3.8 以降: |  #// VSCode のエディターで警告されます（完全ではないが）
                    from typing import Literal

                    Status = Literal["pending", "approved", "rejected"]

                    def update_status(status: Status) -> None:
                        print(f"Status: {status}")

                    update_status("approved")   #// OK
                    update_status("invalid")    #// VSCode のエディターで警告されます
                    status: Status = "invalid"  #// VSCode のエディターで警告されます
                    if status == "invalid":     #// 警告されません
                        status = "pending"
                Python 3.7 以前: |  #// VSCode のエディターで警告されませんが、Status の型定義は正しく見えます
                    from typing_extensions import Literal

                    Status = Literal["pending", "approved", "rejected"]

                    def update_status(status: Status) -> None:
                        print(f"Status: {status}")

                    update_status("approved")    #// OK
                    update_status("invalid")     #// VSCode のエディターで警告されません
                    status: Status = "invalid"   #// VSCode のエディターで警告されません。Status の型定義は正しく見えます。
                    if status == "invalid":      #// 警告されません
                        status = "pending"
            トラブルシューティング:
                エラー, Cannot extend enumerations:
                    コード: |
                        class __SubEnum__(__SuperEnum__):
                    対処:
                        列挙型の別名を作ります  #search: Python TypeAlias
        グローバル変数:
            グローバル変数よりクラス属性を推奨します:  #search: Python class attribute
            サンプル: |  #keyword: Python global variable
                cc = 0

                ___debug   #// アンダーバーを付けると、クラス属性になったりするので非推奨。

                def increment(x):
                    global cc
                    cc += 1
                    return x + 1

                def decrement(x):
                    global cc
                    cc += 1
                    return x - 1
        特別なグローバル変数:
            参考: https://docs.python.org/ja/3/library/runpy.html
            __name__:  #keyword: Python __name__,  Python __main__
                import したときに実行しないようにします: |
                    def main():
                        print("Hello")
                    if __name__ == "__main__":
                        main()
                .py ファイルを実行したとき:
                    __name__ == "__main__"
                import されたとき:
                    __name__ == "（import に指定したモジュール名。ファイル名から .py を除いた名前）"
                参考: https://blog.pyq.jp/entry/Python_kaiketsu_180207
        オブジェクト: #keyword: Python Object
            #search: Python class
            Object 型: #keyword: Python Object type
                from runtime import Object
                a = Object()
                a.p = 1
            インスタンス:  #search: Python instance attribute
            比較: #search: Python object compare
            with:  #keyword: Python with  #ref: ${programming}/スクリプト/Python.svg#with
                概要: with は関数から戻るタイミングよりも早く __exit__ を呼び出します
                呼び出し側:
                    サンプル: |
                        with open("hello.txt") as hello:
                            print(hello.read())
                    サンプルと同じ処理のコード: |
                        hello = open("hello.txt")
                        try:
                            print(hello.read())
                        finally:
                            hello.close()
                    複数のオブジェクトのサンプル:
                        Python3.9以降: |
                            with (
                                    open("file1") as file1,
                                    open("file2") as file2,
                                    open("file3") as file3):
                                print(file1.read(), file2.read(), file3.read())
                        Python3.8まで: |
                            with \
                                    open("file1") as file1, \
                                    open("file2") as file2, \
                                    open("file3") as file3:
                                print(file1.read(), file2.read(), file3.read())
                呼び出される側:  #keyword: Python __enter__ __exit__
                    (@contextlib.contextmanager) を使う場合:
                        #search: @contextlib.contextmanager
                    __enter__, __exit__ を定義する場合:
                        サンプル コード: |  #focus: __enter__, __exit__, with
                            class MyWithClass:
                                def __enter__(self):
                                    print('withブロックに入ります')
                                    return self

                                def __exit__(self, exc_type, exc_value, traceback):
                                    print('withブロックを抜けます')
                                    if exc_type:
                                        print(f'    exc_type: {exc_type}')
                                        print(f'    exc_value: {exc_value}')
                                        print(f'    traceback: ({traceback})')

                            with MyWithClass() as c:
                                print('    withブロックを実行中です')

                            with MyWithClass() as c:
                                raise Exception('例外が発生しました')
                        サンプル コード の出力: |
                            withブロックに入ります
                                withブロックを実行中です
                            withブロックを抜けます
                            withブロックに入ります
                            withブロックを抜けます
                                exc_type: <class 'Exception'>
                                exc_value: 例外が発生しました
                                traceback: (<traceback object at 0x0000025D1B41BA48>)
                            Traceback (most recent call last):
                            File "c:/Users/____/Desktop/try_pytest/try.py", line 16, in <module>
                                raise Exception('例外が発生しました')
                            Exception: 例外が発生しました
                        __exit__ を直接呼び出す場合:
                            __exit__([])
                        参考: #ref: https://techacademy.jp/magazine/31663
                参考: #ref: https://www.python.jp/pages/with-statement-3.9.html
            public_dict:  #keyword: Python  deep_equals
                #search: public_dict
            UUID: #keyword: Python UUID
                生成: |
                    import uuid
                    uuid.uuid4()
        クラス:  #keyword: Python class  #ref: ${programming}/スクリプト/Python.svg#class
            クラス オブジェクト:
                サンプル: |
                    class  ClassA:         #// ClassA に クラス オブジェクト が入ります（class ブロックの最後で）
                        pass
                    instance_A = ClassA()  #// instance_A に インスタンス オブジェクト が入ります
                説明:
                    - class を実行すると、クラス オブジェクト が生成されます。
                    - クラス オブジェクトに () を付けて呼び出すと、インスタンス オブジェクト が生成されます。
                公式: https://docs.python.org/ja/3/tutorial/classes.html
            データ属性: #keyword: Python attribue
                インスタンス属性:  #// インスタンスの属性  #ref: https://docs.python.org/ja/3/tutorial/classes.html#instance-objects￥
                    データ属性:  #keyword: Python instance attribute
                        判別法: self があること                     
                        class __Class__:
                            def __Method__():
                                self.__InstanceAttribute__
                    有無: |
                        if hasattr(__Object__, '__AttributeName__'):
                    デフォルト値:  #search: Python class default value
                    削除:
                        -   del __Instance__.__Attribute__
                        -   delattr(__Instance__, '__Attribute__')
                dataclass: #search: Python @dataclass
                クラス属性: #keyword: Python class attribute  #// クラスの属性  #ref: https://docs.python.org/ja/3/tutorial/classes.html#class-objects
                    初期値: |  #// 定数はよくここに書かれますが、定数としては扱われません
                        class __Class__:
                            __ClassAttribute__ = 10
                    VSCode 対応:
                        __Class__.__ClassAttribute__ にマウスを合わせると 10 が表示されます。
                        ただし、Pylance 拡張機能をインストールすると表示されません。
                        定数ではありません。初期値として表示されます。
                    変更: |  #// self ではないことがポイント
                        class __Class__:
                            def __Method__(self):
                                __Class__.__ClassAttribute__
                    動的に初期化する場合:
                        #search: Python singleton
                    削除:
                        -   del __Class__.__Attribute__
                        -   delattr(__Class__, '__Attribute__')
                シングルトン: #keyword: Python singleton,   Python get_singleton
                    静的に初期化する場合:
                        呼び出し側 サンプル:
                            value = MySignleton.value
                        定義 サンプル: |
                            class MySignleton:
                                value = 123
                    動的に初期化する場合:
                        呼び出し側 サンプル:  #focus: get_singleton
                            service = MySignleton.get_singleton()
                        定義 サンプル: |
                            class MySignleton:
                                instance = None

                                @classmethod
                                def get_singleton(class_) -> 'MySignleton':
                                    if not class_.instance:
                                        class_.instance = MySignleton()
                                    return class_.instance

                                def __init__(self):
                                    pass
                プライベート変数:  #keyword: Python private attribute   #// プライベートな属性
                    外部からアクセスしない属性: #// _attr  #keyword: name mangling,  Python _attribute
                        命名規則: アンダースコア１つを先頭に付けます。例：_attribute
                        アクセス手段:
                            __Instance__.___HiddenAttributeName__  #// 例: obj._attr
                        言語機能: コンセンサスが得られている命名規則なだけで、アクセスできます
                    名前マングリングされる外部からアクセスしない属性: #// __attr  #keyword: name mangling,  Python __attribute,  名前マングリング
                        書式: アンダースコア２つを先頭に付けます。例：__attribute
                        アクセス手段:
                            __Instance__.___ClassName______HiddenAttributeName__  #// 例: obj._Class__attrA
                        言語機能: コンセンサスが得られている命名規則であり、名前マングリングによりアクセスしにくくなっていますが、アクセスできます
                        参考:  #search: Python not expected call
                        関連:  #search: JavaScript export not exported private_
                    公式: https://docs.python.org/ja/3/tutorial/classes.html#private-variables
                公式: https://docs.python.org/ja/3/tutorial/classes.html#instance-objects
            dataclass, リテラル:  #keyword: Python object literal,  dataclass  #ref: ${programming}/スクリプト/Python.svg#object_literal
                dataclass のインスタンス（リテラル）:  #keyword: Python @dataclass,  Python structure  #ref: https://docs.python.org/ja/3/library/dataclasses.html
                    サンプル プロジェクト:  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/class/dataclass.py#@dataclass
                    サンプル: |  #focus: instance, @dataclass
                        from dataclasses import dataclass

                        @dataclass
                        class Item:
                            name: str
                            unit_price: float
                            option: bool = False  #search: Python class default value

                        instance = Item(name='banana', unit_price=50)
                    __slot__ 自動生成: | #keyword: Python @dataclass __slot__  #search: Python __slot__
                        @dataclass(slots=True)
                        ...
                    __repr__ 自動生成: | #keyword: Python @dataclass __repr__  #search: Python __repr__
                        @dataclass(repr=True)  #// デフォルトは True 
                        ...
                    辞書から:
                        サンプル: |
                            #// Item の定義は上記
                            item_dict = {"name": "banana", "unit_price": 50}
                            instance = Item(**item_dict)
                        参考:  #search: @pytest.mark.parametrize object
                    ネストしたオブジェクト: |  #keyword: Python nested dataclass object  #focus: @dataclass, ParentAA, Child
                        from dataclasses import dataclass

                        @dataclass
                        class ParentA:
                            key: str
                            sub_key: str
                            child: 'ChildA'

                        @dataclass
                        class ChildA:
                            sub_key: str

                        an_object = ParentA(
                            key= "a",
                            sub_key= "b",
                            child= ChildA(
                                sub_key= "c",
                            ))

                        print(an_object)  #// ParentA(key='a', sub_key='b', child=ChildA(sub_key='c'))
                    デフォルト値:
                        デフォルト値, default value: #keyword: Python class default value
                            サンプル: | #focus: =
                                from dataclasses import dataclass
                                from packaging.version import Version
                                @dataclass
                                class Outer:
                                    name: str
                                    quantity: int = 0  #// デフォルト値は、__init__(quantity: int = 0) と等価です
                                    version: Version = Version('0.0.0')
                            基本型以外: #search: Python default_factory
                        サンプル, 辞書, 配列: |  #focus: @dataclass, Dict, Mappings, default_factory  #// 属性が辞書であるときの初期化をする（空の辞書にする）場合
                            from dataclasses import dataclass, field

                            Mappings = dict

                            @dataclass
                            class OutputJSON:
                                output_json: Mappings = field(default_factory=dict)  #search: Python class default value
                                requests: Dict[int, Mappings] = field(default_factory=dict)  # key = frame_num
                                frames: List[int] = field(default_factory=list)
                                error_time_epoch: float = 0
                        default_factory: #keyword: Python default_factory field  #keyword: Python 配列 array list 辞書 dict 初期化 initialize
                            #focus: default_factory
                            _: 基本的な型以外の初期値を設定するのに必要です
                            サンプル: |
                                from dataclasses import field

                                class OutputJSON:
                                    output_json: Mappings = field(default_factory=dict)
                                    requests: Dict[int, Mappings] = field(default_factory=dict)  # key = frame_num
                                    frames: List[int] = field(default_factory=list)
                                    address: Address = field(default_factory=Address)

                                @dataclass
                                class Address:
                                    street: str = ""
                                    city: str = ""
                            参考:
                                関数の デフォルト パラメーター 値:  #search: Python default parameter object
                    ジェネリクス dataclass: |  #focus: @dataclass, Generic
                        from dataclasses import dataclass
                        from typing import TypeVar, Generic
                        T = TypeVar('T')

                        @dataclass
                        class NamedItem(Generic[T]):
                            name: str
                            object: T

                        @dataclass
                        class Item:
                            name: str

                        instance = NamedItem(name='named', object=Item(name='item'))
                NamedTuple, 固定値:  #keyword: Python NamedTuple
                    サンプル: |
                        from typing import NamedTuple

                        class User(NamedTuple):
                            name: str

                        class MyStruct(NamedTuple):
                            foo: str
                            bar: int
                            baz: list
                            qux: User

                        my_item = MyStruct('foo', 0, ['baz'], User('peter'))
                バリデーション: #keyword: __post_init__, Python @dataclass varidation  #// データクラスのオブジェクトを生成したときに、指定された属性値をチェックします
                    #search: Python varidation
                    サンプル: |
                        @dataclass(frozen=True)
                        class UserName:
                        name: str

                        def __post_init__(self):
                            if not self.name:
                                raise ValueError('user name is empty string')
                    #ref: https://ja.stackoverflow.com/questions/74519/pythonのdataclassで値のバリデーションをする方法
                旧 オブジェクト リテラル: |
                    class  TemporaryClass:
                        def  __init__( self ):
                            self.aa = "a"
                            self.bb = "b"
                    obj = TemporaryClass()
                辞書: |
                    dic = { "year": 2000, "month": 1 }
                    print( dic[ "year" ] )  #// 2000
                参考: #ref: https://stackoverflow.com/questions/35988/c-like-structures-in-python
            メソッド: #keyword: Python method
                関数:  #search: Python function
                静的メソッド: | #keyword: Python static method  #focus: method
                    class TesteeClass:
                        @staticmethod
                        def method(argument):
                            ____
                        def caller(argument):
                            self.method()
                    def call_from_global():
                        TesteeClass.method()

                    method = TesteeClass.method
                    def call_from_global_2():
                        method()
                クラス メソッド: | #keyword: Python class method,  Python static method ではない  #focus: @classmethod
                    class TesteeClass:
                        @classmethod
                        def method(cls, argument):
                            ____
                __init__: #keyword: Python __init__
                    概要:
                        引数の構成が異なる複数の __init__ を定義することはできません。
                        デフォルトの関数引数や args、kwargs は使えます。内部で __init__ メソッドを呼び出します。
                        #ref: https://www.geeksforgeeks.org/what-is-a-clean-pythonic-way-to-have-multiple-constructors-in-python/
                __str__: #keyword: Python __str__,  Python object str  #// 人間が読みやすい形式の文字列。デフォルトの例外メッセージ
                    サンプル: |
                        class MyClass:
                            def __str__(self):
                                return ...   #// 文字列
                    例外発生時の表示内容:
                        traceback.format_exc の返り値には、__str__ による文字列が含まれます
                __repr__: #keyword: Python __repr__  #// 開発者向けの整形された（公式な）文字列
                    #//「公式な表現」（official string representation）
                    サンプル: |  #focus: repr
                        # リストの場合
                        my_list = [1, 2, 3]
                        print(repr(my_list))  # [1, 2, 3] と表示される

                        # 日付オブジェクトの場合
                        import datetime
                        today = datetime.datetime.now()
                        print(repr(today))  # datetime.datetime(2025, 5, 20, 12, 34, 56, 789012) のように表示される

                        # オブジェクトのデフォルトの__repr__
                        person = Person("田中", 30)
                        print(repr(person))  # <__main__.Person object at 0x7f8a1c3b4d90> のように表示

                        # オブジェクトの場合
                        class Person:
                            def __repr__(self):
                                return f"Person(name='{self.name}', age={self.age})"
                        person = Person("田中", 30)
                        print(repr(person))  # Person(name='田中', age=30) と表示
                    例外発生時の表示内容:
                        traceback.format_exc の返り値には、__repr__ による文字列が含まれません。 __str__ から含まれます  #search: Python __str__
                __del__: #keyword: Python __del__,  Python destructor
                    関連 >> finally close 方式:  #search: @contextlib.contextmanager
                __slot__: #keyword: Python __slot__  #// インスタンス変数の構成を固定します
                    サンプル: |  #focus: name
                        class Person:
                            __slots__ = ['name', 'age']
                            def __init__(self, name, age):
                                self.name = name
                                self.age = age
                    効果:
                        - メモリーの使用効率が良くなります
                        - 少し高速になります
                        - 指定されたインスタンス変数以外は動的に追加されないため、一覧できます
                    注意:
                        - __dict__ 属性は自動的に作られません。@dataclass が付いている場合でも同じです  #search: Python @dataclass __slot__
                        - 親クラスのインスタンス変数も __slots__ に指定する必要があります
                __init_subclass__: #keyword: Python __init_subclass__  #// サブクラスが生成されたときに呼び出されます
            __init__ など:  #search: Python __init__
            type, mro, isinstance, issubclass:  #// サブクラス
                type:  #// インスタンス ⇒ 型  #keyword: Python type,  Python type typeof
                    書式: type(__Instance__) -> type or Type[__TypeOfInstance__]  #search: Python typing Type type
                    文字列を返す場合: |
                        str(type(__Instance__)) == "<class '__PeriodPath__.__Class__'>"
                        "__Class__" in str(type(__Instance__))
                    基本: #focus: type
                        print(type(1) == int)  #// True
                    継承があるオブジェクトの型:
                        基本: |  #focus: Sub
                            class Super:
                                pass
                            class Sub(Super):
                                pass

                            print(type(Sub()) == Sub)  #// True
                        ダウンキャスト: |  #focus: Sub
                            class Super:
                                pass
                            class Sub(Super):
                                def __init__(self):
                                    self.sub_attribute = 1
                            def function(super: Super):
                                if type(super) == Sub:
                                    sub: Sub = super
                                    print(sub.sub_attribute)

                            function(Sub())
                Type[__TypeParameter__]:  #keyword: Python typing Type type
                    サンプル: |
                        a = 3         # Has type 'int'
                        b = int       # Has type 'Type[int]'
                        c = type(a)   # Also has type 'Type[int]'
                    公式: #ref: https://docs.python.org/ja/3/library/typing.html#typing.Type
                .type:  #// インスタンス ⇒ 型  #keyword: Python dot type
                    書式: __Instance__.type
                ('__ClassName__'): #keyword: Python Forward references  #// '__ClassName__'
                    概要: 型が定義される前でも型の参照を書くことができるようにします
                    サンプル:
                        エラーになるコード: |
                            class Tree:
                                def __init__(self, left: Tree, right: Tree):
                        エラーを回避したコード: |  #// __init__ の Tree を 'Tree' に変えます
                            class Tree:
                                def __init__(self, left: 'Tree', right: 'Tree'):
                    公式:  #ref: https://www.python.org/dev/peps/pep-0484/#forward-references
                    参考:  #ref: https://stackoverflow.com/questions/55320236/does-python-evaluate-type-hinting-of-a-forward-reference
                __class__:  #// インスタンス ⇒ クラス  #keyword: Python __class__
                __module__: #keyword: Python __module__
                    ファイル名や ファイル パス から定義されるモジュール
                    file1.py なら file1 モジュール
                mro:  #// 型 ⇒ 親クラスのリスト。リストの順番はメソッドを探すクラスの順番  #keyword: Python mro
                    書式: __Class__.mro() -> [type, ...]
                is: #search: Python is
                isinstance: #keyword: Python isinstance
                    書式: isinstance(__Instance__, __ClassOrSuperClass__) -> boolean
                    複数のクラスのうちどれか: isinstance(__Instance__, (__ClassA__, __ClassB__)) -> boolean
                issubclass: #keyword: Python issubclass
                    書式: issubclass(__SubClass__, __SuperClass__) -> boolean
                    補足: 第1引数にはインスタンスを指定できません
                callable:
                isinstance(value, Iterable):
                get_type_hints: #keyword: Python get_type_hints  #// 型ヒント情報を取得します
                    -   typing.get_type_hints(cls, globalns=vars(mod))
                        は cls クラスの型ヒント情報を返します。
                    -   get_type_hints() を使うには、実行時にも型情報が必要です。
                        import が相互依存している場合  #search: Python typing.TYPE_CHECKING mutual import  #search: Python 相互 import
                ForwardRef, self.__forward_code__: #keyword:  #// 前方参照、依存クラス
                    クラスの「前方参照」(typing の ForwardRef クラス？) の型は、
                    内部で、属性の型、メソッドの引数の型、メソッドの返り値の型 のいずれかに少なくとも１つあります。
                サンプル: |
                    print('A < B < C')
                    class ClassA:
                        pass
                    class ClassB(ClassA):
                        pass
                    class ClassC(ClassB):
                        pass
                    print( issubclass(ClassB, ClassA))  #// True
                    print( issubclass(ClassA, ClassB))  #// False
                    print( issubclass(ClassC, ClassA))  #// True
                    print( ClassC.mro())  #// [<class '__main__.ClassC'>, <class '__main__.ClassB'>, <class '__main__.ClassA'>, <class 'object'>]

                    b = ClassB()
                    print( type(b))       #// <class '__main__.ClassB'>
                    print( type(ClassB))  #// <class 'type'>
                    print( isinstance(b, ClassB))  #// True
                    print( isinstance(b, ClassA))  #// True
                    try:
                        print( issubclass(b, ClassB))
                    except Exception as ex :
                        print( "exception: "+ type(ex).__name__ +": "+ str(ex) )  #// exception: TypeError: issubclass() arg 1 must be a class

                    print('(X, Y) < Z')
                    class ClassX:
                        pass
                    class ClassY:
                        pass
                    class ClassZ(ClassX, ClassY):
                        pass

                    print( issubclass(ClassZ, ClassX))  #// True
                    print( issubclass(ClassZ, ClassY))  #// True

                    z = ClassZ()
                    print( isinstance(z, ClassX))  #// True
                    print( isinstance(z, ClassY))  #// True
                    print( isinstance(z, ClassZ))  #// True
            setattr, getattr, delattr:  #// インスタンスに属性やメソッドを追加します  #keyword: Python setattr getattr delattr
                概要: アクセスする属性やメソッドを文字列で指定します。
                    属性の追加は setattr を呼び出す必要はありません（下記サンプルを参照）。
                書式: setattr(__Instance__, __AttributeNameString__, __Value__)
                公式:
                    setattr:  #ref: https://docs.python.org/ja/3/library/functions.html#setattr
                    getattr:  #ref: https://docs.python.org/ja/3/library/functions.html#getattr
                    delattr:  #ref: https://docs.python.org/ja/3/library/functions.html#delattr
                getattr サンプル: |  #// プロパティの左が None でもエラーになりません（未確認） #keyword: Python getattr None property
                    getattr(object, 'property')
                    getattr(object, 'property', 'property')
                    #ref: https://stackoverflow.com/questions/46085794/python-get-property-if-object-is-not-none
                setattr サンプル: |
                    class ClassA:
                        pass
                    a = ClassA()

                    a.attribute1 = 11
                    print(a.attribute1)  #// 11
                    def  method1_of_ExtendedClass(self):
                        print('method1: ' + str( self.attribute1 ))

                    ClassA.method1 = method1_of_ExtendedClass
                    a.method1()  #// method1: 11

                    ClassA.method1_l = lambda self: print('method1: ' + str( self.attribute1 ))
                        #// 非推奨。lambda は名前で検索やデバッガーのウォッチで関数名が表示できなくなるため
                    a.method1_l()  #// method1: 11
                    def  function1():
                        print('in function1')

                    a.function1 = function1
                    a.function1()  #// in function1

                    setattr(a, "attribute2", 22)
                    print(a.attribute2)  #// 22

                    setattr(ClassA, "method2", lambda self: print('method2: ' + str( self.attribute2 )))
                    a.method2()  #// method2: 22
                オプションの設定に setattr を使う: |
                    class ClassA:
                        def  __init__(self, options):
                            self.attribute1 = 10
                            self.attribute2 = 20
                            for key, value in  options.items():
                                setattr(self, key, value)

                    a = ClassA({"attribute2": 22})
                    print(a.attribute1)  #// 10
                    print(a.attribute2)  #// 22
                親クラスの属性もフラットにアクセスする:  #// self.parent.attr ⇒ self.attr
                    注意: 属性の定義へジャンプできなくなります。代わりに親オブジェクトを属性に持つオブジェクトを使います #search: Python parent object facade
                    使用サンプル: |
                        self = objects[1]
                        self.attr  #// self.parent.attr
                    定義サンプル: |
                        class Flat:
                            __leaf: ClassB
                            __parent: ClassA

                            def __init__(self, ____):
                                ____

                            def __getattr__(self, key: str):
                                try:
                                    return getattr(self.__leaf, key)
                                except AttributeError:
                                    return getattr(self.__parent, key)
                    クラスを指定してフラットにアクセスする: #keyword: Python parent object facade
                        使用サンプル: |
                            self = objects[1]
                            self.class_b.attr  #// self.parent.attr の代わり
                            self.class_a.attr  #// self.parent.parent.attr の代わり
                        定義サンプル: |
                            class TypedFlat:
                                class_c: ClassC
                                class_b: ClassB
                                class_a: ClassA

                            def __init__(self, leaf: ClassB):
                                self.class_c = leaf
                                self.class_b = leaf.parent
                                self.class_a = leaf.parent.parent
            プロパティ: #keyword: Python property  #// 属性にアクセスするようにメソッドを呼び出します
                サンプル: |
                    @property
                    def property_A(self) -> bool:
                        return  self.__property_A
                __getattr__ と @property の両方定義した場合:
                    両方呼ばれ、__getattr__ の返り値が返るようです（呼ばれることは確認済み。返り値は未確認）
                    __getattr__ がどうしても必要なら、__getattr__ から分岐させます。
                関連 >> データ属性:  #search: Python attribue
            継承, スーパークラス, ABC:  #keyword: Python inheritance,  Python super class
                スーパークラス:
                    サンプル: |  #focus: __SuperClass__, super
                        class __SubClass__(__SuperClass__):
                            def __init__(self):
                                super().__init__()
                    キャスト: |  #search: Python type cast
                            object: __SubClass__ = object  #// 同じ変数名に違う型を入れることもできます
                        #// 関連 #search: Python type cast
                ABC: #keyword: Python ABC,  Python Abstract Base Class interface
                    サンプル: |  #focus: @abstractmethod
                        from abc import ABC, abstractmethod

                        class __SuperClass__(ABC):
                            @abstractmethod
                            def method1(self):
                                pass

                        class __SubClassA__(__SuperClass__):
                            def __init__(self):
                                pass

                        class __SubClassB__(__SuperClass__):
                            def __init__(self):
                                pass
                    プロパティ: |  #focus: @property, @abstractmethod
                        from abc import ABC, abstractmethod

                        class __SuperClass__(ABC):
                            @abstractmethod
                            def method1(self):
                                pass

                            @property
                            @abstractmethod
                            def area(self):
                                pass
                            
                            @property.setter
                            @abstractmethod
                            def area(self, value):
                                pass
                    インターフェースとの違い:
                        メソッドの実装が可能
            ネストしたクラス:  #keyword: Python nested class
                外のクラスから中のクラスを参照する場合:
                    概要: 普通の書き方で参照できます。ただし、self が必要な場合があります
                    サンプル: |  #focus: Inner
                        class Outer:
                            class Inner:
                                pass

                            def __init__(self, inner: Inner):  #// Outer.__init__
                                self.inner = inner

                            def get_object(self) -> Inner:  #// 下で Inner が定義されている場合、'Inner'
                                object = self.Inner()
                                return object
                中のクラスから外のクラスを参照する場合:
                    外のクラスのメソッドの中で定義したクラスを参照する場合:
                        概要: 普通の書き方で参照できます
                        サンプル: |  #focus: Outer, Inner
                            class Outer:
                                def __init__(self):
                                    class Inner:
                                        def __init__(self, outer: Outer):
                                            self.outer = outer
                                    self.inner = Inner(self)
                            outer = Outer()
                            print(outer)
                    中のクラスのメソッドに外のクラスの引数を持つ場合:
                        概要: 型名を ' ' で囲みます
                        サンプル: |  #focus: Outer, Inner
                            class Outer:
                                class Inner:
                                    def __init__(self, outer_argument: 'Outer'):
                                        self.outer = outer_argument

                            outer = Outer()
                            inner = Outer.Inner(outer)
                            print(outer)
                            print(inner)
                        複合サンプル: |  #focus: Outer, Inner
                            class Outer:
                                class Inner:
                                    def __init__(self, label: str, outer_argument: 'Outer'):
                                        self.label = label
                                        self.outer1 = Outer('outer1')
                                        self.outer2 = outer_argument
                                def __init__(self, label: str):
                                    self.label = label
                                def set_inner(self):
                                    self.inner1 = Outer.Inner('inner2', self)

                            outer = Outer('outer0')
                            inner = Outer.Inner('inner0', outer)
                            print(outer)
                            print(inner)
                    メソッドに同じレベルの外のクラスの引数を持つ場合:
                        概要: ルート レベル の外のクラス、ピリオド、同じレベルの外のクラスを ' ' で囲みます
                        サンプル: |  #focus: Outer, Inner
                            class Outer:
                                class Inner1:
                                    def __init__(self):
                                        self.label = 'inner1'
                                class Inner2:
                                    def test(self, inner1_argument: 'Outer.Inner1'):
                                        self.inner1 = inner1_argument

                            inner2 = Outer.Inner2()
                            inner2.test(Outer.Inner1())
                            print(inner2)
                    参考: #ref: https://stackoverflow.com/questions/2024566/how-to-access-outer-class-from-an-inner-class
            クラスを書く順序:  #keyword: Python ' class
                サンプル:
                    エラー: |
                        class ClassA:
                            def method() -> ClassB:  #// エラー
                                pass
                        class ClassB:
                            pass
                    対応: |
                        class ClassA:
                            def method() -> 'ClassB':
                                pass
                        class ClassB:
                            pass
            補足:
                Object や object から継承すべきか:  #keyword: Python Object super class
                    Python 3 では Object を継承しないコードを使って問題ありません:
                    継承するコード:
                        class MyClass(Object):
                    継承しないコード:
                        class MyClass:
                    参考: https://stackoverflow.com/questions/4015417/why-do-python-classes-inherit-object
        ジェネリクス:  #keyword: Python generics  #ref: https://docs.python.org/ja/3/library/typing.html#generics
            型引数型の宣言: T = TypeVar('T')
            ジェネリック クラス の参照: |
                items = Sequence[int]()   #// Sequence は ジェネリック クラス のサンプルです
                                          #// int が新しい型なら、クラス インスタンス も生成されるようです
                items.method()            #// Sequence クラスのメソッドが呼ばれます
            ジェネリック クラス の定義: |
                from typing import TypeVar, Generic

                T = TypeVar('T')      # Declare type variable

                class Sequence(Generic[T]):   # Generic class
                    def method(argument: T):
                        ____;
            ジェネリック関数: |
                from collections.abc import Sequence
                from typing import TypeVar

                T = TypeVar('T')      # Declare type variable

                def first(l: Sequence[T]) -> T:   # Generic function
                    return l[0]
        DI, injector:  #ref: ${programming}/スクリプト/Python.svg#injector  #keyword: Python DI injector,  dependency injection
            注意: DI を使ったコードは、定義にジャンプすることで簡単にクラス構造を調べることができなくなります
                #search: DI debug
            概要, DI 一般:
                DI:  #// = Dependency Injecton  #keyword: DI  #ref: ${programming}/方法論/オブジェクト指向.svg#DependencyInjection
                    #search: Abstract Factory
                目的:
                    - 子オブジェクトのクラスをパラメーター化します。
                        逆にパラメーターではないオブジェクトは DI にしなくてよい
                    - シングルトンのインスタンスの生成を遅延させる ファクトリー パターン です
                    - グローバル変数や TLS (Thread Local Storage) よりも、子オブジェクトの一覧性が上がります。
                        メソッドの内部を調べなくて済むからです
                    - 処理部分によって構成を変えるときは、スコープを定義します。
                        スコープは通常 スレッド ローカル ストレージ、または HTTP などの API リクエスト に関連付けられます
                    #↓ デメリット
                    - DIは内部のオブジェクトをインジェクトする（パラメーター化する）ときだけ有意義だから、ライブラリのクラスに使うものと考えている。
                        普通のクラスは不要。なぜなら静的でも編集できるから。パラメーター化は動的なので柔軟性が増える気がするが、
                        静的解析できなくなるデメリットのほうが大きい。
                        #ref: https://x.com/Ts_Neko/status/1768923978033426824
                    - スーパークラスを引数に取ると何が来るか分からない。
                        ブレークすればわかる
                    - 順序がブラックボックスなので期待と違う時にすごい困る
                デメリットと対策:
                    - 依存するオブジェクトを渡す処理をユーザーが書く必要があります。 シンプルに実装する場合は、
                        全インスタンスの KeyValue のパッケージを渡すか、
                        起動時に呼ぶ専用の 1つの関数がまとめて行います。
                        前者はデータを構造化できるのでお勧めです。
                        後者は適切な内部インスタンスまでユーザーが網羅しなければなりません。
                    - 依存するオブジェクトを渡す処理に DI ライブラリ を使うと、
                        デバッグが難しくなります
                    - 内部で完結して置き換える可能性がないオブジェクトまで引数にすると、
                        細かすぎて複雑になります。
                        String クラスなどは生成して問題ありません。
                遅延生成:  #// 性能の観点
                    DI の遅延生成機能を使うことで、初期化を速くします。
                    ただし、高速化が必要になってからでよい。（早すぎる最適化）
                    初期化コスト vs 使用頻度
                基本 >> コンストラクター:
                    手順:
                        - コンストラクターに子オブジェクトや関連するのオブジェクトを渡します。
                        - コンストラクターでオブジェクトを生成しません
                    コード: |  #// Python (typeless version)
                        class  UserService:
                            def  __init__(self, repository):
                                self.repository = repository  # 外部から注入
                    （問題のない違反したコード）:  #search: Safe not DI
                    メリット:
                        - テスト時にモックを渡せます
                    #ref: https://qiita.com/kentosity/items/d8654dad4fbf216f6843#2-依存性の注入dependency-injection-di
                問題のない違反したコード: | #keyword: Safe not DI  #// Python
                    // コンストラクターでオブジェクトを生成してはいけないことはありません。
                    // 渡されたオブジェクトに置き換えられるデフォルトのオブジェクトであれば生成してもテスト時にモックを渡せます
                    // 依存するグローバル変数が分からなくなることはありません。 import 文に一覧されています。
                    // Dependent global instances: => というコメントより下に import 文を分けます

                    import  Repository  #// class
                    // Dependent global instances: =>
                    import  repository  #// instance

                    class  UserService:
                        def  __init__(self, dependencies = None):
                            self.repository = dependencies.repository if dependencies else repository
                処理順序:
                    クラス登録:
                        - クラスを登録する処理が最初に必要ですが、それを自動的に行うライブラリもあります
                    注入クラス登録:  #// 使わないことが多い
                        - 注入するサブクラスを設定します。注入するとは、所有の子のオブジェクトを生成して、所有の親のオブジェクトの属性に設定することです。
                    インスタンス get or create:
                        - 所有の子のオブジェクトを生成するタイミングは、DI を使わない場合と同じタイミングです（子を共有しない限り）
                データ構造:
                    - 所有の子のオブジェクトは特に指定をしないと共有します（共有しない設定もある）
                デバッグ:
                    - DI のデバッグの難しさは、注入するインスタンスが条件によって変わるときに、事前に登録しているコードを探すことが難しいことです。
                        #search: DI debug
                    - ログ機能の中でブレークさせます
                        #search: Django logger break point
            公式:
                injector:
                    #ref: https://github.com/alecthomas/injector
                    #ref: https://injector.readthedocs.io/en/latest/api.html
                    #ref: https://injector.readthedocs.io/en/latest/index.html
            サンプル: #ref: ${GitHub}/MyPrivateCode/Python/try_Python_injector
            injector.get:  #keyword:  #// インスタンスを取得します。インスタンスが無ければボトムアップに生成します。条件によって注入するインスタンスが変わらない場合
                (@inject):  #// Outer.__init__ に @inject をデコレートします  #keyword: Python DI injector @inject
                    概要: injector.get を呼び出すと、ボトムアップにオブジェクトの構築と __init__ の呼び出しを行います。
                    動き: |
                        下記の injector.get を呼び出すと、
                            データ ツリー:
                                Outer::__init__(_: Inner)
                                    Inner::__init__()
                        に従って、以下の順にコールします。
                            コール ツリー:
                                Inner::__init__()
                                Outer::__init__()
                    main.py : |  #// Outer (注入されるオブジェクト) <>-- Inner (注入するオブジェクト)
                        from injector import Injector, inject
                        from inner import Inner

                        def main():
                            injector = Injector()

                            outer = injector.get(Outer)  #// データ ツリー に従って __init__ をコールしていきます
                            print(outer.inner.forty_two)

                        class Outer:  #// 注入されるオブジェクト
                            @inject
                            def __init__(self, inner: Inner):
                                self.inner = inner

                        main()
                    inner.py : |
                        class Inner:  #// 注入するオブジェクト
                            def __init__(self):
                                self.forty_two = 42
                (@dataclass):  #// メソッドの無い Outer クラスに @dataclass をデコレートします  #keyword: Python DI injector @dataclass
                    (@dataclass)を使う場合: |  #// @dataclass を使う場合も @inject は必要です
                        @inject
                        @dataclass
                        class Outer:
                            inner: Inner
                    (@dataclass)を使わない場合の上記と同じコード: |
                        class Outer:
                            @inject
                            def __init__(self, inner: Inner):
                                self.inner = inner
                    参考:
                        (@dataclass) は Python の仕様です:  #ref: https://www.python.org/dev/peps/pep-0557/
                        サンプル: |
                            @dataclass
                            class Outer:
                                name: str
                                quantity: int = 0  #// デフォルト値は、__init__(quantity: int = 0) と等価です
                        デフォルト値:  #search: Python class default value
            Injector クラスの引数:  #// 事前に、注入する予定のインスタンスを条件によって変えます
                サンプル: |  #ref: ${GitHub}/MyPrivateCode/Python/try_Python_injector/try_Python_injector_2/try.py#injector = Injector
                    injector = Injector([configure, ModuleClass()])  #// 下記 configure と ModuleClass を参照
                bind を呼び出す 関数:  #// ファクトリー パターン に相当する関数  #keyword: Python DI injector binder.bind
                    ConfigurationClass クラスを登録するサンプル: |
                        def main():
                            injector = Injector([configure])
                            outer = injector.get(Outer)

                        def configure(binder):
                            binder.bind(ConfigurationClass, to=ConfigurationClass(), scope=singleton)
                    説明:
                        モジュール: クラスに対応するインスタンスを登録する関数
                        その他:
                            binder 引数は Injector から提供されます
                            クラスからオブジェクトを返すファクトリー（パターン）をモジュールと呼び、
                            それを Injector のコンストラクターに渡します。
                (@provider) のメソッドを持つ インスタンス:  #keyword: Python DI injector @provider
                    Connection クラスを登録するサンプル: |
                        def main():
                            injector = Injector([ModuleClass()])
                            outer = injector.get(Outer)

                        class ModuleClass(Module):
                            @singleton
                            @provider
                            def provide_sqlite_connection(self, conf: ConfigurationClass) -> Connection:
                                return  sqlite3.connect(conf.connection_string)
                    説明:
                        クラスに対応するメソッドを持つインスタンスがモジュールです。
                        クラスからオブジェクトを返すファクトリー（パターン）をモジュールと呼び、
                        それを Injector のコンストラクターに渡します。
            DI によるエラーを解析します: #keyword: DI debug,  DI error
                解析例:
                    step 1:
                        ログ: |
                            ValueError: Error constructing handler for request of type __RequestedClass__
                        状況:
                            __RequestedClass__ は、リクエストされたクラスですが、
                            そのクラスのインスタンスの登録が必要というわけではありません。
                        対処:
                            例外が発生する近くでブレークさせ、
                            次の例外でブレークするようにブレークポイントを張り、
                            例外メッセージから、何のインスタンスが登録されていないかを推測します。
                    step 2:
                        ログ: |
                            InvalidOperationError: Unable to resolve service for type '__A__' while attempting to activate '__B__'
                        状況:
                            __B__ を作成しようとしたが、__B__ のコンストラクターが必要とする __A__ 型（のサービス）のインスタンスが見つけられませんでした。
                        対処:
                            __A__ のインスタンスの登録が必要です。
                子から親を調べる場合:
                    - 親から辿ると一部は抽象クラスになってしまいますが、子から辿るとインスタンスのクラスが分かります
                    - インスタンス（子クラス）の初期化 __init__ にブレークポイントを張ります
                    - コールスタックから親方向に、クラス名を確認します
                親から子を調べる場合:
                    - コンストラクター（Go言語なら Provider）を調べます
                    - 実装クラスを調べます  #search: go navigate implementation
            内部クラスを複数使ったお試しコードを実行する場合:
                メインに近い package にお試しコードを書きます:
                    複数のクラスに共通する親 package を探します
                クラスが必要な場合:
                    概要:
                        メインに近い共通の package からクラスを参照するための import を書きます
                        インターフェースではなく実装クラスを参照します
                    Go 言語:
                        内部: |
                            import  pack
                        メイン: |
                            _ = pack.EventLogClass{}
                インスタンスが必要な場合:
                    概要:
                        使用するオブジェクトを get する公開関数（メソッドではない）またはグローバル変数を作り、
                        メインに近い共通の package から呼び出します。
                    Go 言語:
                        内部: |  #focus: TryClient
                            import  pack
                            var TryClient *elastic.Client
                            func ____() {
                                TryClient = GetClient()
                            }
                        メイン:
                            _ = pack.TryClient
            トラブルシューティング(DI, injector):
                - #// binder.bind に指定したクラスのコンストラクターが呼ばれてしまう
                    手順: injector.get() を呼び出したとき
                    エラー: binder.bind に指定したクラスのコンストラクターが呼ばれてしまう
                    状況:
                        - injector.get に指定したクラスのスーパークラスを binder.bind で置き換えることはできません。
                            __init__ から対象のクラスの __init__ を呼び出すときの後者はスーパークラスです。
                        - モックでも置き換えられません  #search: mock.patch.object
                    対処:
                        injector.get に指定したクラスまたはそのスーパークラスの __init__ にある引数を
                        binder.bind で置き換えることはできます。
                - #// injector.UnknownProvider: couldn't determine provider for
                    手順: injector.get() を呼び出したとき
                    エラー: |
                        injector.UnknownProvider: couldn't determine provider for __TypeA__ to None
                        injector.UnknownProvider: couldn't determine provider for __TypeA__ to __InstanceB__
                        UnknownProvider
                    対処: |
                        def configure(binder):
                            binder.bind(__TypeA__, to=__ClassB__, scope=singleton)
                        injector = Injector([configure])
                        ____ = injector.get(____)
                - #// Can't instantiate abstract class
                    手順: injector.get
                    エラー: |
                        injector.CallError: Call to ABCMeta.__new__() failed: Can't instantiate abstract class __ChildClass__ with abstract methods __Methods__ (injection stack: [<class '__ParentClass__'>])
                        __FilePath__:__LineNumber__: CallError
                    対処:
                        binder.bind(__ChildClass__), to=__NotAbstractClass__, scope=singleton)
                - #// missing __Number__ required positional arguments
                    手順: injector.get
                    エラー: |
                        injector.CallError: Call to __ChildClass__.__init__() failed: __init__() missing __Number__ required positional arguments: ____ (injection stack: [<class '__ParentClass__'>, ____)
                        __FilePath__:__LineNumber__: CallError
                    対処A:
                        (@injector) デコレーターを指定します。
                        (@injector) デコレーターが意図的にオーバーライドされて無効化されている可能性もあります。
                    対処B:
                        パラメーターを取らない __init__ を持つ __NotAbstractClass__ を定義し
                        binder.bind(__ChildClass__), to=__NotAbstractClass__, scope=singleton)
                    対処C: |
                        with mock.patch.object(__packag__, '__ChildClass__', return_value=__NotAbstractClass__()) as class_mock:
                        の行を削除します
        None: | #keyword: Python None,  Python null nil ではない
            var = None
            if var is None:
            if var is not None:
        デフォルト値: #keyword: Python default,  Python initial value
            辞書の値のデフォルト値:  #search: Python dict get
            インスタンスのデフォルト値:  #search: Python default_factory field
            関連 >> 関数の デフォルト パラメーター値:  #search: Python default parameter values
        環境変数: #keyword: Python environment variable,  Python env var
            参照: |
                import os
                print(os.environ[ 'USERPROFILE' ])  #// 参照。キーが無いとエラーになります
                print(os.environ.get( 'USERPROFILE', 'unknown_profile'))  #// 参照。キーが無いと第2引数の値になります
                print(os.environ)  #// 一覧
            値を確認します:
                最初に実行する .py ファイルの先頭で:
                    import os
                    print(os.environ['PYTHONPATH'])
            設定:
                基本:
                    os.environ['NEW_KEY'] = 'test'
                pytest: |
                    def test(self, monkeypatch):
                        monkeypatch.setenv("MY_VAR", "test_value")
            Visual Studio Code + Python プロジェクトの環境変数:
                #search: VSCode .env 環境変数
    制御:
        比較:
            a < b < c:  #// 連結した比較, chained comparison, a < b < c  #keyword: chained comparison
                参考:
                    - #ref: https://docs.python.org/3/reference/expressions.html?highlight=chained#comparisons
                    - #ref: https://www.python.org/dev/peps/pep-0535/
            オブジェクトや List の比較: #keyword: Python object compare
                x is y: オブジェクト（のID）が同じ  if object is None  #keyword: Python is  #search: Python id
                x not is y: オブジェクト（のID）が異なる
                x is not y: #keyword: Python is not
                    オブジェクト（のID）が異なる  is not のほうが not y より結合度が高い
                    #ref: https://stackoverflow.com/questions/4485180/python-is-not-operator
                        #// a is not b cannot be parsed as a is (not b) because the is operator has a higher precedence than the not operator in python.
                x == y:  #keyword: Python ==
                    基本:
                        下記以外の一般的なクラス: test_object_ID を比較します
                        __eq__ メソッドが定義されているクラス: __eq__ メソッドの返り値  #keyword: Python __eq__
                        dataclass:
                            既定の __eq__: それぞれの属性
                            既定の __eq__ を使わない場合: |
                                    @dataclass(eq=False)
                                #ref: https://stackoverflow.com/questions/64482975/how-to-compare-instances-subclasses-of-dataclass-with-same-inheritance
                        List: List の要素が同じ
                    assert に失敗した場合:
                        dataclass: pytest (pytest.ini の addopts) に -vv オプションを指定すると違いがある場所が例外のメッセージに含まれます
                            #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s41_assert_calls/s41_test.py#test_assert_eq
                        __eq__ メソッドが定義されているクラス:
                            基本: __eq__ メソッドの中をステップ実行して期待と異なる原因を特定します
                            モック関数を呼び出したときの引数をテストしている場合:
                                _: False を返した __eq__ メソッドを特定するデバッグ用関数があります
                                debug_eq_method_in_call_args_list: #keyword:
                                    #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s41_assert_calls/s41_test.py#debug_eq_method_in_call_args_list
                        List: 失敗した要素番号が例外のメッセージに含まれます
                            #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s41_assert_calls/s41_test.py#test_debug_eq
                intern: #keyword: Python intern  #ref: https://qiita.com/amedama/items/66b5f797326198b51a2f
                    文字列をオブジェクトにします。同じ文字列値なら同じオブジェクトになります
                参考:
                    id: id(object)  #keyword: Python id  #// オブジェクトのID
                    #ref: https://www.javadrive.jp/python/if/index5.html
            not: #keyword: Python not
                not が True になる例:
                    数値 0,  文字列 "",  None,  配列 []
            and, or: #keyword: Python and,  Python or
                条件: and 条件、or 条件
                短絡評価: あり
                短絡評価とは:  #keyword: 短絡評価,  short-circuit evaluation,  短絡評価 && || and or
                    -   a == 1  and  b == 2 のとき and の左が偽なら and の右を評価（実行）しません
                    -   副作用があると問題になることがあります
        条件式, 三項演算子:  #keyword: Python 三項演算子 else
            基本: b = 1 if a < 0 else -1
            読みやすい書き方:
                b = 1 if (a < 0) \
                    else -1
        繰り返し、ループ (for):  #keyword: Python for in,  Python loop
            配列: | #keyword: Python list array loop
                for  element  in  [ 1, 2, 3 ] :
                    print( element )
                for  index, element  in  enumerate([ 1, 2, 3 ]) :
                    print( element )
            インデックス: #keyword: Python range
                for 文: |
                    for  num  in  range( 1, 5 ) :
                        print( num )
                range(5): --> 0 1 2 3 4
                range(0, 5): --> 0 1 2 3 4
                range(4,7): --> 4 5 6
                range(-2): --> []  #// ループしません
            無限ループ:
                _: |
                    while True:
                        print()
                エラーになるコード: |
                    for :
            ループを抜ける: #keyword: Python break
                1つ: break
                多重ループを抜ける: |  #// 文法としてはありません。フラグを定義してください
                    is_break = False
                    for:
                        for:
                            if:
                                is_break = True
                                break
                        if is_break:
                            break
            次のループへ:
                continue
            関連:
                配列の内包表記: [ __Expression__ for __Variable__ in __Collection__ ]  #search: Python list comprehensions
                Snap Note: #ref: ${programming}/スクリプト/Python.svg#loop
        with:  #search: Python with
        関数: #keyword: Python function  #ref: https://docs.python.org/3.11/reference/compound_stmts.html#function-definitions
            メソッド:  #search: Python method
            型ヒント:  #search: Python function typing hint
            位置引数: #keyword: Python positional argument
                概要: キーワードを付けない引数  #search: Python keyword argument
                定義例: |
                    def  my_function( argument1,  argument2 ):
                呼び出し例:
                    キーワード引数を指定しない場合:
                        - my_function('a', 'b')
                    キーワード引数と混合して指定する場合:
                        - my_function('a', argument2='b')
                        #// 位置引数はキーワード引数より前に書かなければエラーになります
                        #// SyntaxError: positional argument follows keyword argument
            キーワード引数: #keyword: Python keyword argument
                概要: 関数を呼び出すときに引数のキーワードを指定すると、引数の順番を変えることができます。
                定義例: |
                    def  my_function( argument1,  argument2 ):
                呼び出し例:
                    my_function( argument2='b',  argument1='a' )
                #ref: https://docs.python.org/3/glossary.html  >>  keyword argument
            引数リスト:  #// 可変長引数  #keyword: Python argument list
                (*): |  #// キーワードなし引数のリスト
                    def  function(*arguments):
                        print(arguments)  #// (1, 2)
                    function(1, 2)
                (**):
                    定義側: |  #// キーワード引数のリスト
                        def  function(**arguments):
                            print(arguments)  #// {'a': 1, 'b': 2}
                    呼び出し側:
                        - function(a=1, b=2)
                        - function(**{'a':1,'b':2})  #// ** は、辞書からキーワード引数に展開します
                公式: #// parameter_list_starargs （説明なし） #ref: https://docs.python.org/ja/3/reference/compound_stmts.html#function-definitions
            デフォルト値:  #keyword; Python default parameter values  #// デフォルト パラメーター 値
                #ref: https://docs.python.org/3.11/reference/compound_stmts.html#function-definitions  >>  default parameter values
                サンプル: |  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/function/none_default.py
                    def show_target(target=None):
                        target = target or ClassA(5)  #// or でオブジェクトのデフォルトを指定できます
                注意:
                    オブジェクトや辞書などをデフォルトに指定する場合: #keyword: Python default parameter object
                        #// None を指定すること
                        .py: |  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/function/bad_default.py
                            def bad_add(a_list=[]):  #// デフォルトに [] を指定すると、グローバル スコープ の [] になってしまいます
                                a_list.append("a")
                                print(a_list)

                            def good_add(a_list=None):
                                if a_list is None:
                                    a_list = []
                                a_list.append("a")
                                print(a_list)

                            bad_add()  #// ['a']
                            bad_add()  #// ['a','a']
                            good_add()  #// ['a']
                            good_add()  #// ['a']
                        参考:
                            dataclass の属性のデフォルト値:  #search: Python default_factory field
            引数を動的に調べる:  #keyword: watch Python function arguments
                __FunctionOrMethod__.__code__.co_varnames
                #ref: https://qiita.com/chankane/items/3909e9f2d1c5910cc60b
            返り値: #keyword: Python return
                複数:
                    タプルのアンパック: | #keyword: Python tuple unpacking
                        def  x_and_y() -> Tuple[str, str]:
                            return (1, 2)
                        x, y = x_and_y()
                    後でアンパック: |
                        def  x_and_y() -> Tuple[str, str]:
                            return (1, 2)
                        xy = x_and_y()
                        x, y = xy  # Unpack tuple
                two_strings 関数: | #keyword:  #// 配列要素数が 1 のときでも 要素数 2の Tuple を返して例外を抑制します  #search: Python str split
                    def two_strings(values: List[str], default1: str = '') -> Tuple[str, str]:
                        return (
                            values[0],
                            values[1] if len(values) >= 2 else default1)

                    x, y = two_strings(text.split('-'))
                three_strings 関数: | #keyword:  #// 配列要素数が 1 のときでも 要素数 3の Tuple を返して例外を抑制します  #search: Python str split
                    def three_strings(values: List[str], default1: str = '', default2: str = '') -> Tuple[str, str, str]:
                        return (
                            values[0],
                            values[1] if len(values) >= 2 else default1,
                            values[2] if len(values) >= 3 else default2)

                    x, y, z = three_strings(text.split('-'))
            yield: #keyword: Python yield,  yield from
                yield: ジェネレーターを return します #search: Python generator
                yield from: ジェネレーターを引数にとるときは from が必要です
                    #ref: try_Python/examples/yield/yield-from.py
                yield がある関数の呼び出し方:
                    ループの場合: |
                        for x in  yield_function():
                            print('> ' + x)
                    ループではない場合:
                        呼び出す側: |
                            generator = yield_function()  #// 必ず代入すること  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/yield/yield-finally.py#main_NG1
                            next(generator)  #search: Python generator
                        呼び出される側: |
                            def yield_function():
                                try:
                                    dic = {'a': 'yield'}
                                    print('setup ' + dic['a'])
                                    yield dic
                                finally:
                                    print('teardown ' + dic['a'])
        lambda:
            ラムダ式:  #keyword: Python lambda
                サンプル >> 型ヒントなし:
                    書式: |
                        -   lambda: __Expression__
                        -   lambda __Parameters__: __Expression__
                        -   lambda: (__Expression1__, __Expression2__)[__ReturnValueIndex__]
                    サンプル: |
                        -   lambda: print(121)
                        -   lambda x: x + 1
                        -   lambda x: (print(x), x + 1)[1]
                サンプル >> 型ヒントあり: |  #focus: lambda, Callable
                    from typing import Callable
                    def function(var1: str, var2: str)-> int:
                        return var1 + var2
                    lambda_: Callable[[str, str], int] = lambda var1, var2: var1 + var2  #// same operations as function

                    result_f = function('a', 'b')
                    result_l = lambda_('a', 'b')
                    print(result_f)
                    print(result_l)
                バリエーション: |
                    lambda_: Callable[[], int] = lambda: 'abc'
                    lambda_: Callable[[int], None] = lambda var: print(var)
                公式: #ref: https://docs.python.org/ja/3/reference/expressions.html?highlight=lambda#lambda
                参考: #ref: https://www.webdevqa.jp.net/ja/python/ヒントにラムダ関数を入力することはできますか？/1056507541/
            無名関数:  #keyword: Python anonymous function
                概要: lambda にステートメントを含めることはできません
                参考: #ref: https://stackoverflow.com/questions/862412/is-it-possible-to-have-multiple-statements-in-a-python-lambda-expression
                対処:
                    概要: def で定義した関数を渡します
                    サンプル: |  #focus: callable, function
                        from typing import Callable
                        def function(var1: str, var2: str)-> None:
                            print(var1)
                            print(var2)
                        callable: Callable[[int, int], None] = function
                        callable('a','b')
        イテレーター:  #search: Python iterator
            概要: 配列を走査します。next で次の要素を参照します。次の要素は配列に存在します
        ジェネレーター:  #search: Python generator
            概要: yield で返す関数の返り値。イテレーターと同じく next が使えます。次の要素はジェネレーターが作ります
            参考:
                generator vs iterator:  #ref: https://stackoverflow.com/questions/2776829/difference-between-pythons-generators-and-iterators
                What does the "yield" keyword do?: #ref: https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do
        並列処理:  #// 高速化。アクセス待ちなどが多いときに有効
            ThreadPoolExecutor:
                #ref: https://docs.python.org/ja/3/library/concurrent.futures.html
                サンプル:
                    コード: |  #focus: thread_function, ThreadPoolExecutor, executor, submit
                        from concurrent.futures import ThreadPoolExecutor
                        import time
                        import logging
                        logging.basicConfig(level=logging.DEBUG)
                        logger = logging.getLogger(__name__)

                        def main():
                            logger.info("main start")
                            with ThreadPoolExecutor(max_workers=2, thread_name_prefix="thread") as executor:
                                for thread_num in range(5):
                                    executor.submit(thread_function, thread_num)
                                logger.info("submit end")
                            logger.info("main end")

                        def thread_function(thread_num):
                            logger.info("%s start", thread_num)
                            time.sleep(1.0)
                            logger.info("%s end", thread_num)

                        if __name__ == '__main__':
                            main()
                    実行結果:
                        INFO:__main__:main start
                        INFO:__main__:submit end
                        INFO:__main__:0 start
                        INFO:__main__:1 start
                        INFO:__main__:1 end
                        INFO:__main__:0 end
                        INFO:__main__:2 start
                        INFO:__main__:3 start
                        INFO:__main__:2 end
                        INFO:__main__:4 start
                        INFO:__main__:3 end
                        INFO:__main__:4 end
                        INFO:__main__:main end
        time, 処理時間: #keyword: Python time
            待つ: #keyword: Python time.sleep
                import time
                time.sleep(3)  #// 秒。小数も可能
            timeit: | #keyword: timeit,  decorate_all_methods_with  #// 特定のクラスの全てのメソッドに対して処理時間を計測するようにします
                    from timeit import timeit, decorate_all_methods_with

                    @decorate_all_methods_with(timeit)
                    class MyClass:
                        def method1(self, n):
                            ...

                    obj = MyClass()
                    obj.method1(1000000)  #// method1 took 34.68 ms
                    obj.method2(1000000)  #// method2 took 62.53 ms
                #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/time/timeit_example.py
            レート制限: #keyword: Python レート制限
                基礎知識:  #search: レート制限
                #↓ 関数
                limits: #keyword: Python limits  #ref: https://pypi.org/project/limits/  #ref: https://github.com/alisaifee/limits
                    解説:  #ref: https://www.beatcraft.com/labs/2022/02/python.html
                    サンプル: |  #focus: limiter  #// limits に wait するメソッドはありません
                        import time
                        from limits import parse
                        from limits.strategies import MovingWindowRateLimiter
                        from limits.storage import MemoryStorage

                        class RateLimiter:
                            def __init__(self, identity: str, limit: str):
                                self.identity = identity
                                self.storage = MemoryStorage()
                                self.limiter = MovingWindowRateLimiter(self.storage)
                                self.limit = parse(limit)

                            def wait(self, waiting_message: str=""):
                                while True:
                                    if self.limiter.hit(self.limit, self.identity):
                                        return

                                    if waiting_message:
                                        print(waiting_message)
                                    reset_time, _remaining = self.limiter.get_window_stats(self.limit, self.identity)
                                    sleep_for = max(reset_time + 1.0 - time.time(), 0.01)
                                    time.sleep(sleep_for)

                        if __name__ == "__main__":  # test
                            limits = RateLimiter("example", "1/2seconds")
                            print(1)
                            limits.wait()  # no wait
                            print(2)
                            limits.wait("waiting 2")  # wait
                            print(3)
                            limits.wait()  # wait
                            print(4)
                            limits.wait("waiting 4")  # wait
                            print(9)
                    レート制限の量の指定方法:  #ref: https://limits.readthedocs.io/en/latest/quickstart.html#rate-limit-string-notation
                ratelimit: #keyword: Python ratelimit  #ref: https://pypi.org/project/ratelimit/
                    ローカル範囲でのみレートを制限できます:  #ref: https://stackoverflow.com/questions/40748687/python-api-rate-limiting-how-to-limit-api-calls-globally
                #↓ Web API  #// 多くは内部で limits を使っています  #ref: https://limits.readthedocs.io/en/latest/#projects-using-limits
                flask-limiter:
                fastapi-limiter:
        contextlib:
            contextlib.closing クラス:
                概要:
                    - with ブロックを抜けるときに close メソッドを呼び出します
                    - with ブロック内で例外が発生しても close メソッドを呼び出します
                サンプル: |
                    import contextlib

                    with contextlib.closing(open('foo.txt')) as f:
                        print(f.read())

                    print(f.closed)  #=> True
            まとめて __exit__ を呼び出します: |  # close ではなく __exit__ らしい
                with contextlib.ExitStack() as stack:
                    foo = stack.enter_context(open('foo.txt', 'wt'))
                    bar = stack.enter_context(open('bar.txt', 'wt'))
                    baz = stack.enter_context(open('baz.txt', 'wt'))

                    foo.write('foo')
                    bar.write('bar')
                    baz.write('baz')

                    print(foo.closed)  #=> True
            contextlib.suppress:
                概要:
                    - 指定した例外が発生したときは catch して、catch 内では何もしません
                サンプル: |
                    with contextlib.suppress(FileNotFoundError):
                        with contextlib.closing(open('bar.txt')) as f:
                            print(f.read())
        例外, エラー: #keyword: Python exception,  Python error,  Python raise Error try catch except finally
            例外クラス: #keyword: Python Exception class
                #↓カタログ
                ValueError:  #keyword:
                    サンプル: |
                        try:
                            raise ValueError(f"{cls.__name__} must set")
                        except ValueError as exception:
                            print(f'ValueError({exception})')
                    メモ: import ValueError は不要です
                RuntimeError:  #keyword:
                FileNotFoundError:  #keyword:
                NotImplementedError:  #keyword:
                    raise NotImplementedError()
                RecursionError: #keyword:
                    catch できないようです
                #↓ ユーザー定義
                ユーザー定義例外クラス: |
                    class CustomError(Exception):
                        pass
                既存の例外をラップする: |
                    class CustomWrapError(Exception):
                        def __init__(self, detail=None):
                            super().__init__(detail)
                        def __str__(self) -> str:
                            return f'CustomWrapError: {super().__str__()}'
                #↓構造
                例外メッセージ:
                    公式:  #search: Python __repr__
                    非公式:  #search: Python __str__
            raise:  #keyword:  #// raise の訳は「発生させる」
                サンプル: |
                    try:
                        raise ValueError(f"{cls.__name__} must set")
                    except ValueError as exception:
                        print(f'ValueError({exception})')
                例外クラス:  #search: Python Exception class
                メモ: import ValueError は不要です
                パラメーターなし:  #// 再度 raise します
                    raise  #// 現在発生中の例外を、呼び出し元の except に raise します
                exception chaining:  #keyword: Python exception chaining,  Python exception wrap  #// 発生した例外を変えて再度発生させる
                    try:
                        ...
                    except Exception as exception:
                        raise ValueError(f"call_index = {call_index}") from exception
                    #ref: https://stackoverflow.com/questions/696047/re-raise-exception-with-a-different-type-and-message-preserving-existing-inform
                その他: #ref: https://docs.python.org/ja/3/library/exceptions.html
                raise という用語:  #ref: https://stackoverflow.com/questions/53600218/what-do-programmers-mean-when-they-say-raise-an-error-example-why-do-this
            try, except(catch), finnaly: #keyword: Python try  #ref: ${programming}/スクリプト/Python.svg#try_except
                サンプル: |
                    try:
                        raise ValueError('The value must set')
                    except Exception as exception:
                        print(str(exception))  #// The value must set
                            #// コールスタックを出力する場合 #search: Python exception print
                    finally:
                        print('finally')
                例外クラス:  #search: Python Exception class
                全部のクラス:  #// すべての例外を受け取ります  #ref: https://stackoverflow.com/questions/4990718/how-can-i-write-a-try-except-block-that-catches-all-exceptions
                    概要: |
                        except Exception as exception:
                    BaseException: #keyword: Python BaseException
                        注意:
                            すべての例外は BaseException クラスのサブクラスですが、
                            通常は Exception を使用することを推奨します：
                                KeyboardInterrupt（Ctrl+C）などのシステム例外は通常捕捉すべきではない
                                プログラムの終了処理（SystemExit）を妨げない
                        コード: |
                            except BaseException as e:
                else: | #keyword: Python try else  #focus:  #// try が成功したときの処理。 try に入れず、except で再スローしないときに書きます
                    try:
                        _____
                    except _____:
                        ____
                    else:
                        ____
                複数のクラス:  #// 複数のクラスの例外を同じコードの行で catch する場合:
                    except (NameError, TypeError) as error
                    #ref: https://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block
                継承サンプル: | #keyword: PublicError
                    #focus: PublicError, public_message
                    class PublicError(Exception):
                        def __init__(self, public_message: str, private_message: str = ''):
                            self.public_message = public_message
                            self.private_message = private_message
                    try:
                        raise PublicError('ユーザーに見せるエラーメッセージ')
                    except PublicError as exception:
                        print(exception.public_message)
                    except Exception as exception:
                        print('Error.')
                        print(exception)
                例外のラップ: | #keyword: Python raise from,  Python exception wrap  #// Python で呼び出し先で発生した例外オブジェクトをラップした（包み込んだ）例外を発生させる
                    try:
                        try:
                            some_function()
                        except Exception as e:
                            raise WrapperException("追加のエラーメッセージ") from e
                    except WrapperException as e:
                        e1 = e.__cause__
                        e2 = e
                公式: #ref: https://docs.python.org/ja/3/library/exceptions.html
                デバッグ:  #search: Python exception print
                コールスタックを表示します:  #search: Python call stack
                関連 >> finally close 方式: #search: @contextlib.contextmanager
            Django REST framework で呼ばれた関数の中でキャッチできなかった例外をハンドリングします:
                website/settings/base.py: |
                    REST_FRAMEWORK = {
                        'EXCEPTION_HANDLER': '__Folder__.exception_handler',
                        'DEFAULT_AUTHENTICATION_CLASSES': ['__DotPath__.__Class__'],
                __Folder__/exception.py: |
                    def exception_handler(exc, context):
            コンストラクターの例外: #search: constructor exception
            ログ:
                logging: |  #keyword: Python logging,  logger.error  logger.info  logger.warning  logger.debug
                    import traceback
                    import logging
                    logger = logging.getLogger()

                    except Exception as exception:
                        call_stack = traceback.format_exc()
                        logger.error("%s %s", str(exception), call_stack)
                Django LOGGING 変数:  #search: Django LOGGING
                関連 >> コールスタックを表示します:  #search: Python call stack
            公式: #ref: https://docs.python.org/ja/3/library/exceptions.html
        assert:  #keyword: Python assert  #ref: https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement
            assert と同じ処理のコード:
                assert  __Expression__: |
                    if __debug__:
                        if not __Expression__: raise AssertionError
                assert  __Expression__, __ErrorMessage__: |
                    if __debug__:
                        if not __Expression__: raise AssertionError #(__ErrorMessage__)
            参考:
                オブジェクトの == の比較:  #search: Python ==
            assert を無効にします:
                -O オプション: |
                    $ python -c "assert False"
                    Traceback (most recent call last):
                    File "<string>", line 1, in <module>
                    AssertionError

                    $ python -Oc "assert False"
                参考: #ref: https://stackoverflow.com/questions/1273211/disable-assertions-in-python
            配列: | #keyword: assertListEqual  #focus: assertListEqual
                import unittest
                t = unittest.TestCase()
                t.assertListEqual([1,2,3], [1,2,3])  #// Failed, if 1,2,3 => 1,2 | 2,1,3 | 1,2,3,4
                t.assertListEqual(list( config.services.keys()), ["sshd", "httpd"])
            プロジェクト:  #ref: ${GitHub}/MyPrivateCode/Python/try_pytest/s04_assert/s4_test.py#assert
        pass:  #// 何もしないコード。ブレークはできる
    ライブラリ:
        import: #search: Python import from  #// ライブラリの名前を参照できるようにします
        sys.path:  #// ライブラリがある場所  #search: Python sys.path
        python3-devel, platform-python-devel: #keyword:  #// Python用の開発パッケージ
            - platform-python-devel は RHEL8 以降の命名規則。機能的には python3-devel とほぼ同じ
            - C拡張モジュールをコンパイルするために必要なヘッダーファイルとライブラリ
        シェルのオプション解析:  #glossary:
            argparse: #keyword:
                公式: #ref: https://docs.python.org/ja/3.6/library/argparse.html
                基本:
                    コマンド例: python.exe try_argparse.py
                    try_argparse.py: |  #keyword: argparse.ArgumentParser
                        import argparse
                        parser = argparse.ArgumentParser()
                        arguments = parser.parse_args()
                        print(arguments)
                名前なし引数:
                    コマンド例: python.exe try_argparse.py  aaa
                    try_argparse.py: |  #focus: add_argument, argument1
                        import argparse
                        parser = argparse.ArgumentParser()

                        parser.add_argument('argument1', type=str)  #// 1st mandatory positional argument
                        arguments = parser.parse_args()
                        print(arguments.argument1)
                オプション引数:  #// 例 --sort key
                    コマンド例:
                        短いオプション: python.exe try_argparse.py  -s key1
                        長いオプション: python.exe try_argparse.py  --sort-key key1
                    try_argparse.py: |  #focus: add_argument, -s, --sort-key, sort_key
                        import argparse
                        parser = argparse.ArgumentParser()

                        parser.add_argument('-s', '--sort-key', type=str, default='key0', help='sort key name')
                        parser.add_argument('--long-option-only')
                        arguments = parser.parse_args()
                        print(arguments.sort_key)
                オプション フラグ:  #// 例 --option
                    コマンド例: python.exe try_argparse.py --option
                    try_argparse.py: |  #focus: store_true, option
                        import argparse
                        parser = argparse.ArgumentParser()

                        parser.add_argument('--option', action='store_true', default=False)
                        arguments = parser.parse_args()
                        print(arguments.option)  #// True or False(default)
                選択:  #// オプションの値を、プログラムが指定した値だけを受け入れるようにします
                    文字列:
                        コマンド例: python.exe try_argparse.py --fruit banana
                        try_argparse.py: |  #focus: choices, fruit
                            import argparse
                            parser = argparse.ArgumentParser()

                            parser.add_argument('--fruit', choices=['apple', 'banana', 'orange'])
                            arguments = parser.parse_args()
                            print(arguments.fruit)
                    数値:
                        コマンド例: python.exe try_argparse.py --num 1
                        try_argparse.py: |  #focus: choices, num
                            import argparse
                            parser = argparse.ArgumentParser()

                            parser.add_argument('--num', type=int, choices=[1, 3, 5])
                            arguments = parser.parse_args()
                            print(arguments.num)
                ヘルプにコマンドの概要を表示します:
                    コマンド例:
                        短いオプション: python.exe try_argparse.py -h
                        長いオプション: python.exe try_argparse.py --help
                    try_argparse.py の一部:
                        parser = argparse.ArgumentParser(description='This is shown by -h option.')
            click:  #keyword: Python click
                click 公式: #ref: https://click.palletsprojects.com/en/8.0.x/
                プロジェクトへのインストール: pipenv install click
                (@click.argument):  #// 引数なし引数
                    基本サンプル:
                        コマンド例:
                            python.exe try_click.py  : |
                                file_name = file_name_default

                            python.exe try_click.py aaa  : |
                                file_name = aaa
                        try_click.py: |  #focus: click, file_name
                            import click

                            @click.command()
                            @click.argument('file_name', type=str, default='file_name_default')
                            def main(file_name):  #// 引数名は @click.argument に指定した名前に合わせます
                                print(f'file_name = {file_name}')

                            if __name__ == '__main__':
                                main()
                    コールバックで値を調整するサンプル: |
                        @click.command()
                        @click.argument('handler', callback=_create_handler)
                        def cmd(handler):  #// 引数名はオプション名に合わせます
                            ____
                        def _create_handler(ctx, param, value):
                            return  open(value)
                    参考: #search: Python Click option
                (@click.option):  #// オプション  #keyword: Python Click option
                    サンプル:
                        コマンド例:  #// 使えるようになるコマンドのオプション
                            python.exe try_click.py  : |
                                name = name_default
                            python.exe try_click.py --name aaa  : |
                                name = aaa
                            python.exe try_click.py -n aaa  : |
                                name = aaa
                            python.exe try_click.py --help  : |
                                Usage: try_click.py [OPTIONS]

                                Options:
                                -n, --name TEXT  Name option.
                                --help           Show this message and exit.
                            python.exe try_click.py -h  : |
                                （同上）
                        コード >> try_click.py: |  #focus: click, name
                            import click

                            @click.command()
                            @click.option('-n', '--name', type=str, default='name_default', help='Name option.')
                            @click.option('-s', '--sort-key', type=str, default='default_key', help='Sort key option.')
                                #search: click.option
                            def main(name, sort_key):  #// 引数名はオプション名に合わせます
                                print(f'sort_key = {sort_key}')

                            if __name__ == '__main__':
                                main()
                    (@click.option) の引数: #keyword: click.option
                        第1引数:  #// 短いオプション名。省略可能
                            サンプル: -n
                        第2引数:  #// 長いオプション名
                            サンプル: --name
                            対応する引数名:
                                法則:
                                    - 先頭のハイフンは削除します
                                    - 途中のハイフンはアンダースコアになります
                                オプション名が１語の場合:
                                    --name: name
                                オプション名が２語以上の場合:
                                    --your-name: your_name
                        default: #// デフォルト値。オプションを指定しなかったときに変数に渡す値
                            省略時: ""
                        type:  #// 解析結果を格納する変数の型
                            サンプル コード: |
                                @click.command()
                                @click.option('--age', type=int, help='Your age.')
                            省略時: str
                            str:
                                --option-name  __StringValue__
                            bool:
                                オプションの有無で指定する場合:
                                    コマンド:
                                        --option-name
                                    コード: |  #// True を指定するフラグと False を指定するフラグをスラッシュで区切って @click.option に指定します
                                        @click.option('--flag/--no-flag', default=False)
                                boolean 型のパラメーターで指定する場合:
                                    コマンド:
                                        --option-name  __BooleanValue__
                                    コード: |
                                        @click.option('--flag', type=bool, help='a flag.')
                                    補足:
                                        The string values “1”, “true”, “t”, “yes”, “y”, and “on” convert to True.
                                        0”,“false”, “f”, “no”, “n”, and “off” convert to False.
                        help: #// ヘルプ表示が要求されたときに表示する内容
                            サンプル コード: |
                                @click.command()
                                @click.option('--prefix', help='Prefix of greetings.')
                                def cmd(age: int):
                            サンプル実行: |
                                $ python ____.py --help
                                Usage: ____.py [OPTIONS]

                                Options:
                                --prefix TEXT  Prefix of greetings.
                                --help         Show this message and exit.
                (@click.group):  #// サブ コマンド。 コマンドラインが __CommandName__ __SubCommandName__  __Options__ の形式のもの
                        コマンド例:
                            python.exe try_click.py  : |
                                Usage: try_click.py [OPTIONS] COMMAND [ARGS]...

                                Options:
                                --help  Show this message and exit.

                                Commands:
                                get
                                set
                            python.exe try_click.py get --help  : |
                                main
                                Usage: try_click.py get [OPTIONS] FILE_NAME

                                Options:
                                --help  Show this message and exit.
                            python.exe try_click.py get aaa  : |
                                main
                                get file_name = aaa
                            python.exe try_click.py set aaa bbb  : |
                                main
                                set file_name = aaa, new_value = bbb
                        try_click.py: |  #focus: tag, group, cmd
                            import click

                            @click.group()
                            def main():  #// この関数は、最初に呼ばれます。また、後で command() メソッドを呼べるオブジェクトになります
                                print('main')

                            @main.command()
                            @click.argument('file_name') #// 第1引数
                            def get(file_name):  #// 引数名は @click.argument に指定した名前に合わせます
                                print(f'get file_name = {file_name}')

                            @main.command()
                            @click.argument('file_name', type=str, default='file_name_default') #// 第1引数
                            @click.argument('new_value', type=str, default='new_value_default') #// 第2引数
                            def set(file_name, new_value):  #// 引数名は @click.argument に指定した名前に合わせます
                                print(f'set file_name = {file_name}, new_value = {new_value}')

                            if __name__ == '__main__':
                                main()
                (@click.command):  #// click で解析する関数の最初に書きます
                バリデーション:
                    IntRange:  #// 範囲
                        サンプル コード: |
                            @click.command()
                            @click.option('--age', type=click.IntRange(0, 100))
                            def cmd(age):
                    Choice:  #// 候補
                        サンプル コード: |
                            @click.command()
                            @click.option('--age', type=click.Choice(['Japanese', 'English'])
                            def cmd(age):
                    BadParameter:  #// 例外
                        サンプル コード: |
                            @click.command()
                            @click.option('--age', type=int, help='Your age.')
                            def cmd(age):
                                if age > 100:
                                    raise click.BadParameter('Really!?')
                        サンプル実行: |
                            $ python ____.py --age 101
                            Usage: ____.py [OPTIONS]

                            Error: Invalid value: Really?!
                その他:  #// https://blog.amedama.jp/entry/2015/10/14/232045
            optparse:  #// 古い標準 バージョン 2.7 以前
        GUI操作の自動化:  #keyword: Python GUI automation
            PyAutoGUI: #ref: https://qiita.com/konitech913/items/301bb63c8a69c3fcb1bd  #keyword: PyAutoGUI
                #// RDP の接続先で実行する場合、接続を切断すると動きません
        Django: #keyword:  #ref: ${programming}/スクリプト/Python.svg#Django
            手順:
                Django プロジェクトを新規作成します:  #search: install Django
                Django でデータベースを初期化します、またはデータベースをエクスポートします:
                    Django でデータベースを初期化する:
                        MySQL の場合、データベースを削除します: |
                            mysql> drop database  __DataBaseName__;
                            mysql> create database  __DataBaseName__;
                            mysql> exit
                            mysql -p __DataBaseName__ --user ____ --password=____
                        スキーマを設定します:  #keyword: Django migrate
                            python manage.py migrate
                        __Project__/__Application__/fixtures/__Application___initial の例: |
                            [
                                {
                                    "model": "app.Post",
                                    "pk": 1,
                                    "fields": {
                                        "title": "おはよう"
                                    }
                                },
                                {
                                    "model": "app.Post",
                                    "pk": 2,
                                    "fields": {
                                        "title": "こんにちは"
                                    }
                                }
                            ]
                        settings.py の USE_TZ を正しく設定します:
                        Git bash:
                            - cd  "__Project__"
                            - 以下は一度に実行できます: |
                                cd  "__ProjectName__"
                                source  ../__ProjectName___env/Scripts/activate
                                export DJANGO_SETTINGS_MODULE=__ApplicationName__.settings_local
                            - python manage.py loaddata __Application___initial.json
                    データベースをエクスポートする:
                        - python manage.py dumpdata --indent=4 > __Application___back_up.json
                        - 文字コードを変換します: |
                            [System.IO.File]::WriteAllLines("__Application___back_up.json",
                                (Get-Content "__Application___back_up.json"), (New-Object System.Text.UTF8Encoding($False)));
                        - Unicode をアンエスケープします: |
                            [System.IO.File]::WriteAllLines("__Application___back_up_8.json",
                                [regex]::replace(
                                    (Get-Content "__Application___back_up.json"),
                                    '(?:\\u[0-9a-f]{4})+',
                                    { param($m)
                                        $int32Array = (-split ($m.Value  -replace '\\u([0-9a-f]{4})', '0x$1 ')).ForEach([System.Int32])
                                        $charArray = $int32Array.ForEach({ [char]::ConvertFromUTF32($PSItem) })
                                        $string = -join $charArray
                                        $string
                                    }
                                ));
                        - format_json を実行します
                        - sort_json を実行します
                SQLite のシェルを開きます:
                    設定: #settings:
                        __Application__: django1
                    SQLite の sqlite3.exe をダウンロードして PATH の通ったフォルダーに配置します:
                        - https://www.sqlite.org/index.html >> (Latest Release) >> Download >> Precompiled Binaries for Windows >>
                            sqlite-tools-win32-x86-__SQLiteVersion__.zip
                        - .zip の中にある sqlite3.exe を PATH の通ったフォルダーにコピーします
                            例： django1_env\Scripts  #template: __Application___env
                    現在のプロセスで manage.py を使えるようにします:
                        #PowerShell
                            #// Git bash では dbshell 起動直後にシェルが固まります
                            #// Git CMD ではコピー＆ペーストができません
                        - cd  "__Project__"
                        - （初回のみ。下記 activate スクリプトの実行に必要）:
                            Set-ExecutionPolicy  RemoteSigned  -Scope CurrentUser
                        - （下記は一度に実行できます）: |
                            cd  "django1"  #template: "__Application__"
                            ..\django1_env\Scripts\activate  #template: __Application___env
                        - 下記は settings_local.py を使うときだけ:
                            PowerShell の場合:
                                ${env:DJANGO_SETTINGS_MODULE} = "django1.settings";
                            bash の場合:
                                export DJANGO_SETTINGS_MODULE=django1.settings_local  #template: __Application__
                    SQLite のシェルを開きます:
                        python manage.py dbshell
                    コマンドの例:
                        - .tables  #// テーブルを一覧します
                        - select * from __TableName__;  #// テーブルの内容
                        - Ctrl + C で終了:
                Django のフロントエンドの一部を React にします:
                    参考: DjangoのページをReactで作る - Webpack4
                        https://qiita.com/sand/items/15da91117c680a618c2b
                    設定: #settings:
                        __Work__: django_work
                        __Project__: django_with_react  #// サイト名と同じにします
                        __Application__: withfront
                        __HOME__: /c/Users/user1
                        __PythonVer2__: 38  #// 3.8.2 なら 38
                    サンプルのプロジェクトを新規作成します:
                        Django プロジェクトが使う仮想環境を構築します:
                            #Git bash
                            - cd  "__ParentOfProject__"
                            - mkdir  "django_work"  #template: "__Work__"
                            - cd  "django_work"  #template: "__Work__"
                            - export PATH=/c/Users/user1/AppData/Local/Programs/Python/Python38/Scripts:$PATH
                                #template: __HOME__/AppData/Local/Programs/Python/Python__PythonVer2__/
                                #// python.exe に PATH を通します
                            - pip install virtualenv
                            - virtualenv  "django_with_react_env"  #template: "__Project___env"
                            - source "django_with_react_env/Scripts/activate"
                            - pip freeze  #// 何もインストールされていないことをチェックします
                            - pip install "django"
                        Django プロジェクトを新規作成します:
                            - django-admin startproject "django_with_react"  #// Django プロジェクトを作成します  #template: "__Project__"
                            - cd "django_with_react"  #template: "__Project__"
                            - python manage.py migrate
                            - python manage.py runserver  #// Watching for file changes with StatReloader と表示されるまで待つ
                            - http://localhost:8000/ をブラウザーで開きます
                            - Ctrl + C  #// python manage.py runserver を終了します
                        React に対応した Django アプリケーションを新規作成します:
                            #Git bash
                            - cd  "__Work__"
                            - cd  "django_with_react"  #template: "__Project__"
                            - source "../django_with_react_env/Scripts/activate"  #template: __Project___env
                            - django-admin startapp "withfront"  #// アプリケーションを追加します  #template: __Application__
                            - __Work__/django_with_react/withfront/views.py を変更します:  #template: /__Project__/__Application__/
                                変更前: |
                                    # Create your views here.
                                変更後: |
                                    def index(request):
                                        return render(request, 'withfront/index.html')  #template: __Application__/
                            - 新規作成するファイルをコピーします: |
                                export  src_="${HOME}/Desktop/django-with-react-template/django"  #// programming\スクリプト\Python.files\django-with-react-template.zip
                                export  dst_="withfront"  #template: __Application__
                                    export  file_="src/components/App.js"  &&  mkdir -p `dirname ${dst_}/${file_}` && cp -f  "${src_}/${file_}"  "${dst_}/${file_}"
                                    export  file_="src/index.js"           &&  mkdir -p `dirname ${dst_}/${file_}` && cp -f  "${src_}/${file_}"  "${dst_}/${file_}"
                                    export  file_="urls.py"                &&  mkdir -p `dirname ${dst_}/${file_}` && cp -f  "${src_}/${file_}"  "${dst_}/${file_}"
                                unset  src_ dst_ file_
                                export  src_="../../django-with-react-template/django/templates/__app__"
                                export  dst_="withfront/templates/withfront"  #template: __Application__/templates/__Application__
                                    export  file_="index.html"  &&  mkdir -p `dirname ${dst_}/${file_}` && cp -f  "${src_}/${file_}"  "${dst_}/${file_}"
                                unset  src_ dst_ file_
                            - __Work__/django_with_react/withfront/templates/withfront/index.html の中の __app__ を withfront に置き換えます:
                                    #template: /__Project__/__Application__/templates/__Application__/index.html の中の __app__ を __Application__ に
                            - __Work__/django_with_react/django_with_react/settings.py の INSTALLED_APPS に withfront を追加: |  #template: /__Project__/__Project__/settings.py の INSTALLED_APPS に __Application__
                                INSTALLED_APPS = [
                                    'withfront',  #template: '__Application__'
                            - __Work__/django_with_react/django_with_react/urls.py を変更します:  #template: /__Project__/__Project__/
                                import に include を追加:
                                    変更前: from django.urls import path
                                    変更後: from django.urls import path, include
                                urlpatterns に withfront.urls を追加: |  #template: __Application__.urls
                                    urlpatterns = [
                                        path('', include('withfront.urls')),  #template: __Application__.urls
                        React プロジェクトを新規作成します:
                            #Git bash
                            - cd "__Work__"
                            - cd  "django_with_react"  #template: "__Project__"
                            - source "../django_with_react_env/Scripts/activate"  #template: __Project___env
                            - npm init -y
                            - Node.js コンポーネントをインストールします: |
                                npm install --save-dev \
                                    webpack \
                                    webpack-cli \
                                    @babel/core babel-loader \
                                    @babel/preset-env \
                                    @babel/preset-react \
                                    babel-plugin-transform-class-properties \
                                    react \
                                    react-dom \
                                    prop-types \
                                    babel-preset-react
                            - __Work__/django_with_react/package.json の scripts に下記の dev, build を追加します: |  #template: __Project__
                                "scripts": {
                                    "build": "webpack --mode production  ./withfront/src/index.js --output-path ./withfront/static/withfront",
                                        #template: ./__Application__/src/index.js --output-path ./__Application__/static/__Application__
                                    "dev": "  webpack --mode development ./withfront/src/index.js --output-path ./withfront/static/withfront",
                                        #template: ./__Application__/src/index.js --output-path ./__Application__/static/__Application__
                                #// 上記 #template の行（2か所）は削除してください
                                #// "dev" のスクリプトは無くても構いません
                            - 新規作成するファイルをコピーします: |
                                export  src_="../../django-with-react-template/nodejs"
                                export  dst_="."
                                    export  file_=".babelrc"           &&  mkdir -p `dirname ${dst_}/${file_}` && cp -f  "${src_}/${file_}"  "${dst_}/${file_}"
                                    export  file_="webpack.config.js"  &&  mkdir -p `dirname ${dst_}/${file_}` && cp -f  "${src_}/${file_}"  "${dst_}/${file_}"
                                unset  src_ dst_ file_
                        React プロジェクトをビルドします:
                            #Git bash
                            - cd  "__Work__"
                            - cd  "django_with_react"  #template: "__Project__"
                            - npm run build  #// または npm run dev
                                #// __Work__/django_with_react/frontend/static/frontend/main.js ファイルが更新されます
                                #template: /__Project__/frontend
                        Django サーバーを起動します:
                            #新しい Git bash
                            - cd  "__Work__"
                            - cd  "django_with_react"  #template: "__Project__"
                            - source "../django_with_react_env/Scripts/activate"  #template: __Project___env
                            - python manage.py migrate
                            - python manage.py runserver  #// Watching for file changes with StatReloader と表示されるまで待つ
                            - http://localhost:8000/ をブラウザーで開きます
                            #// React here! と表示されたら成功です
                            - 使わなくなったら Ctrl + C  #// python manage.py runserver を終了します
                    Django + React プロジェクトのバックアップを取ります（しなくてもよい）:
                        - cd  "__Work__"
                        - cd  "django_with_react"
                        - tar cvzf  "../_bk-django_with_react.tar.gz"  --exclude "node_modules"  --exclude "__pycache__"  "."
                    Django + React プロジェクトのバックアップから復元します（しなくてもよい）:
                        - cd  "__Work__"
                        - mkdir  "_decompressed"
                        - tar xvf   "_bk-django_with_react.tar.gz"  --directory  "_decompressed"
                        - 上記「Django プロジェクトが使う仮想環境を構築します」を実施します:
                    React で作られた ModularAdmin の左ペインを追加します:
                        - cd  "__Work__"
                        - cd  "django_with_react"  #template: "__Project__"
                        - source "../django_with_react_env/Scripts/activate"  #template: __Project___env
                        - Node.js コンポーネントをインストールします: |
                            npm install --save-dev \
                                @material-ui/core \
                                @material-ui/icons \
                                react-router-dom \
                                react-intl \
                                @types/react-dom \
                                web-vitals \
                                typescript \
                                ts-loader \
                                file-loader
                        - tsconfig.json を __Work__/django_with_react にコピーします:
                        - webpack.config.json を __Work__/django_with_react にコピーします:
                        - ModularAdmin_components.zip の内容を __Work__/django_with_react/withfront/src/components に展開します:
                        - npm run build
                        - http://localhost:8000/ をブラウザーで開きます
            ファイル, フォルダー:
                manage.py: #keyword:
                    runserver: #keyword: manage.py runserver
                        - python manage.py runserver  #// Watching for file changes with StatReloader と表示されるまで待つ
                        - または python manage.py runserver 0.0.0.0:8011
                        - または poetry run ./manage.py runserver 0.0.0.0:8011
                        #search: install Django
                    ログを取りながら実行する: #keyword: manage.py without buffer
                        #// サービス起動時に以下のように Python のバッファーをオフにすること。（env PYTHONUNBUFFERED=1 と python -u）
                        #// VSCode でファイルをリロードするには、VSCode ウィンドウの外をクリックしてから、VSCode ウィンドウをクリックします。もしくは File メニュー >> Revert File
                        env PYTHONUNBUFFERED=1  poetry run  python -u  ./manage.py runserver --insecure 0.0.0.0:8080  2>&1  |  tee  __LogFilePath__
                            または
                        direnv exec '.'  env PYTHONUNBUFFERED=1  poetry run  python -u  ./manage.py runserver --insecure 0.0.0.0:8080  2>&1  |  tee  __LogFilePath__
                    2回呼ばれる: #keyword: manage.py 2回呼ばれる
                        - auto-reloader の仕組みのために 2回呼ばれます。
                            #ref: https://stackoverflow.com/questions/28489863/why-is-run-called-twice-in-the-django-dev-server
                        - urls.py コードは最初のリクエストでのみ実行されます。
                            #ref: https://stackoverflow.com/questions/6791911/execute-code-when-django-starts-once-only
                    shell:  #search: Django shell
                    カスタム管理コマンド: #keyword: manage.py custom manage command
                        起動コマンド: python manage.py __Command__
                        コード:
                            __Command__.py: #ref: __Application__/management/commands/__Command__.py
                                #// ファイル名 __Command__ がカスタム管理コマンド名です
                                add_arguments:
                                    # class Command(BaseCommand):
                                    #     def add_arguments(self, parser):
                                    #         parser.add_argument('--config', default=defaults['config'])
                                    #         ...
                                handle:
                                    #     def handle(self, *args, **opts):
                urls.py: #keyword: urls.py,  urlpatterns,  Django URL,  Django URLディスパッチャ,  URLConf
                    #ref: ${programming}/スクリプト/Python.svg#urlpatterns
                    __Project__/__Site__/urls.py: |  #focus: __Application__
                        from django.urls import path

                        urlpatterns = [
                            path('api/',  include('__Application__.urls')),
                            path('',      include('__Application__.urls')),
                        ]
                    __Project__/__Site__/__Application__/urls.py: |
                        from django.urls import path

                        urlpatterns = [
                            path('/__Path__/', __Application__.views.__FileName__.__Method__),          # メソッドベースのビュー  #search: Django request argument
                            path('/__Path__/', __Application__.views.__FileName__.__Class__.as_view()), # クラスベースのビュー
                            :
                        ]
                    as_view: #keyword: Django as_view
                        メソッドにコールバックさせる場合:  #search: Django view method
                        #ref: https://qiita.com/tell-k/items/38c0612a44497b311d6b
                    urls.py がある場所の設定: #search: ROOT_URLCONF
                    ベースURL: #keyword: Django base URL,  Django api/v1
                        path('users/', が定義してあるとき、デフォルトでは
                            http://localhost:8080/users
                        にマッピングされます。
                            http://localhost:8080/api/v1/users
                        にマッピングする方法は見つかっていません。
                        HTTP クライアントの環境変数や設定ファイルに http://localhost:8080/api/v1 を設定します。
                static フォルダー: #keyword: Django static, Django static folder
                    #ref: ${programming}/スクリプト/Python.svg#Django_static_server
            設定変数: #keyword: Django 設定変数  #glossary: Django settings
                公式:
                    概要 >> Django 4.1:  #ref: https://docs.djangoproject.com/en/4.1/topics/settings/
                    個別 >> SECRET_KEY の場合 >> Django 4.1:  #ref: https://docs.djangoproject.com/en/4.1/ref/settings/#secret-key
                設定変数の場所: #keyword: Django settings,  Django settings.py  #// settings.py とは限りません
                    DJANGO_SETTINGS_MODULE 環境変数: #keyword:  #ref: https://docs.djangoproject.com/en/4.1/topics/settings/#envvar-DJANGO_SETTINGS_MODULE
                        サンプル:
                            __Project__/.env :
                                - DJANGO_SETTINGS_MODULE = settings          #// __Project__/settings.py または __Project__/settings/__init__.py  #keyword: Django settings.py
                                - DJANGO_SETTINGS_MODULE = website.settings  #// __Project__/website/settings.py または __Project__/website/settings/__init__.py
                分類:
                    基本:  DEBUG,  ALLOWED_HOSTS,  ROOT_URLCONF
                ALLOWED_HOSTS: クライアントの制限。['*'] は全許可
                CACHES:  #ref: https://docs.djangoproject.com/en/4.1/ref/settings/#cache
                    #search: Django cache settings
                    #search: Django cache back ends
                DATABASES:  #search: Django DATABASES
                DEBUG: True or False  #// ローカルでは True、サーバーでは False
                ROOT_URLCONF: urls.py ファイルの場所。サンプル：'website.urls'
                SECRET_KEY:  #ref: https://docs.djangoproject.com/en/4.1/ref/settings/#secret-key
                    作成:
                        REST プロジェクトを新規作成してコピーします:
                            コマンド:  #ref: https://www.django-rest-framework.org/tutorial/quickstart/
                                cd $HOME
                                mkdir tutorial
                                cd tutorial
                                python3 -m venv ".venv"
                                source ".venv/bin/activate"
                                pip install django
                                pip install djangorestframework
                                django-admin startproject tutorial "."
                                less tutorial/settings.py
                        安全な秘密鍵に変えます:
                            django-insecure- を別の乱数生成の一部に置き換えます:  #keyword: django-insecure-
                                Django secret key generator  #ref: https://django-secret-key-generator.netlify.app/
                            参考:
                                50文字未満のときは何かによって警告されるようです
                                #ref: https://docs.djangoproject.com/en/3.2/ref/checks/#security  >>  security.W009
                        環境変数に秘密鍵を配置するようにします:
                            import os
                            SECRET_KEY = os.environ['SECRET_KEY']
                        #ref: https://stackoverflow.com/questions/67240635/django-insecure-in-secret-key-in-settings-py-in-django
                    参考:
                        SECRET_KEYなどの機密情報を別ファイルで管理:  #ref: https://chigusa-web.com/blog/django-secret/
                        Djangoが「SECRET_KEY」を設定する目的は何ですか?:
                            #ref: https://stackoverflow.com/questions/7382149/whats-the-purpose-of-django-setting-secret-key
                            #ref: https://stackoverflow.com/questions/15170637/effects-of-changing-djangos-secret-key/15383766
                USE_TZ:
                    設定例:
                        USE_TZ = True
                        TIME_ZONE = ‘Asia/Tokyo’
                    影響範囲:
                        テンプレート: |
                            {% now %}
                        データベース:
                INSTALLED_APPS:
                    概要:
                        アプリケーションに対して、import_module と AppConfig.ready を呼び出します。
                        パッケージ（フォルダー）または AppConfig クラスのサブクラスを指定します。
                        内部で import_module を実行したときに ImportError が発生しますが、無視してください。
                            .venv/lib/python3.7/site-packages/django/apps/config.py
                    __Project__/settings.py : |  #focus: MyAppConfig
                        INSTALLED_APPS = [
                            ...
                            'init.MyAppConfig',
                    __Project__/init.py : |  #keyword: AppConfig.ready  #ref: https://docs.djangoproject.com/en/4.1/ref/applications/#django.apps.AppConfig.ready
                        from django.apps import AppConfig

                        class MyAppConfig(AppConfig):
                            name = "empty"
                            def ready(self):
                                pass
                    __Project__/empty/__init__.py: |
                        （内容なし）
                    #ref: https://docs.djangoproject.com/en/4.1/ref/applications/#configuring-applications
                    #ref: https://python.keicode.com/django/django-app-directory.php
                    #ref: https://stackoverflow.com/questions/37429726/overriding-appconfig-ready
            コールバック:
                view: #keyword: Django request argument,  Django view  #ref: ${programming}/スクリプト/Python.svg#query_parameter
                    関数にコールバックさせる場合: #keyword: Django view function
                        #ref: https://www.django-rest-framework.org/api-guide/views/#function-based-views
                        urls.py: |  #focus: main  #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/try_DjangoREST/site_1/urls.py
                            from django.urls import path
                            import examples

                            urlpatterns = [
                                path('examples/a1_first/first_function.py', examples.a1_first.first_function.main),
                            ]
                        views.py: |  #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/try_DjangoREST/examples/a1_first/first_function.py
                            from rest_framework.decorators import api_view
                            from rest_framework.response import Response

                            __all__ = ['main']

                            @api_view(['GET'])
                            def main(request):
                                return Response({"id": 1}, status = 200)
                    メソッドにコールバックさせる場合: #keyword: Django view method
                        urls.py: |  #focus: as_view  #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/try_DjangoREST/site_1/urls.py
                                urlpatterns = [
                                    path('tutorial/app1/serializer/serialize_1.py', UsersView.as_view()),
                            #search: Django as_view
                        views.py: | #focus: APIView, get, post  #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/try_DjangoREST/site_1/app1/views.py
                            from rest_framework.views import APIView
                            from rest_framework.response import Response

                            class UsersView(APIView):

                                #// curl -i http://127.0.0.1:8000/users/
                                def get(self, request):
                                    return Response({"id": 1}, status = 200)

                                #// curl -i -X POST http://127.0.0.1:8000/users/
                                def post(self, request):
                                    return Response({"key": "value"}, status = 400)
                    クエリー パラメーター:  #focus: GET, POST
                        #// URL が http://localhost:80000/hello/?var=hello の場合
                        必須パラメーター: |  #// パラメーターが存在しないと例外が発生します。辞書と同じ
                            def  example_view( request ):
                                message = request.GET['var']    #// HTTP GET メソッド の場合
                                message = request.POST['var']   #// HTTP POST メソッド の場合
                        オプション パラメーター: |
                            def  example_view( request ):
                                message = request.GET.get('var')  #// 省略されたら None
                                message = request.POST.get('var')
                    JSON:  #focus: data
                        リクエストのコマンド: |
                            curl -X POST  http://localhost:80000/hello/  -H "Content-Type:application/json" -d '{
                                "Field": "aaa"
                            }'
                        def  example_view( request ):
                            value = request.data['Field']  #// "aaa"
                    Cookie: #keyword: Django Cookie,  Python Cookie
                        取得: | #focus: COOKIES
                            def  example_view( request ):
                                message = request.COOKIES.get('count', 0)
                        設定: | #focus: response
                            def  example_view( request ):
                                response = HttpResponse()
                                response.set_cookie('count', 1)
                                return response
                        #ref: https://yu-nix.com/archives/django-cookie/
                    HTTP header: #keyword: Django HTTP header  #ref: https://docs.djangoproject.com/en/4.1/ref/request-response/#django.http.HttpRequest.headers
                        取得: | #// HTTP ヘッダーの項目名は大文字小文字を区別しません
                            def  example_view( request ):
                                request.headers['User-Agent']
                        設定:
                            全ての応答:
                                settings.py: |
                                    MIDDLEWARE = [
                                        ...,
                                        'yourapp.middleware.MyMiddleware',
                                        ...,
                                    ]
                                __Project__/yourapp/middleware: |
                                    class MyMiddleware:
                                        def __init__(self, get_response):
                                            self.get_response = get_response
                                        def __call__(self, request):
                                            response = self.get_response(request)
                                            response['X-My-Header'] = "my value"
                                            return response
                                #ref: https://stackoverflow.com/questions/36099244/how-to-add-an-http-header-to-all-django-responses
                ready (runserver 初期化後):
                    ready が呼ばれます  #search: INSTALLED_APPS
                Ctrl + C キーを押したとき: #keyword: Django Ctrl+C
                    サーバーの処理は中断します。クライアントには接続エラーになります。
                    #ref: https://stackoverflow.com/questions/39736330/manage-py-runserver-and-ctrlc-django
                エラー ハンドリング: #keyword: Django error
                    例外発生時:
                    404 エラー: #keyword: Django HTTP 404 error
                        #ref: https://docs.djangoproject.com/en/4.1/ref/views/#the-404-page-not-found-view
                        #ref: https://www.w3schools.com/django/django_404.php
            構成:
                Django Middleware: #keyword: Django middleware
                    処理の順: |
                        WSGI Handler    #keyword: WSGI Handler
                            ├─ MyMiddleware.__call__()
                            │   ├─ pre-processing
                            │   ├─ get_response()
                            │   │   └─ URL Resolver
                            │   │        ├─ MyMiddleware.process_view()
                            │   │        ├─ __ViewFunction__() 🌟
                            │   │        │   ├─ render()   // Template Rendering
                            │   │        │   └─ Context Processors
                            │   │        └─ MyMiddleware.process_exception() [if exception occurs]
                            │   ├─ MyMiddleware.process_template_response() [if TemplateResponse]
                            │   └─ post-processing
                            └─ WSGI Handler (sends response)
                    コード:
                        middleware.py: |
                            class MyMiddleware:
                                def __init__(self, get_response):
                                    self.get_response = get_response
                                def __call__(self, request):
                                    #// 前処理
                                    response = self.get_response(request)
                                    #// 後処理
                                    return response
                Django's cache framework:  #keyword: Django's cache framework,  Django cache,  django.core.cache
                    公式:
                        Django 4.1:  #ref: https://docs.djangoproject.com/en/4.1/topics/cache/#basic-usage
                        Django 2.1:  #ref: https://docs.djangoproject.com/en/2.1/topics/cache/#basic-usage
                    操作: #keyword: Django cache operation
                        インストール:
                            CACHES 設定変数  #search: Django cache back ends
                        基本:
                            from django.core.cache import cache
                            cache.set("mykey", "aaa")
                            cache.get("mykey")   #// "aaa"
                        クリア, 削除: #keyword: Django cache clear
                            1つのキー:
                                cache.delete('my_key')
                            複数のキー:  #ref: https://stackoverflow.com/questions/9048257/get-list-of-cache-keys-in-django
                                参考）keys は Django 2.1 にはありません: |
                                    keys = cache.keys('__Prefix__*')
                                    if keys:
                                        cache.delete(*keys)
                            1つのキャッシュ: |  #search: Django shell  #// 1つのキャッシュのすべてのキー
                                echo  "from django.core.cache import cache;  cache.clear()"  |  poetry run ./manage.py shell
                            複数のキャッシュ: #search: Django multi cache  #// 複数のキャッシュのすべてのキーを CLI からクリアします
                                ヒア ドキュメント を使う場合: |  #search: Linux here document
                                    #// サービスの停止や再起動は不要です
                                    cd ____
                                    poetry run ./manage.py shell  << HERE_DOCUMENT_Python
                                    if True:
                                            from django.core.cache import caches
                                            caches['default'].clear()
                                            caches['persistent'].clear()
                                    HERE_DOCUMENT_Python
                            （メモ）:
                                サービスが稼働中で再起動しなくても削除できます。ただし、一時的にキャッシュにしないため、一時的にパフォーマンスが悪くなります
                                ./manage.py createcachetable  を実行してもクリアされません
                                ./manage.py clear_cache  は使えません
                                DB をクリアするとキャッシュもクリアされますが、sqlite がどのファイルを使っているか不明
                                    .venv/lib/python3.7/site-packages/django/core/cache/backends/db.py
                                #ref: https://docs.djangoproject.com/en/4.1/topics/cache/#django.core.caches.cache.delete
                        一覧:
                            すべてのキー:
                                - できません  #ref: https://stackoverflow.com/questions/9048257/get-list-of-cache-keys-in-django#answer-37558008
                                - ただし、バックエンド（キャッシュの実装）を直接操作することでできる可能性があります
                            複数のキャッシュ:  #search: Django multi cache
                            Redis:  #search: Django Redis  #ref: https://stackoverflow.com/questions/9048257/get-list-of-cache-keys-in-django#answer-37558008
                        更新:
                            有効期限:  #// 指定した時間が経過したら、キャッシュからクリアします
                                set するとき: cache.set('my_key', data, timeout=300)  #// 300秒後にクリアされます
                                get するとき: 指定できません
                            ポーリング, フェッチ:  #// 対象からバージョン番号だけなどをチェックします
                                特に cache のメソッドは使いません
                                定期的に統合したステータスをフェッチすることで負荷が低くなります
                            通知の受信:
                                Webhook など
                        その他、バックエンド固有の操作:  #search: Django cache back ends
                    構成:
                        複数のキャッシュ: #keyword: Django multi cache
                            一覧:  #// キャッシュの一覧。キーの一覧は django.core.cache パッケージでは
                                辞書型の CACHE 設定変数を参照してください  #search: Django cache settings
                            選択:
                                from django.core.cache import caches
                                cache1 = caches["default"]  #// default は CACHE 設定変数のキーです  #search: Django settings CACHE
                            デフォルト: |  #// caches["default"]
                                from django.core.cache import cache
                                from django.core.cache import caches
                                cache.set("mykey", "aaa")
                                cache.get("mykey")              #// "aaa"
                                caches["default"].get("mykey")  #// "aaa"   cache オブジェクトは caches["default"] からでも参照できます
                                cache is caches["default"]      #// False   オブジェクトは異なるが同じバックエンド
                        バックエンド: #keyword: Django cache back ends,  Django CACHES,  Django バックエンド キャッシュ エンジン
                            LocMemCache:
                                settings,py サンプル: |
                                    CACHES = {
                                        'default': {
                                            'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
                                            'LOCATION': 'unique-snowflake',
                                            'TIMEOUT': 300,
                                        }
                                    }
                                MemoryCache:  #// Python 3.2～3.7  django.core.cache.backends.base.MemoryCache
                                    デバッガーで表示される内部のクラス
                            Memcached: #keyword: Django Memcached,  PyMemcacheCache   #// Memcached をキャッシュのバックエンドに使う場合。
                                _: 高性能なキャッシュシステムで、分散環境で非常に有効です
                                settings,py サンプル: |
                                    CACHES = {
                                        'default': {
                                            'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
                                            'LOCATION': [
                                                '172.19.26.240:11211',
                                                '172.19.26.242:11211',
                                            ]
                                        }
                                    }
                                #ref: https://docs.djangoproject.com/en/4.1/topics/cache/#memcached
                            Redis: #keyword: Django Redis,  Django RedisCache  #// Redis をキャッシュのバックエンドに使う場合。Django 4 以降
                                settings,py サンプル: |
                                    CACHES = {
                                        'default': {
                                            'BACKEND': 'django.core.cache.backends.redis.RedisCache',
                                            'LOCATION': 'redis://127.0.0.1:6379/1',
                                            'OPTIONS': {
                                                'CLIENT_CLASS': 'django_redis.client.DefaultClient',
                                            },
                                            'TIMEOUT': 300,  # キャッシュのデフォルト有効期限（秒）
                                        }
                                    }
                                #ref: https://docs.djangoproject.com/en/4.1/topics/cache/#redis
                            Database: #keyword: Django DatabaseCache  #// データベースをキャッシュのバックエンドに使う場合
                                settings,py サンプル: |
                                    CACHES = {
                                        'default': {
                                            'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
                                            'LOCATION': 'my_cache_table',  # キャッシュデータを保存するデータベーステーブル名
                                        }
                                    }
                                作成:
                                    python manage.py createcachetable
                                クリア:
                                    #search: Django cache operation
                                DatabaseCache:  #// Python 3.7  django.core.cache.backends.db.DatabaseCache
                                    デバッガーで表示されるクラス
                    ファイル:
                        settings.py:
                            設定変数: #keyword: Django cache settings
                                CACHES 設定変数:  #search: Django cache back ends  #search: Django 設定変数
                QuerySets: #keyword:  #// Django に付属の DB アクセス。 プログラムによってはこれを使わず、他の DB API を使うものもある
                    サンプル: |
                        from django.db import models
                        class MyModel(models.Model):  # Model を継承
                            name = models.CharField(max_length=100)
                            created_at = models.DateTimeField(auto_now_add=True)
                            
                        MyModel.objects.all()
                        MyModel.objects.filter(...)
                        MyModel.objects.get(...)
                    QuerySets を使ったプログラムに共通するコード:
                        -   from django.db import models
                        -   .objects
                翻訳ファイル: #keyword: Django 翻訳ファイル
                    手順:
                        キャッシュのクリア:  #// これが正しく翻訳されない原因の可能性は低いです
                            from django.utils import translation
                            translation._trans.__dict__.clear()
                    API:
                        準備:
                            settings.py: |
                                MIDDLEWARE = [
                                    'django.middleware.locale.LocaleMiddleware
                        HTTP ヘッダー を使う場合:
                            日本語でリクエスト: |
                                curl -H "Accept-Language: ja" http://localhost:8000/api/users/
                            英語でリクエスト: |
                                curl -H "Accept-Language: en" http://localhost:8000/api/users/
                        クエリー パラメーター を使う場合:
                            http://localhost:8000/api/users/?lang=ja
                            http://localhost:8000/api/users/?lang=en
                    ファイル:  #// 翻訳する文章や、言語設定
                        .po:
                            場所: locale/ja/LC_MESSAGES/django.po  #keyword: locale/ja/LC_MESSAGES/django.po
                        .mo:
                            .po をコンパイルしたファイル
                        settings.py: |  #focus: LANGUAGE_CODE
                            USE_I18N = True
                            LANGUAGE_CODE = 'ja'

                            LANGUAGES = [
                                ('ja', 'Japanese'),
                                ('en', 'English'),
                            ]

                            LOCALE_PATHS = [
                                BASE_DIR / 'locale',  # または os.path.join(BASE_DIR, 'locale')
                            ]

                            MIDDLEWARE = [
                                # ...
                                'django.middleware.locale.LocaleMiddleware',  # これが必要
                                'django.middleware.common.CommonMiddleware',
                                # ...
                            ]
                    コード:  #// 翻訳処理
                        翻訳関数 gettext, _L, _: #keyword: Django 翻訳関数,  Django gettext _L _
                            サンプル _L: |
                                from django.utils.translation import gettext as _L

                                # これは同じ意味：
                                message = gettext("こんにちは")
                                message = _L("こんにちは")
                            サンプル _: |
                                from django.utils.translation import gettext as _

                                # これは同じ意味：
                                message = gettext("こんにちは")
                                message = _("こんにちは")
                        内部コード:
                            gettext:
                                # def gettext(message):
                                #     _default = _default or translation(settings.LANGUAGE_CODE)
                                #     translation_object = getattr(_active, "value", _default)
                                #     result = translation_object.gettext(eol_message)
                                gettext:
                                    # def gettext(self, message):
                                    #     tmsg = self._catalog.get(message, missing)
                    トラブルシューティング:
                        正しく翻訳されない:
                            .mo ファイルがあることをチェックしてください
            ログ:  #keyword: Django logger,  logging.getLogger
                手順 >> 基本:
                    ____/file.py: |
                        import logging
                        logger = logging.getLogger(__name__)
                        def method():
                            url = "http://example.com"
                            logger.setLevel(logging.INFO)
                            logger.info("message (%s)", url)
                    (%s) など:
                        数値型でも %s を指定します。与えられた値を文字列に変換して埋め込みます。
                        ただし、f-string を使うことを推奨します。
                出力:
                    ____/log/django.log: |  #// 設定により異なる場合があります
                        2021-01-01 10:10:30,000 file.method INFO: message (http://example.com)
                    保存場所の設定: #keyword: Django LOGGING filename  #focus: __Path__
                        settings.py など: |  #search: Django 設定変数
                            LOGGING = {
                                'handlers': {
                                    'file': {
                                        'filename': __Path__
                        #search: Django logger code
                    書式: |
                        __Date__ __Time__ __PythonFileName__.__MethodName__ __Level__: __Message__
                    __PythonFileName__: Python のファイル名から拡張子を削除した名前
                    #// フォルダー名、クラス名は記録されません
                公式: https://docs.djangoproject.com/en/3.2/topics/logging/
                本番設定:
                    #ref: https://qiita.com/okoppe8/items/3e8ab77c5801a7d21991#本番環境用設定についての考察
                setLevel は階層化されているらしい:
                    logger.parent.name
                ログが出ないとき: #keyword: Django logger trouble,  Django configure_logging
                    サンプル: |
                        import logging
                        logger = logging.getLogger(__name__)
                        logger.setLevel(logging.DEBUG)
                        logger.debug("ここはログが出る")

                        def view():
                            logger.debug("ここはログが出ない")
                    対処:
                        初期化を 1回にします:
                            #ref: .venv/lib/python3.7/site-packages/django/utils/log.py
                            編集前: |
                                def configure_logging(logging_config, logging_settings):
                                    if logging_config:
                                        __Code__
                            編集後: |  #focus: logging_initialized
                                def configure_logging(logging_config, logging_settings):
                                    global logging_initialized
                                    if logging_config  and  not logging_initialized:
                                        __Code__
                                        logging_initialized = True
                                logging_initialized = False
                        Django の LOGGING 設定変数に root を設定します: |
                            LOGGING = {
                                'version': 1,
                                    ...
                                'root': {
                                    'level': 'DEBUG',
                                    'handlers': ['console']
                                },
                    原因:
                        概要:
                            configure_logging 関数が複数回呼ばれるため。
                            import_module した後で configure_logging 関数が呼ばれ、
                            グローバル スコープ で setLevel したものがリセットされるため。
                        コール ツリー:
                            メイン プロセス:
                                manage.py:
                                    execute_from_command_line:
                                        execute:
                                            setup:  #ref: .venv/lib/python3.7/site-packages/django/__init__.py
                                                configure_logging:  #ref: .venv/lib/python3.7/site-packages/django/utils/log.py
                                                    # def configure_logging(logging_config, logging_settings):
                                                    #     if logging_config:
                            サブ プロセス:
                                メイン スレッド:
                                    #// 同上
                                        configure_logging:
                                サブ スレッド:
                                    wrapper:
                                        ...:
                                            import_module( urls.py ):
                                                from app import ____
                                        ....:
                                            get_wsgi_application:
                                                setup:
                                                    configure_logging:
                ブレークさせる: #keyword: Django logger break point  #// 特定のパターンのログが出力されたタイミングでブレークさせます
                    #ref: ~/.pyenv/versions/3.7.1/lib/python3.7/logging/__init__.py
                    編集前: |
                        def emit(self, record):
                            ...
                            msg = self.format(record)
                            stream = self.stream
                            stream.write(msg)
                            ...
                    編集後: |  #focus: __Keyword__
                        def emit(self, record):
                            ...
                            msg = self.format(record)
                        ### debug
                            import re
                            if re.compile(r'__Keyword__').search(msg):
                                msg = msg  #// Set break point here
                        ###
                            stream = self.stream
                            stream.write(msg)
                            ...
                コード:  #search: Django logger code
        Django REST framework: #keyword: Django REST Framework, Python REST, rest_framework
            公式:  #ref: https://www.django-rest-framework.org/
                検索:  #ref: https://www.django-rest-framework.org/  >>  Search（上）
            手順:
                プロジェクト一覧: #keyword: Django REST projects
                    基本:   #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/REST_simple
                    テスト: #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/try_DjangoTest
                    その他: #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/try_DjangoREST
                Django REST Framework の最小限を WSL2 にインストールします: #keyword: install Django REST Framework,  REST_simple
                    WSL2 Ubuntu 20.04 をクリーン状態にします:
                        #search: install WSL2 Ubuntu
                    プロジェクトを Linux にコピーします:
                        コピー元:  #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/REST_simple
                        コピー先:  #ref: \\wsl$\Ubuntu-20.04-Django\home\user1
                    commands: |
                        sudo apt install -y  python3.8-venv
                        cd ~/REST_simple
                        python3 -m venv ".venv"
                        source ".venv/bin/activate"
                        pip install django
                        pip install djangorestframework
                        code .
                        extension >> python >> install
                        VSCode >> Terminal >> New Terminal
                    （参考）オリジナルの commands:  #ref: https://www.django-rest-framework.org/tutorial/quickstart/
                        cd $HOME
                        mkdir tutorial
                        cd tutorial
                        python3 -m venv ".venv"
                        source ".venv/bin/activate"
                        pip install django
                        pip install djangorestframework
                        django-admin startproject tutorial "."
                        cd tutorial
                        django-admin startapp quickstart
                        cd ..
                    run server:
                        ブレークポイントを張ります:
                            __Project__/tutorial/app1/views.py の post メソッド
                        API サーバーを起動します:  #// python manage.py runserver コマンドをデバッガーに接続して実行します
                            F5 キー
                        REST API を呼び出します:
                            curl -i -X POST http://127.0.0.1:8000/users/
                    コードの説明:  #// HTTP リクエストに応答するコード
                        サンプル: |  #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/REST_simple/tutorial/app1/views.py
                            from rest_framework.views import APIView
                            from rest_framework.response import Response

                            class UsersView(APIView):

                                #// curl -i http://127.0.0.1:8000/users/
                                def get(self, request):
                                    return Response({"id": 1}, status = 200)

                                #// curl -i -X POST http://127.0.0.1:8000/users/
                                def post(self, request):
                                    return Response({"key": "value"}, status = 400)
                        説明:
                            APIView: #keyword:
                                urlpatterns に指定するオブジェクトは APIView クラスから継承させます
                            get: HTTP GET メソッドに応答するコードが入った関数
                            post: HTTP POST メソッドに応答するコードが入った関数
                            Response: #keyword: Django Response  #// レスポンスの内容
                                書式: Response(__BodyDictionary__, status = __HTTP_StatusCode__)
                                __BodyDictionary__: レスポンスの body に含める JSON に指定する辞書。
                                脆弱性: #// なし
                                    ダブルクオーテーション(") は Response の内部でエスケープするので、安全です
                                    #search: Python dict
                                    #ref: https://atmarkit.itmedia.co.jp/ait/articles/1306/05/news006.html
                Django Testing tools を WSL2 にインストールします: #keyword: install Django Testing tools
                    プロジェクト:  #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/try_DjangoTest
                    手順は REST_simple と同じです: #search: install Django REST Framework
                        ただし、pip install が少し多いです。 README を参照
                    SimpleTestCase: #keyword: Django Testing tools SimpleTestCase  #// SimpleTestCase から継承すると settings.DATABASES に設定されたデータベースの初期化等を行います
                    サンプル:
                        テスト: |  #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/try_DjangoTest/tutorial/app1/tests/test_views.py
                            from django.test import SimpleTestCase

                            class FirstTest(SimpleTestCase):  #// SimpleTestCase から継承すると settings.DATABASES に設定されたデータベースの初期化等を行います
                                def test_1(self):
                                    response = self.client.get('/users/')
                                    self.assertEqual(response.status_code, 200)
                            #// XML-RPC の場合 #search: SimpleXMLRPCDispatcher test
                        テスト対象: |  #// 上記 self.client.get から HTTP 通信をしないで下記 get を間接的に呼び出します。ブレーク ポイント も機能します
                            class ServiceSpecificMocaCheckREST(APIView):
                                def get(self, request):
                                    return Response({"StatusCode" : "200", "Result": {}}, status = 200)
                    参考:  #search: django.test.Client
                REST と RPC を共存するサンプルをインストールします:  #keyword: Django REST and RPC
                    プロジェクト:  #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/REST_and_RPC/README.yaml
                    コード:  #keyword: Django REST and RPC code
                        REST:  #focus: as_view
                            urlpatterns:  #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/REST_and_RPC/tutorial/urls.py#urlpatterns =
                                # urlpatterns = [
                                #     path('users/', UsersView.as_view()),
                                get (UsersView):  #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/REST_and_RPC/tutorial/app1/views.py#UsersView
                                    # class UsersView(APIView):
                                    #     #// curl -i http://127.0.0.1:8000/users/
                                    #     def get(self, request):
                        RPC:  #focus: example_rpc_handler
                            urlpatterns:  #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/REST_and_RPC/tutorial/urls.py#urlpatterns =
                                # urlpatterns = [
                                #     path('rpc/', example_rpc_handler),  #// rpc でないとコールバックされないバージョンもあります。例 2.1.15
                                example_rpc_handler:  #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/REST_and_RPC/tutorial/rpc_server.py#def example_rpc_handler
                    参考:
                        （かなり古いコードでそのままでは動きません）:
                            #ref: https://stackoverflow.com/questions/3108507/best-way-to-get-xml-rpc-and-django-working-together
                            #ref: https://code.djangoproject.com/wiki/XML-RPC
                Django REST Framework をインストールします:
                    参考: #ref: https://udemy.benesse.co.jp/development/python-work/django-rest-framework.html
                    pipenv に対応した Python プロジェクトを新規作成します:
                        右記リンク先の pipenv install まで実行します  #search: Python VSCode
                    Django プロジェクトを新規作成します:
                        VSCode の Terminal を開いて、自動的に下記 source コマンドが実行されるまで、Terminal を再起動します:
                            source __Project__/.venv/Scripts/activate
                        最新の Django の場合:
                            bash:  #// in VSCode Terminal
                                - pipenv install  django  markdown  django-filter  pytz
                                - django-admin startproject  try_rest  #// try_rest プロジェクトを新規作成します
                                - cd  try_rest
                                - django-admin startapp  try_app  #// try_app 新規アプリケーションをプロジェクトに追加します
                        Django 2.1 の場合:
                            bash:  #// in VSCode Terminal
                                - pipenv install  django==2.1.15  djangorestframework==3.9.4  django-filter==2.2.0
                                - （以下、最新と同じ）
                            （後で CORS を使うとき）:
                                - pipenv install  django-cors-headers==3.4.0
                    Django Rest Framework をインストールします:
                        bash:  #// in VSCode Terminal
                            - pipenv install  djangorestframework
                        __Project___/try_rest/try_rest/settings.py : |  #// rest_framework を追加します
                            INSTALLED_APPS = [
                                    :
                                'rest_framework',
                            ]
                    Serializer, ViewSet, router を追加します:  #// 下記 from と class と router を追加します
                        __Project__/try_rest/try_rest/urls.py : |  #focus: TrySerializer, TryViewSet, router
                            from django.urls import path, re_path  #// この行は re_path のみ追加
                            from django.conf.urls import include
                            from django.contrib.auth.models import User
                            from rest_framework import routers, serializers, viewsets

                            class TrySerializer(serializers.HyperlinkedModelSerializer):
                                class Meta:
                                    model = User
                                    fields = ('url', 'username', 'email', 'is_staff')

                            class TryViewSet(viewsets.ModelViewSet):
                                queryset = User.objects.all()
                                serializer_class = TrySerializer

                            router = routers.DefaultRouter()
                            router.register(r'users', TryViewSet)

                            urlpatterns = ...
                    urlpatterns に REST API の URL を設定します:
                        __Project__/try_rest/try_rest/urls.py : |  #focus: router
                            urlpatterns = [
                                    :
                                re_path(r'^', include(router.urls)),
                                re_path(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework')),
                            ]
                    Web サーバーを起動します:
                        新しい bash:  #// in VSCode Terminal
                            - cd  __Project__/try_rest  #// manage.py ファイルがあるフォルダー
                            - python manage.py migrate    #// （初回のみ） __Project__/try_rest/db.sqlite3 ファイルのスキーマを作ります
                            - python manage.py runserver
                    Web ページを開きます:
                        http://localhost:8000/
                            #// Api Root の画面が表示されます
                    ユーザーを追加します:
                        Web UI を使う場合:
                            REST API の UI を開きます:  #// UI は Django REST Framework 固有の機能です
                                http://localhost:8000/users/
                            ユーザーを追加します:
                                Username: a
                                POST ボタン（右下）:
                                    #// 押したら追加された情報が表示されます。一覧ではありません
                        CLI を使う場合:
                            Git bash: |
                                curl -X POST -H "Content-Type: application/json"  -d '{"username":"a","email":"","is_staff":false}'  http://localhost:8000/users/
                    ユーザーを一覧します:
                        REST API の UI を開きます:  #// UI は Django REST Framework 固有の機能です
                            http://localhost:8000/users/
                        #// もしくは、POST ボタンを押した後で、GET ボタン（右上）:
                        CLI を使う場合:
                            Git bash: |
                                curl http://localhost:8000/users/
                        Talend API Tester を使う場合:
                            インストールします:  #search: Talend API Tester GET
                            METHOD: GET
                            SCHEME: http://localhost:8000/users/
                            HEADERS:
                                Origin: http://localhost:8000
                            応答:
                                HTTP: |
                                    HTTP/1.1 200 OK
                                        :
                                    [{"url":"http://localhost:8000/users/1/","username":"a","email":"","is_staff":false}]
                    Web サーバーを終了します:
                        Ctrl + C  #// python manage.py runserver を実行中のシェルで
                    データベースを削除します:
                        #// Web サーバーが終了した状態で
                        __Project__/try_rest/db.sqlite3 を削除
                    その他:
                        リレーションを展開します: #// 他のテーブルを子要素として追加したものを GET します  #ref: https://qiita.com/kimihiro_n/items/86e0a9e619720e57ecd8#リレーションモデルを展開する
                        ペジネーション: #ref: https://qiita.com/kimihiro_n/items/86e0a9e619720e57ecd8#ペジネーション
                        フィルター: #// 一部のフィールドだけ GET します  #ref: https://qiita.com/kimihiro_n/items/86e0a9e619720e57ecd8#フィルター
                CORS をインストールします（Django Rest Framework）: #keyword: install Django REST Framework CORS
                    Django REST Framework をインストールします:
                        参照...  #search: install Django REST Framework
                    Django CORS headers をインストールします:
                        bash:  #// in VSCode Terminal
                            - pipenv install  django-cors-headers
                        __Project___/try_rest/try_rest/settings.py : |  #// corsheaders などを追加します
                            INSTALLED_APPS = [
                                    :
                                'corsheaders',
                            ]

                            MIDDLEWARE = [
                                'corsheaders.middleware.CorsMiddleware',
                                    :
                            ]

                            （下記はファイルの末尾に追加します）
                            # CORS
                            if DEBUG is True:
                                CORS_ALLOW_ALL_ORIGINS = True
                    Web サーバーを起動します:
                        参照...  #search: install Django REST Framework
                    CORS 関連の HTTP ヘッダーを確認します:  #// Access-Control-Allow-Origin: *
                        参考: Access-Control-Allow-Origin  #search:  #// CROS 関連のヘッダー
                        Talend API Tester を使う場合:
                            Talend API Tester をインストールして開きます:
                                #search: install Talend API Tester
                            GET メソッドを使う場合:
                                METHOD: GET
                                SCHEME: http://localhost:8000/users/
                                HEADERS:
                                    Origin: http://localhost:8000
                                応答:
                                    HTTP: |
                                        HTTP/1.1 200 OK
                                            :
                                        Access-Control-Allow-Origin: *
                            OPTIONS メソッドを使う場合:  #search: プリフライト リクエスト
                                METHOD: OPTIONS
                                SCHEME: http://localhost:8000/users/
                                HEADERS:
                                    Origin: http://localhost:8000
                                    Access-Control-Request-Method: GET  #// Access-Control-Allow-Origin: * の場合、無くてもよい
                                応答:
                                    HTTP: |
                                        HTTP/1.1 200 OK
                                        access-control-allow-headers: accept, accept-encoding, authorization, content-type, dnt, origin, user-agent, x-csrftoken, x-requested-with
                                        access-control-allow-methods: DELETE, GET, OPTIONS, PATCH, POST, PUT
                                        access-control-allow-origin: *
                                        access-control-max-age: 86400
                    Origin を制限します:  #// Access-Control-Allow-Origin: http://localhost:8000
                        __Project___/try_rest/try_rest/settings.py : |
                            DEBUG = False

                            ALLOWED_HOSTS = ['localhost']
                                :

                            # CORS
                            if DEBUG is True:
                                CORS_ALLOW_ALL_ORIGINS = True  #// DEBUG = False なら、CORS_ALLOW_ALL_ORIGINS は設定されません
                            else:
                                CORS_ORIGIN_WHITELIST = ['http://localhost:8000']
                        （補足）:
                            #// DEBUG = False に設定すると static フォルダーにあるファイルの GET が失敗しますがここでは無視できます。
                            GET する URL の例: http://localhost:8000/static/rest_framework/css/bootstrap.min.css
                            本番環境での解決法: #search: Django static
                        Talend API Tester を使って確認します:
                            METHOD: OPTIONS
                            SCHEME: http://localhost:8000/users/
                            HEADERS:
                                Origin: http://localhost:8000
                                Access-Control-Request-Method: GET  #// 必須。後でリクエストしようとする HTTP メソッド
                            応答:
                                HTTP: |  #focus: access-control-allow-origin
                                    HTTP/1.1 200 OK
                                    access-control-allow-headers: accept, accept-encoding, authorization, content-type, dnt, origin, user-agent, x-csrftoken, x-requested-with
                                    access-control-allow-methods: DELETE, GET, OPTIONS, PATCH, POST, PUT
                                    access-control-allow-origin: http://localhost:8000
                                    access-control-max-age: 86400
                        拒否されることを確認します:
                            __Project___/try_rest/try_rest/settings.py : |
                                CORS_ORIGIN_WHITELIST = ['http://localhost:8111']
                            Talend API Tester を使って確認します:
                                METHOD: OPTIONS
                                SCHEME: http://localhost:8000/users/
                                HEADERS:
                                    Origin: http://localhost:8000
                                    Access-Control-Request-Method: GET  #// 必須。後でリクエストしようとする HTTP メソッド
                                応答:
                                    HTTP: |
                                        HTTP/1.1 200 OK
                                        Content-Length: 0   #// access-control-allow-origin ヘッダーは返りません。つまり、拒否されました
                            戻します:
                                __Project___/try_rest/try_rest/settings.py : |
                                    CORS_ORIGIN_WHITELIST = ['http://localhost:8000']
                    参考:
                        Django Rest Framework で CORS の設定が効かないと思い込んでいた話: #ref: https://blog.tsukumijima.net/article/django-rest-framework-cors/
            設定変数:
                REST framework:  #ref: https://www.django-rest-framework.org/api-guide/settings/
                    REST_FRAMEWORK: #keyword:
                        DEFAULT_AUTHENTICATION_CLASSES:  #ref: https://www.django-rest-framework.org/api-guide/settings/#default_authentication_classes
                        EXCEPTION_HANDLER:  #ref: https://www.django-rest-framework.org/api-guide/settings/#exception_handler
                            概要: 例外をキャッチしなかったときに呼ばれる関数。指定方法は import と同じ。
                                ログにコールスタックを出力して、HTTP レスポンスを適切に設定します。
                            コール ツリー:  #focus: get,  exception_handler
                                view:  #ref: .venv/lib/python3.7/site-packages/django/views/generic/base.py
                                    # def view(request, *args, **kwargs):
                                    #     return self.dispatch(request, *args, **kwargs)
                                    dispatch:  #ref: .venv/lib/python3.7/site-packages/rest_framework/views.py
                                        # def dispatch(self, request, *args, **kwargs):
                                        #     try:
                                        #         response = handler(request, *args, **kwargs)
                                        get | post:  #// urlpatterns に指定したメソッド
                                        #     except Exception as exc:
                                        #         response = self.handle_exception(exc)
                                        （例外の内容）:  #search: Python exception print
                                        handle_exception:  #ref: .venv/lib/python3.7/site-packages/rest_framework/views.py
                                            # def handle_exception(self, exc):
                                            #     response = exception_handler(exc, context)
                                            (exception_handler):  #// EXCEPTION_HANDLER に指定した関数
                Django:  #search: Django settings  #ref: https://docs.djangoproject.com/en/4.1/topics/settings/
            rest_framework:
                Python パッケージ名: djangorestframework
                rest_framework.serializers: #keyword:  #ref: https://note.crohaco.net/2018/django-rest-framework-serializer/
                    サンプル:  #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/try_DjangoREST/examples/serializer/serialize_1.py
                        シリアライズする前のオブジェクト: |  #focus: Comment
                            from datetime import datetime

                            class Comment:
                                def __init__(self, email, content, created=None):
                                    self.content = content
                                    self.email = email
                                    self.created = created or datetime.now()
                        シリアライズ処理を行うオブジェクト: |  #focus: CommentSerializer
                            from rest_framework import serializers

                            class CommentSerializer(serializers.Serializer):
                                email = serializers.EmailField()
                                content = serializers.CharField(max_length=10)
                                created = serializers.DateTimeField()
                        シリアライズ: |  #focus: serialized_data
                            comment = Comment(email='leila@example.com', content='foo45678901')
                            serializer = CommentSerializer(comment)

                            serialized_data = serializer.data  #// data property returns "rest_framework.utils.serializer_helpers.ReturnDict" class
                            email = serialized_data['email']
                            content = serialized_data['content']
                            unknown = serialized_data.get('unknown', '??')
                        バリデーション: | #keyword: Django REST framework varidation  #focus: is_valid  #ref: https://www.django-rest-framework.org/api-guide/serializers/#validation
                            good_data = {'email': 'leila@example.com',
                                'content': 'foo4567890', 'created': '2022-12-02T05:38:31.380182Z'}
                            error_data = {'email': 'leila@example.com',
                                'content': 'foo45678901', 'created': '2022-12-02T05:38:31.380182Z'}
                            serializer = CommentSerializer(data=good_data)

                            is_valid = serializer.is_valid()  #// or .is_valid(raise_exception=True)
                            if not is_valid:
                                error_message = str(serializer.errors)
                                    #// "{'content': [ErrorDetail(string='Ensure this field has no more than 10 characters.', code='max_length')]}"
                            else:
                                deserialized_object = serializer.validated_data
                    レスポンスの一部のフィールドを無くしてシリアライズします: | #keyword: ignore Django REST Framework serializer field
                        resp.ignore_fields = ['__FieldA__', '__FieldB__']
                        if hasattr(resp, 'ignore_fields'):
                            class TemporarySerializer(serializer_cls):
                                def to_representation(self, obj):
                                    ret = super(TemporarySerializer, self).to_representation(obj)
                                    for field_name in resp.ignore_fields:
                                        ret.pop(field_name)
                                    return ret

                            return TemporarySerializer(resp).data
            エラー ハンドリング: #keyword: Django error
                例外発生時:
                404 エラー: #keyword: Django HTTP 404 error
                    デフォルト:
                        DEBUG = True:  #// 設定変数 DEBUG の値が True のとき
                            エラーの詳細が書かれた HTML が返ります
                        DEBUG = False:
                            <h1>Not Found</h1><p>The requested resource was not found on this server.</p>
                    #ref: https://stackoverflow.com/questions/35156134/how-to-properly-setup-custom-handler404-in-django
                    #ref: https://stackoverflow.com/questions/42032668/how-do-you-return-404-when-resource-is-not-found-in-django-rest-framework
            テスト:  #ref: https://docs.djangoproject.com/en/4.1/topics/testing/tools/
                サンプル プロジェクト:  #search: install Django Testing tools
                    #ref: https://stackoverflow.com/questions/59939819/run-django-tests-in-the-vscode-test-explorer
                django.test.Client: #keyword:  #ref: https://selfs-ryo.com/detail/django_test_2#_5
                    client.get:
                        ライブラリのコード:
                            #ref: .venv/lib/python3.7/site-packages/django/test/client.py:csv#class Client,def get(
                    client.post: |  #keyword: Django Testing tools client.post
                        from django.test import SimpleTestCase
                        class Test(SimpleTestCase):
                            def test(self):
                                with open('exmple.json') as fp:
                                    json_document = fp.read()
                                json_data = json.loads(json_document) 

                                response = self.client.post('/example', data=json_data, content_type='application/json')
                                self.assertEqual(response.status_code, 200)
                    client.generic:  #keyword: Django Testing tools client.generic
                        #search: SimpleXMLRPCDispatcher test
                Coverage.py:  #ref: https://selfs-ryo.com/detail/django_test_2#coveragepy
            トラブルシューティング:
                - #// 404 (Not Found) エラーになってしまう
                    手順:
                        HTTP リクスト
                    対処:
                        Django REST framework の中で URL のパターンの一覧をチェックします
                    コード:
                        inner:  #ref: .venv/lib/python3.7/site-packages/django/core/handlers/exception.py
                            _get_response:  #focus: 422, ModelValidationError  #ref: .venv/lib/python3.7/site-packages/django/core/handlers/base.py
                                # def _get_response(self, request):
                                #     resolver_match = resolver.resolve(request.path_info)
                                resolve:
                                    # def resolve(self, path):
                                    #     sub_match = pattern.resolve(new_path)
                                    pattern:
                                        pattern.url_patterns  #keyword: Django REST url_patterns  #// URL のパターンの一覧
                - #// この値は所要のパターンにマッチしません。 #keyword: Django REST framework error message 
                    手順:
                        HTTP リクスト
                        応答するコールバック関数を呼び出す前？の Django REST Frameowork 内
                    ログ: |
                        {"errors": {"serviceCode": ["この値は所要のパターンにマッチしません。"]}}
                    対処:
                    原因:
                    コード:
                        gettext:
                            # def gettext(message):
                            #     return _trans.gettext(message)
                        message:
                            fields.py:    #ref: https://github.com/encode/django-rest-framework/blob/master/rest_framework/fields.py#L785
                                # default_error_messages = {
                                #     'invalid': _('This value does not match the required pattern.')
                                # }
                            django.po:  #ref: https://github.com/encode/django-rest-framework/blob/master/rest_framework/locale/ja/LC_MESSAGES/django.po#L192
                                # #: fields.py:827
                                # msgid "This value does not match the required pattern."
                                # msgstr "この値は所要のパターンにマッチしません。"
        メール: #keyword: Python mail
            EmailMessage:  #keyword:
                ポリシーの変更:
                    #ref: https://stackoverflow.com/questions/44556428/email-with-invalid-hour-in-date-header-throws-exception
                公式: #ref: https://docs.python.org/ja/3/library/email.message.html
            smtplib:  #keyword: smtplib
                Python からメールを送ります。
                SMTP サーバーが必要です  #search: SMTP server
    デコレーター, @:  #keyword: Python @, Python デコレーター
        概要:
            関数を定義すると、@ に指定した関数が呼び出されます。
            (@) に指定した関数の引数には、定義した関数が渡ります。
            ライブラリ、または、ユーザーが @ の内容を定義します。Python の文法として定義されているわけではありません。
        用途の例:
            アスペクト志向的に、関数呼び出しをする前後に共通の処理を実行します:
            関数定義時に、関数に対する処理を実行します:
            関数呼び出しをしても、実際は後で非同期に呼び出します:
        () を付けないデコ―レーター:  #// @deco
            次の２つのコードは同じ動きをします:
                デコレーターを使う場合: |
                    @staticmethod
                    def f(...):
                        ...
                デコレーターを使わない場合: |
                    def f(...):
                        ...
                    f = staticmethod(f)    #// f の内容を置き換えます
            サンプル:
                コード: |  #focus: deco, test, wrapper
                    def deco(func):                   #// 定義時に呼ばれる関数
                        def wrapper(*args, **kwargs):
                            print('--start--')
                            func(*args, **kwargs)
                            print('--end--')
                        return wrapper                #// test を呼び出そうとすると実際に呼ばれる関数

                    @deco
                    def test():
                        print('Hello Decorator')

                    test()
                出力:
                    --start--
                    Hello Decorator
                    --end--
                解説:
                    - (@demo) の部分（関数の中ではなく関数定義）を実行すると、deco 関数が呼び出されます
                    - test の内容は、deco 関数の返り値の内容に置き換わります
        () を付けるデコ―レーター:  #// @deco()
            呼び出し時にデコレーションした関数をラップする場合:
                サンプル:
                    コード: |  #focus: deco, deco_def, test, wrapper
                        def deco(parameter: str = 'x'):   #// 定義時に @deco から呼ばれる関数
                            def deco_def(func):
                                def wrapper(*args, **kwargs):
                                    print('--start--')
                                    print(parameter)
                                    func(*args, **kwargs)
                                    print('--end--')
                                return wrapper     #// test を呼び出そうとすると実際に呼ばれる関数
                            return deco_def        #// 定義時に def test から呼ばれる関数

                        @deco('deco_parameter')
                        def test():
                            print('Hello Decorator')

                        test()
                    出力:
                        --start--
                        deco_parameter
                        Hello Decorator
                        --end--
                    解説:
                        - デコレーターに () が付くと、デコレーターの定義はネストします
                        - 定義時に deco と deco_def が呼ばれます
            定義時にデコレーションする関数に対して処理をする場合:
                サンプル:
                    コード: |  #focus: deco, deco_def, test, _attribute
                        def deco(parameter: str = 'x'):   #// 定義時に @deco から呼ばれる関数
                            def deco_def(func):
                                setattr(func, '_attribute', parameter)
                                return func     #// test を呼び出そうとしたときに実際に呼ばれる関数も test
                            return deco_def     #// 定義時に def test から呼ばれる関数

                        @deco('deco_parameter')
                        def test():
                            print('Hello Decorator')

                        test()
                        print(test._attribute)  #// deco_parameter
                    出力:
                        --start--
                        Hello Decorator
                        deco_parameter
                        --end--
                    解説:
        参考: https://qiita.com/mtb_beta/items/d257519b018b8cd0cc2e
        公式: https://docs.python.org/ja/3/glossary.html >> decorator
    #!/usr/bin/env python3: #search: /usr/bin/env
ユーザー インターフェース:
    stdin, stdout:  #keyword: Python stdin stdout
        標準入出力に対してファイル名でアクセスします:
            stdin_fd = sys.stdin.fileno()
            input_file_path = os.readlink(f"/proc/self/fd/{stdin_fd}")
            stdout_fd = sys.stdout.fileno()
            output_file_path = os.readlink(f"/proc/self/fd/{stdout_fd}")
    logging: #keyword: Python logging,  logger.warning,  logger.debug
        setLevel のサンプル: |
            import logging
            logger = logging.getLogger('app.io')
            logger.setLevel(logging.INFO)
        basicConfig サンプル: |  #focus: basicConfig
            import logging
            logging.basicConfig(level=logging.DEBUG)   #// logging のツリー構造のルートを設定しますが、下記 logger には設定されないようです
            logger = logging.getLogger(__name__)

            logger.info("Hello, world!")
            logger.warning('Protocol problem: %s', 'connection reset', extra=d)
        コマンド:
            オプションはありません。上記の basicConfig を追加してください。
            #ref: https://coralogix.com/blog/python-logging-best-practices-tips/
            #ref: https://stackoverflow.com/questions/28284107/how-to-enable-debug-mode-as-an-option-using-pythons-logging-module
            #ref: https://stackoverflow.com/questions/14097061/easier-way-to-enable-verbose-logging
    Jupyter: #keyword:  #// 「ジュパイター」。旧 IPython ノートブック
        インストール: #keyword: install Jupyter
            プロジェクト:  #keyword: try_Jupyter  #ref: ${GitHub}/MyPrivateCode/Python/try_Jupyter/README.yaml
            Visual Studio Code:  #keyword: install Jupyter VSCode
                仮想環境とプロジェクトを新規作成します:
                    #search: install venv VSCode
                Jupyter をインストールします:
                    pip install jupyter 
                .ipynb ファイルを新規作成します:
                仮想環境を選びます:
                    Select Kernel（カーネル ピッカー：右上）から仮想環境を選びます
                コード セル にコードを入力します:
                    #// コード セル の領域の右下には、Python と表示されています
                    コード: |
                        message = "Hello"
                        print(message)
                デバッグ実行します:
                    #ref: https://code.visualstudio.com/docs/datascience/jupyter-notebooks#_debug-a-jupyter-notebook
                IPython シェルを開きます: #keyword: open IPython shell
                    ターミナル:
                        ipython
            ブラウザー (Anaconda):  #keyword: install Jupyter browser
                #ref: https://udemy.benesse.co.jp/development/python-work/jupyter-notebook.html
        IPython ノートブック, .ipynb ファイル: #keyword: Jupyter notebook, .ipynb  #// markdown + Python
            コマンド モード, 編集モード:
                コマンド モード: #keyword: VSCode Jupyter command mode
                    表示: 左に縦の青いバーが表示された状態。
                    入る: コード セル の左をクリック
                    概要: vi の INSERT モードではないときのキー配列になります。
                編集モード: #keyword: VSCode Jupyter edit mode
                    表示: コード セル の枠が青い状態
                    入る:
                        - コード セル をクリック
                        - コマンド モード で Enter キー を押す
                        - レンダリング状態で鉛筆ボタン
                レンダリング状態: #// markdown のコードに基づいて文書を表示した状態
                    入る: 編集モードで ✓
            行番号のオンオフ: コマンド モード で Shift + L
            データ ビューアー, プロット: #ref: https://code.visualstudio.com/docs/datascience/jupyter-notebooks#_variable-explorer-and-data-viewer
        Jupyter Notebook: #// ブラウザー版 IPython ノートブック
            #search: install Jupyter browser
        JupyterLab: #// Jupyter Notebook の進化版
        IPython: #keyword:  #ref: https://ipython.org/
            インストール: #search: install Jupyter
            IPython シェルを開きます: #search: open IPython shell
    Ctrl + C:  #search: Python signal
ファイル: #keyword: Python files  #ref: https://docs.python.org/ja/3.12/library/os.html
    アップロード: #keyword: Django file upload  #ref: ${programming}/スクリプト/Python.svg#Django_file_upload
        関連:
            ブラウザーの開発者ツールで見たファイルのアップロード:  #search: HTTP file upload
    ファイル パス:  #ref: ${programming}/スクリプト/Python.svg#path
        search_parent: #keyword: Python  search_parent
            #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/path/search_parent.py
    ソース ファイル のパス: #keyword: Python source file path  #glossary: Python
        __file__ 変数:
        __pycache__ フォルダー: #keyword: __pycache__
            削除:  #// サブ フォルダー も含めて __pycache__ フォルダーを削除します
                find "." -type d -name "__pycache__" -exec rm -rf {} +
    open: #keyword: Python open, Python file open
        相対パスで開きます: |  #focus: current_directory, __RelativePath__
            import os
            current_directory = os.path.split(os.path.realpath(__file__))[0]
            with open(os.path.join(current_directory, '__RelativePath__'), encoding='utf_8_sig') as file:
                text = file.read()
            with open('readme.txt', 'w') as file:
                file.write('readme')
        Python の最新 open–closed principle: #keyword: Python open close
            #search: @contextlib.contextmanager
        同時に任意の数のファイルを開く場合:  #// 数が動的に決まる場合
            Python3:
                #// 1つの with で複数の file オブジェクトを一度に close します。enter_context の返り値は引数と同じです
                サンプル: |  #focus: ExitStack,  stack,  enter_context
                    from contextlib import ExitStack

                    filenames = ["file1.txt", "file2.txt", "file3.txt"]  # 開きたいファイル名のリスト

                    with ExitStack() as stack:
                        files = [stack.enter_context(open(fname)) for fname in filenames]
                        # ここで、files は開いたファイルオブジェクトのリストです。
                        for file in files:
                            print(file.read())  # それぞれのファイルから読み込みます
            Python2: |  #// import ExitStack の代わりに下記を定義します
                class ExitStack:
                    def __init__(self):
                        self.files = []
                    def enter_context(self, file):
                        self.files.append(file)
                        return file
                    def __enter__(self):
                        return self
                    def __exit__(self, exc_type, exc_value, traceback):
                        for file in self.files:
                            file.close()
    有無: | #keyword: Python os.path.exists
        import os
        if not os.path.exists( "C:\FolderA" ):
            os.mkdir( "C:\FolderA" )
    フォルダー:
        os.mkdirs:  #// Python 3.2 以上  #ref: https://docs.python.org/ja/3.12/library/os.html#os.makedirs
            - os.makedirs(dir_name, exist_ok=True)
            - os.makedirs(os.path.dirname(file_path), exist_ok=True)
        os.mkdir: |  #// 非推奨。レース コンディション を引き起こす可能性があるため。mkdirs を使ってください
            if not os.path.exists(dir_name):
                os.makedir(dir_name)
        親フォルダー: os.path.dirname(file_path)  #// 親フォルダーのパス
    JSON: #keyword: Python JSON,  json.loads
        基本:
            辞書との変換:
                sample.py : |
                    import json
                    dictionary = ['foo', {'bar': ('baz', None, 1.0, 2)}]
                    json_document = json.dumps(dictionary, indent=2, sort_keys=True, ensure_ascii=False)  #// dict => JSON (str)
                    json_data = json.loads(json_document)  #// JSON (str) => dict
                読む: |
                    with open(file_path, "r") as json_file:
                        loaded_data = json.load(json_file)
                保存: |
                    with open(file_path, "w") as json_file:
                        json.dump(data_to_save, json_file)
            トラブルシューティング:
                - #// TypeError: Object of type __Type__ is not JSON serializable  #keyword: is not JSON serializable in Python
                    手順: json.dumps()
                    エラー: |
                        TypeError: Object of type __Type__ is not JSON serializable
                    対処:
                        __Object__.__dict__ または public_dict を使って辞書型に変えてください
        改行コメント対応: #keyword: Python JSONC
            # (//) から始まる行をコメントとしてパースします。データとコメントには対応していません。/* */ 形式には対応していません
            サンプル: |  #focus: startswith  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/JSON/JSONC/test_jsonc.py
                import json

                json_document = ""
                with open('examples/JSON/JSONC/example.jsonc') as json_file:
                    for line in json_file:
                        if not line.strip().startswith('//'):  # Cut comment only line
                            json_document += line

                json_dict = json.loads(json_document)
                assert  json_dict['objectA']['attribute1'] == "A"
            参考: #ref: https://stackoverflow.com/questions/69021815/how-to-read-json-file-with-comments
        関数:
            json.dumps 関数: #keyword: Python json.dumps
                サンプル:  #search: Python JSON
                ensure_ascii 引数:
                    True (default): Ascii 以外は「\u6771」のようなコードにエスケープします
                    False: Ascii 以外は「東」のように文字に変換します
                    #ref: https://stackoverflow.com/questions/18337407/saving-utf-8-texts-with-json-dumps-as-utf-8-not-as-a-u-escape-sequence
        json.tool: | #// 整形のみ
                echo '{"json": "obj"}' | python -m json.tool
                {
                    "json": "obj"
                }
            #ref: https://docs.python.org/3/library/json.html#module-json.tool
        requests Response:  #search: Python requests Response
        Pydantic: #keyword: Pydantic,  Python varidation,  Python Marshaller Unmarshaller
            基本:  #ref: https://qiita.com/Tadataka_Takahashi/items/8b28f49d67d7e1d65d11
                parameters = Parameters(**parameters_dict)
            キャメル ケース から スネーク ケース に変換することもできます。:
                #ref: https://qiita.com/ninomiyt/items/a5c9252784a33f8eb464
            関連 >> @dataclass:
                parameters = Parameters(**parameters_dict)
                キャメル ケース から スネーク ケース に変換することはできないと思われる
                #search: Python @dataclass varidation
    YAML: #keyword: Python YAML
        プロジェクトへインストール:
            #// 以下のいずれか
            - pip install pyyaml
            - pipenv install pyyaml
            - poetry add pyyaml
        ファイルをロードします:
            sample.py : | #focus: yaml.safe_load
                import yaml
                with open('input.yaml') as file:  #search: Python open
                    yaml_data = yaml.safe_load(file)
                    print(yaml_data['z'])
        YAML 文字列を解析します:
            sample.py : | #focus: yaml.safe_load
                import yaml
                yaml_string = '''a:
                    b: 1
                    c: 2
                '''
                yaml_data = yaml.safe_load(yaml_string)
                print(yaml_data['z'])
        辞書をオブジェクトに変換します:  #search: Python dict to object
        値の "" を削除する#cut:"":  #keyword: (#cut:"")
            サンプル:
                削除前:
                    field: "value"  #cut:""
                削除後:
                    field: value
            コード:
                after = re.compile(r'([^ ]+):( +)\"(.*)\" +#cut:\"\"( |\n|$)').sub(r'\1:\2\3\4', before)
            プロジェクト:
                #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/YAML/cut_quotation.py#re.compile
    CSV: #keyword: Python CSV
        #ref: ${programming}/スクリプト/Python.svg#CSV_file
        CSV をパースします:
            CSV が文字列に入っている場合:
                簡易版: |  #// ダブルクォートなどがない場合
                    [column.strip() for column in csv_text.split(",")]
                厳密版: |  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/CSV/CSV.py
                    import csv
                    def parse_csv_line(csv_line: str) -> List[str]:
                        values: List[str] = []
                        buffer = None
                        try:
                            buffer = io.StringIO()
                            buffer.write(csv_line)
                            buffer.seek(0)

                            csv_reader = csv.reader(buffer, delimiter=",", doublequote=True, skipinitialspace=True)
                            values = next(csv_reader)
                        finally:
                            if buffer:
                                buffer.close()
                        return values
            CSV がファイルに入っている場合:
                Python3: |
                    with open('data/src/example.csv') as file:
                        sample_csv = [row for row in csv.reader(file)]          #// こちらか...
                        sample_csv = {row[0]: row for row in csv.reader(file)}  #// こちらの片方だけ実行すること
                Pytohn2, Python3 両対応: |
                    import codecs
                    import platform
                    import sys
                    if platform.python_version()[0:2] == '2.':
                        reload(sys)
                        sys.setdefaultencoding('utf-8')
                    def main():
                        with codecs.open('example.csv', "r", 'shift_jis') as file:
                            sample_csv = [row for row in csv.reader(file)]          #// こちらか...
                            sample_csv = {row[0]: row for row in csv.reader(file)}  #// こちらの片方だけ実行すること
        配列を CSV 形式 の文字列にする場合: |  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/CSV/CSV.py
            def make_csv_line(columns: List[Any]) -> str:
                output = io.StringIO()
                writer = csv.writer(output, lineterminator='')
                writer.writerow(columns)
                return output.getvalue().replace(',', ', ')
        文字コード, エンコード: #keyword: Python character encoding  #ref: https://docs.python.org/3/library/codecs.html#standard-encodings
            utf_8, euc_jp, shift_jis
    pickle: #keyword: Python pickle  #// バイナリにシリアライズします
        注意: 署名をしないと通信経路の途中で悪意のあるコードが埋め込まれデコード時に実行される可能性があります。
        公式: #ref: https://docs.python.org/ja/3/library/pickle.html
        基本: | #// エンコードとデコード
            binary = pickle.dumps({1: "Apple", 2: "Orange"})  #// binary は bytes 型
            data = pickle.loads(binary)
    Jinja2:  #keyword: Jinja2, j2
        公式: #ref: https://jinja.palletsprojects.com/en/3.0.x/templates/
        手順, サンプル:
            テンプレートを使います:
                テンプレートが文字列の場合:
                    （プロジェクト）: #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/jinja2/jinja2_from_file.py
                    テンプレートの文法:  #search: Jinja2 template
                テンプレートがファイルの場合:
                    （プロジェクト）: #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/jinja2/jinja2_from_string.py
                    プロジェクトを作ります:  #search: install Python unittest VSCode
                    サンプルコードをプロジェクトに追加します:
                        __Project__/main.py : |
                            from jinja2 import Template, Environment, FileSystemLoader
                            
                            def main():
                                env = Environment(loader=FileSystemLoader('.'))
                                template = env.get_template('template.txt.j2')
                                parameters = {
                                    "animal": "熊",
                                }
                            
                                rendered = template.render(parameters)
                                print(str(rendered))
                        __Project__/template.txt.j2 : |
                            {{ animal }} 出没注意
                    実行します:  #search: install Python unittest VSCode
        文法:
            テンプレート, 式: #keyword: Jinja2 template
                処理と表示:
                    template.txt.j2 : |
                        {% set text='aaaa' %}  {# 変数に代入します #}
                        {{ text }}
                    出力:
                        aaaa
                    解説:
                        - '{%  %} で囲まれた部分は、処理です'
                        - '{{ }} で囲まれた部分は、表示内容です。print の引数と同じく式を指定できます'
                        - '{# #} で囲まれた部分は、コメントです'
                    リテラル: https://jinja.palletsprojects.com/en/3.0.x/templates/#literals
                    公式: https://jinja.palletsprojects.com/en/3.0.x/templates/#synopsis
                プロパティと式:
                    プロパティ:
                        - "{{ foo.bar }}"
                        - "{{ foo['bar'] }}"
                        - "{{ object[att] }}"
                        - "{{ object|attr(att) }}"
                        #ref: https://stackoverflow.com/questions/35407008/using-getattr-in-jinja2-gives-me-an-error-jinja2-exceptions-undefinederror-ge
                    プロパティが無いとき: #keyword: Jinja2 default  #focus: default
                        - "{{ foo.bar | default('') }}"  #// default フィルター が無いと nil になります
                制御構文:
                    if: |  #keyword: Jinja2 if
                        {# if文のsample #}
                        {% if x > 0 %}
                            xは0より大きいです
                        {% elif x == 0 %}
                            xは0です
                        {% else %}
                            xは0より小さいです
                        {% endif %}
                        {% if collection|length > 0 %}
                            配列の要素数で判定します
                        {% endif %}
                    for: |  #keyword: Jinja2 for
                        {# for文のsample #}
                        商品一覧
                        {% for item in items %}
                        ・　{{ item }}
                        {% endfor %}
                    macro: |
                        {% macro render_dialog(title, class='dialog') -%}
                            <div class="{{ class }}">
                                <h2>{{ title }}</h2>
                                <div class="contents">
                                    {{ caller() }}
                                </div>
                            </div>
                        {%- endmacro %}

                        {% call render_dialog('Hello World') %}
                            This is a simple dialog rendered by using a macro and
                            a call block.
                        {% endcall %}
                    include: |
                        {% include 'header.html' %}
                            Body
                        {% include 'footer.html' %}
                    load:
                        サンプル: |
                            {% load code %}  {# ./code.py を実行します #}
                        公式: 資料なし https://jinja.palletsprojects.com/en/3.0.x/templates/
                        jinja2 で実行すると下記のエラーになります:
                            エラーメッセージ: |
                                jinja2.exceptions.TemplateSyntaxError: Encountered unknown tag 'load'.
                            未確認: Django が必要か？  カスタム テンプレート タグ  #ref: ${programming}/スクリプト/Python.svg#django_custom_template_tag
                        変換ツール: |
                            from django.template.loader import get_template
                            body_template = get_template(template)
                            body = body_template.render({
                                'inquiry': inquiry,
                フィルター:
                    List of Builtin Filters: https://jinja.palletsprojects.com/en/3.0.x/templates/#list-of-builtin-filters
            フィルター: #keyword: Jinja2 filter  #ref: https://jinja.palletsprojects.com/en/3.0.x/templates/#builtin-filters
                書式:
                    - __Argument1__ | __Filter__   #// ❗括弧を書かないことに注意
                    - __Argument1__ | __Filter__(__Argument2__)
                定義済みフィルター:
                    カテゴリー別:  #// フィルター名は Python と同じです
                        #// ここに書かれていないものの次は groupby 。 順序は横が先。最も右を調べたら次の行へ（abc順ではない） #ref: https://jinja.palletsprojects.com/en/3.0.x/templates/#builtin-filters
                        コレクション: [ first, list, map ]
                        オブジェクト: [ attr ]
                        文字列: [ lower, capitalize, trim, format ]
                        JSON, HTML: [ tojson, forceescape, safe ]
                        数値: [ abs, float, round, max ]
                        エラー: [ default ]
                        （未調査）: [ batch, select, truncate ]
                        Jinja2 単体では使えないフィルター:
                            Ansible の カスタム フィルター:  #search: Ansible filter
                    一覧:  #glossary: Jinja2 filter
                        #// abc 順
                        capitalize:  #ref: https://jinja.palletsprojects.com/en/3.0.x/templates/#jinja-filters.capitalize
                            先頭文字を大文字、それ以外を小文字にします
                        default:  #ref: https://jinja.palletsprojects.com/en/3.0.x/templates/#jinja-filters.first
                            処理内容: 偽と評価される値が入力された、または 例外が発生したら __DefaultValue__ を返します
                            書式:
                                - __Expression__ | default(__DefaultValue__)
                                - __Expression__ | default(__DefaultValue__, True)  #// 真と評価される値が入力されたら __DefaultValue__ を返します
                        first:  #ref: https://jinja.palletsprojects.com/en/3.0.x/templates/#jinja-filters.first
                            処理内容: 最初の要素を返します
                            書式: __Iteratable__ | first
                        format:
                            サンプル コード: |
                                "%s, %s!"|format(greeting, name)
                            出力例:
                                Hello, World!
                        list:  #ref: https://jinja.palletsprojects.com/en/3.0.x/templates/#jinja-filters.list
                            処理内容: 配列に変換します
                            書式: __Item__ | list
                        safe:  #ref: https://jinja.palletsprojects.com/en/3.0.x/templates/#jinja-filters.safe
                            処理内容: HTML の文字列としてエスケープされないようにします。ただし XSS 攻撃 に注意してください
                関連:
                    Ansible で使えるフィルター: #search: Ansible filter
        関連 >> JavaScript の Jinja2:  #search: Handlebars
    google diff-match-patch: #keyword: google-diff-match-patch  Python
        言語共通部分:  #search: google-diff-match-patch
        公式:  #ref: https://github.com/google/diff-match-patch
            説明:  #ref: https://github.com/google/diff-match-patch/wiki/API
            テスト コード:  #ref: https://github.com/google/diff-match-patch/blob/master/python3/tests/diff_match_patch_test.py
        手順:
            インストール:
                pip install diff-match-patch  #ref: https://pypi.org/project/diff-match-patch/
            サンプル:
                diff:  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/diff/1_diff.py
                patch_make:  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/diff/2a_patch_make.py
                patch_apply:  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/diff/2b_patch_apply.py
                    apply_line_patch:  #// 行単位パッチ  #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/diff/2b_patch_apply.py#def apply_line_patch
                    関連 >> 行単位パッチのテキストを作ります:
                        #search: google-diff-match-patch YAML
                        #ref: ${GitHub}/MyPrivateCode/Python/try_Python/examples/diff/2b_patch_apply.py#Patch_Margin
                    行単位パッチの対応状況:  #ref: https://github.com/google/diff-match-patch/issues/91
                    デバッグ時に使えるウォッチ: |
                        [ord(x[1]) for x in index_patch[0].diffs]
                        [ord(x) for x in list(old_line_indices)]
                        [ord(x) for x in list(applied_indices)]
    エクセル ファイル: #keyword: Python Excel file
        openpyxl: #keyword:  #ref: https://myafu-python.com/syntax/library/openpyxl/
            インストール:
                pipenv install openpyxl
            サンプル: |  #search: try_pipenv
                import openpyxl as xl

                def main():
                    load()
                    change_sheets()
                    change_cells()

                def load():
                    workbook = xl.load_workbook('./Book1.xlsx')  #// 新規作成した空白のブック
                    print(workbook.sheetnames)  #// ['Sheet1']
                    print(workbook.worksheets)  #// [<Worksheet "Sheet1">]

                def change_sheets():  #keyword: openpyxl change_sheets
                    workbook = xl.load_workbook('./Book1.xlsx')
                    workbook.create_sheet(title='New1')
                    workbook.create_sheet(title='New2', index=1)
                    print(workbook.sheetnames)  #// ['Sheet1', 'New2', 'New1']
                    workbook.save('_Book1_change_sheets_1.xlsx')

                    new_sheet_2 = workbook['New2']
                    new_sheet_2_copy = workbook.copy_worksheet(new_sheet_2)
                    print(workbook.sheetnames)  #// ['Sheet1', 'New2', 'New1', 'New2 Copy']

                    new_sheet_2 = workbook['New2']
                    workbook.remove(new_sheet_2)
                    print(workbook.sheetnames)  #// ['Sheet1', 'New1', 'New2 Copy']

                    new_sheet_1 = workbook['New1']
                    new_sheet_1.title = 'New (1)'
                    print(workbook.sheetnames)  #// ['Sheet1', 'New (1)', 'New2 Copy']

                def change_cells():  #keyword: openpyxl change_cells
                    workbook = xl.load_workbook('./Book1.xlsx')
                    sheet = workbook['Sheet1']

                    #// set
                    sheet['A1'].value = 123
                    sheet['A2'].value = 'abc'
                    workbook.save('_Book1_change_cells_1.xlsx')

                    #// get
                    a1 = sheet['A1']
                    a2 = sheet['A2']
                    print(a1.value)  #// 123
                    print(a2.value)  #// 'abc'
                    print(a2.coordinate)  #// 'A2'
                    print(a2.row)  #// 2
                    print(a2.column_letter)  #// 'A'

                    #// range
                    workbook = xl.load_workbook('./Book1.xlsx')
                    sheet = workbook['Sheet1']
                    rows = sheet["C2":"F4"]
                    for row in rows:
                        for cell in row:
                            cell.value = 1
                    rows = sheet["C5":"F5"]
                    for row in rows:
                        for cell in row:
                            cell.value = f'=SUM({cell.column_letter}2:{cell.column_letter}4)'

                    #// number_format
                    sheet["C2"].number_format = '0.000'
                    workbook.save('_Book1_change_cells_2.xlsx')

                if __name__ == '__main__':
                    main()
            シート: #search: openpyxl change_sheets
            セル: #search: openpyxl change_cells
            参考:
                Excelファイルの操作（openpyxl）: #ref: https://myafu-python.com/syntax/library/openpyxl/
                Excelファイルの中でjinja2テンプレートを使う: #ref: https://qiita.com/kokumura/items/18e55ac364193ab42c74
環境変数: #keyword: Python environment variable
    環境変数:
        PYTHONPATH:  #search: PYTHONPATH  #// 仮想環境の位置
        PYENV_ROOT:
    設定場所:
        .bashrc:
        .env:
        .envrc:
ネットワーク: #keyword: Python network
    HTTP 通信 >> Django REST framework:  #search: Django REST framework  #// サーバー
    HTTP 通信 >> HTTPSConnection: #keyword: Python HTTPSConnection  #// クライアント
        Basic 認証:  #keyword: Python basic authentication
            #ref: https://stackoverflow.com/questions/6999565/python-https-get-with-basic-authentication
            自己署名証明書: import ssl   #ref: https://stackoverflow.com/questions/5319430/how-do-i-have-python-httplib-accept-untrusted-certs
    HTTP 通信 >> requests: #keyword: Python requests,  Python Session,  Python HTTP client  #// クライアント
        公式: #ref: https://docs.python-requests.org/en/latest/
        サンプル:
            VSCode プロジェクト: #ref: ${GitHub}/MyPrivateCode/Python/try_Python_requests
            requests.get:  #search: Python requests or session  #search: Python requests .get or .request
                response = requests.get('https://reqbin.com/echo')
                print(response.content)
                print(response.status_code)
            session.get:   #search: Python requests or session  #search: Python requests .get or .request
                session = requests.session()
                response = session.get("http://127.0.0.1/admin/login/")
            session.headers: |
                session = requests.Session()
                session.headers.update(
                    {'token': token}
                )
            session.request: #keyword: Python request session.request  #// session.get などから呼ばれます  #search: Python requests .get or .request
                method:  #// メソッド名
                    GET:
                        session = requests.Session()
                        session.request('GET', url, param=param)
                    POST:
                        session = requests.Session()
                        session.request('POST', url, json=json)
                    抽象:
                        session = requests.Session()
                        session.request(method, url, *args, **kwargs)
                url:  #// URL
                params:  #// GET メソッドの クエリー パラメーター
                    辞書型: |  #// GET https://____/____?q=python_requests&page=1&limit=10
                        session.request('GET', 'https://____/____', params={
                            'q': 'python_requests',
                            'page': 1,
                            'limit': 10})
                data:  #// POST メソッドなどの body
                    辞書型: |  #// POST https://____/____   body: {"q":"python_requests","page":1,"limit":10}
                        session.request('GET', 'https://____/____', params={
                            'q': 'python_requests',
                            'page': 1,
                            'limit': 10})
                    JSON 文字列型: #search:
                        data 引数ではなく json 引数に指定します
                json: #keyword: Python request json  #// 指定すると自動的にContent-Typeも設定されます
                    JSON 文字列  #// サニタイジングは行われない？
                その他: |
                    headers=None,             # HTTPヘッダー
                    cookies=None,             # クッキー
                    files=None,               # ファイルアップロード
                    auth=None,                # 認証情報
                    timeout=None,             # タイムアウト
                    allow_redirects=True,     # リダイレクト許可
                    proxies=None,             # プロキシ設定
                    hooks=None,               # イベントフック
                    stream=False,             # ストリーミング
                    verify=True,              # SSL証明書検証
                    cert=None,                # クライアント証明書
                    json=None                 # JSONデータ
            proxies: |
                proxies = {
                    'http': 'http://proxy_host:8080',
                    'https': 'http://proxy_host:8080',
                }
                requests.get('http://127.0.0.1/admin/login/', proxies=proxies)
        リクエスト, メソッドの仕様:
            requests.get と session.get の違い: #keyword: Python requests or session
                requests:
                    毎回新しい接続をします
                    状態を持たないため明快です
                session:
                    同じセッションを使います
                    クッキー, ヘッダー が保持されます
                    リクエストを何度も行うと処理効率が高いです
                #// その他は同じです
            .get 等と .request の違い: #keyword: Python requests .get or .request
                .get, .put, .post, .delete:
                    内部で .request を呼び出します
                .request:
                    メソッド名を引数に指定します
                #// その他は同じです
            引数:  #search: Python request session.request
        レスポンス:
            Response 型: #keyword: Python requests Response
                .json(): JSON 形式のレスポンスが入った Response 型オブジェクトを、辞書に変換します  #search: Python dict __str__
                .raise_for_status:  #// レスポンスの HTTP ステータス が 200 番台以外のときに例外を発生させます
                    必要性:  #ref: https://stackoverflow.com/questions/61463224/when-to-use-raise-for-status-vs-status-code-testing
        コールツリー:
            get:  #ref: .venv/lib/python3.7/site-packages/requests/sessions.py#def get
                # def get(self, url, **kwargs):
                #    return self.request('GET', url, **kwargs)
                request:
                    # resp = self.send(prep, **send_kwargs)
                    send:  #ref: .venv/lib/python3.7/site-packages/requests/sessions.py#def send
                        # def send(self, request, **kwargs):
        HTTPS:
            サンプル >> .crt ファイルがある場合:  #ref: https://kumano-te.com/activities/enable-python-requests-to-self-signed-ssl-host
                import requests

                url = "https://my-self-signed-host.internal"
                cafile = "/usr/share/ca-certificates/my-self-signed-ca.crt"
                response = requests.get(url=url, verify=cafile)
            自己署名証明書の HTTPS サーバーの場合: #keyword: Python requests self signed certificate
                self.__session.request(____, verify=False)
        関連 >> Basic 認証:  #search: Python basic authentication
    HTTP 通信 >> WSGI: #keyword: WSGI  #// サーバー
        wsgiref:  #// wsgiref (WSGI ref) は、WSGI アプリケーション を CGI として動作させるためのモジュールの１つ
            サンプル 関数: | #keyword: wsgiref code  #focus: start_response,  application
                #// 未確認
                def application(environ, start_response):
                    start_response('200 OK', [('Content-type', 'text/plain')])
                    return 'Hello, world'

                from wsgiref import simple_server
                if __name__ == '__main__':
                    server = simple_server.make_server('', 8080, application)
                    server.serve_forever()
            関連 >> .wsgi:  #search: dot WSGI  #// 拡張子が .wsgi の Python ソース ファイル
            サンプル クラス: |  #focus: method
                #// 未確認
                class Application:
                    def __call__(self, environ, start_response):
                        method = environ['REQUEST_METHOD']

                        if method == 'GET':
                            return self.listMessages(environ, start_response)
                        else:
                            start_response('501 NotImplemented', [('Content-type', 'text/plain')])
                            return 'Not Implemented'
        ミドルウェア: #keyword: WSGI middleware
            概要:
                - WSGI アプリケーションより前で HTTP リクエストを受け取り、WSGI アプリケーションに HTTP リクエストを転送します。
                    #ref: https://gihyo.jp/dev/feature/01/wsgi/0003
                - Django ミドルウェア と WSGI ミドルウェアは別のものです
                    #ref: https://thinkami.hatenablog.com/entry/2016/12/13/061856
            サンプル 機能:
                - リクエストURLに応じたアプリケーションのマッピング
                - ユーザ認証
                - レスポンスヘッダへの情報追加
                - アプリケーションで生成された動的コンテンツのキャッシュ
            サンプル コード: |
                class Nop(object):
                    def __init__(self, application):
                        self.application = application
                    def __call__(self, environ, start_response):
                        #// ここで処理を行います
                        return self.application(environ, start_response)
                application = Nop(application)
        Apache mod_wsgi: #keyword:  #// mod_wsgi は Apache 専用。Apache Web サーバー
            #ref: https://www.yoheim.net/blog.php?q=20170206
            wsgi.conf: |  #// Apache の設定ファイルのうち WSGI に関する設定
                LoadModule wsgi_module /usr/local/lib/python3.6/site-packages/mod_wsgi/server/mod_wsgi-py36.cpython-36m-x86_64-linux-gnu.so

                WSGIDaemonProcess myapp user=hoge group=hoge
                WSGIProcessGroup myapp
                WSGISocketPrefix /var/run/wsgi
                WSGIScriptAlias /app /var/www/app/app.wsgi

                <Directory /var/www/app/>

                Options ExecCGI MultiViews Indexes
                MultiViewsMatch Handlers

                AddHandler wsgi-script .py
                AddHandler wsgi-script .wsgi

                DirectoryIndex index.html index.py app.wsgi

                Order allow,deny
                Allow from all

                </Directory>
            app.wsgi: |  #keyword: dot WSGI,  WSGI アプリケーション
                def application(environ, start_response):
                    start_response('200 OK', [('Content-type', 'text/plain')])
                    return [b'Hello, world']
            関連 >> wsgiref .py: #search: wsgiref code
        uWSGI: #keyword:
        ASGI インタフェース: #keyword: ASGI  #ref: https://asgi.readthedocs.io/en/latest/  #ref: https://en.wikipedia.org/wiki/Asynchronous_Server_Gateway_Interface
            概要: Asynchronous Server Gateway Interface。WSGI の後方互換。非同期？ 実装例は Uvicorn
            サンプル: |  #ref: https://note.com/keyem/n/nc6d879ed59a4
                async def application(scope, receive, send):
                    await send({
                        "type": "http.response.start",
                        "status": 200,
                        "headers": [
                            [b"content-type", b"text/plain"],
                        ]
                    })
                    
                    await send({
                        "type": "http.response.body",
                        "body": b"Hello, World",
                    })
                    

                # scopeの例
                scope = {
                    "type": "http",
                    "method": "POST",
                    "path": "/",
                    "query_string": b"a=b",
                }

                # receiveの例
                receive = {
                    "type": "http.request.body",
                    "body": b'{"example": "JSON data"}',
                    "more_body": False,
                }
        Gunicorn: #keyword:  #// Gunicorn は Web サーバー です。gnicorn ではありません。GreenUnicorn の略称。発音は「グニコーン」または「ジーユニコーン」  #ref: https://gunicorn.org/
            概要:
                Django の python manage.py runserver より速い
                    #ref: https://blog.hirokiky.org/entry/2018/10/06/151830
            手順: #keyword: Gunicorn tutorial
                #ref: https://blog.hirokiky.org/entry/2018/10/06/151830
                CentOS7 の VM を作ります:
                    #search: Vagrant CentOS7
                    #// メモリーは 1024MB なら動きます。256MB では動きません
                Gunicorn を VM にインストールします:
                    sudo yum install python3 -y
                    sudo pip3 install gunicorn
                一時的に Web サーバーを起動してみます:
                    vi wsgi_example.py : |
                        def application(environ, start_response):
                            start_response('200 OK', [('Content-type', 'text/plain')])
                            return [b'Hello, world']
                    Web サーバーを起動します:
                        新しいシェル:
                            gunicorn wsgi_example:application
                    ブラウザーで開きます:
                        http://127.0.0.1:8000
                            #// gunicorn を起動したときのメッセージに表示される URL です
                    Web サーバーを終了します:
                        gunicorn を起動したシェル:
                            Ctrl + C キー
                Web サーバーをサービスとして登録＆起動します:  #keyword: Gunicorn systemd
                    sudo vi /usr/local/bin/wsgi_example.py : |
                        def application(environ, start_response):
                            start_response('200 OK', [('Content-type', 'text/plain')])
                            return [b'Hello, world']
                    Web サーバーを起動してみます:
                        新しいシェル:
                            gunicorn  wsgi_example:application  --chdir /usr/local/bin/
                        ブラウザーで開きます:
                            http://127.0.0.1:8000
                                #// gunicorn を起動したときのメッセージに表示される URL です
                        Web サーバーを終了します:
                            gunicorn を起動したシェル:
                                - Ctrl + C キー
                                - シェルを閉じます
                    gunicorn のフルパスをメモします:
                        which gunicorn
                        #// /usr/local/bin/gunicorn
                    Unit ファイルを作ります:  #search: systemd unit file tutorial
                        sudo vi /etc/systemd/system/gunicorn-example.service : |  #focus: ExecStart, Description
                            [Unit]
                            Description=gunicorn-example
                            After=network.service

                            [Service]
                            Type=simple
                            ExecStart=/usr/local/bin/gunicorn  wsgi_example:application  --chdir /usr/local/bin/
                            ExecStop=/bin/kill -WINCH ${MAINPID}
                            Restart=always

                            [Install]
                            WantedBy=multi-user.target
                    サービスを起動します: |
                        systemctl status gunicorn-example.service
                        sudo systemctl start gunicorn-example.service
                        systemctl status gunicorn-example.service
                        sudo tail /var/log/messages
                WSGI アプリケーションをサーバーでデバッグします: #keyword: Gunicorn debug
                    #// サービスとして実行するプログラムでは、未確認。例：Can't connect to /run/__Service__/socket エラーになるなど。 debugpy でリモートデバッグするか？
                    デバッガーなしで動作確認します:  #// 起動実績があるコードを使ってデバッガーなしで起動できることを確認します:
                        #search: Gunicorn systemd
                    デバッグするコードを設定します:
                        sudo vi /usr/local/bin/wsgi_example.py : |
                            import os
                            import pdb; pdb.set_trace()

                            def application(environ, start_response):
                                start_response('200 OK', [('Content-type', 'text/plain')])
                                if 'ENV_A' in os.environ:
                                    body = f"ENV_A: {os.environ['ENV_A']}"
                                    return [bytes(body, encoding='utf-8')]
                                else:
                                    return [b'Hello, world']
                    デバッガーなしで起動して再現してみます:
                    デバッグ用の設定ファイルを作ります:  #keyword: gunicorn.conf.py example
                        sudo vi /usr/local/bin/gunicorn.conf.py : |
                            gunicorn_logfile = "/dev/null"
                            gunicorn_loglevel = "error"
                            debug = True
                            timeout = 900000
                            workers = 1
                            worker_class = "sync"
                    設定ファイルを指定して Web サーバーを起動します:
                        コマンド:
                            /usr/local/bin/gunicorn  wsgi_example:application  --chdir /usr/local/bin/  --config /usr/local/bin/gunicorn.conf.py
                            #// PDB のプロンプトが表示されて、デバッグできます
                        注目すべき ユニット ファイル の項目:
                            ExecStart, EnvironmentFile, WorkingDirectory
            コマンド:
                基本:
                    gunicorn wsgi:application
                        #template__: gunicorn __PythonFileBaseName__:__WSGI_Application_ObjectName__
                        #// wsgi.py ファイルの中で定義されている application という名前のオブジェクト（WSGI アプリケーション）を
                        #// 使って Web サーバーを起動します
                    #search: Gunicorn tutorial
                Flask + Gunicorn:  #ref: https://flask.palletsprojects.com/en/1.0.x/deploying/wsgi-standalone/
                    コマンド:
                        gunicorn myapp:app
                    myapp.py:
                        app = Flask(...)
                Django + Gunicorn:
                    コマンド:
                        gunicorn __ProjectName__.wsgi
                            #// __ProjectName__/wsgi.py の application オブジェクト
                            #// wsgi.py は自動的に作られます
                    サンプル:
                        gunicorn  --env DJANGO_SETTINGS_MODULE=myproject.settings.production  myproject.wsgi
                            #// DJANGO_SETTINGS_MODULE 環境変数を指定しています
            設定ファイル:
                サンプル: #search: gunicorn.conf.py example
                ファイルの指定: #ref: https://docs.gunicorn.org/en/stable/settings.html#config-file
                構文: #ref: https://docs.gunicorn.org/en/stable/configure.html#configuration-file
    HTTP 通信 >> XML-RPC:  #keyword: Python XML-RPC
        サンプル プロジェクト:  #ref: ${GitHub}/MyPrivateCode/Python/try_Python_XML_RPC
            client: #ref: ${GitHub}/MyPrivateCode/Python/try_Python_XML_RPC/1_XML_RPC/client.py
            server: #ref: ${GitHub}/MyPrivateCode/Python/try_Python_XML_RPC/1_XML_RPC/server.py
        クライアント: #keyword: xmlrpc.client.ServerProxy
            公式: #ref: https://docs.python.org/ja/3/library/xmlrpc.client.html
            開きます:
                自己署名証明書の HTTPS サーバーの場合 (RPC):
                    example.py: #keyword: _create_unverified_context
                        import xmlrpc.client
                        import ssl
                        ssl._create_default_https_context = ssl._create_unverified_context
                        server = xmlrpc.client.ServerProxy('https://localhost:8443/RPC')  #// open
        サーバー:  #// SimpleXMLRPCServer, SimpleXMLRPCDispatcher
            SimpleXMLRPCServer: #keyword:  #// 内部に メッセージ ループ を持ちます
                公式: #ref: https://docs.python.org/ja/3/library/xmlrpc.server.html#simplexmlrpcserver-example
                サンプル: |
                    from xmlrpc.server import SimpleXMLRPCServer  #// 古い Python では from SimpleXMLRPCServer import SimpleXMLRPCServer
                    import os

                    server = SimpleXMLRPCServer(('localhost', 9000), allow_none=True)

                    server.register_function(os.listdir, 'dir.list')  // 代わりに register_instance も使えます
                    server.register_function(os.mkdir, 'dir.create')
                    server.register_function(os.rmdir, 'dir.remove')
                        #ref: ${GitHub}/MyPrivateCode/Python/try_Python_XML_RPC/1_XML_RPC/server.py#register_function
                        #ref: ${GitHub}/MyPrivateCode/Python/try_Python_XML_RPC/1_XML_RPC/server.py#register_instance  #keyword: SimpleXMLRPCServer  register_instance

                    try:
                        print 'Use Control-C to exit'
                        server.serve_forever()
                    except KeyboardInterrupt:
                        print 'Exiting'
                エラー処理: #keyword: SimpleXMLRPCServer fault
                    _: XML-RPCサーバエラーが発生すると Fault インスタンスを送出し、
                        HTTP/HTTPSトランスポート層でエラーが発生した場合には ProtocolError を送出します。
                    #// 公式   #ref: https://docs.python.org/ja/3/library/xmlrpc.client.html#fault-objects
                    XML のサンプル:  #// サーバーで例外が発生したときのレスポンスの XML のサンプル
                        <?xml version='1.0'?>
                        <methodResponse>
                            <fault>
                                <value>
                                    <struct>
                                        <member>
                                            <name>faultCode</name>
                                            <value>
                                                <int>1</int>
                                            </value>
                                        </member>
                                        <member>
                                            <name>faultString</name>
                                            <value>
                                                <string>&lt;class 'ZeroDivisionError'&gt;:division by zero</string>
                                            </value>
                                        </member>
                                    </struct>
                                </value>
                            </fault>
                        </methodResponse>
                    コール ツリー: #keyword: SimpleXMLRPCServer exception call tree
                        #// Python 3.9
                        do_POST:  #ref: python39/lib/xmlrpc/server.py
                            # def do_POST(self):
                            #     response = self.server._marshaled_dispatch(
                            _marshaled_dispatch:
                                # def _marshaled_dispatch(self, data, dispatch_method = None, path = None):
                                #     try:
                                #         response = self._dispatch(method, params)
                                _dispatch:
                                    # def _dispatch(self, method, params):
                                    #     return func(*params)
                                    (RPC の応答関数):
                                        raise ValueError("debug")
                                #     except Fault as fault:
                                #         response = dumps(fault, allow_none=self.allow_none,
                                #     except:
                                #         response = dumps(
                                #             Fault(1, "%s:%s" % (exc_type, exc_value)),
                                response:  #keyword: Python XML-RPC error response example  #// 標準 Python XML-RPC が例外をキャッチしたときのレスポンス
                                    "<?xml version='1.0'?>
                                    <methodResponse>
                                        <fault><value><struct>
                                            <member>
                                                <name>faultCode</name>
                                                <value><int>1</int></value>
                                            </member>
                                            <member>
                                                <name>faultString</name>
                                                <value><string>&lt;class 'ValueError'&gt;:debug</string></value>
                                            </member>
                                        </struct></value></fault>
                                    </methodResponse>"
                    関連 >> マーシャリング:  #search: Python Marshaller Unmarshaller
            SimpleXMLRPCDispatcher: #keyword:  #// 内部に メッセージ ループ を持ちません
                サンプル:
                    register_function:  #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/REST_and_RPC/tutorial/rpc_server.py#SimpleXMLRPCDispatcher(
                        # def main():
                        #     dispatcher = SimpleXMLRPCDispatcher(allow_none=False, encoding=None)
                        #     dispatcher.register_function(multiply)
                        # def multiply(a, b):
                        #     return a * b
                    register_instance:
                        #keyword: SimpleXMLRPCDispatcher  register_instance
                        #search: SimpleXMLRPCServer  register_instance
                        SimpleXMLRPCServer と同じ:  #ref: ${GitHub}/MyPrivateCode/Python/try_Python_XML_RPC/1_XML_RPC/server.py#register_instance
                    _marshaled_dispatch:  #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/REST_and_RPC/tutorial/rpc_server.py#_marshaled_dispatch
                テスト: | #keyword: SimpleXMLRPCDispatcher test
                    from django.test import SimpleTestCase
                    import xmlrpc.client

                    class FirstTest(SimpleTestCase):

                        def test_rpc_api(self):
                            body = xmlrpc.client.dumps(methodname='multiply', params=(3,5,))
                                #// params の要素が 1つの場合、末尾にコンマが必要です。タプルにする必要があるため
                            response = self.client.generic('POST', '/RPC', data=body, content_type='text/xml')
                            self.assertEqual(response.status_code, 200)
            SimpleXMLRPCRequestHandler:
        XML 変換, マーシャリング: #keyword: Python XML Marshaller Unmarshaller
            概要: Python 標準の XML-RPC は、Unmarshaller（サーバーが受信するとき）は <i4>, <int> などに対応しているが、
                Marshaller は <int> にしか対応していない
            xmlrpc.client.dumps:  #// タプル から XML に変換します
                import xmlrpc.client
                xmlrpc.client.dumps((1,))  // コンマが必要です。無いとタプルにならないため
                #ref: https://www.programcreek.com/python/example/84212/xmlrpc.client.dumps
            class Unmarshaller: |  #// python39\lib\xmlrpc\client.py
                dispatch["i4"] = end_int
            class Marshaller: |  #// python39\lib\xmlrpc\client.py
                def dump_long(self, value, write):
                    write("<value><int>")
                    write(str(int(value)))
                    write("</int></value>\n")
                dispatch[int] = dump_long
            関連 >> 辞書とのマーシャリング:  #search: Python Marshaller Unmarshaller
        XML-RPC 通信の様子を表示します: #keyword: capture XML-RPC Python client
            xmlrpc.client.ServerProxy のオプションを使う場合:
                サンプル プロジェクト:  #ref: ${GitHub}/MyPrivateCode/Python/try_Python_XML_RPC
                verbose=True を指定します:  #ref: ${GitHub}/MyPrivateCode/Python/try_Python_XML_RPC/1_XML_RPC/client.py#verbose
                    server = xmlrpc.client.ServerProxy('https://localhost:8443/RPC', verbose=True)
                    print(server.pow(2,3)) 
                出力例: |  #focus: send, reply, body
                    send: b'POST /RPC2 HTTP/1.1\r\nHost: localhost:8000\r\nAccept-Encoding: gzip\r\nContent-Type: text/xml\r\nUser-Agent: Python-xmlrpc/3.9\r\nContent-Length: 187\r\n\r\n'
                    send: b"<?xml version='1.0'?>\n<methodCall>\n<methodName>pow</methodName>\n<params>\n<param>\n<value><int>2</int></value>\n</param>\n<param>\n<value><int>3</int></value>\n</param>\n</params>\n</methodCall>\n"
                    reply: 'HTTP/1.0 200 OK\r\n'
                    header: Server: BaseHTTP/0.6 Python/3.9.5
                    header: Date: Wed, 08 Jun 2022 05:40:34 GMT
                    header: Content-type: text/xml
                    header: Content-length: 121
                    body: b"<?xml version='1.0'?>\n<methodResponse>\n<params>\n<param>\n<value><int>8</int></value>\n</param>\n</params>\n</methodResponse>\n"
                    8
            キャプチャーする場合:  #// OS から通信データを横取りします
                #search: HTTP capture
            参考:
                    StackOverflow: #ref: https://stackoverflow.com/questions/2390772/how-to-debug-apache-xml-rpc-client-with-python-server
    HTTPS:
        クライアント:
            自己署名証明書の HTTPS サーバーの場合: #keyword: Python self signed certificate
                XML-RPC:  #search: _create_unverified_context
                requests:  #search: Python requests self signed certificate
    SSH: #keyword: Python SSH
        Paramiko SSHClient: #keyword:
            サンプル:
                from paramiko import SSHClient
                client = SSHClient()
                client.set_missing_host_key_policy(AutoAddPolicy())
                client.connect(
            SSHClient:
                connect:  #ref: https://docs.paramiko.org/en/stable/api/client.html  >>  connect(hostname,
            SFTP: #keyword: Paramiko SFTP  #ref: https://docs.paramiko.org/en/stable/api/sftp.html
                SSHClient.open_sftp で SFTP のインスタンスを取得します
            モック: #keyword: Python SSH mock
                方法A: |  #// 下記はモックのデタッチに対応していませんが、アタッチには使えます
                    from paramiko import SSHClient
                    from unittest import mock
                    import logging
                    logger = logging.getLogger(__name__)

                    def  enable_ssh_mock():
                        mock.patch.object(SSHClient, 'connect', new=SSHClientMock.connect).__enter__()
                        mock.patch.object(SSHClient, 'close', new=SSHClientMock.close).__enter__()
                        mock.patch.object(SSHClient, 'exec_command', new=SSHClientMock.exec_command).__enter__()
                        mock.patch.object(SSHClient, 'open_sftp', new=SSHClientMock.open_sftp).__enter__()

                    class SSHClientMock:

                        def connect(self, hostname, port=22, username=None, password=None, key_filename=None, timeout=None, look_for_keys=True, allow_agent=True):
                            logger.info('SSHClientMock.connect')
                            logger.info(hostname)
                            logger.info(port)
                            logger.info(username)
                            logger.info('*******')  # password
                            return None

                        def close(self):
                            return None

                        def exec_command(self, cmd):
                            logger.info('SSHClientMock.exec_command')
                            logger.info(cmd)
                            return StdinMock(), StdoutMock(), ""

                        def open_sftp(self) -> 'SFTPClientMock':
                            return  SFTPClientMock()

                    class SFTPClientMock:

                        def putfo(self, fl, remotepath:str):
                            logger.info('SFTPClientMock.putfo')
                            logger.info(fl.read())  # certificate
                            logger.info(remotepath)
                            pass

                        def remove(self, path:str):
                            pass

                    class StdoutMock:
                        def read(self):
                            return "testhost1"

                    class StdinMock:
                        def close(self):
                            return None
                方法B >> MagicMock:
                    stdout = mock.MagicMock()
                    stdout.read().strip.return_value = "file1\nfile2\nfile3\n"
                    #ref: https://stackoverflow.com/questions/36135687/mock-paramiko-sshclient-exec-command
                方法C >> DummySSHClient:
                    #ref: https://hawksnowlog.blogspot.com/2021/06/paramiko-monkeypatch.html
            mock-ssh-server:  #// ほぼ本物の SSH サーバーを立てる？
                #ref: https://github.com/carletes/mock-ssh-server
                #ref: https://pypi.org/project/mock-ssh-server/
    ソケット通信(socket): #keyword: Python socket, Python ソケット通信  #// ソケット通信 = TCP/IP 通信
        公式: #ref: https://docs.python.org/ja/3/library/socket.html
        サンプル:
            VSCode: #ref: ${GitHub}/MyPrivateCode/Python/try_Python_socket
        定数:
            socket.AF_INET: IPv4
            socket.SOCK_STREAM: (socket stream) TCP 通信
            socket.SOCK_DGRAM: (socket datagram) UCP 通信
                #ref: https://ja.stackoverflow.com/questions/66552/af-unixにおける-sock-streamとsock-dgramの違いはなんですか
                #ref: https://docs.oracle.com/cd/E19253-01/819-0392/sockets-4/index.html
            socket.SO_REUSEADDR: マルチプロセスで受信？
                client.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                #ref: https://qiita.com/takaomag/items/f43d0ccac04eb8dd9e5c
    暗号化:
        python3-cryptography, python-crypto: #keyword:
            python3-cryptography のほうが新しいです。python-crypto より。
    ホスト名: #keyword: Python hostname
        import socket
        print(socket.gethostname())
        #ref: https://stackoverflow.com/questions/4271740/how-can-i-use-python-to-get-the-system-hostname
プロセス: #keyword: Python process
    シェルから実行します: #search: try Python    
    コマンドライン オプション:  #// 起動時に指定した引数
        argparse: #keyword: Python argparse
            #ref: https://docs.python.org/ja/3/library/argparse.html
        sys.argv: #keyword: Python sys.argv
            公式: #ref: https://docs.python.org/ja/3/library/sys.html#sys.argv
            sys.argv[0]:
                スクリプトの名前。フルパス名かどうかは、OSによって異なります
    subprocess: #keyword: Python subprocess,  Python shell command system call  #ref: https://docs.python.org/ja/3/library/subprocess.html
        サンプル:
            import subprocess

            ret= subprocess.call( "notepad.exe a.txt" )
            assert  ret == 0
        check_call:  #// 子プロセスが 0 以外を返したら subprocess.CalledProcessError 例外が発生します  #ref: https://docs.python.org/3/library/subprocess.html#subprocess.check_call
            subprocess.check_call( "notepad.exe a.txt" )
        脆弱性:  #search: OS command injection
        Snap Note: #ref: ${programming}/スクリプト/Python.svg#call_subprocess
    スレッド:
        concurrent.futures: #keyword:
            
        threading: #keyword: Python threading
            スレッド生成:
                サンプル: |
                    def boil_udon():
                        print('  うどんを茹でます。')
    
                    thread1 = threading.Thread(target=boil_udon)
                    thread1.start()
                    thread1.join()
                参考: #ref: https://qiita.com/tchnkmr/items/b05f321fa315bbce4f77
            ロック: #keyword: Python threading lock
                with を使う場合: |  #// 未確認
                    import threading
                    lock = threading.Lock()  #// ロック オブジェクト を生成します
    
                    def foo():
                        with lock:
                            # do something...
                with を使わない場合: |  #// 未確認
                    import threading
                    lock = threading.Lock()  #// ロック オブジェクト を生成します
    
                    def foo():
                        lock.acquire()
                        try:
                            # do something...
                        finally:
                            lock.release()
                #ref: https://docs.python.org/ja/3/library/threading.html#using-locks-conditions-and-semaphores-in-the-with-statement
            デバッグ: #keyword: debug Python thread
                スレッドでブレークしたとき:
                    親スレッドを特定する:  #// 親スレッドはスレッドを生成したスレッドです
                        - VSCode の CALL STACK の中から thread.py の中にいるスレッドを探します。 たとえば、.pyenv/versions/3.7.1/lib/python3.7/concurrent/futures/thread.py
        GIL: #keyword: GIL, Global Interpreter Lock
            - プロセスに対するロック
            - プロセスが違えば待たない
            - メモリー空間が違うことで共有できないデータに対して使う
            - 物理PUが違えば同時実行もできる
            - CPU処理が多いときに有効
        thread: #keyword: Python old thread
            旧仕様。 代わりは  #search: Python threading
    シグナル, Ctrl + C:  #keyword: Python signal,  Python Ctrl+C
        コード: |
            signal.signal(signal.SIGTERM, __ShutdownFunction__)  #keyword: SIGTERM,  kill コマンド  #search: kill
            signal.signal(signal.SIGINT, __ShutdownFunction__)   #keyword: SIGINT, Ctrl + C
        Django:  #search: Django Ctrl+C
        #ref: https://docs.python.org/3/library/signal.html#examples
パッケージ管理: #keyword: Python package,  Python module
    仮想環境: #keyword: Python venv,  Python 仮想環境 .venv  #// Python パッケージがいくつか入ったフォルダー
        手順:
            場所の表示: #keyword: 仮想環境 パス,  仮想環境 場所  #// 仮想環境の場所や設定を表示します
                Python: #keyword: which python  #// これが最も確実
                    python コマンドのパスを表示します:
                        (bash):
                            which python
                        Poetry:
                            poetry env info --path  など  #search: virtualenvs.path
                    サンプル:
                        ~/.pyenv/shims/python と表示されたら、仮想環境は ~/.pyenv
                        ~/service/api/.venv/bin/python と表示されたら、仮想環境は ~/service/api/.venv
                VSCode: #keyword: VSCode venv  #// VSCode が認識している仮想環境
                    表示:  #// VSCode が認識している Python のバージョンと仮想環境を表示します
                        概要:
                            VSCode の左下にある Python の右に表示されます
                            例： Python 3.7.9 ('.venv':pipenv)
                        詳細:
                            VSCode のターミナルが使っているシェル（右上）にカーソルを合わせます。
                            アクティブな Python の仮想環境のパスなどが表示されます。
                            #ref: https://github.com/microsoft/vscode-python/wiki/Activate-Environments-in-Terminal-Using-Environment-Variables
                    変更:  #// VSCode が認識している仮想環境を変更します  #search: VSCode Python Select Interpreter
                        - Visual Studio Code でフォルダーを開き、Python ファイルを開きます。
                        - Visual Studio Code の右下の Python の右の .venv などをクリックします 
                        - 仮想環境の中の bin にある python 本体のパスを選ぶか入力します
                        #// 例： Python 3.7.9 ('.venv':pipenv)
                    Python Select Interpreter: #keyword: VSCode Python Select Interpreter  #// Visual Studio Code が使う仮想環境を選びます
                        #ref: https://code.visualstudio.com/docs/python/environments#_create-a-conda-environment-in-the-terminal
                        （1回目）:
                            （必要なら）Visual Studio Code を開きなおします:
                                #// Visual Studio Code のターミナルで venv コマンドを実行した場合のみ必要です
                            仮想環境を選びます:
                                方法A: |
                                        - F1 キー >> Python: Select Interpreter >>（仮想環境のフルパス= .venv）
                                        - 仮想環境の中の bin にある python 本体のパスを選ぶか入力します
                                    #// .venv が候補に表示されないときは Visual Studio Code を開きなおします
                                方法B:
                                    - Visual Studio Code でフォルダーを開き、Python ファイルを開きます。
                                    - Visual Studio Code の右下の Python の右の .venv などをクリックします 
                                    - 仮想環境の中の bin にある python 本体のパスを選ぶか入力します
                                仮想環境をアクティベートしたくない場合:
                                    - 上記のパスを選ぶときに、Global の Python のバージョンを選びます
                            ターミナルを開きなおします:  #// Visual Studio Code を開きなおすことは不要です
                                #// 仮想環境がアクティベートされたプロンプトが表示されます:
                                (.venv)
                        （2回目以降）__Project__/.venv の場合:
                            Python ファイルを開きます  #// 無ければ、空の .py ファイルを作って開きます
                            #// これだけで Select Interpreter で選んだ仮想環境が選ばれます
                            #// Python Create Terminal も自動的に実行します
                            #// 以後、Visual Studio Code を開きなおすまで、New Terminal メニューなどでターミナルを開くときに、自動的に仮想環境をアクティベートします
                    PYTHONPATH 環境変数:  #keyword: VSCode PYTHONPATH  #// Visual Studio Code が使う仮想環境を選びます
                        __Project__/.env ファイル:  #// 下記 __VENV__ は仮想環境のパスに置き換えてください
                            PYTHONPATH=__VENV__\Lib\site-packages
                    python.pythonPath: #keyword:  #// ❗廃止されました
                        __Project__/.vscode/settings.json: |
                            {
                                "python.pythonPath": "____"
                            }
                        参考:
                            - #ref: https://atmarkit.itmedia.co.jp/ait/articles/2106/25/news028.html#:~:text=python.pythonPath項目
                            - #ref: https://github.com/TheButlah/vscode-reorder-python-imports/issues/7
                            - #ref: https://github.com/microsoft/vscode-python/issues/12313
                            - #ref: https://code.visualstudio.com/docs/python/environments#_select-and-activate-an-environment
                poetry: #search: poetry config --list
                pipenv:
                    pipenv --venv  #// 仮想環境のパスを表示します
            構成を調べます:  #// 仮想環境のフォルダーにあるファイルなどから構成を調べます
                Python バージョン:
                    $ ls -l __VEnv__/bin/python*
                    lrwxrwxrwx 1 user group  __VEnv__/bin/python -> python3.8
                venv または virtualenv のどちらを使ったか:
                    __VEnv__/pyvenv.cfg が存在すれば venv
                元となったPythonの位置:
                    __VEnv__/pyvenv.cfg  >>  home
                仮想環境の設定:
                    システムの site-packages ディレクトリにもアクセスするかどうかなど
                Pythonパッケージの一覧:  #// 依存するパッケージも含むので注意。動かなかったら追加すればよさそう
                    ls  __VEnv__/lib/pythonX.X/site-packages
                #ref: ${typrm_files}/ref/Python-AI.yaml#label: venv analyze
            追加: #keyword: add Python package  #// Python パッケージを追加します
                poetry: #search: Poetry VSCode
                pipenv: #search: pipenv install
            再構築します:  #search: poetry rebuild
            ツール: #search: Python venv tools
        ファイル:
            site-packages: #keyword:
                .venv/lib/python____.____/site-packages/__PackageName__
                .venv/lib/python____.____/site-packages/__PackageAndVersionName__.dist-info
        参考:
            Snap Note: #ref: ${programming}/スクリプト/Python.svg#virtualenv
    Python モジュール:  #// 1つの .py ファイル
        コードから区別する場合: |  #// コードだけでは区別でませんが、そのパスに何があるかで区別できます
            import math          # math は「モジュール」（単一ファイル）
            import numpy         # numpy は「パッケージ」（複数ファイルの集合） 区別できない
            from os.path import join  # os は「パッケージ」、path は「サブモジュール」
        手順など:
            下記
    Python パッケージ:  #// 複数の .py ファイルをまとめたもの
        ツール: #keyword: Python venv tools
            PyPI: #keyword: PyPI,  Python catalog  #// Python Package Index というリポジトリ  #ref: https://pypi.org/
                .whl をダウンロードします:  #keyword: PyPi download  #// wheel ファイル (.whl) または、ソース .tar.gz ファイルをダウンロードします
                    #// 通常、ダウンロードしなくても pip install コマンドなどで自動的にダウンロードします
                    パッケージ名とバージョンを指定する場合:
                        シェルを開きます:
                            ただし、.wheel ファイルを使ってインストールする先の OS と同じ OS のシェルを開いてください
                        .whl ファイルをダウンロードします:
                            依存するものを含まない場合:
                                pip wheel  --no-deps  __Package__==__Version__  #// カレント フォルダー に保存します
                            依存するものも含む場合:
                                #search: wheel dependency  #// 指定したフォルダーに保存します
                            PyPI サーバー を指定する場合:
                                pip wheel  --no-deps  __Package__==__Version__  --index-url https://__PyPIServer__/  --trusted-host __PyPIServer__
                    URL を指定する場合:
                        URL を調べます:  #// 使えるバージョン番号を調べます  #keyword: Python package versions
                            補足:  #// __Package__==__Version__ 形式URL を調べる方法しかないようです。
                            ホームページ:
                                最新版:
                                    https://pypi.org/ >>（パッケージ名を検索）>> Download files（左）>> Built Distribution（中央）>> ___.whl
                                    #// Built Distribution が無ければ Source Distribution >> ____.tar.gz
                                古い版:
                                    https://pypi.org/ >>（パッケージ名を検索）>> Release history（左）>>（バージョン番号）>>
                                    Download files（左）>> Built Distribution（中央）>> ___.whl
                                    #// Built Distribution が無ければ Source Distribution >> ____.tar.gz
                        pip download コマンド: #keyword: pip download one
                            コマンド: pip download --no-deps -d __SavingPath__  __DownloadWheelURLOrPath__
                                #// または pip3
                            動作内容:
                                - 互換性があればダウンロードします。
                                - 互換性がなければエラーになりダウンロードしません。まずは正しい名前を確認してください  #search: Python Wheel using platform
                                    #// __WheelFileName__ is not a supported wheel on this platform.
                                - 既にファイルがあれば、File was already downloaded と表示されてダウンロードしません。
                        互換性を確認します: #keyword: Python Wheel platform
                            .whl ファイルの確認:  #// ファイルが現在のプラットフォームで使えるかどうかを確認します
                                pip download コマンドで互換性を確認する場合:  #search: pip download one
                            名前の確認: #keyword: Python Wheel using platform  #// 仮想環境（プロジェクト）に入っている Wheel のプラットフォーム名を確認します
                                .venv/lib/python__Version__/site-packages/__Package__-__Version__.dist-info/WHEEL : |
                                    Tag: cp36-abi3-manylinux_2_17_x86_64
                                    Tag: cp36-abi3-manylinux2014_x86_64
                                    #// poetry を使った場合だけかも
                            命名規則: #keyword: Python Wheel name  #// .whl ファイルの命名規則
                                #// Python のバージョン
                                cp: CPython. #keyword: cp39,cp38,cp37,cp36  #ref: ${typrm_files}/ref/Python-AI.yaml#label: Wheel cp
                                #// Linux のバージョン
                                manylinux: #keyword:  #ref: ${typrm_files}/ref/Python-AI.yaml#label: manylinux
                                manylinux_2_24:
                                    2_24 の部分は glibc のバージョンです  #search: glibc version
                                musllinux: #keyword:  #ref: ${typrm_files}/ref/Python-AI.yaml#label: musllinux
                                    Alpine Linux などの軽量 Linux 向け。
                                musllinux_1_1:
                                    1_1 の部分は musl libc のバージョンです
                                #// Linux のディストリビューション別
                                CentOS: { OK: manylinux2014, manylinux2010, NG: manylinux_2_24 }
                            bcrypt-4.0.1: #keyword:
                                bcrypt-4.0.1-cp36, manylinux_2_17:
                                    ファイル名: bcrypt-4.0.1-cp36-abi3-manylinux_2_17_x86_64.manylinux2014_x86_64.whl
                                    対応: CentOS7, pip 20.2.4
                                    非対応: CentOS7, pip 18.1
                                    #// 19.0.3 は不明
                                bcrypt-4.0.1-cp36, manylinux_2_24:  #// 非対応
                                    ファイル名: bcrypt-4.0.1-cp36-abi3-manylinux_2_24_x86_64.whl
                                    非対応: CentOS7, 20.2.4
                                bcrypt-4.0.1-cp37:  #// 非対応
                                    ファイル名: bcrypt-4.0.1-pp37-pypy37_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl
                                    非対応: CentOS7, 20.2.4
                        社内リポジトリがある場合:  #keyword: Python Wheel repository  #// .wheel ファイルを置いてある社内リポジトリ
                            .wheel ファイルを追加します:  #// 依存する .wheel ファイルも追加します
                                pip wheel コマンド:  #search: pip wheel
                            既存の .wheel ファイルに合わせます:
                                poetry の場合:  poetry add __Module__==__Version__  #search: poetry add
                    #search: pip wheel
                Poetry, pipenv, anaconda の違い:  #search: Poetry pipenv
                ファイル名 >> Wheel: cp37, manylinux など  #search: Python Wheel
                Simple Repository API: #keyword: Python Simple Repository API,  PEP 503
                    サーバーのファイル構成: #// HTTP サーバー を PyPI リポジトリ として使うのに必要なファイルとその構成
                        ファイル構成:
                            /pypi/
                            ├── numpy/
                            │   ├── numpy-1.21.0-py3-none-any.whl
                            │   └── index.html
                            ├── requests/
                            │   ├── requests-2.25.1-py2.py3-none-any.whl
                            │   └── index.html
                            └── index.html
                        /pypi/index.html:
                            #// ここに書く正確なパッケージ名は、.whl ファイル名の先頭とは限りません。
                            #// 既存の .venv/lib64/python____.____/site-packages を参照。
                            #// たとえば、attrs-18.2.0-py2.py3-none-any.whl のパッケージ名は attr です（sなし）
                            <html>
                            <body>
                            <a href="numpy/">numpy</a><br>
                            <a href="requests/">requests</a><br>
                            </body>
                            </html>
                        /pypi/numpy/index.html:
                            <html>
                            <body>
                            <a href="numpy-1.21.1-py3-none-any.whl">numpy-1.21.1-py3-none-any.whl</a><br>
                            <a href="numpy-1.22.0-cp39-cp39-win_amd64.whl">numpy-1.22.0-cp39-cp39-win_amd64.whl</a><br>
                            </body>
                            </html>
                    create_pypi_repo.sh コマンド: | #keyword: create_pypi_repo.sh
                        #!/bin/bash

                        function  ShowHelp() {
                            echo "Usage: $0 [options] __PackageDir__ __OutputDir__"
                            echo ""
                            echo "Create PyPI Simple Repository from wheel and tar.gz files"
                            echo ""
                            echo "Arguments:"
                            echo "  __PackageDir__   Directory containing .whl and .tar.gz files"
                            echo "  __OutputDir__    Output directory for Simple Repository"
                            echo ""
                            echo "Options:"
                            echo "  -h, --help       Show this help message"
                            echo ""
                            echo "Example:"
                            echo "  $0 packages simple"
                        }

                        #// Global variables
                        OutputDir=""
                        PackageDir=""

                        #// Parse command line options
                        PositionalArgs=()
                        while [[ $# -gt 0 ]]; do
                            case $1 in
                                -h|--help) ShowHelp; exit 0;;
                                -*) Error  "Unknown option $1";;
                                *) PositionalArgs+=("$1"); shift;;
                            esac
                        done
                        set -- "${PositionalArgs[@]}"
                        unset PositionalArgs

                        #// Validate arguments
                        if (( $# != 2 )); then
                            Error  "Expected 2 arguments, got $#. Use -h for help."
                        fi

                        PackageDir="$1"
                        OutputDir="$2"

                        function  Main() {
                            ValidateInputs
                            CreateOutputDirectory
                            ProcessPackages
                            CreateRootIndex
                            echo  "PyPI repository created in ${OutputDir}"
                            echo  "To serve locally: cd ${OutputDir} && python -m http.server 8080"
                            echo  "Usage: pip install --extra-index-url http://localhost:8080/ package_name"
                        }

                        function  ValidateInputs() {
                            local  packageDir="$1"
                            local  outputDir="$2"
                            
                            if [[ "${PackageDir}" == "" ]]; then
                                Error  "Package directory cannot be empty"
                            fi
                            
                            if [[ "${OutputDir}" == "" ]]; then
                                Error  "Output directory cannot be empty"
                            fi
                            
                            if [[ ! -d "${PackageDir}" ]]; then
                                Error  "Package directory '${PackageDir}' does not exist"
                            fi
                        }

                        function  CreateOutputDirectory() {
                            mkdir -p "${OutputDir}"  ||  Error  "Failed to create output directory '${OutputDir}'"
                        }

                        function  ProcessPackages() {
                            local  hasFiles=false
                            
                            #// Process .whl files
                            for file in "${PackageDir}"/*.whl; do
                                if [[ -f "${file}" ]]; then
                                    hasFiles=true
                                    ProcessSinglePackage  "${file}"
                                fi
                            done
                            
                            #// Process .tar.gz files
                            for file in "${PackageDir}"/*.tar.gz; do
                                if [[ -f "${file}" ]]; then
                                    hasFiles=true
                                    ProcessSinglePackage  "${file}"
                                fi
                            done
                            
                            if [[ "${hasFiles}" == "false" ]]; then
                                Error  "No Python packages (.whl or .tar.gz) found in '${PackageDir}'"
                            fi
                        }

                        function  ProcessSinglePackage() {
                            local  filePath="$1"
                            local  basename="$( basename "${filePath}" )"
                            local  packageName=""
                            
                            packageName="$( ExtractPackageName  "${basename}" )"
                            
                            if [[ "${packageName}" == "" ]]; then
                                echo  "Warning: Could not extract package name from '${basename}', skipping"
                                return
                            fi
                            
                            CreatePackageDirectory  "${packageName}"
                            CopyPackageFile  "${filePath}" "${packageName}"
                            UpdatePackageIndex  "${packageName}"
                        }

                        function  ExtractPackageName() {
                            local  filename="$1"
                            local  packageName=""
                            
                            if [[ "${filename}" == *.whl ]]; then
                                #// For wheel files: package_name-version-python_tag-abi_tag-platform_tag.whl
                                packageName="$( echo "${filename%.whl}" | sed -E 's/-[0-9].*//' | tr '[:upper:]' '[:lower:]' | tr '_' '-' )"
                            elif [[ "${filename}" == *.tar.gz ]]; then
                                #// For tar.gz files: package-name-version.tar.gz
                                packageName="$( echo "${filename%.tar.gz}" | sed -E 's/-[0-9].*//' | tr '[:upper:]' '[:lower:]' | tr '_' '-' )"
                            fi
                            
                            echo  "${packageName}"
                        }

                        function  CreatePackageDirectory() {
                            local  packageName="$1"
                            local  packageDir="${OutputDir}/${packageName}"
                            
                            mkdir -p "${packageDir}"  ||  Error  "Failed to create package directory '${packageDir}'"
                        }

                        function  CopyPackageFile() {
                            local  filePath="$1"
                            local  packageName="$2"
                            local  filename="$( basename "${filePath}" )"
                            local  targetPath="${OutputDir}/${packageName}/${filename}"
                            
                            if [[ ! -e "${targetPath}" ]]; then
                                cp "${filePath}" "${targetPath}"  ||  Error  "Failed to copy '${filePath}' to '${targetPath}'"
                            fi
                        }

                        function  UpdatePackageIndex() {
                            local  packageName="$1"
                            local  packageDir="${OutputDir}/${packageName}"
                            local  indexPath="${packageDir}/index.html"
                            
                            CreatePackageIndexHeader  "${packageName}" > "${indexPath}"
                            
                            for file in "${packageDir}"/*.whl "${packageDir}"/*.tar.gz; do
                                if [[ -f "${file}" ]]; then
                                    local  filename="$( basename "${file}" )"
                                    echo  "<a href=\"${filename}\">${filename}</a><br/>" >> "${indexPath}"
                                fi
                            done
                            
                            echo  '</body></html>' >> "${indexPath}"
                        }

                        function  CreatePackageIndexHeader() {
                            local  packageName="$1"
                            
                            echo  '<!DOCTYPE html>'
                            echo  '<html>'
                            echo  '<head>'
                            echo  "<title>Links for ${packageName}</title>"
                            echo  '</head>'
                            echo  '<body>'
                            echo  "<h1>Links for ${packageName}</h1>"
                        }

                        function  CreateRootIndex() {
                            local  indexPath="${OutputDir}/index.html"
                            
                            echo  '<!DOCTYPE html>' > "${indexPath}"
                            echo  '<html>' >> "${indexPath}"
                            echo  '<head>' >> "${indexPath}"
                            echo  '<title>Simple Index</title>' >> "${indexPath}"
                            echo  '</head>' >> "${indexPath}"
                            echo  '<body>' >> "${indexPath}"
                            echo  '<h1>Simple Index</h1>' >> "${indexPath}"
                            
                            for dir in "${OutputDir}"/*/; do
                                if [[ -d "${dir}" ]]; then
                                    local  dirname="$( basename "${dir}" )"
                                    echo  "<a href=\"${dirname}/\">${dirname}</a><br/>" >> "${indexPath}"
                                fi
                            done
                            
                            echo  '</body>' >> "${indexPath}"
                            echo  '</html>' >> "${indexPath}"
                        }

                        function  Error() {
                            local  message="$1"
                            echo  "Error: ${message}" >&2
                            exit 1
                        }

                        Main
                    dumb-pypi コマンド: #keyword: dumb-pypi  #// 公式だけど Python が必要
                        コマンド: |
                            pip install dumb-pypi
                            かきかけ
                    dir2pi コマンド: #keyword: dir2pi  #// 無くなったらしい。サーバーのファイル構成を作ります
                        コマンド: |
                            pip install dir2pi

                            mkdir packages
                            pip download --only-binary=:all: -d packages  __Package1__ __Package2__  #// numpy requests flask

                            mkdir simple
                            dir2pi packages simple
                        入力フォルダー:  #// 対象は直下のファイルのみ。サブフォルダーの中の .whl は処理しません
                            packages/
                            ├── numpy-1.21.0-py3-none-any.whl
                            ├── requests-2.28.0-py3-none-any.whl
                            ├── flask-2.0.1-py3-none-any.whl
                            └── dependency-1.0.0-py3-none-any.whl
                        出力フォルダー: |
                            simple/
                            ├── index.html                           # 全パッケージ一覧
                            ├── numpy/
                            │   ├── index.html                      # numpyのバージョン一覧
                            │   └── numpy-1.21.0-py3-none-any.whl   # シンボリックリンク
                            ├── requests/
                            │   ├── index.html
                            │   └── requests-2.28.0-py3-none-any.whl
                            ├── flask/
                            │   ├── index.html
                            │   └── flask-2.0.1-py3-none-any.whl
                            └── dependency/
                                ├── index.html
                                └── dependency-1.0.0-py3-none-any.whl
            pip: #keyword:  #// Python パッケージの追加・除外など
                手順:
                    インストール: #keyword: install pip   #// ここは pip 本体のインストール。パッケージの追加は pip install
                        ローカル環境 >> Ubuntu 20.04 + WSL2 + Python:
                            プロキシ環境の場合:
                                http_proxy, https_proxy 環境変数の設定が必要です  #search: Ubuntu Linux proxy
                            venv コマンドをインストールします:
                                sudo apt install -y  python3.8-venv
                            プロジェクトと仮想環境を作ります:
                                cd $HOME
                                mkdir tutorial
                                cd tutorial
                                python3 -m venv ".venv"
                                source ".venv/bin/activate"
                                pip install django  #// Django を使う場合
                        CentOS7 + Python3:
                            sudo yum install python3 -y
                            python3 --version
                            #// python3 や pip3 コマンドが使えるようになります
                            #// Python 3.6.8 が使えます
                        CentOS7 + Python2:
                            注意: 最新の pip は Python2 に対応していません  #// 22.0.2 (2022-02-01)  #ref: https://pip.pypa.io/en/stable/news/#v21-0
                            Docker 内: |  #keyword: Python2 pip docker
                                cd  "__Working__"
                                docker container run  -v "${PWD}:/root/host"  -it centos:7  /bin/bash
                                cd  /root/host/test
                                export https_proxy="____"   #// 必要なら
                                curl  "https://bootstrap.pypa.io/pip/2.7/get-pip.py" -o "get-pip.py"
                                python get-pip.py
                                pip install  PyYAML
                            Docker なし:
                                （不要→ sudo yum install -y python-setuptools）
                                curl "https://bootstrap.pypa.io/pip/2.7/get-pip.py" -o "get-pip.py"
                                sudo python get-pip.py
                                pip --version
                                    pip 20.3.4 from /usr/lib/python2.7/site-packages/pip (python 2.7)
                                pip install dnspython
                                    インストール先
                                        /var/lib/jenkins/.local/lib/python2.7/site-packages/dnspython-1.16.0.dist-info/
                                        /var/lib/jenkins/.pyenv_ci/pypi/dnspython-1.16.0-py2.py3-none-any.whl
                            失敗するコマンド: sudo yum install python-pip -y  #// 8.1.2 (2022-02-01)
                        pip か pip3 か, 対象の環境:
                            アクティブな仮想環境なし:  #// 主にサーバーで使います
                                pip:  システム全体の Python2
                                pip3: システム全体の Python3
                            アクティブな仮想環境あり:  #// 主にローカル環境で使います
                                pip:  仮想環境内
                                pip3: 仮想環境内
                        バージョン: #keyword: pip version
                            pip 本体のバージョン:
                                仮想環境の pip のバージョン:
                                    poetry が作った仮想環境に pip が入っており、その pip のバージョンは最新のようです。
                                    OS に入っている pip のバージョンとは異なることがよくあります。
                                    - .venv/bin/pip --version
                                    - pip --version
                                バージョン アップ: #keyword: pip --upgrade  #// pip 自体のバージョンアップ
                                    基本:
                                        - #// which pip や Ansible の pip モジュールの executable などで pip のパスを調べます
                                        - ____/pip  --version  #// 現在のバージョンが表示されます
                                        - ____/pip install --upgrade pip==__Version__  #// 指定のバージョンの pip に置き換えます
                                    Python3 用の最新:
                                        - ____/pip install --upgrade  pip
                                    Python2 用の最新:
                                        - ____/pip install --upgrade "pip < 21.0"  #ref: https://stackoverflow.com/questions/65558034/cant-install-pip-anymore-with-python-2-7
                                    .whl ファイルを指定:
                                        - ____/pip install ____/pip-__Version______.whl
                                python3 -m venv や ensurepip: #// によってインストールされる pip のバージョン
                                    python3 のバージョンに対応した pip のバージョンがインストールされます。
                                    これは、ensurepip が pip のバージョンを指定しているためです。
                                    しかし ensurepip を変更することは避け、実行後に pip upgrade するのがよいでしょう。
                                    #ref: ${typrm_files}/ref/Python-AI.yaml#label: ensurepip
                            各種 Python パッケージのバージョン: #keyword: Python Package versions
                                使用中のパッケージ:
                                    pip show __Package__
                                一覧:
                                    https://pypi.org/ で検索します
                        Python パッケージのインスト―ル:  #search: pip install
                        プロキシ環境の場合:  #search: install pip
                    パッケージのインストール:
                        状況: #keyword: pip show exit code
                            if pip show  "__Package__"  2>&1 > /dev/null; then
                            if .venv/bin/pip show  "__Package__"  2>&1 > /dev/null; then
                        インストール実施:  #search: pip install
                    URL を調べる:
                        - PyPI で検索
                        - pip show __PackageName__
                        - pip install __PackageName__ --no-deps --download /tmp
                        #ref: ${typrm_files}/ref/Python-AI.yaml#label: Python package version
                    一覧: #keyword: pip list  #// 仮想環境に行っているすべてのパッケージを一覧します
                        表形式で:
                            pip list
                        requirements.txt 形式で:
                            pip freeze
                コマンド:  #// 以下は pip で書かれています pip と pip3 で共通です
                    pip --version:  #// pip のバージョンを表示します  #search: pip version
                    pip install: #keyword: pip install,  pip3 install add  #// パッケージを追加します。
                        #// ❗注意 プロジェクトによって pip の代わりに poetry や pipenv を使います
                        #// Python2 環境を編集する場合は pip3 の代わりに pip を使います
                        手順:
                            サンプル:
                                - which pip
                                - pip install __PackageName__  #// which pip で表示された仮想環境に __PackageName__ をインストールします
                                - pip install -r ./requirements.txt  #search: pip requirements.txt
                            バージョン指定:  #// 追加するパッケージのバージョンを指定します
                                pip install __PackageName_＿==__Version__
                            pip 自体をバージョンアップします:  #search: pip --upgrade
                            GitLab の private リポジトリ からインストールします: #keyword: pip install private GitLab repository
                                ~/.config/pip/pip.conf : | #keyword:  #// __token__ は置き換えません。__PAT__ は read_api スコープ を持つ PAT です  #search: GitLab PAT  #search: GitLab deploy token
                                    [global]
                                    index-url = https://__token__:__PAT__@gitlab.com/api/v4/projects/__ProjectID__/packages/pypi/simple
                                        または
                                    index-url = https://__DeployUserName__:__DeployToken__@gitlab.com/api/v4/projects/__ProjectID__/packages/pypi/simple
                        ファイル:  #search: pip files
                        関連:
                            requirements.txt: #search:
                            pipenv:  #search: pipenv Windows install
                            Poetry:  #search: poetry add
                        #↓ オプション
                        --index-url オプション: #keyword: pip install --index-url  #// 参照する PyPI をデフォルトから置き換えます。Simple Repository API 準拠であること
                            _: --index-url http://localhost:8080/simple/
                            トラブルシューティング:
                                エラー, HTTP error 404 while getting .whl: #keyword: pip install trouble .whl 404
                                    手順:
                                    ログ: |
                                        pip install isort==5.6.4  --index-url https://__token__:${PAT}@gitlab.com/api/v4/projects/1234/packages/pypi/simple
                                            Looking in indexes: https://PRIVATE-TOKEN:****@gitlab.com/api/v4/projects/1234/packages/pypi/simple
                                            Collecting isort
                                            ERROR: HTTP error 404 while getting https://gitlab.com/api/v4/projects/1234/packages/pypi/files/isort-5.6.4-py3-none-any.whl#sha256= (from https://gitlab.com/api/v4/projects/1234/packages/pypi/simple/isort/)
                                    対処A, pip の場合:  #search: pip --upgrade
                                        他のパッケージで試します:
                                            --index-url を使って他のパッケージのインストールができても、pip の更新ができないことがあります
                                    対処B:
                                        Simple API の HTML に書かれた URL を確認します: |  #focus: isort
                                            curl -u "${DEPLOY_USERNAME}:${DEPLOY_TOKEN}"  https://gitlab.com/api/v4/projects/1234/packages/pypi/simple/isort/
                                                ...
                                                <title>Links for pip</title>
                                                <a href="https://gitlab.com/api/v4/projects/1234/packages/pypi/files/e02c24.../zipp-3.4.0-py3-none-any.whl#sha256=102c2f3f8f171..."
                                                ...
                                                以下の場合は NG。 #search: twine
                                                <a href="https://gitlab.com/api/v4/projects/1234/packages/pypi/files/isort-5.6.4-py3-none-any.whl#sha256="
                                                ...
                                        ダウンロードします:  #// トークン要らない？
                                            curl -O -u "${DEPLOY_USERNAME}:${DEPLOY_TOKEN}" https://gitlab.com/api/v4/projects/1234/packages/pypi/files/e02c24.../zipp-3.4.0-py3-none-any.whl#sha256=102c2f3f8f171...
                        --extra-index-url オプション: #keyword: pip install --extra-index-url  #// 参照する PyPI を追加します。Simple Repository API 準拠であること
                            --extra-index-url http://localhost:8080/simple/
                        -f, --find-links オプション: #keyword: pip install -f,  pip3 install -f  #// sdist (.tar.gz) ファイルや wheel (.whl) ファイルなどのパッケージがある場所
                            #// 指定したフォルダーは Simple Repository API 準拠の構成が不要で、直下に .whl ファイルを配置します
                            値: URL または ファイルパス
                            #// このオプションを指定しない場合、ネットからダウンロードします
                            #ref: https://pip.pypa.io/en/stable/cli/pip_install/#cmdoption-f
                            トラブルシューティング:
                                No matching distribution found for __Package__==__Version__ (from -r /home/proj/requirements.txt (line __LineNum__))"
                        --no-index オプション: #keyword: pip install --no-index
                            指定すると、リポジトリ内に .whl ファイルが単純に並べられたものとします
                        -U, --upgrade オプション: #ref: https://pip.pypa.io/en/stable/cli/pip_install/#cmdoption-U
                    pip uninstall:
                        サンプル:
                            - which pip
                            - pip uninstall __PackageName__  #// which pip で表示された仮想環境に __PackageName__ をインストールします
                    pip list:  #search: pip list  #// 仮想環境にインストール済みのパッケージとそのバージョンの一覧
                    pip show:
                        パッケージの属性を表示します: |
                            Name: pip
                            Version: 20.2.4
                            Summary: The PyPA recommended tool for installing Python packages.
                            Home-page: https://pip.pypa.io/
                            Author: The pip developers
                            Author-email: distutils-sig@python.org
                            License: MIT
                            Location: /python/lib/python3.9/site-packages
                            Requires: 
                            Required-by: 
                    pip freeze: #keyword: pip freeze command  #// 仮想環境にインストール済みのパッケージとそのバージョンの一覧
                        手順:  #search: pip freeze
                        pip list との違い:  #search: pip list
                    pip wheel: #keyword: pip wheel
                        #search: Python Wheel
                        .whl ファイルをビルドする場合 >> requirements.txt を使う場合:  #keyword: pip wheel requirements.txt 
                            pip wheel --wheel-dir=__WheelsFolderPath__  -r requirements.txt
                        ダウンロードする場合:  #search: PyPi download
                        関連:
                            requirements.txt に書かれた Wheel ファイルをダウンロードします:  #search: pip download requirements.txt
                    pip download: #keyword: pip download,  wheel download  #// 指定した .tar.gz などをダウンロードします
                        .whl をダウンロードする場合:  #search: PyPi download
                        requirements.txt を使う場合:  #keyword: pip download requirements.txt
                            .whl の場合: |  #// requirements.txt に書かれたすべての .whl を カレント フォルダー にダウンロードします。
                                    ___/.venv/bin/pip  download  --only-binary=:all:  -r ___/requirements.txt
                                #// .whl ファイルが提供されていないためにエラーになった場合、パッケージを除いた ~/_tmp/requirements.txt を作って再実行します。
                            .tar.gz の場合:  #// requirements.txt に書かれたすべての .tar.gz などをダウンロードします。.whl に対応する .tar.gz もダウンロードします
                                cd ____
                                pip download -r ___/requirements.txt
                ファイル: #keyword: pip files
                    requirements.txt: #search:  #// インストールするパッケージの一覧
                    パッケージ:  #// pip がインストールした パッケージ フォルダー やファイル
                        場所:
                            サンプル:
                                - .pyenv/versions/3.9.1/bin/__Package__
                                - .pyenv/versions/3.9.1/lib/python3.7/site-packages/__Package__
                            探す:
                                $ pip --version
                                pip 20.3.4 from /usr/lib/python2.7/site-packages/pip (python 2.7)
                    pip 実行ファイル:
                        - .pyenv/versions/3.9.1/bin/pip   #// メイン, Python ファイル
                        - .pyenv/versions/3.9.1/lib/python3.9/site-packages/pip/  #// サブ
                    pip.conf:  #ref: ~/.config/pip/pip.conf
                        サンプル: |
                            [global]
                            index-url = https://__token__:__PAT__@gitlab.com/api/v4/projects/__ProjectID__/packages/pypi/simple
                        index-url, extra-index-url:
                            サンプル >> GitLab の private リポジトリ からインストールします:  #search: pip install private GitLab repository
                        find-links:  #// --find-links オプションと同じ  #search: pip install -f
                            find-links =
                                /path/to/local/wheels
                                https://example.com/simple/
                        no-index:  #// --no-index オプションと同じ  #search: pip install --no-index
                            no-index = true
                参考:
                    Snap Note:  #ref: ${programming}/スクリプト/Python.svg#pip
                    Poetry, pipenv, anaconda の違い:  #search: Poetry pipenv
                トラブルシューティング(pip):
                    - #// Could not find a version that satisfies the requirement __Package__
                        手順: pip wheel  --no-deps  __Package__==__Version__  --index-url https://__PyPIServer__/
                        ログ: |
                            WARNING: The repository located at __PyPIServer__ is not a trusted or secure host and is being ignored. If this repository is available via HTTPS we recommend you use HTTPS instead, otherwise you may silence this warning and allow it anyway with '--trusted-host __PyPIServer__'.
                            ERROR: Could not find a version that satisfies the requirement __Package__ (from versions: none)
                            ERROR: No matching distribution found for __Package__
                        対処:
                            HTTPSを使用していない場合は --trusted-host オプション を指定してください  #search: PyPi download
                    - #// Could not find a version that satisfies the requirement
                        手順: sudo python "_get-pip.py" --no-index --find-links=./
                        エラー: |
                            ERROR: Could not find a version that satisfies the requirement __PackageName__ (from versions: none)
                            ERROR: No matching distribution found for __PackageName__
                        対処:
            venv: #keyword:  #// Python3 標準パッケージに入っている仮想環境の操作コマンド
                仮想環境の作成:  #ref: https://docs.python.org/ja/3/library/venv.html
                    #search: install venv VSCode
                Poetry, pipenv, anaconda の違い:  #search: Poetry pipenv
            virtualenv: #keyword:  #// Python2 標準の仮想環境を操作するコマンド
                Python 2.7.5, CentOS7: |
                    sudo yum install -y  python-virtualenv
                    cd __Project__
                    /usr/bin/virtualenv-2.7  ".venv"
                    source ".venv/bin/activate"
                    which pip  #// pip2
            pyenv: #keyword: pyenv  #// Linux 用の複数のバージョンの Python を切り替えます
                公式: #ref: https://github.com/pyenv/pyenv/blob/master/COMMANDS.md
                インストール:  #search: install pyenv
                Python のバージョン切り替え:
                    バージョン一覧: #// バージョンの一覧と現在のバージョンを表示します
                        コマンド:
                            pyenv versions
                        出力例: |
                            _ system
                            * 3.7.1 (set by /home/user1/.pyenv/version)
                            3.7.2
                    バージョンをインストールします: #keyword: pyenv install python version
                        pyenv install -v 3.7.2    #search: Python version  #ref: https://www.python.org/downloads/  >> Release Schedules
                        #// インストールすると、そのバージョンがアクティブになります
                    バージョンが書かれた設定ファイル:  #// Python のバージョンが書かれている開発環境やミドルウェア等の設定ファイル
                        コマンド:  #// 編集と処理のタイミングがあります
                            -   code  pyproject.toml
                            -   code  tox.ini
                            -   code  .envrc
                            -   pyenv install -v 3.7.2  または  pyenv local 3.9.19   #search: pyenv install python version
                            -   direnv allow  #// .envrc が無い場合、または pyenv local を実行したときは不要
                            -   poetry update  #search: poetry update  #// Python 本体のバージョンを変えたときは後で実行します
                            -   rm -rf __VirtualEnvironment__
                            -   poetry install
                            -   find "." -type d -name "__pycache__" -exec rm -rf {} +
                    バージョンを切り替えます:
                        グローバル: #keyword: pyenv global  #// .python-version ファイル が親フォルダーにも無い場合
                            pyenv global 3.7.2
                            #// ~/.shims/python などが置き換わるようです
                            #// 現在の PYENV_ROOT 環境変数が指す仮想環境を使う場合に、カレント フォルダー (?) に影響しないことをグローバルと言っているようです
                        ローカル: #keyword: pyenv local
                            コマンド:
                                .envrc ファイルがある場合:
                                    direnv
                                .envrc ファイルが無い場合:
                                    pyenv local 3.7.1 （例）を実行すると、そのフォルダーだけ 3.7.1 を実行します。
                            .python-version ファイル:  #keyword: .python-version
                                内容:  #// バージョン番号だけが書いてあります
                                    3.7.1
                                poetry + direnv を使う プロジェクト フォルダー の場合:
                                    .python-version ファイルを作る:
                                        .python-version ファイルが無い場合:
                                            poetry install コマンドを実行すると pyproject.toml の設定に合わせて作られます
                                        .python-version ファイルが有る場合:
                                            poetry install コマンドを実行しても .python-version ファイルの内容は変わりません
                                    実行:  #// Python を実行します
                                        bash から python3 を起動する場合:
                                            .python-version ファイルは無視され、pyproject.toml の設定が有効になります
                                        Gradle（他のプロセス？）から python3 を起動する場合:
                                            .python-version ファイルは使われます。
                                            使われない場合は poetry の仮想環境を再構築します  #search: poetry rebuild
                                    .gitignore:
                                        poetry を使う場合、.python-version ファイルを .gitignore に入れます。
                                        #ref: https://stackoverflow.com/questions/54315206/should-we-gitignore-the-python-version-file
                        複数バージョンを有効にする場合:
                            pyenv + tox で複数バージョンのテストを行うには、使用するバージョンすべてを.python-versionに書いておきます
                                #ref: https://www.xn--ebkc7kqd.com/entry/pyenv-tox
                    バージョンをアンインストールします: #keyword: pyenv uninstall python version
                        - pyenv global system    #// アンインストールするバージョンが global の場合のみ実行
                        - pyenv uninstall -f 3.7.1
                    参考:
                        Pyenvの使い方:  #// Python のバージョン管理について
                            #ref: https://qiita.com/mogom625/items/b1b673f530a05ec6b423
                （禁止）パッケージの追加:  #// tox などのコマンドは追加していいかも
                    #// パッケージの追加は poetry で行います。pyenv + poetry というパターンです
                    現在のバージョンにパッケージをインストールします:
                        pip3 install __PackageName__
                        #// 通常 pyenv ではなく poetry でパッケージをインストールします
                    関連 >> 開発時のみプロジェクトに追加する >> poetry:  #search: poetry add --dev
                トラブルシューティング(pyenv):
                    - #// pyenv global コマンドを実行してもバージョンが変わらない
                        手順:
                            pyenv global 3.7.2
                            python --version
                        対処A:
                            direnv したフォルダーでは pyenv global は効きません
                        対処B:
                            ~/.pyenv/shims に PATH を通すよう ~/.bashrc を編集します
                            which pytho
                            echo $PATH
                参考:
                    #ref: https://realpython.com/intro-to-pyenv/
            pipenv: #keyword: pipenv, Python 仮想環境 pipenv,  pipenv .venv  #// 主にローカルで使います
                手順 >> インストール:
                    #search: pipenv projects VSCode
                pipenv コマンド:
                    install:  #keyword: pipenv install  #// パッケージを追加します、または、仮想環境を最新のモジュールで作ります
                        リリース物に含めるパッケージを追加します:
                            pipenv install  __Package__
                        開発用パッケージも含めて追加します:
                            pipenv install --dev  __Package__
                        バージョンを指定します:
                            pipenv install --dev  __Package__~=1.2
                            #ref: https://pipenv-fork.readthedocs.io/en/latest/basics.html#specifying-versions-of-a-package
                        仮想環境を最新のモジュールで作ります: #keyword: pipenv install only
                            pipenv install
                    clean:  #// パッケージを削除します
                        Pipfile から削除するパッケージの行を削除します:
                            サンプル: |  #// たとえば、djangorestframework を削除するとき
                                :
                                [packages]
                                    :
                                djangorestframework = "==3.4.0"     #// この行を削除します
                                    :
                        clean を実行します:
                            #// シェル
                            pipenv clean
                        参考:
                            (Pipenv) uninstallよりcleanの方が多分便利: #ref: https://qiita.com/eduidl/items/c0e8256bb3a5a735d19c
                    sync: #// 仮想環境を再構築します  #keyword: pipenv sync
                        Git bash:  #// VSCode でターミナルを開くと仮想環境が有効になってしまうときは、フォルダーを右クリック >> Git bash Here
                            - export PIPENV_VENV_IN_PROJECT=1  #// 直下に .venv フォルダーを作る場合のみ
                            - cd __Project__
                            - rm -rf .venv
                            - pipenv sync --dev
                        PowerShell:
                            - ${env:PIPENV_VENV_IN_PROJECT} = 1  #// 直下に .venv フォルダーを作る場合のみ
                            - cd __Project__
                            - rm -r -fo .venv
                            - pipenv sync --dev
                        Pipfile.lock ファイルが無い場合:
                            #search: pipenv install only
                    lock: #// インストールしたパッケージを一覧します。依存先は含みません
                        pipenv lock -r
                    参考: #ref: ${programming}/スクリプト/Python.svg#pipenv
                Python 仮想環境一般: #search: Python venv
            Poetry: #keyword:  #// 主にローカルで使います。サーバーでは仮想環境なしで pip 等を使います
                公式:
                    #ref: https://python-poetry.org/
                    #ref: https://python-poetry.org/docs/
                    #ref: https://python-poetry.org/docs/basic-usage/
                    #ref: https://github.com/python-poetry/poetry
                概要:
                    Poetry, pipenv, anaconda の違い:  #keywrod: Poetry pipenv,  Poetry pipenv anaconda
                        #ref: https://vaaaaaanquish.hatenablog.com/entry/2021/03/29/221715
                        pip:   #// 基本。パッケージのインストールのみ
                        venv:  #// 基本。仮想環境のインストールのみ
                        pipenv:  #// 依存関係
                            Pipfile を使う
                        Poetry:  #// pipenv + build + publish  #search: Poetry pyproject.toml
                            Poetry は pyproject.toml の拡張版を使います。
                            pyproject.toml の [tool.poetry] が Poetry 独自の部分です。
                        Anaconda:  #// PyPI ミラー、Anaconda でしか依存関係を解決できないパッケージもある。大規模な商用利用では有償は有料
                手順:  #// インストールなど
                    Poetry のインストール: #keyword: install poetry
                        mac の場合: |  #ref: https://python-poetry.org/docs/
                            brew install pipx
                                pipx --version
                            pipx install poetry
                                pipx ensurepath
                                #// Restart terminal
                                poetry --version
                            cd  __ParentOfPyProjectToml__
                            code pyproject.toml
                                [project]
                                name = "__ProjectName__"
                                version = "0.1.0"
                                description = ""
                                authors = []
                                readme = "../README.md"
                                requires-python = ">=3.10"
                                dependencies = [
                                ]

                                [build-system]
                                requires = ["poetry-core>=2.0.0,<3.0.0"]
                                build-backend = "poetry.core.masonry.api"
                            poetry add pandas
                            poetry self add poetry-plugin-shell
                            poetry shell
                            (__ProjectName__-py3.__Num__) __Prompt__ $ python ____.py
                        WSL2 の場合:
                            WSL の VM を初期状態で作ります:  #search: WSL2
                                WSL の VM を削除します:
                                    (PowerShell):
                                        - wsl -l   #// 存在する VM を一覧します
                                        - wsl --unregister  "Ubuntu-20.04-tox"
                                初期状態の WSL のバックアップをリストアします:  #search: WSL2 restore
                                    (PowerShell):
                                        wsl --import  "Ubuntu-20.04-tox" `
                                            "${HOME}\WSL_VMs\Ubuntu-20.04-tox" `
                                            "${HOME}\WSL_back_up\Ubuntu-20.04-1.tar"
                            WSL を起動します:
                                (PowerShell):
                                    wsl -d "Ubuntu-20.04-tox"
                            Poetry をインストールします:
                                プロキシ環境にいる場合:
                                    (bash):
                                        echo $HTTP_PROXY  #// 小文字 http_proxy ではありません
                                    HTTP_PROXY に値が無い場合:
                                        nano ~/.bashrc : |  #// 末尾に追加  #search: __Company__ proxy
                                            export  HTTP_PROXY="http://____"
                                            export  HTTPS_PROXY="http://____"
                                        コマンド:
                                            source ~/.bashrc
                                            echo $HTTP_PROXY
                                Poetry をインストールします:
                                    curl -sSL https://install.python-poetry.org | POETRY_VERSION=1.1.5  python3 -
                                （必要なら）ダウングレードします: #keyword: poetry downgrade
                                    poetry self update __PoetryVersion__
                                現在のユーザーだけ使えるようにする場合:
                                    PATH に /home/____/.local/bin が無い場合:
                                        無いか確認します:
                                            echo $PATH | grep $HOME/.local/bin  #// 何も表示されなければ無い
                                        nano ~/.bashrc : |  #// 末尾に追加
                                            export  PATH="/home/user1/.local/bin:$PATH"
                                        コマンド:
                                            source ~/.bashrc
                                全てのユーザーで使えるようにする場合:
                                    コマンド:
                                        chmod 755 ~/.local/share
                                        #// 以下に続きます
                                    Ubuntu の場合:  #// 2箇所設定するようです
                                        sudo nano /etc/profile :  #// 全てのユーザーに対する設定
                                            PATH="/home/user1/.local/bin:$PATH"
                                            #// user1 は poetry をインストールしたときのユーザー
                                        sudo nano /etc/environment :  #// 全てのユーザーに対する設定
                                            PATH="/home/user1/.local/bin:__DefaultPATHs__"
                                        Ubuntu を再起動します:
                                バージョンを確認します:
                                    poetry --version  #// 1.2.2
                              #// 以下に続きます
                        CentOS7 の場合:
                            CentOS に Poetry をインストールします: #keyword: CentOS Poetry
                                参考: #ref: https://github.com/python-poetry/poetry#installation
                                shell:
                                    - curl -sSL https://install.python-poetry.org | POETRY_VERSION=1.1.5  python3 -  #// 末尾の - を忘れないこと
                                    - poetry --version
                            #// 以下に続きます
                        既存の仮想環境の場合:  #// 任意の OS
                            コマンドの場合:  #// 未確認
                            Ansible の場合:
                                #search: Ansible install poetry
                        新規 pyproject.toml の場合:  #// pyproject.toml ファイル を新規作成する場合:  #// WSL2, Visual Studio Code
                            pyproject.toml を新規作成します:
                                コマンド:
                                    - cd __ParentOfProject__
                                    - poetry new  poetry-demo  #// poetry-demo フォルダーができます
                                    - cd  poetry-demo
                                    - poetry install
                                cat > example.py : |
                                    import yaml
                                    yaml_string = '''a:
                                        b: 1
                                        c: 2
                                    '''
                                    yaml_data = yaml.safe_load(yaml_string)
                                    print(yaml_data['a']['c'])  #// 2
                            実行します:
                                仮想環境をアクティベートします:
                                    poetry shell
                                    which  python  #// 仮想環境の中の python のパスが表示されるはずです
                                コマンド:
                                    poetry add  pyyaml
                                    python  example.py  #// 2
                                仮想環境をデアクティベートします:
                                    exit
                            Visual Studio Code デバッガーで実行します:
                                初回:
                                    VSCode を開きます:
                                        code "."
                                    Python 拡張機能をインストールします:
                                        Extensions（左）>> Python
                                    Select Interpreter:  #keyword: poetry shell
                                        仮想環境のパスを表示します:  #// poetry shell で仮想環境のアクティベートも行われます
                                            (bash in VSCode):
                                                poetry shell
                                                which python
                                        仮想環境のパスを設定します: |
                                            F1 キー >> Python: Select Interpreter >> Enter interpreter path >>
                                                （仮想環境のフルパス= which python コマンドの出力）
                                        #// Select Interpreter に設定すると、次回（下記）から自動的にアクティベートされます
                                    デバッガーの設定をします:
                                        __Project__/.vscode/launch.json ファイルを新規作成します:
                                            Run and Debug（左）>> create a launch.json file >> Python >> Python File
                                        __Project__/.vscode/launch.json : |
                                            "program": "${workspaceFolder}/example.py",  // 実行するファイル
                                            "justMyCode": false  // ライブラリもデバッガーが停止できる
                                    safe_load を呼び出すコードにブレークポイントを張ります:
                                        行番号の左をクリック
                                    デバッガーで実行します:
                                        F5 キー
                                        VSCode を閉じる
                                2回目以降:
                                    VSCode を開きます:
                                        code "."
                                    開いたターミナルを閉じます:  #// 仮想環境がアクティベートされていないため
                                    ターミナルを開きます:  #// 仮想環境が自動的にアクティベートされます
                                    実行します:
                                        python  example.py
                                    デバッガーで実行します:
                                        F5 キー
                        既存 pyproject.toml の場合:  #// pyproject.toml ファイル があるプロジェクトを使う場合:
                            #// Visual Studio Code でデバッグします(Poetry):  #keyword: Poetry VSCode
                            プロジェクトのフォルダーを開きます:
                                pyproject.toml ファイルがあるフォルダーを Visual Studio Code で開きます
                            .venv:  #keyword: Poetry .venv for VSCode
                                __Project__/.venv フォルダーがないとき:
                                    メニュー: VSCode >> Terminal >> New Terminal  #// bash が開きます
                                    仮想環境のフォルダー(__Project__/.venv) をプロジェクトの直下に作成します:
                                        #// これで VSCode が自動的に認識できるようになります
                                        - poetry config --list  #// 現在の設定を表示します。この設定はプロジェクトごとではなくグローバルです
                                            #// 既に下記のように設定済みで自動的に認識したら、プロンプトの行頭に (.venv) が表示されます
                                        - poetry config  virtualenvs.in-project  true  #// 設定します
                                        - poetry config  virtualenvs.path  ".venv"     #// 仮想環境のフォルダーのパスを設定します
                                        - poetry install
                                    Visual Studio Code でフォルダーを開きなおします:
                                        #// もしくは、 VSCode >> Python __Version__（左下） >> ./.venv/bin/python.exe
                                    python extension を（右下で）勧められたら Yes ボタンを押します:
                            launch.json:  #// __Project__/.vscode/launch.json を作ります: |  #// 🌟下記の program, args の値は変更してください
                                {
                                    "version": "0.2.0",
                                    "configurations": [
                                        {
                                            "name": "Python: Django",
                                            "type": "debugpy",
                                            "request": "launch",
                                            "console": "integratedTerminal",
                                            "cwd": "${workspaceFolder}",
                                            "program": "manage.py",
                                            "args": ["runserver", "--insecure", "0.0.0.0:8080" ]
                                        }
                                    ]
                                }
                            .envrc: #// __Project__/.envrc ファイルがあるとき
                                .envrc ファイルから環境変数を設定している部分だけ .env ファイルにコピーします
                                    #search: VSCode .env
                            仮想環境を選びます:  #// VSCode の Testing ビュー でエラーが出るとき
                                #search: Python Select Interpreter
                            デバッガーを接続しながらプロジェクトを起動します:
                                F5 キーを押します
                    パッケージのインストール:  #search: Poetry commands
                    パッケージの追加など:  #search: poetry add
                    パッケージの更新:  #search: poetry update
                    仮想環境を構築します:  #search: poetry install
                    アクティベート:  #search: poetry shell
                    起動:  #// 仮想環境を使って Python を実行します
                        #// https://python-poetry.org/docs/cli/#run
                        Python ファイルのパスを指定する場合:
                            - poetry run ./manage.py runserver  #// manage.py という Python スクリプト
                            - poetry run ./manage.py shell  #// ./manage.py に実行権限が必要です
                            - poetry run python ./example.py __Parameters__  #// ./example.py に実行権限は不要です
                        pyproject.toml ファイルの中のスクリプト名を指定する場合:  #//  [tool.poetry.scripts] の __ScriptName__
                            pyproject.toml の一部の例: |
                                [tool.poetry.scripts]
                                __ScriptName__ = "my_module:main"
                            起動コマンド:
                                poetry run __ScriptName__
                        pyproject.toml ファイルの中のタスク名を指定する場合, taskipy, タスク: #keyword: pyproject.toml  taskipy,  pyproject.toml  tool.taskipy.tasks
                            pyproject.toml の一部の例: |  
                                [tool.taskipy.tasks]
                                __TaskName__ = "pytest"
                                __TaskName2__ = "pytest ./test"
                                __TaskName3__ = __ComandLine__
                            起動コマンド: #keyword: poetry run task
                                poetry run task __TaskName__
                                    #// 上記の pyproject.toml ファイルの [tool.taskipy.tasks] の場合 __TaskName__ == "pytest"
                            #ref: https://pypi.org/project/taskipy/
                コマンド: #keyword: Poetry commands  #// Poetry のコマンド
                    #ref: https://python-poetry.org/docs/cli/
                    #ref: https://qiita.com/ragnar1904/items/0e5b8382757ccad9a56c
                    poetry add: #search:
                    poetry remove: #search:
                    poetry update: #search:
                    poetry install: #search:
                    poetry config: #search:
                概念:
                    仮想環境: #keyword: Poetry 仮想環境
                        場所:
                            表示:
                                - poetry config virtualenvs.path
                                - poetry config virtualenvs.in-project
                                    #search: Poetry config
                        構築: #keyword: poetry install  #// 仮想環境のフォルダーを構築します:
                            通常:  #// poetry.lock ファイルに書かれたバージョンをインストールします
                                poetry install
                            開発環境用を除く:
                                poetry install --no-dev
                            仮想環境のパス:  #search: poetry env info --path
                                poetry env info --path  #snip:
                        再構築: #keyword: poetry rebuild,  poetry cache clean  #// 仮想環境を作りなおします
                            #// コマンドはありません。仮想環境を削除して poetry install してください。
                            - poetry run python -m site  # 現在の設定を表示します
                            - poetry config --list
                            - poetry config --local  virtualenvs.in-project  true  #// 設定します。--local オプションがあると poetry.toml ファイルができます
                            - poetry config --local  virtualenvs.path  ".venv"     #// 仮想環境のフォルダーのパスを設定します
                            - # VIRTUAL_ENV="${PWD}/.venv"   #// VIRTUAL_ENV 環境変数の値のほうが優先されます。通常この環境変数は設定しませんが、アクティベートすると設定されます
                            - ターミナルの再起動？
                            - rm -rf .venv   #// .venv 以外の場合もあります
                            - rm -rf $HOME/.cache/pypoetry/artifacts/*  #ref: https://stackoverflow.com/questions/69836936/poetry-attributeerror-link-object-has-no-attribute-name
                            - rm .python-version
                            - poetry install
                            #ref: https://github.com/python-poetry/poetry/issues/796
                            #// pyenv の仮想環境も使っているので、そちらの再構築も必要かもしれません
                            #// 関連 >> MySQL >> #search: MySQL Python libmysqlclient trouble
                        poetry.lock ファイル:
                            出力:  #// 出力コマンド？
                                poetry lock
                    パッケージ, モジュール:
                        追加: #keyword: poetry add  #// モジュールを追加します  #// 以下のいずれか
                            コマンド:
                                - poetry add __Module__
                                - poetry add __Module__==__Version__  #// 例 django==2.2.8
                                - poetry add "__Module__>=__OldVersion__,<__NewVersion__"  #// 例 "limits>=1.0.0,<2.0.0"
                                - poetry add __Module__ --group dev  #keyword: #// リリースに含めないモジュール  #ref: https://python-poetry.org/docs/cli/#options-4
                                    #// import するコード  #search: Python development import
                            poetry add で指定していないモジュールまでアップデートしてしまう:
                                #// 未確認
                                poetry lock --no-update:
                                    これでも lock ファイルが更新されてしまう
                                poetry add debugpy==1.6.3 --no-update:
                                    --no-update オプションは無い
                                #ref: https://stackoverflow.com/questions/65883059/what-is-the-difference-between-poetry-lock-and-poetry-update-lock
                            開発時のみインスト―する場合: #keyword: poetry add --dev
                                パッケージを追加します:
                                    poetry add --group dev  pytest   #// pyproject.toml の [tool.poetry.dev-dependencies] に追記されます
                                パッケージのコマンドを実行します:
                                    poetry run pytest
                        削除: #keyword: poetry remove,  delete poetry  #// モジュールを削除します
                            pyproject.toml の [tool.poetry.dependencies] にあるモジュールを削除します:
                                poetry remove __Module__
                            pyproject.toml の [tool.poetry.dev-dependencies] にあるモジュールを削除します:
                                poetry remove __Module__ -D
                            関連 >> 再構築:  #search: poetry rebuild
                        更新: #keyword: poetry update  #// モジュールを最新版に更新します
                            モジュールを更新します:  #// または バージョン ダウン します
                                編集します: pyproject.toml,  .envrc があればそれも  3つ目のバージョン番号まで書くこと。例 3.9.10
                                コマンド: poetry update
                                    #search: semantic varsioning caret
                                動作:
                                    - pyproject.toml の設定に合わせて バージョン アップ または バージョン ダウン します
                                    - poetry.lock ファイルも更新します
                                エラー: #keyword: change python via env use,  is not allowed by the project
                                    ログ: |
                                        Current Python version (__CurrentVersion__) is not allowed by the project (__NewVersion__)
                                        Please change python executable via the "env use" command.
                                    状況:
                                        __CurrentVersion__: 仮想環境にある Python のバージョン
                                        __NewVersion__: pyproject.toml に設定されている Python のバージョン
                                    対処:
                                        Python 本体を更新します  #search: poetry update python
                            Python 本体を更新します: #keyword: poetry update python  #// または バージョン ダウン します
                                コマンド: |  #// Python が 3.7.2、仮想環境が ./.venv にある場合
                                    (.envrc があれば) 
                                        .envrc を編集します
                                            use python 3.7.2 
                                        direnv allow
                                    pyenv install -v 3.7.2  #// または  pyenv local 3.7.2
                                    rm -rf .venv
                                    poetry install
                                poetry.lock ファイルを更新するなら:
                                    poetry lock
                                poetry lock: #keyword:
                                    新しい依存関係がある場合のみ更新します。それ以外はアップグレードしません
                            モジュールの更新をしたらどうなるかを表示します:
                                poetry update --dry-run
                            メジャー バージョン を上げるとき:
                                CLI で 1つのモジュールだけの場合:
                                    poetry add __Module__==__Version__
                                編集後に一度に行う場合:
                                    poetry update  #search: poetry update
                            使えるバージョン番号:  #search: Python package versions
                Poetry config: #keyword:
                    表示: #// 仮想環境の場所や設定を表示します  #keyword: poetry config --list
                        一覧: #keyword: list poetry config  #// config の一覧
                            poetry config --list
                            #// 参考: https://python-poetry.org/docs/configuration/
                        1つ: #keyword: poetry env info --path,  virtualenvs.path,  virtualenvs.in-project
                            #// １つの config
                            - poetry env info --path
                            - poetry config --local virtualenvs.path  #search: VIRTUAL_ENV  #// この設定よりも VIRTUAL_ENV 環境変数 の値が優先されます
                            - poetry config --local virtualenvs.in-project
                            #// など
                        VIRTUAL_ENV 環境変数: #keyword: VIRTUAL_ENV
                            概要:
                                - virtualenvs.path より優先されます  #search: poetry virtualenvs.path
                            注意:  #// 複数の poetry プロジェクトを含む場合
                                - VSCode の Python Select Interpreter を VSCode が開いているフォルダーの中に指定すると、
                                    VIRTUAL_ENV 仮想環境をアクティベートするときに設定されてしまいます
                                - 複数の poetry プロジェクトを含むフォルダーを開いている VSCode では、
                                    VIRTUAL_ENV 環境変数が指す仮想環境が常に poetry の対象になってしまいます
                            設定をチェックするスクリプト: |
                                test  "${VIRTUAL_ENV}" == ""  -o  "${VIRTUAL_ENV}" == "${PWD}/.venv"  ||  \
                                    Error  "ERROR: VIRTUAL_ENV environment variable must be unset."
                            設定されないようにする場合:  #search: VSCode Python Select Interpreter
                    変更: #keyword: update poetry config
                        書式:
                            local:  #search: poetry.toml
                            global: poetry config __Name__  __Value__
                        サンプル:  #search: Poetry .venv for VSCode
                    削除: #keyword: delete poetry config
                        poetry config __Name__  --unset
                ファイル: #glossary: Poetry
                    pyproject.toml: #keyword: Poetry pyproject.toml  #// 使うパッケージの設定
                        Poetry は pyproject.toml の拡張版を使います。
                        pyproject.toml の [tool.poetry] が Poetry 独自の部分です。
                        直接編集せずに poetry add などのコマンドを使います
                    poetry.lock: #// 依存するパッケージも含めた全設定
                    poetry.toml: #// poetry config コマンドによる poetry のローカル設定
                        __Project__/poetry.toml: |
                            [virtualenvs]
                            in-project = true
                            path = ".venv"
                        上記を出力するコマンド:  #keyword: poetry .venv  #// virtualenvs.in-project, virtualenvs.path
                            - poetry config --local virtualenvs.in-project true
                            - poetry config --local virtualenvs.path .venv
                トラブルシューティング(Poetry): #keyword: Poetry trouble
                    - raise JSONDecodeError("Expecting value", s, err.value) from None:
                        手順: poetry install
                        ログ: |
                            The following error occurred when trying to handle this error:
                            JSONDecodeError
                            Expecting value: line 1 column 1 (char 0)
                            at ~/.pyenv/versions/3.7.17/lib/python3.7/json/decoder.py:355 in raw_decode
                                351│         """
                                352│         try:
                                353│             obj, end = self.scan_once(s, idx)
                                354│         except StopIteration as err:
                                → 355│             raise JSONDecodeError("Expecting value", s, err.value) from None
                                356│         return obj, end
                                357│
                            • Installing py (1.11.0)
                            • Installing pynacl (1.5.0)
                            • Installing python-dateutil (2.7.5)
                            • Installing pytz (2018.9)
                            • Updating setuptools (67.6.1 -> 67.5.0)
                            • Installing sqlalchemy (1.3.15)
                            • Installing toml (0.10.2)
                            /home/user1/.local/share/pypoetry/venv/lib/python3.7/site-packages/secretstorage/util.py:23: CryptographyDeprecationWarning: Python 3.7 is no longer supported by the Python core team and support for it is deprecated in cryptography. A future release of cryptography will remove support for Python 3.7.
                            from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
                        対処:
                            POETRY_HTTP_TIMEOUT=60  PIP_DEFAULT_TIMEOUT=60  poetry install
                            #// タイムアウトして JSON が取れないため
                    - Command not found:;; task:   #keyword: Command not found: task:
                        手順:
                            poetry run task test
                        ログ: |
                            Command not found: task
                        対処A:
                            仮想環境を作り直します  #search: poetry rebuild
                        対処B:
                            VIRTUAL_ENV の値が正しい、または設定されていないことが正しいことを確認します  #searhc: VIRTUAL_ENV
                    - The currently activated Python version __OlderVersion__ is not supported by the project (__NewerVersion__).:
                        手順: poetry install や poetry lock
                        ログ: |
                            The currently activated Python version __OlderVersion__ is not supported by the project (__NewerVersion__).
                            Trying to find and use a compatible version. 
                        対処:
                            仮想環境のフォルダーが無い場合:
                                警告は無視できます
                        補足: |
                            仮想環境のフォルダーが無い場合、プロジェクトの外の Python が使われるため、プロジェクトが要求するバージョンと異なるのは問題ありません。
                                $ poetry env info

                                Virtualenv
                                Python:         3.7.1
                                Implementation: CPython
                                Path:           NA
                                Executable:     NA

                                System
                                Platform:   linux
                                OS:         posix
                                Python:     3.7.1
                                Path:       /home/user1/.pyenv/versions/3.7.1
                                Executable: /home/user1/.pyenv/versions/3.7.1/bin/python3.7
                    - No dependencies to install or update と表示されて .venv フォルダーができない :
                        手順: poetry install
                        ログ: |
                            Installing dependencies from lock file
                            No dependencies to install or update
                        対処:
                            virtualenvs.in-project と virtualenvs.path を設定します
                            #search: Poetry .venv for VSCode
                    - poetry install which doesn't match any versions, version solving failed.:
                        手順: poetry install
                        エラー: |
                            Installing dependencies from lock file
                            Warning: poetry.lock is not consistent with pyproject.toml. You may be getting improper dependencies. Run `poetry lock [--no-update]` to fix it.
                            Because rep-api depends on pyparsing (3.0.9) which doesn't match any versions, version solving failed.
                        対処:
                            poetry lock --no-update
                    - entry_points() got an unexpected keyword argument 'group':
                        手順: poetry install
                        エラー: |
                            entry_points() got an unexpected keyword argument 'group'
                        対処:
                            poetry と tox が要求する importlib-metadata のバージョンを変更します
                        参考:
                            エラーが発生していた場所を調べます: |  #// importlib-metadata のバージョンが問題であることを突き止めます
                                vi /var/lib/jenkins/.pyenv_ci/versions/3.7.1/lib/python3.7/site-packages/cleo/application.py
                                    : set number
                                    /ODO: Custom error exit codes
                                vi /var/lib/jenkins/.pyenv_ci/versions/3.7.1/lib/python3.7/site-packages/poetry/plugins/plugin_manager.py
                                    for ep in metadata.entry_points(group=self._group)
                                /var/lib/jenkins/.pyenv_ci/versions/3.7.1/lib/python3.7/site-packages/importlib_metadata/__init__.py   importlib-metadata==2.0.0
                                    def entry_points(self):
                    - _'Link' object has no attribute 'is_absolute':  #keyword: no attribute is_absolute
                        手順: poetry install
                        エラー: |  #// 以下のいずれか
                            'Link' object has no attribute 'is_absolute'
                        対処A:
                            Poetry をバージョンアップして仮想環境を再構築します。poetry.lock を削除してから再構築します  #search: poetry rebuild
                        対処B:
                            Poetry が作る仮想環境を再構築します  #search: poetry rebuild
                        対処C:
                            仮想環境を構築したときの poetry のバージョンに戻します  #search: poetry downgrade
                    - Could not parse version constraint:;; >=2011k:
                        手順: poetry install
                        エラー: |  #// 以下のいずれか
                            Could not parse version constraint: >=2011k
                        対処A:
                            Poetry をバージョンアップして poetry.lock を削除してから poetry install します
                        対処B:
                            Poetry が作る仮想環境を再構築します  #search: poetry rebuild
                        対処C:
                            仮想環境を構築したときの poetry のバージョンに戻します  #search: poetry downgrade
                    - Installing markupsafe (1.1.1):;; Failed:  #keyword: markupsafe Failed
                        手順: poetry install
                        エラー: |  #// 以下のいずれか
                            - Installing markupsafe (1.1.1): Failed
                        対処:
                            poetry add  markupsafe==2.0.1
                    - Installing mysqlclient (______):;; Failed:
                        手順: poetry install
                        エラー: |
                            Installing mysqlclient (______): Failed
                        対処:
                            MySQL client と mysql_config をインストールします:
                                #ref: ${GitHub}/MyPrivateCode/ansible_vagrant/single_vm_ansible/GoCD/playbooks/mysql_client.yml
                            Poetry が作る仮想環境を再構築します:
                                #search: poetry rebuild
                    - ERROR:;; No matching distribution found for poetry==__NewestVersion__:
                        手順: curl -sSL https://install.python-poetry.org | python3 -
                        エラー: |
                            ERROR: No matching distribution found for poetry==1.3.2
                        対処:
                            curl -sSL https://install.python-poetry.org | POETRY_VERSION=1.1.5  python3 -
                    - Warning:;; The lock file is not up to date with the latest changes in pyproject.toml:
                        手順: poetry install
                        エラー: |
                            Warning: The lock file is not up to date with the latest changes in pyproject.toml. You may be getting outdated dependencies. Run update to update them.
                        対処:
                            poetry lock --no-update
                            #ref: https://stackoverflow.com/questions/62040724/warning-the-lock-file-is-not-up-to-date-with-the-latest-changes-in-pyproject-to
                    - ModuleNotFoundError:;; No module named '__Module__':
                        手順: poetry run ./manage.py
                        エラー: |
                            ModuleNotFoundError: No module named '__Module__'
                        対処:
                            poetry add __Module__
            tox: #search:  #// CI環境用
            Anaconda: #keyword:
                公式リポジトリ: 大規模な商用利用では有償
                Poetry, pipenv, anaconda の違い:  #search: Poetry pipenv
            Manba: #keyword:
            Minforge: #keyword:
                概要:
                    conda パッケージの インストール ツール とリポジトリ。
                    scikit-learn は pip ではインストールできませんが、Miniforge ではできます。
                公式: #ref: https://github.com/conda-forge/miniforge
                種類: #keyword: Minforge bases
                    Minforge3: Python 3.9 ベース
                    Minforge: PyPy 3.7 ベース
                    Manbaforge: Manba ベース
                    Manbaforge-pypy3: Manba と PyPy 3.7 ベース
                インストール: #search: install Minforge scikit-learn
                conda-forge: #// Miniforge が使うリポジトリ
            Wheel: #keyword: Python Wheel, wheel .whl
                _: Python のパッケージの形式の１つ。現在の主流。zip形式。PEP 427
                .whl ファイルの命名規則:  #search: Python Wheel name
                互換性の確認:  #search: Python Wheel platform
                ダウンロード:  #search: pip wheel
                ホームページ:  #search: PyPi download
                依存バージョン: #keyword: wheel dependency,  .whl 依存関係  #// Python .whl ファイルが直接依存するパッケージのバージョンを一覧します
                    ダウンロードと同時に依存関係を確認する場合:
                        pip 22.2 以上の場合:  #ref: https://stackoverflow.com/questions/29531094/how-to-make-pip-dry-run
                            pip install  __Package__==__Version__ --dry-run  #// 未確認
                        pip 22.2 未満の場合: |
                            mkdir -p  ~/_wheel
                            pip install --upgrade pip==__PIP_Version__  #// pip wheel に失敗するときに実行します。 ==__PIP_Version__ を省略すると最新版になります
                            pip wheel --wheel-dir=~/_wheel  __Package__==__Version__
                            ls -l  ~/_wheel
                            rm -rf ~/_wheel
                    .whl ファイルを展開してできる METADATA ファイルから確認する場合: |
                        #ref: https://stackoverflow.com/questions/50170588/list-dependencies-of-python-wheel-file
                        mkdir -p  ~/_tmp/wheel
                            cd ~/_tmp/wheel
                            pip wheel --wheel-dir=__WheelsFolderPath__  __AppendingPackage__==__Version__
                        mkdir -p  ~/_tmp/unzip
                            cd  ~/_tmp/unzip
                            unzip -o ____.zip  #// カレント フォルダー に展開されます。.zip の内容によっては、カレント フォルダー に複数のファイルができる場合もあります。
                                unzip -o  ~/common-pypi/tox
                            code  __Package__-__Version__.dist-info/METADATA
                                Requires-Python: >=3.7
                                Requires-Dist: filelock>=3.10.7
            egg: #keyword: Python egg
                Python のパッケージの形式の１つ。現在の主流は Wheel
            関連 >> 仮想環境:  #search: Python venv
        概念:
            バージョン指定子: #keyword: Python version specifiers  #// __Package__~=2.0
                PEP 440: #keyword: PEP 440 version specifiers  #ref: https://peps.python.org/pep-0440/#version-specifiers
                    パッケージ名の例: pytest, packaging
                    バージョン指定:
                        バージョン指定なし:
                            __Package__
                        バージョン指定あり:
                            - __Package__~=2.0   #// 互換性がある最新  #keyword: pip ~= version
                            - __Package__ >= 2.0
                            - __Package__>=2.0
                PEP 508: #keyword: Python package version, PEP 508  #ref: https://peps.python.org/pep-0508/
                    #// Dependency specification for Python Software Packages
                    パッケージ名の例: pytest, packaging
                    バージョン指定:
                        バージョン指定なし:
                            __Package__
                        バージョン指定あり:
                            - __Package__ >= 2.0
                            - __Package__>=2.0
                            #// 他の記号: ==, >=, <=, <, >
                バージョン番号の処理:  #search: Python semantic versioning
        ファイル: #glossary: Python  #// プロジェクト ファイル など
            pyproject.toml:  #// Poetry のプロジェクトのパッケージに関する設定  #search: Poetry pyproject.toml
            Pipfile:  #// pipenv のプロジェクトのパッケージに関する設定  #search: Pipfile
            requirements.txt: #keyword: pip requirements.txt  #// ポータブルなパッケージに関する設定
                #ref: https://pip.pypa.io/en/latest/reference/requirements-file-format/
                基本:
                    requirements.txt を出力します: #keyword: pip freeze  #// 現在のプロジェクトが使っているパッケージの情報を requirements.txt に出力します
                        cd  __Project__
                        pip freeze > requirements.txt
                    パッケージをインストールします:
                        pip の場合:  #search: pip install
                            (sudo) pip install -r ./requirements.txt
                            #// Linux サーバーの場合: sudo pip3 install -r requirements.txt
                        pipenv の場合:
                            (sudo) pipenv install -r ./requirements.txt
                    コメント:  #ref: https://pip.pypa.io/en/latest/reference/requirements-file-format/#example
                        #
                実践:
                    requirements.txt と requirements.lock を使い分ける:  #keyword: pip requirements.lock
                        目的:
                            将来、古いバージョンの依存関係が崩れてエラーになる可能性があるため、
                            依存関係情報に頼らずに指定のバージョンをインストールします
                        仮想環境を作ります:
                            CreatePythonVenv 関数を使う場合:  #// #search: CreatePythonVenv
                                -   仮想環境のパスを指定します
                                -   requirements.txt と requirements.lock の内容を指定します
                                -   requirements.lock を作り直すかどうかは引数に指定します。
                                    スクリプトを起動するときに指定する requirements.lock を作り直すオプションを CreatePythonVenv 関数の引数に渡します
                                -   constraints.txt を指定することもできます
                            手動で行う場合:
                                作る場合:  #// 初回、または requirements.lock を新しく作りなおす場合
                                    書式:
                                        code  "${HOME}/bin/__VenvName__.requirements.txt"
                                            __Package__
                                            __Package__
                                                (or)
                                            __Package__==__Version__
                                        source __ActivateVenv__
                                        pip install -r  "${HOME}/bin/__VenvName__.requirements.txt"
                                        pip freeze >    "${HOME}/bin/__VenvName__.requirements.lock"
                                    サンプル: |
                                        echo  $USER  #// manual check
                                        cd  "${HOME}/bin"
                                        code  "${HOME}/bin/ansible-venv.requirements.txt"
                                            ansible==9.1.0
                                        rm -rf  ansible-venv
                                        python3.11 -m venv  ansible-venv
                                        source  "${HOME}/bin/ansible-venv/bin/activate"
                                        pip install -r "${HOME}/bin/ansible-venv.requirements.txt"
                                        pip freeze   > "${HOME}/bin/ansible-venv.requirements.lock"
                                        ansible --version  #// 2.16.2
                                        pip show ansible  #// 9.1.0  https://docs.ansible.com/ansible/latest/roadmap/COLLECTIONS_9.html
                                使う場合:  #// requirements.lock を使う場合。存在するなら通常使います
                                    code  "${HOME}/bin/__VenvName__.requirements.txt"  "${____}"
                                        __Package__
                                        __Package__
                                            (or)
                                        __Package__==__Version__
                                    code  "${HOME}/bin/__VenvName__.requirements.lock"  "${____}"
                                        ...
                                    source __ActivateVenv__
                                    pip install -r  "${HOME}/bin/__VenvName__.requirements.lock"
                            #ref: https://qiita.com/methane/items/11219ceedb44c0ebcc75
            constraints.txt:  #// パッケージのバージョン指定。複数の requirements.txt で共通のバージョンのパッケージを使うようにします
                pip install -r requirements.txt -c constraints.txt
                #ref: https://qiita.com/methane/items/11219ceedb44c0ebcc75
            パッケージ >> バージョン:  #search: Python Package versions
        コード:  #// コード内でパッケージを利用または参照できるようにします
            import:  #keyword: Python import from,  Python import
                シンボル（クラス名など）を参照できるようにします:  #// from ____ import ____
                    絶対インポートで書く場合:  #// from ____ import ____
                        書式: from ____ import ____  #// from（または from のない import）のすぐ右をピリオド以外から始めるように書きます
                        サンプル: from  core.http  import  HttpClient  #// __Project__/core/http.py ファイルの中に定義された HttpClient クラスをインポートします
                        基準パス:  #// 以下両方を探します
                            - プロジェクトのルート または カレント フォルダー
                            - sys.path
                        ファイル名: ハイフンは使えません。アンダースコアや大文字は使えます
                        拡張子(.py): import 文には書きません
                        フォルダーの区切り: ピリオド
                    相対インポートで書く場合:  #// from .____ import ____  #keyword: Python relative import
                        注意:  #// 以下のいずれかの場合のみ使えます
                            - __package__ 属性が None かつ __name__ 属性が __main__ のとき
                            - Python コマンド起動時に -m オプションを付けたとき
                        書式: from .____ import ____  #// from（または from のない import）のすぐ右をピリオドから始めるように書きます
                        サンプル:
                            - from  .client  import  ConsulClient  #// ./client.py ファイルをインポートします
                            - from  .  import  client  #// from . は暗黙的な相対インポート（explict relative import）と呼ばれます
                        基準パス: import が書かれたファイルがあるフォルダー
                        参考: https://qiita.com/ysk24ok/items/2711295d83218c699276
                    参照するシンボルを複数定義する場合:
                        from ____ import __Symbol__, __Symbol__
                    __init__.py: #keyword: Python __init__.py  #// 公開するシンボルがあるファイルを設定するファイル
                        作らない場合:
                            __Project__/__Site__ の中の場合:  #// __init__.py を作る必要はありません
                                __Project__/urls.py: |
                                    from  example.module1.file1  import  function1   #// OK
                                __Project__/example/module1/file1.py: |
                                    def function1():
                                        pass
                            __Project__/__Site__ の外の場合:  #focus: function1  #// __init__.py を作らないとエラーになります
                                __Project__/urls.py: |
                                    from  example.module1.file1  import  function1   #// エラー
                                __Project__/example/module1/file1.py: |
                                    def function1():
                                        pass
                        作る場合:  #focus: function1,  import
                            __Project__/urls.py: |
                                from  example.module1.file1  import  function1   #// OK
                            __Project__/example/__init__.py: |
                                from .module1 import *
                            __Project__/example/module1/__init__.py: |
                                from .file1 import *
                            __Project__/example/module1/file1.py: |
                                __all__ = ['function1']  #keyword: Python __all__  #// import されます  #ref: https://docs.python.org/ja/3.13/tutorial/modules.html#importing-from-a-package

                                def function1():
                                    pass
                ファイルを別名で参照できるようにします:  #// from ____ as ____
                    サンプル: |
                        from  core.http  as  ht  #// __Project__/core/http.py ファイルが定義するクラスを ht から参照できるようにします
                        instance = ht.MyClass()
                development 用モジュールをインポートします: #keyword: Python development import
                    概要: development 用モジュールは関数内でインポートしてください。
                        そうしないと、リリース時（development 用モジュールが無い場合）にエラーになってしまいます。
                        development 用モジュールとは  #search: poetry add --dev
                    サンプル: |  #focus: import
                        if config.get('inspector', None):
                            enable_inspector(config['inspector'])

                        def enable_inspector():
                            import inspector
                            inspector.function()
                namespace package:  #// Python 3.3 以降の __init__.py がないとき
                    判断基準: import する対象のフォルダーに __init__.py ファイルがないとき
                    __path__: _NamespacePathオブジェクト
                    __file__: なし
                    公式: https://www.python.org/dev/peps/pep-0420/
                regular package:
                    判断基準: import する対象のフォルダーに __init__.py ファイルがあるとき
                    __path__: リスト
                循環参照対策:  #search: Python 相互 import
                エラー:  #keyword: Python import error trouble
                    #search: Import "__DotPath__" could not be resolved
                    #search: No module named
                    #search: Python import not found module
                    #search: Python cannot load module has no attribute
            import_module:  #keyword: Python import_module  #// 文字列で指定したモジュールを、動的にインポートします
            環境変数:  #// PYTHONPATH 環境変数
                PYTHONPATH 環境変数: #keyword: PYTHONPATH
                    サンプル:
                        PYTHONPATH="/path/to/add:$PYTHONPATH"
                    複数指定するとき:
                        コロン(:)で区切ります
                    VSCode:  #search: VSCode PYTHONPATH
                    参考:
                        Python で環境変数を操作します: #search: Python 環境変数
    middleware:  #keyword: Python middleware  #ref: ${programming}/スクリプト/Python.svg#middleware
Lint, ソース成形ツール:
    pylint: #keyword:
        チェックの例:
            no-member:  #keyword: pylint no-member  #ref: https://pylint.pycqa.org/en/latest/user_guide/messages/error/no-member.html
                ただし実際は使い物にならない。引数に指定されたオブジェクトのメンバーはチェックしないなど。
                    #ref: https://stackoverflow.com/questions/29494573/list-out-unimplemented-python-functions-without-running-the-application
                    #ref: ${GitHub}/MyPrivateCode/Python/try_Python_pylint/no_member_2.py#a = data.virtual__servers
        サンプル: #ref: ${GitHub}/MyPrivateCode/Python/try_Python_pylint/no_member_1.py
        __Project__/.vscode/settings.json : |
            "python.linting.pylintArgs": [
                "--disable", "missing-module-docstring",
                "--disable", "missing-function-docstring",
                "--disable", "missing-class-docstring",
                "--disable", "line-too-long",
                "--disable", "wrong-import-order",
                "--disable", "invalid-name"]
    isort: #keyword:  #ref: https://pypi.org/project/isort/  #// Shift + Alt + O
        インストール:
            VSCode 拡張機能:  #search: VSCode isort extension
            CLI: pip install isort
        ソート:
            VSCode で開いているファイル:  #search: VSCode isort extension
                Shift + Alt + O
            1つのファイル:  #// Python の import をソートするようにソースファイルを編集します
                isort __FolderOrFilePath__
            複数のファイル:  #// ブランチが編集したすべての .py ファイルの import をソートします
                git diff --name-only __BaseBranch__ | grep .py$ | xargs isort
    Flake8: #keyword:  #ref: https://github.com/pycqa/flake8
        VSCode 拡張機能:  #search: VSCode Flake8 extension
        flake の意味:  #// フレーク と読む
            小さな問題、かけら
        警告の対処法:  #search: VSCode Flake8 extension
            E128: continuation line under-indented for visual indent
            W504: line break after binary operator
                矛盾しているため、警告を抑制してください。
                #ref: https://stackoverflow.com/questions/57074300/what-is-the-recommended-way-to-break-a-long-if-statement-w504-line-break-after
    vulture: #keyword:  #// 静的解析ツール。使われていない Python 関数を探します（未確認）  #ref: https://pypi.org/project/vulture/
        #ref: https://scrapbox.io/PythonOsaka/Pythonの静的解析ツールVultureを使ってみよう
        インストール:
            pip install  vulture  #// など
        解析実行:
            date;  vulture  ".";  date
                #template__: vulture  __Folder__
        confidence:  #// 到達不能なコード
            100%  function/method/class argument, unreachable code
            90%   import
            60%   attribute, class, function, method, property, variable
            #// 100%未満の値は非常に大まかな推定値です
            #ref: https://pypi.org/project/vulture/  >>  Types of unused code
        サンプル: |
            $ vulture unuse.py
            unuse.py:2: Unused variable 'UNUSE'
            unuse.py:5: Unused class 'UnUse'
            unuse.py:6: Unused variable 'unuse_attr'
            unuse.py:8: Unused function 'unuse'
            unuse.py:9: Unused variable 'data'
            unuse.py:12: Unused function 'unuse_func'
            unuse.py:13: Unused variable 'func_data'
            services/unuse.py:600: unused import 'AntiSite' (90% confidence)
            services/unuse.py:622: unused method 'mock_time' (60% confidence)
            services/unuse.py:642: unused variable 'mock_time' (100% confidence)
機械学習:  #keyword:
    pandas: #keyword:  #// データ解析ライブラリ。Python 用。機械学習に限りません
        pandas.DataFrame: #keyword:
            resample:  #ref: https://note.nkmk.me/python-pandas-time-series-resample-asfreq/
                mean: |
                    df = df.resample('30Min').mean()
                カラム別混合: |
                    resampled_df = df.resample('30T').agg({
                        'A': 'sum',      # Aカラムにはsumを適用
                        'B': 'mean',     # Bカラムにはmeanを適用
                        'C': 'mean',     # Cカラムにもmeanを適用
                    })
            groupby sum:  #ref: https://sparkbyexamples.com/pandas/pandas-groupby-sum-examples/
                コード: |
                    df = df.groupby(lambda x: x.split('.')[0], axis=1).sum()
                引数:
                    x.split('.')[0]: 返り値が同じものをグループ化します。x はカラム名
                    axis=1: 処理対象が列方向
                解説:
                    例えば、以下のようなDataFrameがあったとします：
                        /  A.1  A.2  B.1  B.2  C.1
                        0    1    2    3    4    5
                        1    6    7    8    9   10
                    この処理を適用すると、「A.1」と「A.2」が「A」というグループに、
                    「B.1」と「B.2」が「B」というグループに、
                    「C.1」が「C」というグループになり、同じグループ内の列の値が合計されます：
                        /   A   B   C
                        0   3   7   5
                        1  13  17  10
            それぞれのデータに対して計算します:
                サンプル コード: |  #// 時間軸にサンプリングされた各種データをすべて 8 で割る場合
                    import pandas as pd

                    # サンプルデータを作成（複数の数値カラムを含む）
                    data = {
                        'timestamp': [
                            '2024-01-01 00:00:00', '2024-01-01 01:00:00', '2024-01-01 02:00:00',
                            '2024-01-01 03:00:00', '2024-01-01 04:00:00'
                        ],
                        'temperature': [20, 22, 24, 23, 21],
                        'humidity': [60, 58, 55, 57, 59],
                        'pressure': [1013, 1014, 1015, 1014, 1012]
                    }

                    df = pd.DataFrame(data)
                    df['timestamp'] = pd.to_datetime(df['timestamp'])

                    print("元のデータ:")
                    print(df)
                        # 元のデータ:
                        #             timestamp  temperature  humidity  pressure
                        # 0 2024-01-01 00:00:00           20        60      1013
                        # 1 2024-01-01 01:00:00           22        58      1014
                        # 2 2024-01-01 02:00:00           24        55      1015
                        # 3 2024-01-01 03:00:00           23        57      1014
                        # 4 2024-01-01 04:00:00           21        59      1012

                    # 数値型のカラムをすべて8で割る
                    numeric_columns = df.select_dtypes(include=['number']).columns
                    df[numeric_columns] = df[numeric_columns] / 8

                    print("すべての数値カラムを8で割った後のデータ:")
                    print(df)
                        # すべての数値カラムを8で割った後のデータ:
                        #             timestamp  temperature   humidity   pressure
                        # 0 2024-01-01 00:00:00        2.500   7.500000  126.62500
                        # 1 2024-01-01 01:00:00        2.750   7.250000  126.75000
                        # 2 2024-01-01 02:00:00        3.000   6.875000  126.87500
                        # 3 2024-01-01 03:00:00        2.875   7.125000  126.75000
                        # 4 2024-01-01 04:00:00        2.625   7.375000  126.50000

                    print("\n統計情報:")
                    print(df.describe())
                        # 統計情報:
                        #     temperature   humidity    pressure
                        # count     5.000000   5.000000    5.000000
                        # mean      2.750000   7.225000  126.700000
                        # std       0.206155   0.240723    0.145774
                        # min       2.500000   6.875000  126.500000
                        # 25%       2.625000   7.125000  126.625000
                        # 50%       2.750000   7.250000  126.750000
                        # 75%       2.875000   7.375000  126.812500
                        # max       3.000000   7.500000  126.875000
            デバッグ表示: #keyword: pandas.DataFrame print
                #// デバッガーでは print は不要です
                df.info: |  #// カラム一覧
                    print(df.info())
                        <class 'pandas.core.frame.DataFrame'>
                        DatetimeIndex: ____ entries, __FromDateTime__ to __ToDateTime__
                        Data columns (total ____ columns):
                        __ColumnName__      __NonNullCount__ non-null __Type__
                        __ColumnName__      __NonNullCount__ non-null __Type__
                        __ColumnName__      __NonNullCount__ non-null __Type__
                        dtypes: __Type__(__Count__)
                        memory usage: _____ KB
                df.head: |
                    print(df.head(5))
                        item_id                      __ColumnName1__  __ColumnName2__
                        datetime
                        2025-01-01 00:00:00+09:00           100             200
                        2025-01-01 00:00:01+09:00           101             202
                        ....
                    print(df['__ColumnName1__'].head())
                        datetime
                        2025-01-01 00:00:00+09:00           100
                        2025-01-01 00:00:01+09:00           101
                        ....
                df.loc:  #// 指定の時間範囲の特定のカラムの値の一覧
                    df.loc['2025-04-24 18:00:00+09:00':'2025-04-24 19:00:00+09:00', '__ColumnName1__']
                df.describe: |  #// サンプル数と平均値など
                    print(df.describe())
                        count: 各列の非欠損値の数（サンプル数）
                        mean: 各列の平均値
                        std: 各列の標準偏差（データのばらつきを示す）
                        min: 各列の最小値
                        25%: 各列の第1四分位数（データを小さい順に並べたときの25%の位置にある値）
                        50%: 各列の中央値（メディアン）
                        75%: 各列の第3四分位数（データを小さい順に並べたときの75%の位置にある値）
                        max: 各列の最大値
                特定のカラムの値の個数:
                    print(df['__ColumnName__'].value_counts())
                        __Value1__ __Conut1__
                        __Value2__ __Conut2__
                        __Value3__ __Conut3__
        iterrows: #keyword: pandas iterrows  #// 行を取り出します
            コード: |
                import pandas as pd
                
                df = pd.read_excel('example.xlsx')
                for index, data in df.iterrows():
                    print('--------')
                    print(index)
                    print(data[0])
                    print(data['名前'])
                    print(data)
            example.xlsx:
                名前  職業
                ----------
                田中  会社員
                佐藤  自営業
            出力: |
                --------
                0
                田中
                田中
                名前  田中
                職業  会社員
                --------
                1
                佐藤
                佐藤
                名前  佐藤
                職業  自営業
        構成:
            行:  #// ロウ, 行名, インデックス, 行のラベル
            列:  #// カラム, 列名, カラム名, 列のラベル
                デバッグ表示:  #search: Python VSCode DEBUG CONSOLE
                    df.columns  #// カラム名を一覧します
    Pythonで不動産データ分析: https://myfrankblog.com/machine-learning-analysis-for-real-states-data/
        データの整形がいちばん大事
コマンド: #keyword: Python commands  #glossary:
    python:
    python -m:
        sys.path からモジュールまたはパッケージを検索します。
        パッケージなら、__main__.py を実行します。
        それ以外は、-m オプションなしと同じです。
    pip: #search:
    pyenv: #search:
    poetry: #search:
    pytest: #search:
Microsoft Store からダウンロードする:
    - Windows キーを押して PowerShell とキーボードから入力して PowerShell を開きます
    - python （とシェルに入力）
    - Microsoft Store からインストール（例）バージョン 3.9.1
    #// 環境変数 Path には登録されませんが python, pip コマンドが使えるようになりますが、
    #// WARNING: The script virtualenv-clone.exe is installed in 'C:\____' which is not on PATH.
動作のしくみ: #keyword: Python しくみ,  Python 動作 しくみ 高速化 CPython
    バイトコード: #keyword: Python バイトコード
        #ref: https://www.python.jp/news/wnpython311/specializing-adaptive.html
        サンプル: |
            >>> def func_add(a, b):
                    return a + b
            >>> dis.dis(func_add)
                2           0 LOAD_FAST                0 (a)
                            2 LOAD_FAST                1 (b)
                            4 BINARY_ADD
                            6 RETURN_VALUE
    特殊化適応的インタープリター: #keyword: Python 特殊化適応的インタープリター, Python Specializing Adaptive interpreter
        概要: バイトコードをキャッシュ的に変えます
        適合的: Adaptive
        サンプル: |  #focus: BINARY_ADD,  BINARY_ADD_UNICODE
            >>> def func_add(a, b):
                    return a + b
            >>> dis.dis(func_add)
                2           0 LOAD_FAST                0 (a)
                            2 LOAD_FAST                1 (b)
                            4 BINARY_ADD
                            6 RETURN_VALUE
            >>> func_add("abc", "def")
                    abcdef
            >>> dis.dis(func_add)
                2           0 LOAD_FAST                0 (a)
                            2 LOAD_FAST                1 (b)
                            4 BINARY_ADD_UNICODE
                            6 RETURN_VALUE
トラブルシューティング:
    デバッグ実行:  #search: Python debug
    手順:
    - #// lambda で発生する例外をデバッグする  #search: LambdaDebugTracer for Python
    - #// self signed certificate
        手順: xmlrpc.client.ServerProxy('https://____')
        エラー: |
            ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: self signed certificate (_ssl.c:1056)
        対処:
            #search: _create_unverified_context
    - #// venv（仮想環境）の中でブレークさせる
        __Project__/launch.json : |
            {
                "version": "0.2.0",
                "configurations": [
                    {
                        "justMyCode": false
    - #// 属性が表示されない（ウォッチ ビュー）
        手順: VSCode の ウォッチ ビュー（左）でオブジェクトを展開したとき
        症状: コードに書かれている属性がウォッチに表示されない
        対処A: 名前マングリング
        対処B: デバッグ コンソール（右下のビューのタブ）で属性を入力して Enter を押すと
            値が表示されますが、この操作によってウォッチにも属性が表示されるようになります
    - #// 属性が表示されない（インテリセンス）
        手順: テキスト エディター でオブジェクトの右でピリオドを入力したとき
        症状: コードに書かれている属性がウォッチに表示されない
        対処:
            型ヒントを書く
            import をファイル名にしない
                修正前 from folder import file.Class
                修正後 from.file folder import Class
    - #// エラーメッセージを読む
        書式: |
            Traceback (most recent call last):
                main 側のコードの場所
                深い方のコードの場所
                エラーメッセージ
            The above exception was the direct cause of the following exception:
            (上記の例外は、次の例外の直接の原因でした)
                main 側のコードの場所
                深い方のコードの場所
                エラーメッセージ
        説明:
            - 上のコール スタックは、最初の raise
            - 下のコール スタックは、呼び出し元側の raise 。
                main から表示される可能性が高い。
            #ref: ${programming}/スクリプト/Python.svg#error_message
    - #// pp, ref_debug_out:  #ref: ${GitHub}/MyPrivateCode/Python/pp.py
    - #// 呼び出し先が期待と違う  #keyword: Python not expected call
        手順: _Example__method を呼び出す
        エラー: |  #// 呼び出しているメソッドではないエラー
            TypeError: __method() missing 1 required positional argument: '__Argument__'
        原因:
            名前マングリングによって __method を呼び出そうとしています。
            上記の引数不足のエラーは、呼び出し先の __method の引数より、
            呼び出し元の _Example__method に指定した引数が不足しているというエラーです
            #search: name mangling
        対処A:
            _Example__method または __method の引数を編集します
        対処B:
            動的に引数の名前や構成を調べます: #search: watch Python function arguments
    - #// スルー カウンター:  #keyword: Python through counter
        サンプル: |
            ### debug
            cc = 0
            ###

            def do_anything(x):
            ### debug
                global cc
                cc += 1
            ###
    - #// HTTP リクエストの関数がコールバックされない
        Django cache にヒットした可能性:  #search: Django's cache framework
    - #// スレッドのデバッグ  #search: debug Python thread
    個別エラー:
    - #// TypeError: __init__() got an unexpected keyword argument '__Keyword__'
        手順:
            オブジェクト生成時
        ログ: |
            TypeError: __init__() got an unexpected keyword argument '__Keyword__'
        対処:
            
    - #// VSCode で Python のデバッグを起動したとき AttributeError: module 'matplotlib' has no attribute 'rcParams' と表示されてデバッグ対象のプロセスを起動できない
        手順: VSCode で Python のデバッグを起動
        ログ: |
            AttributeError: module 'matplotlib' has no attribute 'rcParams'
        対処:
            ブレークポイントをすべて削除します
    - #// TypeError: __new__() missing 2 required positional arguments: '__Argument1__' and '__Argument2__'
        手順: |  #// クラス定義時にエラーになります
            class TemporaryClass(__SuperClass__):
                ____
        ログ: |
            TypeError: __new__() missing 2 required positional arguments: '__Argument1__' and '__Argument2__'
        対処:
            class TemporaryClass の引数に追加します: |
                class TemporaryClass(__SuperClass__, __Argument1__=__Value1__, __Argument2__=__Value2__):
        補足:
            これらの引数は、__SuperClass__ のクラス type(__SuperClass__) が要求しているようです。
    - #// cannot load: module '__PeriodPath__' has no attribute '__FileName__'  #keyword: Python cannot load module has no attribute ModuleNotFoundError: No module named
        手順: python 実行
        エラー: |
            cannot load: module '__PeriodPath__' has no attribute '__FileName__'
            ModuleNotFoundError: No module named '__PeriodFilePath__.__ClassName__'; '__PeriodFilePath__' is not a package
        対処A:
            __Class__ でエラーになる場合:  #// ピリオドを含まない場合
                -   pip install などで Python パッケージ をインストールします
                -   パッケージがローカルにあるときは pip install の -f オプションを使います  #search: pip install -f
        対処B:
            path.to.file.Class でエラーになる場合:  #// __PeriodFilePath__.__ClassName__ でエラーになる場合
                from path.to.file  import Class に変えてください
    - #// Could not find a version that satisfies the requirement pip<21.0
        手順: pyenv
        エラー: |
            ERROR: Could not find a version that satisfies the requirement pip<21.0 (from versions: none)
            ERROR: No matching distribution found for pip<21.0
        対処:
    - #// Could not find config for 'Cache' in settings.CACHES
        #search: Django multi cache
    - #// ImportError: libmysqlclient.so.21: cannot open shared object file: No such file or directory
        #search: MySQL Python libmysqlclient trouble
        #search: LD_LIBRARY_PATH
    - #// cannot import name 'soft_unicode' from 'markupsafe'
        手順: poetry run python manage.py compilemessages -l ja 
        エラー: |
            cannot import name 'soft_unicode' from 'markupsafe'
        対処:
            poetry add  markupsafe==2.0.1
            #ref: https://stackoverflow.com/questions/72191560/importerror-cannot-import-name-soft-unicode-from-markupsafe
    - #// Couldn't import Django. Are you sure it's installed and available on your PYTHONPATH environment variable? Did you forget to activate a virtual environment?
        手順: manage.py
        エラー: |
            Couldn't import Django. Are you sure it's installed and available on your PYTHONPATH environment variable? Did you forget to activate a virtual environment?
            ModuleNotFoundError: No module named 'django'
        対処:
            仮想環境を正しく設定します  #search: Python venv
    - #// rest_framework/api.html TemplateDoesNotExist
        手順: ブラウザーで Django REST framework の view を呼び出そうとしたとき
        エラー: |  #// ブラウザーで開いて
            rest_framework/api.html
            Exception Type: TemplateDoesNotExist
        対処:
            curl を使ってください
    - #// .accepted_renderer not set on Response
        手順: Django REST framework から Django view の関数を呼び出そうとしたとき
        エラー: |  #// ブラウザーで開いて
            .accepted_renderer not set on Response
        対処:
            (@api_view) を関数に付けます  #search: Django view function
    - #// django.core.exceptions.ImproperlyConfigured: Requested setting REST_FRAMEWORK
        手順: Django REST framework のライブラリのメソッドを呼び出したとき
        エラー: |
            django.core.exceptions.ImproperlyConfigured: Requested setting REST_FRAMEWORK,
            but settings are not configured.
            You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.
        対処:
            Django REST framework のライブラリを使うときは、
            Django view から呼ばれる関数などの中からメソッドを呼び出すようにします。
            #ref: ${GitHub}/MyPrivateCode/Python/DjangoREST/try_DjangoREST/examples/serializer/serialize_1.py
    - #// django.core.exceptions.ImproperlyConfigured: settings.DATABASES is improperly configured. Please supply the ENGINE value. Check settings documentation for more details.
        手順:  python manage.py test tutorial/app1/tests
        エラー: |
            django.core.exceptions.ImproperlyConfigured: settings.DATABASES is improperly configured. Please supply the ENGINE value. Check settings documentation for more details.
        対処:
            TestCase クラスから継承したクラスを SimpleTestCase から継承するように変更します
        #ref: https://stackoverflow.com/questions/5917587/django-unit-tests-without-a-db
    - #// Django configure_logging  Unable to configure handler 'file'
        手順: python ./migrate.py  または  django.core.cache の set メソッド  #// Django
        エラー: |
            File "__Project__/.venv/lib/python3.7/site-packages/django/__init__.py", line 19, in setup
                configure_logging(settings.LOGGING_CONFIG, settings.LOGGING)
            File "__Project__/.venv/lib/python3.7/site-packages/django/utils/log.py", line 76, in configure_logging
                logging_config_func(logging_settings)
            File "__Python__/lib/python3.7/logging/config.py", line 799, in dictConfig
                dictConfigClass(config).configure()
            File "__Python__/lib/python3.7/logging/config.py", line 570, in configure
                '%r' % name) from e
            ValueError: Unable to configure handler 'file'
        対処:
            設定変数 LOGGING の handlers >> file >> filename に書かれたフォルダーを作ります
    - #// Django sqlite3 django.db.utils.OperationalError: unable to open database file
        手順: python ./migrate.py  または  django.core.cache の set メソッド  #// Django
        エラー: |
            File "__Project__/.venv/lib/python3.7/site-packages/django/db/backends/sqlite3/base.py", line 159, in get_new_connection
                conn = Database.connect(**conn_params)
            django.db.utils.OperationalError: unable to open database file
        対処:
            設定変数 DATABASES の NAME に書かれたフォルダーを作ります
    - #// django.core.cache  unable to open database file
        手順: django.core.cache の set メソッド
        エラー: |
            django.db.utils.OperationalError: no such table: persistent_cache_table
        対処:
            poetry run ./manage.py migrate
            poetry run ./manage.py createcachetable
    - #// Command 'python' not found
        手順: source ".venv/bin/activate"  &&  python
        エラー: |
            Command 'python' not found
        対処:
            echo $PATH で表示される最初のパスが仮想環境のパスではない場合:
                仮想環境を作りなおします
    - #// "No module named '____'; '____' is not a package"
        手順: import_module を呼び出す
        エラー: |
            "No module named '____'; '____' is not a package"
        対処:
            - クラス名ではなくパッケージ（フォルダー）を指定します。
            - フォルダー名を変えます（公開パッケージと衝突しないようにする）
            - __pycache__ を削除します。
    - #// pyenv: version `3.7.2' is not installed (set by ____)
        手順: Gradle
        エラー: |
            pyenv: version `3.7.2' is not installed (set by ____)
        対処:
            pyenv 環境に Python 3.7.2 をインストールします  #search: install pyenv
    - #// A server error occurred.  Please contact the administrator.
        手順: curl で Django にリクエスト
        エラー: |
            A server error occurred.  Please contact the administrator.
        対処:
            サーバーのログを確認してください
    - #// manage.py runserver: error: unrecognized arguments: --insecure  #keyword: --insecure
        手順: manage.py --insecure ...
        エラー: |
            manage.py runserver: error: unrecognized arguments: --insecure
        対処:
            #ref: https://docs.djangoproject.com/en/dev/ref/contrib/staticfiles/#cmdoption-runserver-insecure
    - #// TypeError: 'NoneType' object is not iterable
        手順: items.reverse()
        エラー: |
            TypeError: 'NoneType' object is not iterable
        対処:
            items[::-1]  #// items.reverse()
            #search: Python reverse
        原因:
            len(items) == 0 のとき、items.reverse() は例外  を発生します
    - #// The "python.pythonPath" setting in your settings.json is no longer used by the Python extension.
        手順: VSCode の Python 拡張機能をインストールする
        エラー: |
            The "python.pythonPath" setting in your settings.json is no longer used by the Python extension.
            If you want, you can use a new setting called "python.defaultInterpreterPath" instead.
            Keep in mind that you need to change the value of this setting manually as the Python extension doesn’t modify it when you change interpreters.
            settings.json の "python.pythonPath" 設定は、Python 拡張機能では使用されなくなりました。
            必要に応じて、代わりに「python.defaultInterpreterPath」という新しい設定を使用できます。
            この設定の値は、インタープリターを変更しても Python 拡張機能によって変更されないため、手動で変更する必要があることに注意してください。
        対処:
            無視できます。
        python.defaultInterpreterPath: #keyword:
            #ref: https://github.com/microsoft/vscode-python/wiki/Setting-descriptions#pythondefaultinterpreterpath
    - #// remove __pycache__ / .pyc files and/or use a unique basename for your test file modules
        手順: pytest を使う環境での Testing アイコンのリロード
        エラー: |
            import file mismatch:
            imported module '__FileBaseName__' has this __file__ attribute:
            c:\__FoldersA__\__FileBaseName__.py
            which is not the same as the test file we want to collect:
            c:\__FoldersB__\__FileBaseName__.py
            HINT: remove __pycache__ / .pyc files and/or use a unique basename for your test file modules
        対処:
            異なるフォルダーにあってもファイル名 __FileBaseName__ が同じにならないようにします。
    - #// AttributeError: 'Object' object has no attribute '__Attribute__'
        手順: |
            object = Object()
            object.attr = 1
        エラー: |
            AttributeError: 'Object' object has no attribute '__Attribute__'
        対処: |
            class  TmpObject:
                def __init__(self):
                    self.attr = 1
            object = TmpObject()
    - #// pytest のツリーが表示されない
        #search: pytest Testing error
    - #// ModuleNotFoundError No module named  #keyword: No module named,  Python import not found module
        手順: Python を実行します。import 実行時
        エラー: |  #keyword: ModuleNotFoundError,  ModuleNotFoundError:
            ModuleNotFoundError: No module named 'myapp1'
        対処:
            仮想環境のパスを確認します:
                #search: which python
                #search: Python Select Interpreter
            シンボリックリンクの場合:
                シンボリックシンクで共有している Python ファイルでエラーが発生する場合、
                それぞれのフォルダーにおいて、from 文 や import 文 に書かれたパスが指す先が存在するかどうかをチェックしてください。
            Python パッケージを確認する場合:
                Poetry を使うプロジェクトの場合:
                    poetry.lock ファイルの中でエラーが発生したモジュールを検索します
            Python パッケージを追加する場合:
                #search: add Python package
            VSCode のターミナルで仮想環境をアクティベートしたくない場合:
                #search: VSCode Python version
            Python のバージョンが違う場合:
                poetry を使っている場合:
                    #search: poetry rebuild
            PATH (sys.path) を確認する場合:  #keyword: Python sys.path
                _: import するフォルダーのルートは、環境変数 PATH などです
                サンプル:
                    エラーが発生するコード:
                        from __future__ import annotations
                    PATH を確認するように一時的に変更したコード:  #// このコードは Python インタープリター に入力することもできます
                        # from __future__ import annotations
                        import sys
                        print(sys.path)
                        raise ValueError(f"eeeeeeee")
                    出力例: |
                        ['/home/user1/my_application/api'
                        '/home/user1/.pyenv/versions/3.7.1/lib/python37.zip'
                        '/home/user1/.pyenv/versions/3.7.1/lib/python3.7'
                        '/home/user1/.pyenv/versions/3.7.1/lib/python3.7/lib-dynload'
                        '/home/user1/my_application/api/.venv/lib/python3.7/site-packages']
            .py ファイルの名前がライブラリ名に一致する場合:
                .py ファイルの名前を import するライブラリ名とは異なる名前に変更します。
            プロジェクト内にあるファイルが見つからない場合:
                環境変数 PYTHONPATH に myapp1 フォルダーが
                あるフォルダーのパスを設定します（見つからなかったモジュールの場所によって異なります）。 
                この環境変数とは、バッチファイルやコマンドプロンプトの環境変数のことです。
            PYTHONPATH を設定します:
                #search: PYTHONPATH
    - #// Import "__DotPath__" could not be resolved
        手順:  from __DotPath__ import __Symbol__
            __DotPath__ に含まれるフォルダー名を変更したとき
        エラー: |  #// VSCode 静的解析で表示されるエラー
            Import "__DotPath__" could not be resolved
        対処:
            VSCode のウィンドウを開きなおします
    - #// [Errno 2] No such file or directory:
        手順: デバッガーで起動
        エラー: |
            def islink(path):
                """Test whether a path is a symbolic link"""
                try:
                    st = os.lstat(path)
        対処:
            Raised Exceptions のブレークポイントを解除してください
    - #// pip install >> ModuleNotFoundError: No module named 'request'
        手順: python -m pip install -r____/requirements.txt -c____/constraints.txt^C
        エラー: |
            Collecting http
                Using cached http-0.02.tar.gz (32 kB)
                    Preparing metadata (setup.py) ... error
                    error: subprocess-exited-with-error
                    
                    × python setup.py egg_info did not run successfully.
                    │ exit code: 1
                    ╰─> [8 lines of output]
                            Traceback (most recent call last):
                                File "<string>", line 36, in <module>
                                File "<pip-setuptools-caller>", line 34, in <module>
                                File "/tmp/pip-install-eu1wlvyu/http_3bec5b3ae42f4d2aab046fa40ea387bc/setup.py", line 3, in <module>
                                    import http
                                File "/tmp/pip-install-eu1wlvyu/http_3bec5b3ae42f4d2aab046fa40ea387bc/http/__init__.py", line 17, in <module>
                                    from request import Request
                            ModuleNotFoundError: No module named 'request'
                            [end of output]
                    
                    note: This error originates from a subprocess, and is likely not a problem with pip.
                error: metadata-generation-failed
                
                × Encountered error while generating package metadata.
                ╰─> See above for output.
        対処:
            requirements.txt に書かれている Python パッケージのうち、
            Collecting に書いてあるパッケージ（上記 http）が正しいかチェックします。
        note: This is an issue with the package mentioned above, not pip.
        hint: See above for details.
    - #// ERROR: InvocationError for command could not find executable .tox/server/bin/python
        手順: tox -e server
        エラー: |
            ERROR: InvocationError for command could not find executable .tox/server/bin/python
        対処:
            修正前: |  #// 下記 testenv:server は tox -e server のときの対象となる設定です
                [testenv:server]
                commands =
                    .tox/server/bin/python ....
            修正後A: |  #// PATH が通ったパスにします。相対パスやシンボリックリンクのリンク元のパスは指定できません
                [testenv:server]
                commands =
                    python ....
            修正後B: |  #// フルパスにします
                [testenv:server]
                commands =
                    /__Project__/.tox/server/bin/python ....
    - #// partially initialized module 'argparse' has no attribute 'ArgumentParser' (most likely due to a circular import)
        手順: .py ファイル実行開始時。import 実行時
            import argparse
        エラー: |
            Exception has occurred: AttributeError
            partially initialized module 'argparse' has no attribute 'ArgumentParser' (most likely due to a circular import)
        対処:
            .py ファイルの名前を import するライブラリ名とは異なる名前に変更します。
    - #// version solving failed. 最新版ではサポートしていないバージョンがあるエラー
        手順: poetry add
        エラー:
            #focus: django-cors-headers, 3.10.1, Django, 2.1.15
            Because django-cors-headers (3.10.1) depends on Django (>=2.2)
            and no versions of django-cors-headers match >3.10.1,<4.0.0, django-cors-headers (>=3.10.1,<4.0.0) requires Django (>=2.2).
            So, because __Application__ depends on both Django (2.1.15) and django-cors-headers (^3.10.1), version solving failed.
        対処:
            対応している Django のバージョンが PyPi の django-cors-headers に書いてあるので、
            適切なバージョンの django-cors-headers をインストールします。
            #search: PyPi  #// Python Package Index
            #search: poetry add
        参考:
            構成のバージョンアップ:  #search: version upgrade debug
    - #// invalid method signature
        手順: pytest refresh
        エラー: |
            During handling of the above exception, another exception occurred:
            Could not determine arguments of <bound method TestWithMock.module1_MyClass of <s42_test.TestWithMock object at 0x0000020BF95C06A0>>:
            invalid method signature
        対処:
            TestWithMock.module1_MyClass メソッドに self 引数を追加します
    - #// AttributeError: module '__From__' has no attribute '__PublicSymbol__'
        手順: ビルド時。 from . import __sub__ したシンボルから .（ピリオド）でたどる __PublicSymbol__ を参照したとき
            import path.to.module as Module
            Module.__PublicSymbol__
        エラー: |
            AttributeError: module '__From__' has no attribute '__PublicSymbol__'
        対処: |
            __all__ に '__PublicSymbol__' を追加します
    - #// Pytest Discovery Error. Error discovering pytest tests (see Output > Python)
        #search: pytest Testing error
    - #// ImportError: attempted relative import with no known parent package
        手順: from . import __sub__ 実行時
        エラー: |
            ImportError: attempted relative import with no known parent package
            （訳：ImportError：既知の親パッケージがない状態で相対インポートを試行しました）
        対処:
            from . import __sub__ の場合: |
                import __sub__ に変更します
            from .sub import __sub__ の場合: |
                from sub import __sub__ に変更します
        解説:
            import を書くファイルがパッケージの外の場合:
                import 文を書き換える場合:
                    相対インポートが使えないので、絶対インポートに書き換えます
                Python の起動オプションを変える場合:
                    -m オプションを追加することで、パッケージの中にします
            import を書くファイルがパッケージの中の場合:
                相対インポートが使えるので、上記のエラーになりません
    - #// 相互 import して ImportError: cannot import name '__InterfaceA__' from 'folder.file'
        手順: Python 実行時
        エラー: |
            ImportError: cannot import name '__InterfaceA__' from 'folder.file'
        対処A:
            __all__ に __InterfaceA__ を追加します  #search: Python __all__
        対処B:
            相互 import しないようにします。たとえば、インターフェースを別のファイルに分けます
        #search: Python 相互 import
    - #// expected a bytes-like object, str found
        手順: regexp sub メソッド  #search: Python regexp sub
        エラー: expected a bytes-like object, str found
        対処: 文字列に .encode() メソッドを呼び出します。 a_string.encode()
    - #// SyntaxError self.async
        手順: Python を実行します
        エラー: |
            File "/home/____/.pyenv/versions/3.7.1/lib/python3.7/site-packages/kafka/producer/simple.py", line 54
                return '<SimpleProducer batch=%s>' % self.async
            SyntaxError: invalid syntax
        対処:
            pip install kafka kafka-python
        参考:  https://stackoverflow.com/questions/65809459/syntaxerror-on-self-async-when-running-python-kafka-producer
    - #// makemigrations と migrate したら Duplicate が出る:
        エラー: |
            django.db.utils.OperationalError: (1060, "Duplicate column name '__Field__'")
        参考:
            #// 以下は今回の方法とは違うが
            - https://stackoverflow.com/questions/36016485/duplicate-column-name
            - https://stackoverflow.com/questions/39165779/duplicate-column-name-model-id-django-mysql-error-on-migrate
        MySQL コマンドライン ツールで現在のスキーマの内容を調べて model.py を合わせます:
        MySQL コマンドライン ツールで問題のフィールドを削除します:
            mysql> alter table __Table__ drop column __Field__
        スキーマを同期します:
            - python manage.py makemigrations
            - python manage.py migrate
            #// MySQL は問題のフィールドが追加されます
            #//プロジェクトは migrations フォルダーが更新されます
        プロジェクトのバックアップを取ります:
        リポジトリに保存されないファイルを削除します: git clean -Xdf
        MySQL を再起動します:
            - docker-compose down
            - docker-compose up --build
        スキーマを同期します(2):
            - python manage.py makemigrations
            - python manage.py migrate
        念のためスキーマを変更できることを確認します:
            - model.py の変更
            - python manage.py makemigrations
            - python manage.py migrate
        プロジェクトのバックアップからリストア:
        リストアが正しくできたことを確認します:
            docker-compose down
            docker-compose up --build
            python manage.py makemigrations
            python manage.py migrate
        git commit する:
    - #// TypeError: non-default argument '____' follows default argument
        手順: pytest のリロード時など
        エラー: |
            ValueError: No mandatory attributes allowed after an attribute with a default value or factory.  Attribute in question: Attribute(name='records', default=NOTHING, validator=None, repr=True, cmp=True, hash=None, init=True, metadata=mappingproxy({}), type=typing.List[typing.Any], converter=None, kw_only=False)
            TypeError: non-default argument 'price' follows default argument
        対処:
            状況: スーパークラスにデフォルト値は指定できないようです。
            サンプル: |  #focus: name
                from dataclasses import dataclass

                @dataclass
                class SuperClass:
                    name: str = ''

                @dataclass
                class SubClass(SuperClass):
                    price: int

                object = SubClass(name='a', price=100)
                print(object)
    - #// An error occurred while installing pyyaml!
        手順: pipenv install pyyaml
        エラー: |
            Courtesy Notice: Pipenv found itself running within a virtual environment, so it will automatically use that environment,
            instead of creating its own for any project. You can set PIPENV_IGNORE_VIRTUALENVS=1
            to force pipenv to ignore that environment and create its own instead. You can set PIPENV_VERBOSITY=-1 to suppress this warning.
            Installing pyyaml...
            Error:  An error occurred while installing pyyaml!
            Error text:
        対処:
            .venv を作り直す(?) #search: pipenv sync
    - #// AssertionError: assert None
        手順: assert mock_create_host.assert_has_calls([call(
        エラー: |
            E       AssertionError: assert None
            E        +  where None = ____________
        対処:
            修正前: assert mock_create_host.assert_has_calls([call(
            修正後: mock_create_host.assert_has_calls([call(
        原因:
            assert に None が指定されました
    - #// Could not find a version that satisfies the requirement
        手順: pip install
        エラー: |
            Could not find a version that satisfies the requirement __Package__==__Version__
            (from -r __Path__/requirements.txt (line __LineNum__)) (from versions: __FromVersion__)
            No matching distribution found for __Package__==__Version__
            Looking in links: /local/common-pypi
        エラー2: |
            :stderr:   Could not find a version that satisfies the requirement dulwich<0.22.0,>=0.21.2 (from poetry==1.4.2) (from versions: )
            No matching distribution found for dulwich<0.22.0,>=0.21.2 (from poetry==1.4.2)
        ヒント:
            - 標準エラー出力に書かれているパッケージについて対処してください。
            - 標準出力に書かれているパッケージは依存関係があるパッケージについても書いてあります
        対処A:
            dulwich 0.21.2 などを .wheel を入れるリポジトリに登録します  #search: pip download requirements.txt
        対処B:  #// インターネットではなく社内サーバーなどに .wheel のリポジトリがある場合。既存のパッケージのバージョンが勝手に上がってしまった場合
            リポジトリにあるバージョンに固定します。エラーメッセージの (from versions に候補が書いてあります。
            #search: Python Wheel repository
        対処C:
            pip をバージョンアップします  #search: pip --upgrade
        対処D:
            pip download コマンドを使って、パッケージが現在のプラットフォームにインストールできることをチェックします  #search: pip download one
        互換性情報:  #search: Python Wheel platform
    - #// pipenv install request
        手順: pipenv install request
        エラー: |
            > pipenv install request
            Installing request...
            Error:  An error occurred while installing request!
            Error text:
            ERROR: Could not find a version that satisfies the requirement request (from versions: none)
            ERROR: No matching distribution found for request
        対処:
            request は提供されなくなったようです。
            request を使う ソース ファイル は、ビルド対象から外してください
