#keyword: JavaScript.yaml, js, TypeScript, ts  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg
検索: #ref: https://typescriptbook.jp >> 検索（右上）
記号: #keyword:  #ref: https://book.yyts.org/symbols-and-keywords
    =>: #// アロー関数, 無名の関数
    (#):  #search: ECMAScript private prefix
    (&&), (||):  #search: JavaScript && ||
    (?): #keyword: TypeScript ?
        関数の引数の ?:  #search: TypeScript optional argument
        インターフェースのプロパティの ?:  #search: TypeScript option argument
    (??): #keyword: TypeScript ??  #search: nullish coalescing operator ??
    (__):  #// メソッド名の接頭辞の __  #search: JavaScript サブルーチン メソッド
    (!!):  #// Boolean 型 にします
    ...:  #// スプレッド構文  #search: JavaScript spread operator
    <>, </>: #search: React.Fragment
    "{' '}": #// 空白のコード JSX(?)
    "{[__DummyName__: __IndexType__]: __ItemType__}":  #search: 連想配列
    "type __Type__ = ____${__TypedExpression__}____":  #search: テンプレート リテラル 型
    "type ____<Type> = {  __Modifiers__  [Property in keyof Type]__Modifiers__: __PropertyType__":  #search: Mapped Types
    大文字小文字: #keyword: TypeScript 大文字小文字
        大文字から始まるシンボル >> パスカル ケース: クラス, インターフェース
        小文字から始まるシンボル >> キャメル ケース: 関数, 変数
        大文字のみのシンボル >> 大文字の スネーク ケース: 定数
手順:  #// JavaScript TypeScirpt を試す, デバッグ方法
    プロジェクト:  #search: Node.js projects
        try_TypeScript_Node_js:  #ref: ${GitHub}/Trials/try_TypeScript_Node_js
            #search: try_TypeScript_Node_js
    Playground: #keyword: JavaScript playground
        TypeScript Playground: #ref: https://www.typescriptlang.org/play
        JavaScript CodePen: #ref: https://codepen.io  >>  Start Coding（左上） >>  JS  #// コーディングすると自動実行します
            #// 出力は Console の上端を上に広げると見えます
        JSFiddle:  #ref: https://jsfiddle.net/  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#JSFiddle
        MDN で試す: #// https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Math/max
    バージョン: #keyword:
        概要: #ref: https://www.tohoho-web.com/js/what.htm
        ES2020: ECMAScript 2020, ES11
        ES2019: ECMAScript 2019, ES10
        ES2018: ECMAScript 2018, ES9
        ES2017: ECMAScript 2017, ES8
        ES2016: ECMAScript 2016, ES7
        ES2015: ECMAScript 2015, ES6
        ES5.1: ECMAScript 5.1th Edition
        ES5: ECMAScript 5th Edition
    公式: #keyword: TypeScript official tooling
        コマンド:
            npm install -g typescript
        5分でTypeScriptツール: #ref: https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html
    MDN で試す: #// https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Math/max  #keyword: MDN
        動作する JavaScript エンジン: ブラウザーの JavaScript のバージョンが動きます。
            MDN の各ページの下側に書いてあるブラウザーの互換性に注意してください
        import, require を使う場合:
            typrm の開発環境を開きます:  #ref: ${GitHub}/typrm
            typrm_test.ts の先頭: |  #ref: ${GitHub}/typrm/src/typrm_test.ts
                import * as path from 'path';
                    ...
                const d = path.basename( '/path/to' );    // お試しコード
            ブレークポイントを張り、d をウォッチします:
    デバッガー: #keyword: TypeScript VSCode debugger
        ブレークした後に非同期処理が入るとき: print を使い、デバッグ対象を再起動してください。
            非同期処理を実行したら、ウォッチしている変数の値やブレークする順番が正しくなくなります。
        デバッグ用関数: dd, watchPrint, countThrough
        プログラムを再起動します:  #search: VSCode JavaScript debug
        ブレーク ポイント がずれるとき:
            通常: Jest のプロンプトでもう一度再実行します  #search: VSCode JavaScript debug
            npm で起動した Jest 環境: npm を再起動してください
        Jest で例外がキャッチされなかったとき: コールスタックが表示されます
    Jest の test.each の中の 1行だけ実行します:  #keyword: test.only  #snippet-depth: 2
        サンプル:
            if (caseName !== '____') {return;}  // || subCase !== '____'
                chdirInProject('src')
                __TestCode__
            expect('test code').toBe('deleted skip code.');
        実行する test.each を test.only.each に置き換えます:
        テスト関数の最初に実行しない行についてスキップするコードを書きます:
    未定義のテストがあることをスキップで記録します:  #keyword: test.skip
        test.skip('__TestName__',()=>{});
    tsconfig.json: #search:
文法: #keyword: JavaScript 文法
    参考:
        TypeScript:
            公式:  #ref: https://www.typescriptlang.org
            非公式:
                サバイバルTypeScript:  #ref: https://typescriptbook.jp
    制御構文: #glossary: js
        if:
            値のみの条件式 if(___): #keyword: JavaScript if value only  #// 例: if (var), if (undefined)
                偽と判定される値:
                    if (false)
                    if (0)
                    if ('')
                    if (undefined)
                    if (null)
                    if (NaN)
                真と判定される値:
                    if (true)
                    if (1)
                    if ('a')
                    if (' ')
                    if ({a:1})
                    if ({})
            (&&), (||):  #keyword: JavaScript && ||
                注意: 偽は nullなども含みます
                __A__ && __B__:
                    __A__ が真と判定される値の場合: __B__  #// 例: 'a' && 12 === 12
                    __A__ が偽と判定される値の場合: __A__  #// 例: ''  && 12 === ''
                __A__ || __B__:
                    __A__ が真と判定される値の場合: __A__  #// 例: 'a' || 12 === 'a'
                    __A__ が偽と判定される値の場合: __B__  #// 例: ''  || 12 === 12
                __A__ && __B__ || __C__:
                    #// 非推奨。推奨は #search: JavaScript 条件演算子
                    __A__ が真と判定され __B__ が真と判定される値の場合: __B__  #// 例: 'a' && 12 || 34 === 12
                    __A__ が真と判定され __B__ が偽と判定される値の場合: __C__  #// 例: 'a' && 0  || 34 === 34
                    __A__ が偽と判定される値の場合:                     __C__  #// 例: ''  && 12 || 34 === 34
                解説: 演算途中で boolean 型にキャストされることはありません
            (??):  #keyword: JavaScript ??  #search: JavaScript オプション引数
            条件演算子, 三項演算子 (?:):  #keyword: JavaScript 条件演算子 三項演算子
                基本: |
                    __Condition__ ? __ValueIfTrue__ : __ValueIfFalse__
                条件によって一部の属性を変える場合:
                    サンプル: |
                        const  object = {
                            a: 1,
                            b: 2,
                            ... (condition) ? {  // ... は スプレッド構文
                                c: 3,
                                d: 4,
                            } : {
                                c: 33,
                                d: 44,
                            },
                        }
                    condition が偽と判定される値の場合: |
                        const  object = {
                            a: 1,
                            b: 2,
                            c: 3,
                            d: 4,
                        }
                    condition が真と判定される値の場合: |
                        const  object = {
                            a: 1,
                            b: 2,
                            c: 33,
                            d: 44,
                        }
                ElseIfMethodChain: #keyword:  #// IfElseMethodChain ではない
                    #ref: https://qiita.com/Takakiri/items/be93a6fb84bd78846749#comment-429c54aa27d929b08dd2
                    完全版: |  #ref: ${GitHub}/breadcrumb/tree-breadcrumb/src/tree-breadcrumb.ts#Readable ternary operator
                        // Readable ternary operator
                        //      Example:
                        //          const  value =_( data ).elseIf(data === "").then("empty");
                        //          const  value =_(()=>( object!.name )).elseIf(!object).then("");  // lazy evaluation
                        function  _<T>(value: T): ElseIfMethodChain<WidenType<T>> {  // The function name is '_'
                            return  new ElseIfMethodChain<WidenType<T>>(value as WidenType<T>);
                        }
                        class  ElseIfMethodChain<T> {
                            constructor(
                                public  value: T
                            ) {}
                            elseIfCondition = true;

                            elseIf(condition: boolean): ElseIfMethodChain<T> {
                                this.elseIfCondition = condition;
                                return  this;
                            }

                            then(elseValue: TOrFunctionType<T>): TOrReturnType<T> {
                                if ( ! this.elseIfCondition) {
                                    if (typeof this.value === 'function') {
                                        return  this.value();
                                    } else {
                                        return  this.value  as TOrReturnType<T>;
                                    }
                                } else {
                                    if (typeof elseValue === 'function') {
                                        const  elseFunction = elseValue as ((...args: any[]) => any);
                                        return  elseFunction();
                                    } else {
                                        return  elseValue  as TOrReturnType<T>;
                                    }
                                }
                            }
                        }
                        type  TOrReturnType<T> =
                            T extends (...args: any[]) => any
                            ? ReturnType<WidenType<T>>
                            : T;
                        type  TOrFunctionType<T> =
                            ((...args: any[]) => T)
                            | TOrReturnType<T>
                            | T;
                        type WidenType<T> =  // e.g.) type 1 => type number, type "A" => type string
                            T extends number ? number :
                            T extends string ? string :
                            T extends boolean ? boolean :
                            T extends (...args: any[]) => number ? (...args: any[]) => number :
                            T extends (...args: any[]) => string ? (...args: any[]) => string :
                            T extends (...args: any[]) => boolean ? (...args: any[]) => boolean :
                            T;

                        function  conditionals(n: number) {
                            const r0 =_( 1 ).elseIf(n > 0).then( n );
                            const r1 =_( 1 ).elseIf(n > 0).then(()=>( n ));
                            const r2 =_(()=>( 1 )).elseIf(n > 0).then( n );
                            const r3 =_(()=>( 1 )).elseIf(n > 0).then(()=>( n ));
                            console.log(`${n}: ${r0},${r1},${r2},${r3}`);
                        }

                        // Main
                        for (let n: number = -1; n <= 3; n+=1) {
                            conditionals(n);
                        }
                    簡易定義版: |  #// 読みやすい定義ですが、返り値（下記 Example の value）が any 型になってしまいます。lazy evaluation もできません
                        // Readable ternary operator
                        //      Example:
                        //          const  value = _( data ).elseIf(data === "").then("empty");
                        function  _(value: any): ElseIfMethodChain {  // The function name is '_'
                            return  new ElseIfMethodChain(value);
                        }
                        class  ElseIfMethodChain {
                            constructor(
                                public  value: any
                            ) {}
                            elseIfCondition = true;

                            elseIf(condition: boolean): ElseIfMethodChain {
                                this.elseIfCondition = condition;
                                return  this;
                            }

                            then(elseValue: any): any {
                                if ( ! this.elseIfCondition) {
                                    return  this.value;
                                } else {
                                    return  elseValue;
                                }
                            }
                        }
                    関連 >> else 必須ルール:  #keyword: if else coding rule
                        場合分けするときは、必ず if ブロック、else if ブロック、else ブロック の中に必ず入れる書き方の方針、
                        つまり、それらのブロックの外に場合分けの値を書かない方針は、基本的に良いが、
                        オプションを指定しない通常のケースでは、最後の else ブロックになってしまう。
                            if
                                a = 1
                            else if 
                                a = 2
                            else
                                a = 0
                        変数に代入することに関しては、if の前に通常のケースを書いたほうが可読性は上がります。
                        また、if else を書いたときに else を必ず書くルールも余計なルールになります。
                            a = 0
                            if
                                a = 1
                            else if 
                                a = 2
        for:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#loop
            配列:  #search: JavaScript array for loop
            Map:  #search: JavaScript map for loop
            iteratable: |
                let  iteratable = [10, 20, 30];
                for ( const  caseX  of  iteratable ) {
                    console.log( caseX );
                }
            index: |
                for ( var i = 0; i < array1.length; i+=1 ) {
                    array1[i];
                }
            break: #keyword: JavaScript break
                ラベル付き break: | #keyword: JavaScript label break  #focus: loop1
                        loop1: for (let i = 0; i < 3; i++) {
                            for (let j = 0; j < 3; j++) {
                                if (i === 1 && j === 1) {
                                    continue loop1;
                                }
                                console.log(`i = ${i}, j = ${j}`);
                            }
                        }
                    #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Statements/label
        try, catch, finally: #keyword: JavaScript try exception,  JavaScript try throw　catch finally Error assert
            Example: |
                try {
                    throw new Error('unexpected');
                } catch (e: any) {  // e: Error はできません
                } finally {
                }
            throw:  #// throw の訳は「投げる」
            main 関数で例外をキャッチする:  #search: JavaScript main catch
            メッセージを変える:
                Error の派生クラスの場合: |  #focus: throw  #search: exampleReadStream
                    function  handleError() {
                        try {
                            riskyOperation();
                        } catch (error) {
                            if (exception instanceof Error) {
                                exception.message = `${exception} in makeSettingTree(${parser.filePath}:${errorLineNum})`;
                            }
                            throw  exception;
                        }
                    }
                それ以外の場合: |  #// 未確認
                    const newError = new Error("変更後のエラーメッセージ");
                    newError.stack = error.stack; // 元のスタックトレースを新しいエラーに設定
                    throw newError;
            コール スタック を表示する: |  #keyword: JavaScript call stack
                } catch (exception: any) {
                    if ((programOptions.test  ||  programOptions.verbose))  &&  exception instanceof Error) {
                        console.log(exception.stack); 
        Promise:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#Promise
            async, await: #keyword:  #// エイシンク, アウェイト, エイシンクロナス
                async: 非同期処理が始まるという意味
                読み: #ref: https://twitter.com/chomado/status/1101647873307897856
                constructor の async:  #// ができないので、その代わり
                    静的 ファクトリー メソッド: |  #search: JavaScript static method
                        static async create(): Promise<MyClass> {
                getter の async:  #// ができないので、その代わり
                    get____ メソッドに変える:
                async に変えることの連鎖を断ち切るには:
                    #ref: ${typrm_files}/ref/JavaScript-AI.yaml#label: prevent async chain
            or 条件待ち, Promise.race: |  #focus: race
                const promise1 = ____
                const promise2 = ____

                const result = await Promise.race([
                    promise1.then(() => 'dialog'),
                    promise2.then(() => 'success')
                ]);
                if (result === 'dialog') {
                    ____
                } else {
                    ____  
                }
    データ:  #// 数値、文字列、配列、オブジェクト、クラス  #glossary: TypeScript
        型, Type annotations: #keyword: TypeScript type annotations
            型の必要性:  #// 型を書くことで型のチェックが行われるようになります
                TypeScript の開発者である Anders Hejlsberg 氏が言っています。プログラミングにおいてはクラスですら必要ないのですが、コードを構造化することが有用であることは実証されており、静的型付けによって構造化されれば IDE（Visual Studio）を活用したリファクタリング、コード補完、（データの）参照元の検索やナビゲート（参照先の検索）ができるようになるからです。静的型付けが無ければ推測（動作させて調査）しなければなりませんし、文章によるヘルプを書くこともできません。と言っています。
                    https://www.youtube.com/watch?v=5AqbCQuK0gM
                以下は私の解釈ですが、ライブラリを使う人は型を書く必要はなく（型を読む必要がないという意味ではなく読んでもよい）、ライブラリを使う人が上記の機能を使う上で役立つ情報を「すぐに」提供できるようにする手段の1つが型だという認識です。 
                私はあるサービスの改修を引き継いだとき、型が書かれていないために改修があったデータの参照元の検索ができなくて改修の影響範囲を特定できず、膨大なテストをして見つけるという大変苦労したという経験があります。型があれば数秒で検索できるのにと思いながら（改善しつつ）作業しました。なので型は必須だと考えています。
            変数の型: |  #focus: ClassA
                const  v: ClassA = ____
            関数の引数の型: |  #focus: ClassA
                function  a(v: ClassA) {}
            関数の返り値の型: |  #focus: ClassA
                function  a(): ClassA {}
            type-predicates:  #keyword: type-predicates, 型ガード
                TypeScriptの型定義から型ガードを自動生成する type-predicates-generator の紹介: #ref: https://zenn.dev/kimuson/articles/type_predicates_generator
            関連:
                ユーティリティ型
        グローバル オブジェクト, グローバル変数:
            globalThis:  #// JavaScript の実行環境全体で共有される本当の意味でのグローバルオブジェクトへの参照
                JavaScript の window:  #// ブラウザー  #keyword: window of JavaScript browser
                    書式:  #// 以下のいずれか。どれも同じオブジェクトを指す。globalThis 以外は環境によって存在しないことがあります
                        -   window.__Variable__
                        -   __Variable__    #// globalThis.__Variable__ と同じオブジェクト
                        -   self.__Variable__
                        -   globalThis.__Variable__  #keyword: globalThis  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/globalThis
                    組み込みオブジェクト:
                        すでに用意されている Array, window.innerHeight などは window のプロパティです
                Node.js の global: #keyword: Node.js global
                    サンプル:  #// 以下のいずれか
                        -   global.__Variable__   #// ブラウザー JavaScript の globalThis.__Variable__ と同じオブジェクト
                        -   globalThis.__Variable__  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/globalThis
                    型:
                        # declare var global: NodeJS.Global;
                TypeScript:  #keyword: TypeScript global variable
                    定義:  #keyword: declare global
                        書式: |  #// 1行で定義の前半を書くことを推奨します（定番なので）。また、__Variable__ は g から始めることを推奨します。例 gNow
                            declare global {export const  __Variable__: __Type__} (globalThis as any).
                            __Variable__ = __InitialValue__;
                        サンプル: |
                            declare global {export const  gCurrentIndex: number} (globalThis as any).
                            gCurrentIndex = 1;
                        参考:
                            (globalThis as any) を書く理由:
                                __Variable__ は const なので代入できませんが、
                                globalThis.__Variable__ は const ではないので代入できます。  #search: set globalThis
                            ; を書かない理由:
                                declare の最後（globalThis の前）に ; を付けると、1行 1文原理主義者がうざいので、; は書きません。
                            文法が分かるような定義: |  #// 文法は普段はあまり重要ではないため非推奨。 grep 検索で定義を見つけることもできなくなります
                                declare global {
                                    export const  __Variable__: __Type__;
                                }
                                (globalThis as any).__Variable__ = __InitialValue__;
                        設定クラス:  #search: set globalThis
                        定義へジャンプ:
                            VSCode:
                                VSCode の定義へジャンプする機能で、定義場所はすぐに分かります。
                            grep:
                                grep -rn  "declare.*__Variable__"  "__Project__/src"
                        declare global でエラーになる場合: #keyword: export {};
                            1つも export が無いと declare global の global でエラーになります。
                            export {} を書いてください。
                            #search: JavaScript common global const
                        初期値の依存関係を解消する: #search: declare global dependency  #// 別のグローバル変数の値を初期値にする場合
                    参照:
                        基本:  #// 定義したファイルの中でも外でも同様です
                            #// import は不要です
                            __Variable__  #// const なので代入できません
                            #// デバッガーのウォッチに __Variable__ を入力するだけで値を表示できます。import { __Variable__ } ではデバッガーで表示できません
                        グローバル変数だけ参照する場合の import/require: |  #// import が必要です。 __InitialGlobalVariable__ が定義されている ソース ファイル のうち、グローバル変数だけ参照する場合のみ
                                import '@src/programOptions'
                                __Variable__: __InitialGlobalVariable__;
                            #search: JavaScript import global variable
                        初期値の依存関係を解消する:  #search: declare global dependency
                    設定:  #// 代入
                        設定関数:  #// 代入だけする関数を作ると、そこで console.log やブレークができるようになるので、デバッグしやすくなります
                            定義: | #keyword: set globalThis
                                    export class  Set__Module__ {
                                        static  __Variable__(x: __Type__) {
                                            (globalThis as any).__Variable__ = x;
                                        }
                                    }
                                #// クラスを定義することで、変数名を同じメソッド名を定義できます
                                #// __Variable__ という名前の関数です
                                #// const ではなくなるため代入できます
                            呼び出し:
                                Set__Module__.__Variable__(__NewValue__);
                        代入する場所へジャンプ:
                            VSCode でメソッド名 __Variable__ を逆参照すれば一覧できます
                        直接代入:  #// 非推奨
                            (globalThis as any).__Variable__ = __NewValue__;
                    初期値の依存関係を解消する: #keyword: declare global dependency  #// 別のグローバル変数の値を初期値にする場合
                        状況:  #focus: ReferenceError  #search: gProgramOptions
                            プリミティブ型の場合: |
                                __Variable__ = __InitialGlobalVariable__;    // ReferenceError: __InitialGlobalVariable__ is not defined
                            オブジェクト型の場合: |
                                __Variable__ = {
                                    __Field__: __InitialGlobalVariable__;    // ReferenceError: __InitialGlobalVariable__ is not defined
                                }
                        原因:
                            初期値がグローバル変数を参照している場合、変数の依存関係ではなく ソース ファイル の依存関係によって、相互依存エラーになることがあります。
                            #search: gProgramOptions import 相互依存
                            #search: import 相互依存
                        対処A:  #// 同じ ソース ファイル に定義がある場合
                            参照先側の定義を上に書く:
                                初期値とするグローバル変数の定義を上に移動します
                        対処B:
                            グローバル変数の参照をやめる:
                                初期値をリテラルにします。
                                構成を変えなくて済みますが、初期値の一元化ができません
                        対処C:
                            共有部分を分ける:  #search: import 相互依存
                                #// ソース ファイル のうち、グローバル変数の初期化部分だけを、新しい ソース ファイル に移動します
                                #// グローバル変数だけでなく、グローバル定数（リテラルではない）の場合でも、初期値がリテラルでなければ、相互依存のために共有部分に分ける必要が出てくる場合があります
                                設定関数は分けない:  #// 設定関数の定義を共有部分に移動してもしなくてもエラーになりません
                                    設定関数:  #search: set globalThis
                                初期値の設定:  #focus: __VariableA__,  __VariableB__
                                    修正前:
                                        a.ts: |
                                            import { __IdentifierB__ } from 'b';

                                            declare global {export const  __VariableA__: __Type__} (globalThis as any).
                                            __VariableA__ = __InitialValueA__;
                                        b.ts: |
                                            import { __IdentifierA__ } from 'a';

                                            declare global {export const  __VariableB__: __Type__} (globalThis as any).
                                            __VariableB__ = __VariableA__;
                                    修正後:  #focus: aConst
                                        a.ts: |
                                            import { __IdentifierB__ } from 'b';
                                        aConst.ts: | #keyword: JavaScript common global const  #// 書く内容は通常のグローバル変数の定義と変わりません
                                            import type { __Type__ } from 'a';  // 型を参照する必要がある場合  #keyword: import type
                                            export {}  // 1つも export が無いときなら必要  #search: export {}

                                            declare global {export const  __VariableA__: __Type__} (globalThis as any).
                                            __VariableA__ = __InitialValueA__;
                                        b.ts: |
                                            import { __IdentifierA__ } from 'a';
                                            import 'aConst';

                                            declare global {export const  __VariableB__: __Type__} (globalThis as any).
                                            __VariableB__ = __VariableA__;
                                参考:
                                    gProgramOptions の import 相互依存をなくす:  #search: gProgramOptions import 相互依存
                                    (globalThis as any) は使えません:   #search: not recommended global dependency
                                    循環しているファイルを特定して小さく分けます:
                                        D → A　→ B → C → A なら A, B, C の中の小さいもの  #search: import 相互依存
                        エラーメッセージの詳細: |  #// Jest の場合の相互異存のエラー。　gOldestTime は tick.ts に定義されていますがエラーになります  #search: Jest call stack
                            FAIL  src/test/case/download.test.ts
                            ● Test suite failed to run

                                ReferenceError: gOldestTime is not defined

                                    283 |
                                    284 | export const  emptyRate = {
                                >   285 |     time: new Date(gOldestTime),
                                        |                    ^
                                    286 |     price: 0,
                                    287 | }
                                    288 |

                                at Object.<anonymous> (src/downloader.ts:285:20)
                                at Object.<anonymous> (src/chart.ts:5:1)
                                at Object.<anonymous> (src/tick.ts:2:1)
                                at Object.<anonymous> (src/test/case/download.test.ts:2:1)
                        非推奨: #keyword: not recommended global dependency
                            非推奨）globalThis as any: |  #// 非推奨。import が完了する前にロードしたら、初期値は入りません。定義へのジャンプもできません
                                __Variable__: (globalThis as any).__InitialGlobalVariable__;
                                (globalThis as any).__InitialGlobalVariable__ を初期値に書いてもエラーになりませんが、
                                値 == undefined になってしまいます
                            非推奨）{} as __ObjectType__: |   #// プロパティが不足しているので非推奨
                                __Variable__: {} as __ObjectType__;
                            非推奨）setupFiles: #keyword: Jest setupFiles  #// 複雑な実装になるため非推奨
                                __Project__/src/declare.ts :  #// グローバル変数をここで宣言して、初期化します。declare.ts は本書独自に付けた名前です
                                    依存関係順に定義を書きます。上で定義した変数を、下で定義した変数の初期値として使えます
                                    ただし、共有部分を declare.ts に集めると、モジュール性が無くなり、大きくなってしまいます
                                    #search: declare global
                                jest コマンドの場合:  #// jest.config.js の setupFiles に declare.ts を指定します
                                    __Project__/jest.config.cjs : |  #// Jest はすべての ソース ファイル を探さないため
                                        module.exports = {
                                            setupFiles: ['./src/declare.ts'],
                                node コマンドの場合:  #// declare.ts があるときの node コマンド実行。複雑です
                                    コマンド:
                                        node src/app-start.mjs --live
                                    __Project__/src/app-start.mjs :
                                        import '../build/declare.mjs';
                                        import '../build/app.js';
            ファイル内でのグローバル変数:  #// export しないとファイルの外から参照できません
                グローバルスコープに宣言した変数
            グローバル変数のアンチパターン:  #search: global variable anti pattern
            意見対立:
                https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil
                https://softwareengineering.stackexchange.com/questions/454667/why-is-global-state-hard-to-test-doesnt-setting-the-global-state-at-the-beginn?noredirect=1&lq=1
                引数に全てあるとしても、問題がある部分は結局問題があるコードの近くを見なければならず、グローバルであろうがなかろうが関係ない
            サンプル:
                #ref: ${GitHub}/Trials/try_TypeScriptGlobal  #ref: https://github.com/Takakiriy/Trials/blob/master/try_TypeScriptGlobal/src/1a.main.ts
            参考:
                #ref: ${typrm_files}/Qiita下書き/29_GlobalThisJS/29_GlobalThisJS.md
        プリミティブ型, 基本型:  #// number 数値, string 文字列, 日時 など
            数値:  #keyword: JavaScript number
                number:
                    文字列と数値の変換:  #search: JavaScript string number
                    浮動小数から整数へ:
                        切り下げ: Math.floor(1.9) === 1
                        四捨五入: Math.round(1.5) === 2
                        切り上げ: Math.ceil(1.1) === 2
                    数字かそれ以外かの判定: #glossary: JavaScript  #keyword: JavaScript isNumber
                        #// string 型または number 型なら !isNaN でよい
                        numberRegularExpression:
                            const  numberRegularExpression = /^[0-9]+$/;
                            numberRegularExpression.test(keyword))
                        isNaN:  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/isNaN
                            const  isNumber = ! isNaN(value as any);  // as any は TypeScript の場合のみ必要
                            console.log( isNaN("")        === false );
                            console.log( isNaN("string")  === true );
                            console.log( isNaN("100s")    === true );
                            console.log( isNaN("123")     === false );
                            console.log( isNaN(123)       === false );
                            console.log( isNaN(NaN)       === true );
                            console.log( isNaN(true)      === false );
                            console.log( isNaN(false)     === false );
                            console.log( isNaN(undefined) === true );
                            console.log( isNaN(null)      === false );
                        Number.isNaN:  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN
                            console.log( Number.isNaN("string")  === false );
                            console.log( Number.isNaN("")        === false )
                            console.log( Number.isNaN("100s")    === false );
                            console.log( Number.isNaN("123")     === false );
                            console.log( Number.isNaN(123)       === false );
                            console.log( Number.isNaN(NaN)       === true );
                            console.log( Number.isNaN(true)      === false );
                            console.log( Number.isNaN(false)     === false );
                            console.log( Number.isNaN(undefined) === false );
                            console.log( Number.isNaN(null)      === false );
                        isFinite: #// 有限数  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/isFinite
                        Number.isFinite: #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite
                        Number.isInteger:  #// 整数  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
                    四捨五入:
                        Math.round(num * factor) / factor;
                    NaN: #keyword: JavaScript NaN
                        #snote: %programming%\スクリプト\JavaScrpt\JavaScript.svg#NaN
                        説明: 数値の未定義型 NaN(Not a Number)
                            数値型で不適切な数学的演算が行われた時に返されます
                            undefined + undefined === NaN
                            0 / 0 === NaN  (例外にはなりません)
                        NaN の判定:
                            条件式:
                                if ( ! NaN) // true
                                if (NaN)  // false
                            Number.isNaN:
                                Number.isNaN(NaN) === true
                                Number.isNaN("文字列") === false
                                Number.isNaN(undefined) === false
                            isNaN:  #// 非推奨。数値型以外でも true。Number.isNaN ではない
                                isNaN(NaN) === true
                                isNaN("文字列") === true  (?)
                                isNaN(undefined) === true  (?)
                    random: #keyword: JavaScript random
                        直書き版:
                            Math.floor(Math.random() * (maxValue - minValue + 1)) + minValue
                        簡易版: |
                            function  getRandomInt(min: number, max: number): number {
                                return Math.floor(Math.random() * (max - min + 1)) + min;
                            }
                        完全版: |
                            function getRandomInt(min, max) {
                                // 引数が数値でない場合はエラー
                                if (typeof min !== 'number' || typeof max !== 'number') {
                                    throw new TypeError('引数は数値である必要があります');
                                }

                                // 小数点以下を切り捨てて整数に変換
                                min = Math.ceil(min);
                                max = Math.floor(max);

                                // minがmaxより大きい場合は値を入れ替え
                                if (min > max) {
                                    [min, max] = [max, min];
                                }

                                // min以上max以下のランダムな整数を生成して返す
                                return Math.floor(Math.random() * (max - min + 1)) + min;
                            }
                bigint:
                整数へ最適化: #keyword: JavaScript int
                    _: let j = Math.trunc(someNumber);
                    Math.trunc: #keyword:  #// 小数部の桁を取り除くことによって整数部を返します。整数最適化が期待できます。ただし可読性が落ちます
                    目的: 高速化。現代のCPUアーキテクチャが整数演算が高速
                    考察: |
                        // 1. Bitwise演算子を使用して強制的に32ビット整数として扱う
                        let i = 0 | 0;  // 32ビット整数として初期化

                        // ループの例
                        for (let i = 0 | 0; i < array.length; i = (i + 1) | 0) {
                            // ループ処理
                        }

                        // 2. Math.trunc()を使用して小数点以下を切り捨てる
                        let j = Math.trunc(someNumber);

                        // 3. 左シフト演算子を使用して整数化
                        let k = someNumber << 0;
                数値計算ライブラリ:
                    numJs:  #// Node.js で動く numPy に相当するライブラリ
                    mathjs:
                    technicalindicators:  #// RSI・MACD・CCI など 100 種類以上のテクニカル指標
                        公式:
                            npmjs:  #ref: https://www.npmjs.com/package/technicalindicators
                        コード: #glossary: technicalindicators
                            SMA:  #// Simple Moving Average
                                サンプル: |
                                    import { SMA } from 'technicalindicators';

                                    const smaResult = SMA.calculate({
                                        period: 5,
                                        values: [10, 12, 14, 16, 18, 20, 22, 24, 26, 28]
                                    });
                                    console.log(smaResult);
                                期間（period）: 1つの SMA の値を得るときに入力するサンプル数です
                                出力の長さ: 元データの長さ - period + 1
                                出力の位置:
                                    SMA が遅行指標（lagging indicator）であるように、
                                    period が 5 の場合, 入力値 [0],[1],[2],[3],[4],[5],[6],[7],[8],[9]（大きいほど新しく、9が現在）をプロットしたチャートに対して、
                                    出力の値 [0],[1],[2],[3],[4],[5],[6] を計算した場合、出力[6]は入力[9]の時刻の位置に描画されます。
                                    代わりに中央に配置する「センタード移動平均」というオプションもありますが一般的ではありません。
            文字列:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#string  #keyword: JavaScript string
                #↓基本型と変換
                文字列と数値の変換:  #keyword: JavaScript string number
                    parseInt: #keyword:
                        parseInt( "123" ) == 123
                        parseInt( "123.9" ) == 123
                        parseInt( "-123.9" ) == -123
                        parseInt( "0x12" ) == 0x12 == 18
                        parseInt( "1A", 16 ) == 0x1A == 26
                        parseInt( "1a" ) == 1
                        parseInt( "1番目" ) == 1
                        parseInt( "a2" )   // NaN
                        parseInt( "" )   // NaN
                        parseInt( 123 ) == 123
                    parseFloat: #keyword:
                        parseFloat( "1.1" )
                    toString:
                        123.toString()
                    toFixed:
                        const num = 123.456789;
                        const formatted = num.toFixed(2); // "123.46" (四捨五入されます)
                        const num = 123.4;
                    Intl.NumberFormat: |  #// 最低 2桁、最高 5桁, OS の言語,  日本語にするときは、第1引数を 'ja-JP' にします
                        const formatter = new Intl.NumberFormat(undefined, {
                            signDisplay: 'exceptZero',  // プラスの値のときに + をつける。+1 など
                            minimumFractionDigits: 2,
                            maximumFractionDigits: 5
                        });
                        const formatted = formatter.format(num); // "123.40"
                    数字かそれ以外かの判定: #search: JavaScript isNumber
                数字かそれ以外かの判定: #search: JavaScript isNumber
                #↓言語機能
                変数を埋め込むリテラル, Templare Literal: |  #search: JavaScript テンプレート リテラル
                    `string text ${expression} string text`
                複数行の文字列, : #search: テンプレート リテラル 型
                    const  lines = `1
                    2`;
                #↓検索
                文字列の一部: #keyword: JavaScript part string
                    インデックス指定:
                        メソッド:
                            関数: #glossary: JavaScript string
                                substr: 文字列.substr( __StartOrLast__ [, __Length__ ] )
                                slice: 文字列.slice( start_or_last  [, __OverOrLast__ ] )
                                substring: 文字列.substring(__Start__,  __Over__)
                            説明: #// 上記引数の説明
                                __Start__: 開始位置、0以上。 __Start__ > __Over__ なら終了位置の次
                                __StartOrLast__: 0以上なら左からの開始位置、マイナスなら末尾からの文字数
                                __Over__: 終了位置の次、0以上。 __Start__ > __Over__ なら開始位置
                                __OverOrLast__: 0以上なら終了位置の次、マイナスなら末尾を削除する長さ
                                __Length__: 切り出す文字列の長さ。省略すると最後まで
                        番号: #keyword: JavaScript string index
                            書式:
                                __String__[__Index__]
                            サンプル:  #focus: str
                                const  character = str[i];
                                if ( ! character) {
                                    throw new Error();
                            範囲外のとき:  #// __Index__ >= __String__.length または __Index__ < 0 のとき
                                undefined
                    キーワード指定:  #search: JavaScript string indexOf
                        getLeftOfKeyword: | #keyword: JavaScript getLeftOfKeyword
                            function  getLeftOfKeyword(target: string, keyword: string): string {
                                return  target.substring(0, target.indexOf(keyword));
                            }
                            // または str.split('/')[0];
                        getRightOfKeyword: | #keyword: JavaScript getRightOfKeyword
                            function  getRightOfKeyword(target: string, keyword: string): string {
                                return  target.substring(target.lastIndexOf(keyword) + 1);
                            }
                        getLeftOfLastKeyword: | #keyword: JavaScript getLeftOfLastKeyword
                            function  getLeftOfLastKeyword(target: string, keyword: string): string {
                                return  target.substring(0, target.lastIndexOf(keyword));
                            }
                        getRightOfLastKeyword: | #keyword: JavaScript getRightOfLastKeyword
                            function  getRightOfLastKeyword(target: string, keyword: string): string {
                                return  target.substring(target.lastIndexOf(keyword) + 1);
                            }
                    最終行:
                        const  lines = text.split('\n').filter(line => line.trim() !== '');
                        const  lastLine = lines[lines.length - 1] || '';
                検索:
                    indexOf: #keyword: JavaScript string indexOf
                        基本:  const  separatorIndex = a.indexOf("sep");
                        大文字小文字を区別しない: #search: JavaScript string not case sensitive
                            #snip:  a.toLowerCase().includes(b.toLowerCase())
                        関連 >> 文字列の一部:  #search: JavaScript part string
                    lastIndexOf: #keyword: JavaScript string lastIndexOf  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf
                        paragraph.lastIndexOf(searchTerm);
                    include: #keyword: JavaScript string include
                        大文字小文字を区別しない: #keyword: JavaScript string not case sensitive
                            a.toLowerCase().includes(b.toLowerCase())
                正規表現:  #keyword: regular expression, RegExp, JavaScript RegExp  #ref: ${programming}/検索技術、DB/正規表現.svg
                    正規表現を試すサイト: #search: regular expression application  #ref: https://regex101.com/
                    メタ文字 一覧: . $ ^ { } [ ] ( ) | * + ? \
                        #// [ ] の中のメタ文字 一覧: [ ] -
                    手順:
                        検索:  #search: JavaScript RegExp exec
                            条件:  #search: JavaScript RegExp condition
                        マッチの有無:  #search: JavaScript RegExp test
                        置き換え:  #search: JavaScript string replace
                    RegExp (Regular_Expression クラス): #keyword: JavaScript RegExp class
                        RegExp クラス:  #// new RegExp('abc(.*)xyz','gi')
                            バックスラッシュは '\\': new RegExp('\\.png')
                        RegExp リテラル:  #// /abc(.*)xyz/gi
                            バックスラッシュは \: /\.png/
                        参考:
                            snote:
                                Windows: #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#Regular_Expression
                                mac: #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#Regular_Expression
                            MDN: #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec#description
                        exec:  #keyword: JavaScript RegExp exec
                            サンプル: |
                                match = /abc(.*)xyz/gi.exec( "123abc456xyz789" );  #// 見つからないと null
                            説明:
                                正規表現に ( ) があると、その部分にマッチしたテキストが、返り値[1～] に格納されます。
                                返り値[0] は、正規表現全体にマッチしたテキストです。
                                返り値[1～] は、正規表現の ( ) の部分に対応した Text の一部が格納されます。
                                返り値.index は、Text の中で、マッチした位置（０～）です。
                                返り値.input は、Text と同じです。
                                返り値.lastIndex は、Text の中で、マッチした位置の次の位置（０～）です。
                            最初にマッチした部分だけ処理します:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#exec_Regular_Expression
                                #focus: abc, xyz
                                re = new RegExp( "abc([0-9]+)xyz","gi" );
                                re.lastIndex = 0;  // ❗re がグローバル変数の場合、これを書かないと、
                                    // 次のコードで最初の exec が最初にマッチした部分にヒットしない可能性があります

                                match = re.exec( "123abc456xyz789-987abc654xyz321" );
                                    // match[0] == "abc456xyz"
                                    // match[1] == "456"
                                    // match.index == 3  // "a"
                                    // match.input == "123abc456xyz789-123abc456xyz789" );
                                    // match.lastIndex == 12  // "7"

                                match = re.exec( "123abc456xyz789-987abc654xyz321" );
                                    // match === null
                            次にマッチする部分を検索します:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#exec_Regular_Expression
                                ループにしない場合: |  #focus: abc
                                    re = new RegExp( "abc([0-9]+)xyz","gi" );
                                    re.lastIndex = 0;  // ❗re がグローバル変数の場合、これを書かないと、
                                        // 次のコードで最初の exec が最初にマッチした部分にヒットしない可能性があります

                                    match = re.exec( "123abc456xyz789-987abc654xyz321" );
                                        // match[0] == "abc456xyz"
                                        // match[1] == "456"
                                        // match.index == 3  // "a"
                                        // input == "123abc456xyz789-123abc456xyz789" );
                                        // lastIndex == 12  // "7"

                                    match = re.exec( "123abc456xyz789-987abc654xyz321" );
                                        // match[0] == "abc654xyz"
                                        // match[1] == "654"
                                        // index == 19  // "a"
                                        // input == "123abc456xyz789-123abc456xyz789" );
                                        // lastIndex == 28  // "3"

                                    match = re.exec( "123abc456xyz789-987abc654xyz321" );
                                        // match === null
                                ループにする場合: |  #focus: function
                                    var  text, rex, match;

                                    text = "function  sub1(){}\nfunction  sub2(){}";

                                    rex = new RegExp("function[ \r\n]+([a-zA-Z_][a-zA-Z_0-9]*)\\(","ig");
                                    rex.lastIndex = 0;

                                    var  match: RegExpExecArray | null = null;
                                    while ( (match = rex.exec( text )) !== null ) {
                                        echo( match[1] );  // "sub1", "sub2"
                                    }
                            返り値:
                                - 返り値[0] は、正規表現全体にマッチしたテキストです。
                                - 返り値[1～] は、正規表現の ( ) の部分に対応した Text の一部が格納されます。
                                    数指定子 * を指定して 0個にマッチした場合、* の左のカッコの部分には undefined が格納されます。
                                        match = /((a)*)b/.exec('b')
                                            match[0] === 'b'        // マッチした全体
                                            match[1] === ''         // (a)* の部分
                                            match[2] === undefined  // a の部分
                                    返り値のインデックスは ( ) のツリー構造における深さ優先で数えます。
                                        match = /((a)(b))((c)(d))/.exec('abcd')
                                            match[0] === 'abcd'
                                            match[1] === 'ab'
                                            match[2] === 'a'
                                            match[3] === 'b'
                                            match[4] === 'cd'
                                            match[5] === 'c'
                                            match[6] === 'd'
                                - 返り値.index は、Text の中で、マッチした位置（０～）です。
                                - 返り値.input は、Text と同じです。
                                - (RegExp object).lastIndex は、Text の中で、マッチした位置の次の位置（０～）です。
                                    /___/g の g の指定がないときは常に0です。
                                - 見つからなかったら、返り値は null です
                        test:  #keyword: JavaScript RegExp test  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test
                            サンプル: if (/abc(.*)xyz/gi.test( "123abc456xyz789" )) {...}
                        検索条件:
                            通常文字列指定:  #// パターンを正規表現ではなく、文字列として解釈します
                                書式: new RegExp(escapeRegularExpression('[png]'), 'gi')
                                    #search: escapeRegularExpression
                                注意: grep の -F オプションに相当するものはありません  #ref: ${typrm_files}/ref/JavaScript-AI.yaml#label: RegExp escapeRegularExpression
                            指定した文字列の前までにマッチさせます:  #keyword: RegExp 否定文字列
                                方法: #// 文字列を（肯定後読みで）検索し、.* の部分を正規表現以外で処理します。
                                    サンプル: |
                                        //                                       012345678901234567
                                        console.log((new RegExp('( #|$)')).exec('#the pattern# #end').index)  // 13
                                        console.log((new RegExp('( #|$)')).exec('#the pattern# #end #').index)  // 13
                                        console.log((new RegExp('( #|$)')).exec('#the pattern# end').index)  // 17
                                        console.log((new RegExp('( #|$)')).exec('#the #end').index)  // 4
                                        console.log((new RegExp('( #|$)')).exec('#the').index)  // 4

                                        const  text = '#the pattern# #end';
                                        const  replacedPart = '(cut)';
                                        const  startIndex = 0  // start of .* part
                                        const  overIndex = (new RegExp('( #|$)')).exec(text).index;

                                        const  replaced = text.substr(0, startIndex) + replacedPart + text.substr(overIndex);
                                        console.log(replaced);  // "(cut) #end"
                                不完全な方法: #// 肯定先読みをします
                                    サンプル: |
                                        console.log((new RegExp('.*(?= #)')) .exec('#the pattern# #end'))    // OK '#the pattern#'
                                        console.log((new RegExp('.*(?= #)')) .exec('#the pattern# end'))     // NG null
                                        console.log((new RegExp('.*(?= #)')) .exec('#the pattern# #end #'))  // NG '#the pattern# #end'
                                        console.log((new RegExp('.*(?= #)')) .exec('#the pattern# end #'))   // OK '#the pattern# end'
                                        console.log((new RegExp('(?! #)*'))  .exec('#the pattern# #end #'))  // NG ''
                                        console.log((new RegExp('.*(?= #)?')).exec('#the pattern# #end'))    // NG '#the pattern# #end'
                                        console.log((new RegExp('.*(?= #)?')).exec('#the pattern# end'))     // OK '#the pattern# end'
                                    参考:
                                        .*(?!ed) は .* と同じ動作をします: #keyword: wildcard negative lookahead
                                            問題:
                                                否定先読みの前のパターンマッチング（.*(?!ed) の .*）をした後、
                                                それに続く先読みパターン（.*(?!ed) の ed）がマッチしなかったら、
                                                再検索（.*(?!ed) の .* に戻ることを）します。
                                                また、先読みする部分が末尾より後だったらマッチします。
                                            対処:
                                                先読みパターン（.*(?!ed) の ed）を検索し、
                                                .* の部分を正規表現以外で処理します。
                                                #search: RegExp 否定文字列
                                            その他実験結果: |
                                                console.log((new RegExp('[^#]*'      )).exec('the pattern# #end'))  // "the pattern"
                                                console.log((new RegExp('[^ #]*'     )).exec('the pattern# #end'))  // "the"
                                                console.log((new RegExp('[^( #)]*'   )).exec('the pattern# #end'))  // "the"
                                                console.log((new RegExp('([^ ][^#])*')).exec('the pattern# #end'))  // "the patter"

                                                // 否定的先読み
                                                console.log((new RegExp('^(?!.*pattern).*$' )).exec('the pattern# #end'))  // null
                                                console.log((new RegExp('^(?!.*pattern).*$' )).exec('the Pattern# #end'))  // "the Pattern# #end"
                    検索条件:  #keyword: JavaScript RegExp condition
                        OR条件の []:
                            - a[bcd]e は abe, ace, ade のいずれかにマッチ
                            - /a[\[\]\-]/ または new RegExp('a[\\[\\]\\-]') は a[, a], a- のいずれかにマッチします。'' の中でも \ はエスケープ文字です
                        .* を短くマッチさせる:  #search: .*?
                        肯定先読み, 否定先読み（否定的先読み）, 肯定後読み, 否定後読み（否定的戻り読み）:  #keyword:
                            注意: 肯定先読み、肯定後読みは、正規表現の ( ) と exec の返り値[1～] でも同様のことができます
                                #search: RegExp exec  #search: .*?
                            肯定先読み: #keyword: (?=__Pattern__)  #// パターンの前まで
                                続くパターンが無くてもヒットさせる場合:
                                    -   A.*?(?= C|$)
                                        #// 文字列 "A1 2C3 C" に対して "A" から始まり、" C" の前までをマッチさせます。
                                        #// つまり "A1 2C3" にマッチさせます。
                                        #// 文字列 "A1 2C3" に対して "A1B2C3" にマッチさせます。
                                    -   A.*?( (?=C)|$)
                                        #// 文字列 "A1 2C3 C" に対して "A" から始まり、"C" が右にある " " までをマッチさせます。
                                        #// つまり "A1 2C3 " にマッチさせます。
                                        #// 文字列 "A1 2C3" に対して "A1B2C3" にマッチさせます。
                                続くパターンが無いとヒットさせない場合:
                                    A.*(?=BC)
                                    #// 文字列 "A1B2C3BC" に対して A から始まり、BC の前までをマッチさせます。
                                    #// つまり "A1B2C3" にマッチさせます。
                                    #// 文字列 "A1B2C3" に対してはマッチさせません。
                            否定先読み: #keyword: (?!__Pattern__)  #// negative lookahead
                            肯定後読み: #keyword: (?<=__Pattern__)
                                サンプル: |
                                    console.log((new RegExp('(?<= |^)#')).exec('#if:').index)  // 0
                                    console.log((new RegExp('(?<= |^)#')).exec(' #if:').index)  // 1      #disable-tag-tool:
                                    console.log((new RegExp('(?<= |^)#')).exec('p#if:'))  // null
                                    console.log((new RegExp('(?<= |^)#')).exec('p #if:').index)  // 2     #disable-tag-tool:
                                    console.log((new RegExp('(?<= |^)#')).exec('  #if:').index)  // 2     #disable-tag-tool:
                            否定後読み: #keyword: (?<!__Pattern__)
                            行の一部:
                                指定した単語の直後が指定したパターン, 指定した単語まで >> 肯定先読み:
                                    サンプル: |
                                        console.log((new RegExp('play(?=ed)')).exec('play played').index)
                                            // 5
                                        console.log((new RegExp('.*(?=ed)')).exec('play played').index)
                                            // 0
                                        console.log((new RegExp('.*(?=ed)')).exec('play played'))
                                            // 'play play'
                                指定した単語の直後が指定したパターン以外 >> 否定先読み:
                                    サンプル: |
                                        const  re = new RegExp('play(?!ed)','g');
                                        const  text = 'play plays playe played playede play';
                                        //             0123456789012345678901234567890123456
                                        r = re.exec(text);  console.log( r[0], r.index, re.lastIndex)  // "play" 0 4
                                        r = re.exec(text);  console.log( r[0], r.index, re.lastIndex)  // "play" 5 9
                                        r = re.exec(text);  console.log( r[0], r.index, re.lastIndex)  // "play" 11 15
                                        r = re.exec(text);  console.log( r[0], r.index, re.lastIndex)  // "play" 32 36
                                        r = re.exec(text);  console.log( r )  // null
                                    任意の文字列の直後が指定したパターン以外:
                                        .*(?!ed) は .* と同じ動作をします: #search: wildcard negative lookahead
                                    参考:
                                        https://it-ojisan.tokyo/regex-not/
                                指定した単語の直前が指定したパターン >> 肯定後読み:
                                    ❗注意: Safari は未対応（下記）
                                    サンプル: |
                                        console.log((new RegExp('(?<=ex)change')).exec('change exchange').index)
                                            // 9
                                        console.log((new RegExp('(?<=ex)change')).exec('exchange change').index)
                                            // 2
                                    互換性:
                                        未対応: Safari 2021-09
                                        対応: Chrome 2021-09
                                指定した単語の直前が指定したパターン以外 >> 否定後読み:
                                    ❗注意: Safari は未対応（下記）
                                    サンプル: |
                                        console.log((new RegExp('(?<!ex)change')).exec('exchange change').index)
                                            // 9
                                            // ex から始まらない change
                                    互換性:
                                        未対応: Safari 2021-09
                                        対応: Chrome 2021-09
                            行単位:
                                〜を含まない行: ^(?!.*__Pattern__).*$
                                〜または〜を含まない行: ^(?!.*(__PatternA__|__PatternB__)).*$
                                〜で始まらない行: ^(?!__Pattern__).*$
                                〜で終わらない行: ^(?!.*__Pattern__$).*$
                                〜を含むが、〜を含まない行: ^(?=.*__Contains__)(?!.*__NotContains__).*$
                        エスケープする: #// 正規表現の特殊文字を検索キーワードに含めます  #serach: escapeRegularExpression
                        量指定子 {} のエスケープ: #keyword: RegExp {} escape  #ref: ${typrm_files}/ref/JavaScript-AI.yaml#label: RegExp {} escape
                            書式: |
                                {n}, {n,}, {n,m} のいずれかのみ。n, m は整数。範囲
                            エスケープ:
                                "{n}, {n,}, {n,m} のいずれか": |
                                    { } を文字とするなら（エスケープするには）\{n\}, \{n,\}, \{n,m\}
                                それ以外の {.*}: |  #// sed のみ？
                                    { } を文字とするなら（エスケープせずに）{.*}
                                #// エスケープするとエラー sed: -e expression #1, char 80: Invalid content of \{\}
                    概念:
                        グループ名: #keyword: JavaScript regular expression group name
                            (?<groupX>[a-zA-Z]+)  #ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Backreferences#types
                    正規表現（一般）: #search: regular expression application
                    参考: #ref: ${programming}/検索技術、DB/正規表現.svg
                startsWith: |  #keyword:  #// 前方一致判定
                    "abc".startsWith("ab") === true
                    "abc".startsWith("b") === false
                    "abc".startsWith("") === true
                endsWith:  #keyword:  #// 後方一致判定
                countOccurrences: | #keyword:  #// 出現回数
                        function  countOccurrences(target: string, keywordRegExp: string): number {
                            return  (target.match(new RegExp(keywordRegExp, 'gi')) || []).length;
                        }
                    #// ライブラリに countOccurrences はありません
                #↓置き換え
                replace:  #keyword: JavaScript string replace
                    基本: |
                        const  before = "abcba";
                        const  after = before.replace(/b/g, 'x');  // "axcxa" 
                    複数マッチさせるとき: 第1引数は g オプションが付いた正規表現を指定してください
                    第2引数が文字列のとき:
                        第2引数に '$' を含まないとき: 置き換えた後の文字列
                        第2引数に '$' を含むとき:
                            マッチした部分に置き換える場合: |  #// 置き換える前にマッチした部分をそのまま置き換えた後に入れる場合
                                - console.log("abc".replace(/(b)/g, '($1)'));  // "a(b)c"
                            $ に置き換える場合: |  #// $ はエスケープ文字です。$ に置き換えるときは $$ を指定してください
                                - '$,$'.replace(/\$/g,'$$')
                    第2引数が関数のとき: #// 関数の引数にマッチした状況に関する情報が入り、関数の返り値にマッチした部分が置き変わります
                        サンプル: |
                            after = before.replace(/(\\+)([^\$\\ ]|$)/g, (match, group1, group2, offset, before) => {
                                return  group1.replace(/\\/g,'/') + group2;  // replace \\ to /
                            });
                        arguments を使うサンプル: |  #search: js arguments
                            after = before.replace(/(\\+)([^\$\\ ]|$)/g, function() {
                                const  match = arguments[0];
                                const  offset = arguments[arguments.length - 2];
                                const  before = arguments[arguments.length - 1];
                                return  arguments[1];
                            });
                        match: マッチした文字列。before の一部
                        offset: マッチした位置。0 = before の 1文字目
                        参考: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_function_as_a_parameter
                    一部を置き換えるとき:  置き換えない部分をそのまま置き換えた後に指定します
                    参考:
                        #// https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String/replace
                        #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#string::replace
                配列変換: #search: JavaScript array string
                padStart, padEnd: | #keyword: JavaScript padStart padEnd
                    "12".padStart(5, "0") === "00012"
                    "12".padStart(5, "-") === "12---"
                #↓連続、数
                repeat: |  #// 同じ文字の連続
                    ' '.repeat(5)  #// 空白 5文字
                出現回数:  #search: countOccurrences
                #↓各種形式と連続と区切り
                空白区切り, 連続した空白: #keyword: JavaScript spaces
                    単語に分ける: #keyword: toWordArray  #// 下記 replace をしないと、連続した空白があったときに空文字列が含まれるようになってしまいます
                        #ref: ${GitHub}/typrm/src/lib.ts#function  toWordArray
                    単語数: #keyword: getWordCount
                        #ref: ${GitHub}/typrm/src/lib.ts#function  getWordCount
                    jpsp: #keyword:
                        const  jpsp = String.fromCodePoint(0x3000);  // Japanese space
                    split:  #keyword: JavaScript split  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String/split
                        推奨:  #search: toWordArray
                        基本サンプル: |  #focus: words, chars, strCopy
                            const  str = 'The quick brown fox jumps over the lazy dog.';

                            const  words = str.split(' ');
                            console.log(words[3]);
                            // Expected output: "fox"

                            const  chars = str.split('');
                            console.log(chars[8]);
                            // Expected output: "k"

                            const  strCopy = str.split();
                            console.log(strCopy);
                            // Expected output: Array ["The quick brown fox jumps over the lazy dog."]
                        複数の区切り文字: |  #// , または ; で区切る場合
                            const  str = 'A,B;C D';
                            const  words = str.split(/[,;]/);
                            console.log(words);  // ["A", "B", "C D"]
                pretty-format: #keyword:
                    概要: ツリー状のオブジェクトの値を文字列にします
                    GitHub: #ref: https://github.com/facebook/jest/tree/main/packages/pretty-format#usage-with-plugins
                ファイル名:  #search: JavaScript path
                シークレット, 秘密情報: #keyword: JavaScript シークレット
                    dotenv: #keyword:
                        公式: https://github.com/motdotla/dotenv
                        プロジェクトにインストールします:
                            cd  "__Project__"
                            npm install dotenv
                        ___.ts:
                            import * as dotenv from "dotenv";
                            dotenv.config();
                            console.log(process.env.API_KEY);
                        .env ファイル: #keyword: .env file  #// カレント フォルダー の .env ファイル
                            #comment
                            API_KEY=a
                            PASSWORD=a  #comment
                    dotenv-cli: #keyword:
                        概要: .env ファイルをクラウドに保存します
                            #ref: https://ui.dotenv.org/ui1/login
                        参考: #ref: https://dev.classmethod.jp/articles/react-dotenv-cli/
                    git サーバーにアップロードしないようにする:  #search: git secret hooks
                    秘密情報の扱い一般:
                        - セキュリティ境界を意識する（シークレットを置く範囲）
                        - シークレットを渡したことのログを取る
                diff: #keyword: JavaScript diff  #ref: https://www.npmjs.com/package/diff
                    インストール: npm install diff @types/diff --save
                    サンプル: |
                        import * as diff from 'diff';
                        const  d = diff.diffChars('0125dd89Y', '012aa589X');
                        console.log(d);
                    出力:
                        [
                            {value: "012", count: 3},
                            {value: "aa", count: 2, added: true},
                            {value: "5", count: 1},
                            {value: "dd", count: 2, removed: true},
                            {value: "89", count: 2},
                            {value: "Y", count: 1, removed: true},
                            {value: "X", count: 1, added: true},
                        ]
                ダンプ:  #keyword: JavaScript string dump hex
                    (漢 字) をダンプします:
                        Array.from(new Buffer('漢 字')).map(d=>d.toString(16).toUpperCase())
            日時: #keyword: JavaScript Date,  JavaScript 日付 時間 Date
                #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#Date
                現在の日時: const  now = new Date();  #keyword: JavaScript now
                基本: |
                    dateB.getFullYear()
                    dateB.getMonth()    #// 0 から 11
                    dateB.getDate()     #// 1 から 31
                    dateB.getHours()    #// 0 から 23
                    dateB.getMinutes()
                    dateB.getSeconds()
                ローカル タイムゾーン: #keyword: JavaScript local time zone
                    - HTML であれば、ブラウザー（クライアント）の設定や、ブラウザーが動いている OS の設定によります
                    - サーバー（Web API 呼び出し）であれば、サーバーの OS の設定によります
                0時:
                    ローカル タイムゾーン での今日 0:00: |
                        const  now = new Date();
                        const  today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                        const  localTimeCreatingMark = 'T00:00';
                        const  comparedDate = new Date('2021-01-01' + localTimeCreatingMark);

                        function toLocalISOString(date) {
                            const  offset = date.getTimezoneOffset() * 60000; // タイムゾーンのオフセットをミリ秒で取得
                            const  localISOTime = (new Date(date.getTime() - offset)).toISOString().slice(0, -1);
                            return  localISOTime;
                        }
                    UTCでの今日 0:00: |
                        const  now = new Date().toISOString();
                        const  today = new Date(now.substr(0, now.indexOf('T')));
                指定の時刻:
                    タイムゾーン指定なしの場合: | #keyword: JavaScript without ISO time zone
                        - new Date('2000-04-10').toISOString() == UTC での 0時
                        - new Date('2000-04-10T00:00').toISOString() == ローカル タイムゾーン での 0時
                        - newDateLoosely
                    タイムゾーン指定ありの場合: |
                        console.log('dateA');
                        const  timezone = 'T00:00+09:00';  // JST

                        const  dateA = new Date('2000-04-10' + timezone);  // 日本の日時、タイムゾーンもJST
                        // new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);
                            console.log( dateA.toISOString() );  // NG, "2000-04-09T15:00:00.000Z" // toJSONも同じ. #search: getLocalIsoString
                            console.log( dateA.getDate());   // 10(日) 
                            console.log( dateA.getHours());  // 0(時), システムのタイムゾーンを使用。タイムゾーンはローカル
                            console.log( dateA.getUTCDate());  // 9(日)
                            console.log( dateA.getUTCHours());  // 15(字)。タイムゾーンは UTC
                            console.log( dateA.getMonth() );  // 3 (=4月、1月は 0)
                            console.log( dateA.getTimezoneOffset() ); // -540, システムのタイムゾーンを使用

                        console.log('dateAU');
                        const  dateAU = new Date( dateA.toISOString() ); // Use UTC API as local time zone
                        dateAU.setMinutes( dateA.getMinutes() - dateA.getTimezoneOffset() );
                            console.log( dateAU.toISOString() );  // "2000-04-10T00:00:00.000Z" // toJSONも同じ
                    時刻だけ扱う場合:  #// 年月日を使わない場合
                        #// JavaScript ネイティブの時刻だけ扱うクラスは存在しません
                        サンプル:
                            gDefaultDateChangeTime:  #ref: ${GitHub}/MyPrivateCode/Node_js/tradeBackTest/src/tick.ts#gDefaultDateChangeTime
                            getOperationalDay:  #ref: ${GitHub}/MyPrivateCode/Node_js/tradeBackTest/src/tick.ts#getOperationalDay
                無効値, Invalid Date: #keyword: JavaScript Invalid Date
                    判定: isNaN( dateObject.getTime() )
                閏年: const  isLeapYear = ! isNaN((new Date(year, 2-1, 29)).getDate());
                タイムゾーン: #keyword: JavaScript time zone
                    ローカル タイムゾーン:
                        どのタイムゾーンが使われるか:  #search: JavaScript local time zone
                        数値で取得: getTimezoneOffset
                        ISO 形式で取得: getCurrentTimeZoneIsoFormat  #// +09:00 など
                    タイムゾーン指定なしの場合:  #search: JavaScript without ISO time zone
                Unix Time: #keyword: JavaScript エポック秒,  JavaScript Unix Time
                    new Date(__UnixTime13__)  #// 13桁の Unix Time。 10桁のときは ×1000
                書式, 文字列:
                    ISO8601 形式: #keyword: JavaScript ISO 日時  #// 例：2000-04-09T15:00:00.000Z
                        ローカル: | #keyword: getLocalISOString  #// 末尾にタイムゾーンは付きません
                            export function  getLocalISOString(date: Date): string {
                                const  tzOffset = date.getTimezoneOffset() * (60*1000);

                                const  localISOTime = (new Date(date.getTime() - tzOffset)).toISOString().slice(0, -1);  // Cut last Z
                                return  localISOTime;
                            }
                        UTC: .toISOString()  #// 末尾に Z が付きます
                    YYYYMMDD 形式:
                        JavaScript の標準メソッド: ありません
                        YYYYMMDD:  // from "YYYY-MM-DD"
                            isoString.substring(0, 4) + isoString.substr(5, 2) + isoString.substr(8, 2);
                            #ref: https://stackoverflow.com/questions/23593052/format-javascript-date-as-yyyy-mm-dd
                        #search: Day.js YYYY
                        #search: formatDate
                コピー: #keyword: copy JavaScript Date
                    const  copiedDate = new Date(originalDate);
                比較: |
                    console.log( dateA.getTime() === dateAA.getTime() );  // true
                    console.log( dateA.getTime() !== dateAA.getTime() );  // false
                    console.log( dateB.getTime() !== dateA.getTime() );   // true
                    console.log( dateB.getTime()  >  dateA.getTime() );   // true
                    console.log( dateB.getTime()  <  dateA.getTime() );   // false
                時間: |
                    const  dateA = new Date('2000-04-10T12:00:00');
                    const  dateB = new Date('2000-04-10T12:02:00');
                    const  diffMiliseconds = dateB.getTime() - dateA.getTime();
                    const  diffSeconds = (dateB.getTime() - dateA.getTime()) / 1000;
                計算:  #keyword: JavaScript Date 計算  #// 年月日のそれぞれに、現在の値と加減算します
                    サンプル: |
                        console.log('dateB');
                        const  dateAA = dateA  // 参照。日付オブジェクトは複製されない
                        const  dateB = new Date( dateA );  // 複製

                        dateB.setFullYear( dateB.getFullYear() + 1 );  // 年
                        dateB.setMonth(    dateB.getMonth() + 1 );     // 月
                        dateB.setDate(     dateB.getDate()  + 1 );     // 日
                        dateB.setHours(    dateB.getHours()   + 1 );   // 時
                        dateB.setMinutes(  dateB.getMinutes() + 1 );   // 分
                        dateB.setSeconds(  dateB.getSeconds() + 1 );   // 秒。ミリ秒は setMilliseconds
                    差: |
                        function diffMinutes(later, earlier) {
                            return (later.getTime() - earlier.getTime()) / 60000;
                        }
                    ボツ:
                        他の date + n:
                            サンプル: dateB.setSeconds( dateA.getSeconds() + 1 );
                            問題点:  繰り上がりなどが計算に含まれなくなります。
                                const  dateA = new Date('2021-12-01');
                                dateB.setMonth(    dateA.getMonth() + 1 );     // 13月 → 2022年 1月
                                dateB.setFullYear( dateA.getFullYear() + 1 );  // 2022年
                            対処:  #// 未確認
                                年を先に計算します。
                                const  dateA = new Date('2021-12-01');
                                dateB.setFullYear( dateA.getFullYear() + 1 );  // 2022年
                                dateB.setMonth(    dateA.getMonth() + 1 );     // 13月 → 2023年 1月
                        toISOString: |
                            // toISOString でコピーするとタイムゾーンが UTC になってしまいます
                            console.log( dateB.toISOString() );   // "2001-05-10T16:01:01.000Z"
                            console.log( dateB.getHours() );  // 1
                            console.log( dateB.getTimezoneOffset() ); // -540(timezone)
                待つ:  #search: sleep lib.ts
                性能計測: #keyword: JavaScript benchmark,  measure JavaScript speed time
                    lib.time:  #ref: ${GitHub}/typrm/src/lib.ts#export namespace  time
                        サンプル: |
                            var  timeTag = true;
                            timeTag && lib.time.start(`searchSub`);
                                ...
                            timeTag && lib.time.end(`searchSub`);
                            printTime();  #ref: ${GitHub}/typrm/src/main.ts#function  printTime()
                            #benchmark:
                    console.time:  #// 簡単に使えますが、timeEnd のたびに表示するため、ループ内の合計には使えません
                        サンプル: |
                            var  timeTag = true;
                            timeTag && console.time(`#time: searchSub`);
                                ...
                            timeTag && console.timeEnd(`#time: searchSub`);  // #time: searchSub: 1.648s
                    performance:  #// Node.js
                        サンプル: |
                            import { performance } from 'perf_hooks';
                            performance.now();  // ミリ秒。ミリ秒以下の小数も含みます
                formatDate: | #keyword: JavaScript formatDate
                        function  formatDate(date: Date, format: string): string {
                            return  format
                                .replace('yyyy', String(date.getFullYear()))
                                .replace('MM', String(date.getMonth()+1).padStart(2, '0'))
                                .replace('dd', String(date.getDate()).padStart(2, '0'));
                        }
                    #search: Day.js YYYY
                    #search: JavaScript ISO 日時
                Day.js, dayjs: #keyword:
                    書式:
                        YYYY/MM/DD: |  #keyword: Day.js YYYY
                            import dayjs from 'dayjs';
                            const now = dayjs();
                            console.log(now.format('YYYY/MM/DD'));           // 2025/11/25
                            console.log(now.format('YYYY-MM-DD HH:mm:ss'));  // 2025-11-25 14:30:45
                date-fns: #keyword:  #// 日付の表示形式。ブラウザーの JavaScript でも十分でしょう
                    インストール: npm install date-fns
                    参考: #ref: https://nextjs.org/learn/basics/dynamic-routes/polishing-post-page
                    書式:
                        YYYY/MM/DD: |  #keyword: date-fns YYYY
                            import { format } from 'date-fns';
                            const now = new Date();
                            console.log(format(now, 'yyyy/MM/dd'));           // 2025/11/25
                            console.log(format(now, 'yyyy-MM-dd HH:mm:ss'));  // 2025-11-25 14:30:45
                Moment.js, moment: #keyword: #// Moment.js は現在「メンテナンスモード」になっており、新規プロジェクトでは推奨されていません。
                    書式:
                        YYYY/MM/DD: | #keyword: Moment.js YYYY  #// "YYYY/MM/DD" のような指定はできません
                            import moment from 'moment';
                            moment(new Date(this.year, this.month - 1)).format("YYYY-MM")
                            const  now = moment();
                            console.log(now.format('YYYY/MM/DD'));           // 2025/11/25
                            console.log(now.format('YYYY-MM-DD'));           // 2025-11-25
                            console.log(now.format('YYYY/MM/DD HH:mm:ss')); // 2025/11/25 14:30:45
                            console.log(now.format('YYYY年MM月DD日'));      // 2025年11月25日
                Luxon: #keyword:  #// Moment の開発者が作成したが有名ではない
                Temporal: #keyword: Temporal,  JavaScript Date Temporal  #ref: https://gihyo.jp/article/2025/02/ride-modern-frontend-07
                    取得, タイムゾーン:
                        Temporal.Instant:
                            const  instantDateTime = Temporal.Instant.from("2025-01-01T00:00:00Z");
                        Temporal.ZonedDateTime: |
                            const  zonedDateTime1 = instantDateTime.toZonedDateTimeISO("Asia/Tokyo");
                            const  zonedDateTime2 = new Temporal.ZonedDateTime(BigInt(1735689600000) * 1000n, "Asia/Tokyo");
                            const  zonedDateTime3 = Temporal.ZonedDateTime.from({
                                year: 2025,
                                month: 1,
                                day: 1,
                                hour: 9,
                                minute: 0,
                                timeZone: "Asia/Tokyo",
                            });
                        string: |
                            zonedDateTime.toLocaleString("ja-JP", {
                                dateStyle: "medium",
                                timeStyle: "short",
                            }); // "2025年1月1日水曜日 9:00"
                    計算:
                        Temporal.Duration: |
                            const duration = Temporal.Duration.from({ days: 1, hours: 12 }); // 1.5日
                            const duration_ = new Temporal.Duration(0, 0, 0, 1, 12); // 上と同じ
                        add()／subtract:  #// 日時の加算減算
                            const addedZonedDateTime = zonedDateTime.add(duration);
                        compare()／equals:  #// 日時の比較
                        since()／until:  #// 日時の差分計算
                        round:  #// 日時の丸め
                    書式:
                        YYYY/MM/DD: |  #keyword: Temporal YYYY  #// "YYYY/MM/DD" のような指定はできません
                            const now = Temporal.Now.plainDateISO();
                            const formatted = now.toLocaleString('ja-JP', {
                                year: 'numeric',
                                month: '2-digit',
                                day: '2-digit'
                            }).replace(/\//g, '/'); // 既にスラッシュ区切りになっている場合が多い

                            console.log(formatted); // 2025/11/25
                日時ピッか:
        定数: #keyword: TypeScript const
            グローバル:
                // グローバル スコープ で
                const  Variable = 1;
                const  API_URL = 'https://api.example.com';
                const  VARIABLE = 1;
            クラスのプロパティ: |
                class ApiClient {
                    static readonly  BaseURL = 'https://api.example.com';
                    private static readonly  DefaultHost = 'localhost';
                    static readonly DATABASE = {
                        host: 'localhost',
                        port: 5432,
                        name: 'myapp'
                    } as const;
            構造: |
                const CONFIG = {
                    readonly  apiURL: 'https://api.example.com',
                    readonly  maxRetries: 3
                } as const;
            名前空間: |
                namespace Constants {
                    export const API_BASE_URL = 'https://api.example.com';
            enum:  #search: TypeScript enum
        enum, Union: #keyword: TypeScript enum
            enum:
                enum 型:
                    基本:
                        定義: |
                            enum CardSuit {
                                Clubs,    // 0
                                Diamonds, // 1
                                Hearts,   // 2
                                Spades    // 3
                            }
                        参照と代入: |
                            const cardSuit: CardSuit = CardSuit.Clubs;
                    開始値指定: |
                        enum Color {
                            DarkRed = 3,  // 3
                            DarkGreen,    // 4
                            DarkBlue      // 5
                        }
                    文字列の値: |
                        enum EvidenceTypeEnum {
                            UNKNOWN = '',
                            PASSPORT_VISA = 'passport_visa',
                            PASSPORT = 'passport',
                            SIGHTED_STUDENT_CARD = 'sighted_tertiary_edu_id',
                        }
                    Unicode 文字のシンボル: |
                        enum TestID {
                            あ = "a",
                            し = "shi",
                        }
                        var id = TestID.し;
                        console.log(id); // shi
                Union 型: |  #// enum 型に相当する Union 型  #keyword: TypeScript enum Union,  TypeScript const type typeof keyof
                    const EnumType = {
                        A: "aValue",
                        B: "bValue",
                    } as const;
                    type EnumType = typeof EnumType[keyof typeof EnumType];  // type EnumType = "aValue" | "bValue" 
                    const  typeX: EnumType = EnumType.A;
                enum と Union 型の比較: #keyword: TypeScript compare enum Union
                    比較表: |
                        項目              enum  Union
                        -------------------------------
                        数値の省略         OK    NG
                        型推論            OK    NG
                        数値の値チェック    NG    OK
                        文字列の値チェック  OK    OK
                        ビット フラグ      OK    NG
                        可読性            Good  Bad
                        文字列値の冗長     ?     ?
                    number 型の値の場合: |
                        // enum
                        enum CardSuit {
                            Clubs,    // 0
                            Diamonds, // 1
                            Hearts,   // 2
                            Spades,   // 3
                        }
                        var cardSuit = CardSuit.Clubs;  // 型推論が行われます。cardSuit:CardSuit = CardSuit.Clubs にしなくてよい
                        cardSuit = CardSuit.Diamonds;
                        cardSuit = 99;  // 範囲外の値を代入できてしまいます。CardSuit.____ を使えばそのミスは無くなります
                        console.log(cardSuit);  // 99
                        console.log(cardSuit.toString());  // 99

                        // Union
                        const Color = {
                            Red: 0,
                            Green: 1,
                            Blue: 2,
                        } as const;
                        type Color = typeof Color[keyof typeof Color]; // 0 | 1 | 2

                        var color:Color = Color.Red;  // color = Color.Red にすると、下記のエラー2322になります
                        color = Color.Green;  // 上記型指定が無いと rror: Type '1' is not assignable to type '0'.ts(2322)
                        // color = 99;  // 範囲外の値を代入しようとすると警告してくれます
                        console.log(color);  // 1
                        console.log(color.toString());  // 1
                    ビット フラグ（論理和）として使う number 型の値の場合: |
                        // enum
                        enum Permission {
                            Read    = 1,
                            Write   = 2,
                            Execute = 4,
                        }
                        var cardSuit = Permission.Read;
                        cardSuit = Permission.Execute | Permission.Read;
                        console.log(cardSuit);  // 5
                        cardSuit = 99;  // 範囲外の値を代入できてしまいます。CardSuit.____ を使えばそのミスは無くなります
                        console.log(cardSuit);  // 99

                        // Union　（使えません）
                        const Color3 = {
                            Blue: 1,
                            Green: 2,
                            Red: 4,
                        } as const;
                        type Color3 = typeof Color3[keyof typeof Color3]; // 1 | 2 | 4

                        var color:Color3 = Color3.Blue;  // color = Color.Red にすると、下記のエラー2322になります
                        // color = Color3.Red | Color3.Blue;  // 上記型指定が無いと Error: Type 'number' is not assignable to type 'Color3'.ts(2322)
                        // color = 99;  // 範囲外の値を代入しようとすると警告してくれます
                        console.log(color);  // 1
                    string 型の値の場合: |
                        // enum
                        enum CardSuit {
                            Clubs    = 'クローバー',
                            Diamonds = 'ダイヤ',
                            Hearts   = 'ハート',
                            Spades   = 'スペード',
                        }
                        var cardSuit = CardSuit.Clubs;
                        cardSuit = CardSuit.Diamonds;
                        // cardSuit = 'ジョーカー';  // 範囲外の値を代入しようとすると警告してくれます
                        console.log(cardSuit);  // ダイヤ

                        // Union
                        const Color = {
                            Red:   '赤',
                            Green: '緑',
                            Blue:  '青',
                        } as const;
                        type Color = typeof Color[keyof typeof Color]; // '赤’ | ’緑’ | '青'

                        var color:Color = Color.Red;  // color = Color.Red にすると、下記のエラー2322になります
                        color = Color.Green;  // 上記型指定が無いと Error: Type '1' is not assignable to type '0'.ts(2322)
                        // color = '透明';  // 範囲外の値を代入しようとすると警告してくれます
                        console.log(color);  // 緑
                    参考:
                        #ref: https://www.kabuku.co.jp/developers/good-bye-typescript-enum
                #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#enum
                Template Literal: #keyword: JavaScript テンプレート リテラル,  テンプレート文字列 JavaScript backquote string ``
                    公式: #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Template_literals
                    注意: テンプレート リテラル 型 とは異なります
                    HTML の場合: HTML テンプレート エンジン を使ってください  #search: HTML テンプレート エンジン
                    基本のサンプル: |
                        `string text`
                    複数行のサンプル: |
                        `string text line 1
                        string text line 2`
                    変数参照のサンプル:
                        基本: |  #// ${ } の中に関数や式も書けます
                            `string text ${expression} string text`
                        配列の場合:
                            ${expression}: 配列数
                            ${getAllQuotedCSVLine(expression)}: CSV 形式の要素の並び  #search: getAllQuotedCSVLine
                Tagged Template Literal: #keyword: タグ付き テンプレート リテラル,  Tagged Template Literal
                    書式:
                        参照: __Tag__`__TemplateLiteral__`
                        定義: |  #// 変数参照が 2つある場合
                            - function  __Tag__(__TemplateParts__: string[], __Variable1__: string, __Variable2__: string) {
                            - function  __Tag__(__TemplateParts__: TemplateStringsArray | string,  ... values: any[]): string {
                    #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Template_literals#タグ付きテンプレート
                Template Literal Types: #keyword: JavaScript テンプレート リテラル 型,  JavaScript Template Literal Types
                    公式: #ref: https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html
                    注意: テンプレート リテラル とは異なります
                    概要: 定義の中に変数が使えるリテラル型です
                    書式:
                        type __Type__ = ____${__TypedExpression__}____;
                    サンプル (1): | #focus: World
                        type World = "world1";             // World 型を定義します
                        type Greeting = `hello ${World}`;  // type Greeting = "hello world1"; と同じ処理です
                    サンプル (2): | #focus: Type12
                        type Type1 = "T1A" | "T1B";
                        type Type2 = "T2A" | "T2B";
                        type Type12 = `${Type1 | Type2}_id`;
                            // type Type12 = "T1A_id" | "T1B_id" | "T2A_id" | "T2B_id"; と同じ処理です
                            // 和集合はクロス乗算されます
            Union 型: #keyword: TypeScript Union, 合併型(?)  #// 複数の型のうちどれか1つの型の値をとりうる型
                #ref: https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html#unions
                複数の型:
                    サンプル: |
                        type  MyType = number | string;
                        var  variable: MyType;
                        variable = 1;     // OK
                        variable = 'a';   // OK
                        variable = true;  // エラー
                    参考: https://typescript-jp.gitbook.io/deep-dive/type-system/discriminated-unions
                複数の値:
                    サンプル: |
                        type  SelectType = "a" | "b";
                        var  select: SelectType;
                        select = "a";  // OK
                        select = "b";  // OK
                        select = "c";  // エラー
                enum の代わりとしての Union 型:
                    基本:
                        定義: |
                            const Color = {
                                Red: 0,
                                Green: 1,
                                Blue: 2
                            } as const;
                            type Color = typeof Color[keyof typeof Color]; // 0 | 1 | 2
                        参照と代入: |
                            const color = Color.Red;
                        注意: | #// var で宣言した変数の値を変更できるようにするには、変数名の右に型を書く必要があります
                            var color:Color = Color.Red;  // color = Color.Red にすると、下記のエラーになります
                            color = Color.Green;  // Error: Type '1' is not assignable to type '0'.ts(2322)
                            console.log(color);
                    参考:
                        enum と Union 型の比較: #search: TypeScript enum Union
            リテラル型: #// リテラル型, テンプレート リテラル 型
                リテラル型:  #keyword: リテラル型, Literal Types
                    公式: #ref: https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types
                    概要: 特定の値のみ代入できる型です
                    サンプル: #keyword: リテラル型のユニオン
                        - const  name = "Mario";             // name は string 型ではなく "Mario" のリテラル型です
                        - const  names = "Mario" | "Luigi";  // "Mario" のリテラル型と "Luigi" のリテラル型のユニオン（Union 型）です
                        - const  numbers = 0 | 1 | 2;
                        - const  n = number | "default";     // number 型と "default" のリテラル型のユニオン（Union 型）です
        コレクション:  #// 配列, マップ, 辞書
            配列:  #keyword: JavaScript array  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#Array
                公式: #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Indexed_collections
                初期化:
                    空: |
                        const  names: string[] = [];
                    同じ値の複数要素: |
                        const array = new Array(length).fill(value);
                要素数: __Array__.length
                追加・削除:  #// push, pop, shift, concat, splice
                    追加:  #glossary: JavaScript
                        push: |  #// __Array__.push( __Element__ );  // 最後に追加します
                            const  a = [1,2];
                            a.push(3);       // [1, 2, 3]
                            a.push(4,5);     // [1, 2, 3, 4, 5]
                            const  b = [6,7];
                            a.push(... b);  // [1, 2, 3, 4, 5, 6, 7]  // スプレッド構文
                            a.push(b);      // [1, 2, 3, 4, 5, 6, 7, [6, 7]]
                        unshift: |  #// __Array__.unshift( __Element__ );  // 先頭に追加します
                            const  a = [1,2];
                            a.unshift(3);   // [3, 1, 2]
                        concat: |  #// __Array1__.concat( __Array2__ );  // 配列を結合したものを返します
                            const  arr1 = [ "a", "c" ];
                            const  arr2 = [ "b", "c" ];
                            const  arr = arr1.concat( arr2 );  // ["a", "c", "b", "c"]
                                // 最後に要素を追加した配列を返します
                    削除:  #glossary: JavaScript array
                        pop: const  last = names.pop();  // 空なら undefined
                        shift: const  first = names.shift();  // 空なら undefined
                        splice: const  removedItems = __Array__.splice( __DeletingPosition__, __DeletingCount__ );
                        filter: __ObjectArray__.filter(object => (object !== __RemovingObject__));
                    削除と追加:  #glossary: JavaScript
                        splice: const  removedItems = __Array__.splice( __DeletingPosition__, __DeletingCount__ [, __InsertItem1__ ][, __InsertItem2__ ...] );
                            #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#splice
                    空にします:  #keyword: JavaScript array empty
                        - names = [];
                        - names.length = 0;
                コピー: |  #keyword: copy JavaScript array
                    arr2 = arr1.slice();  // copy  // 全部
                    arr2 = arr1.slice(start, over);
                    arr2 = arr1.obtains!.map((item)=>item!);  // item: number | null を item: number へ
                ループ:  #keyword: JavaScript array for loop
                    要素, 文字: |
                        for (const name of names) {
                            WScript.Echo  name
                        }
                    配列番号: |
                        for (let i = 0;  i < names.length;  i+=1) {
                            WScript.Echo  value
                        }
                    reduce:  #keyword: JavaScript reduce
                        基本形:  #// オブジェクトの配列には使えません
                            サンプル: |  #// sum
                                const array1 = [1, 2, 3, 4];
                                const  cum = array.reduce((sum, element) => (sum + element), 0);  // (0) + 1 + 2 + 3 + 4
                                    // reduce は、第1引数の関数を、それぞれの配列要素に対して呼び出します
                                    // sum (accumulator) は、前に呼び出した関数の返り値です
                            サンプル2: |
                                const array1 = [1, 2, 3, 4];

                                const reducedValue = array1.reduce((previous, element) => {
                                    return  previous + element;
                                });  // 1 + 2 + 3 + 4
                                console.log(reducedValue);  // 10
                            解説:
                                配列の reduce メソッドは、指定した関数 reducer を使って、以下の関数呼び出しを行います。
                                    n1 = reducer(1, 2);
                                    n2 = reducer(n1, 3);
                                    n3 = reducer(n2, 4);
                                上記の previous は、reduce のアキュムレーターと呼びます。
                        カウント:  #// 条件を満たすオブジェクトの数を数えます
                            推奨: #// filter と length を使います
                                __Array__.filter(item => (item.age >= 18)).length  #search: JavaScript filter
                            （非推奨）サンプル: |
                                array1.reduce((previous, match) => (previous + (
                                    element.prop == 'keyword'
                                    ? +1 : 0)), 0);
                        合計、初期値あり:
                            サンプル:
                                アロー関数の場合: |
                                    const array1 = [1, 2, 3, 4];

                                    const reducedValue = array1.reduce((previous, element) => {
                                        return  previous + element * 2;
                                    }, 0);  // 0 + 1*2 + 2*2 + 3*2 + 4*2
                                    console.log(reducedValue);  // 20
                                アロー関数式の場合: |
                                    const array1 = [1, 2, 3, 4];

                                    const sum = array1.reduce((previous, item) => (previous + item * 2),  0);  // 0 + 1*2 + 2*2 + 3*2 + 4*2
                                    console.log(sum);  // 20
                            解説:
                                最初の要素も element 引数に渡されるようにするには、初期値を reduce の第3引数に指定します。
                        max: | #keyword: JavaScript Math.max  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Math/max
                            var arr = [1,2,3];
                            var max = arr.reduce((a, b) => Math.max(a, b), -Infinity);
                検索: #keyword: JavaScript array search
                    indexOf:  #keyword: JavaScript array indexOf  #ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
                        基本サンプル: index = myArray.indexOf('stevie');
                        途中から: index = myArray.indexOf('stevie', startIndex);
                        サンプル: index = myArray.map((e)=>(e.hello)).indexOf('stevie');
                        指定した文字を含まない位置: 正規表現でできます。indentRegularExpression  #ref: ${GitHub}/typrm/src/main.ts#indentRegularExpression =
                        デフォルト値: |  #// 見つからなかったとき
                            あまり短くならない  Python .get(__Key__, __Default__) のようにならない
                            ES2020以降では、Optional Chaining（?.）とNullish Coalescing（??）演算子を組み合わせて以下のように書くこともできます：
                            const index = array.indexOf(searchElement) === -1 ? defaultValue : array.indexOf(searchElement);
                        オブジェクトの中を比較する場合:  #search: JavaScript array findIndex
                        参考:  #ref: https://stackoverflow.com/questions/8668174/indexof-method-in-an-object-array/38516944
                    lastIndexOf:  #keyword: JavaScript array lastIndexOf
                        基本サンプル: index = myArray.lastIndexOf('stevie');
                        途中から検索します: |
                            'canal'.lastIndexOf('a');     // 3 を返す
                            'canal'.lastIndexOf('a', 2);  // 1 を返す
                        参考:  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf
                    findIndex:  #keyword: JavaScript array findIndex
                        概要: 条件を満たす最初の要素のインデックスを返します。見つからなかったら -1
                        基本サンプル:
                            コード: |
                                const array1 = [
                                    { id: 1, value:'A'},
                                    { id: 2, value:'B'},
                                    { id: 3, value:'C'},
                                    { id: 4, value:'B'},
                                ];

                                const  foundIndex = array1.findIndex((element) => (element.value === 'B'));
                                console.log(foundIndex);
                                console.log(array1[foundIndex]);
                            出力: |
                                1
                                Object { id: 2, value: "B" }
                    findLastIndex:  #keyword: JavaScript findLastIndex,  JavaScript findIndex reverse  #// 逆順で検索します。配列の末尾の要素から満たすものを探します
                        ES2023以降の場合:
                            __Array__.findLastIndex((element) => (element.value === 'B'));
                        関数の場合: |
                                export function  findLastIndex<T>(array: Array<T>, predicate: (value: T, index: number, obj: T[]) => unknown): number {
                            #ref: ${GitHub}/MyPrivateCode/Node_js/tradeBackTest/src/primitive.ts#findLastIndex
                        直書きの場合:
                            const result = __Array__.length - 1 - [... __Array__].reverse().find((item) => item.ID === __TargetID__);
                            #// [... ] は、逆順になる配列のコピーを作るためです
                    find:  #search: JavaScript find
                ソート:  #keyword: JavaScript sort
                    文字列配列のソート, オブジェクトのソート:
                        文字コード順: |
                            ["b","aa","c"].sort()  // ["aa","b","c"]
                        オブジェクトのソート: |  #ref: https://stackoverflow.com/questions/51165/how-to-sort-strings-in-javascript
                            [____].sort((a,b)=>('' + a.attr).localeCompare(b.attr))
                        文字の長さの降順: |
                            ["b","aaa","cc"].sort((a,b)=>(b.length - a.length));  // ["aaa", "cc", "b"]
                    数値のソート:
                        サンプル: |
                            const  a = [7,21];
                            a.sort((a,b)=>(a-b));  // a: [7,21]
                        降順のサンプル: |
                            const  a = [7,21];
                            a.sort((a,b)=>(b-a));  // a: [21,7]
                        引数を省略したとき: |
                            const  a = [7,21];
                            a.sort();  // a: [21,7]
                        #// sort に引数を渡さないと、Unicode 文字列に変換してから比較するため、
                        #// [7,21].sort() は [21,7] になってしまいます。
                    逆順:
                        const reversed = array1.reverse();
                    Map のキーでソート: #keyword: JavaScript Map sort  #search: JavaScript Map
                        キーが数値の場合:
                            map = new Map([... map.entries()].sort(([key1,_item1], [key2,_item2]) => key1 - key2));
                        キーが文字列または数値の場合:
                            map = new Map([... map.entries()].sort(([key1,_item1], [key2,_item2]) => key1 < key2 ?-1:+1));
                    #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#sort
                    #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#hash_sort
                フィルター:
                    filter: #keyword: JavaScript filter  #// 条件を満たすすべての要素を含む配列を返します
                        __Array__.filter((item) => (item.age >= 18))
                    find: #keyword: JavaScript find,  JavaScript search find in array  #// 条件を満たす最初の要素を返します。見つからなければ undefined を返します
                        基本:
                            __Array__.find((item) => item.ID === __TargetID__)
                        findIndex:  #search: JavaScript array findIndex
                        index:  #search: JavaScript array indexOf
                        逆順で検索します: #search: JavaScript findLastIndex
                    some: #keyword: JavaScript some  #// 条件を満たす要素が1つでもあるかどうかを返します
                        書式: __Array__.some(__Variable__ => __Expression__)
                        サンプル: items.c((item) => item.type === 1)
                        要素数 0 の場合: false
                    every: #keyword: JavaScript every  #// 全ての要素が条件を満たすかどうかを返します
                        書式: __Array__.every(__Variable__ => __Expression__)
                        サンプル: items.every((item) => item.type === 1)
                        要素数 0 の場合: true
                    map:  #keyword: JavaScript map filter,  JavaScript 内包
                        ret = arr.map( (data) => ( __NewItem__ ));
                        ret = arr.map( (data) => { return __NewItem__ });
                    join: |  #keyword: JavaScript join
                            ["apple", "banana", "cherry"].join(",") === "apple,banana,cherry";
                        #search: JavaScript split
                    slice: #keyword: JavaScript array slice
                        コード: |
                            const array1 = [
                                {id: 1, value:'A'},
                                {id: 2, value:'B'},
                                {id: 3, value:'C'},
                                {id: 4, value:'B'},
                            ];

                            const  slice_1_3 = array1.slice(1,3);
                            console.log(slice_1_3);
                        出力: |
                            Array [Object { id: 2, value: "B" }, Object { id: 3, value: "C" }]
                    先頭からいくつか:
                        #search: JavaScript array slice
                    関連 >> reduce:  #search: JavaScript reduce
                比較:
                    最小: Math.min(... array)
                    順序も同じ: #search: lib.ts isSameArray
                    順不同: #search: lib.ts isSameArrayOf
                含む, 共通要素:
                    includes:  #keyword: JavaScript includes
                        書式: __Array__.includes(__Key__, __StartIndex__)
                        サンプル: |
                            [11, 22, 33].includes(11)  // true
                            [11, 22, 33].includes(44)  // false
                            [11, 22, 33].includes(22, 1)  // true
                            [11, 22, 33].includes(22, 2)  // false
                    共通要素:
                        for 版（推奨）: |
                            function  getCommonItemsUsingFor<T>(arrayA: T[], arrayB: T[]): T[] {
                                const  commonItems = [] as T[];
                                for (const item of arrayA) {
                                    if (arrayB.includes(item)){
                                        commonItems.push(item);
                                    }
                                }
                                return  commonItems;
                            }
                        reduce 版: |
                            function  getCommonItemsUsingReduce<T>(arrayA: T[], arrayB: T[]): T[] {
                                return  arrayA.reduce( (previous, item) => {
                                    if (arrayB.includes(item)){
                                        previous.push(item);
                                    }
                                    return previous;
                                }, [] as T[]);
                            }
                        テスト: |
                            const  arrA = [ 1, 3, 5, 7 ];
                            const  arrB = [ 2, 3, 4, 5 ];
                            console.log(getCommonItemsUsingFor(arrA, arrB));    // [ 3, 5 ]
                            console.log(getCommonItemsUsingReduce(arrA, arrB)); // [ 3, 5 ]
                    重複削除:  #keyword: JavaScript 重複削除
                        Map を使う場合:  #// 処理効率が良いですが、同じ要素のうちどの要素が残るかは不定です  #focus: id: 4
                            コード: |
                                const array1 = [
                                    {id: 1, value:'A'},
                                    {id: 2, value:'B'},
                                    {id: 3, value:'C'},
                                    {id: 4, value:'B'},
                                ];

                                const uniqueArray = Array.from(
                                    new Map(array1.map((element) => [element.value, element])).values()
                                );
                                console.log(uniqueArray);
                            出力: |
                                Array [Object { id: 1, value: "A" }, Object { id: 4, value: "B" }, Object { id: 3, value: "C" }]
                        filter, findIndex を使う場合:  #// 処理効率が悪いですが、インデックスが小さい要素が必ず残ります
                            コード: |
                                const array1 = [
                                    {id: 1, value:'A'},
                                    {id: 2, value:'B'},
                                    {id: 3, value:'C'},
                                    {id: 4, value:'B'},
                                ];

                                const  uniqueArray = array1.filter(
                                    (element, index, array) =>
                                        index === array.findIndex(
                                            (e) => (element.value === e.value)));
                                console.log(uniqueArray);
                            出力: |
                                Array [Object { id: 1, value: "A" }, Object { id: 2, value: "B" }, Object { id: 3, value: "C" }]
                        参考: #ref: https://qiita.com/allJokin/items/28cd023335641e8796c5
                差分: |
                    const  array1 = [1, 2, 3, 4];
                    const  array2 = [1, 2, 5, 6];

                    array1minus2 = array1.filter((element) => (array2.indexOf(element) === -1));
                    console.log(array1minus2); // [3, 4]

                    array2minus1 = array2.filter((element) => (array1.indexOf(element) === -1));
                    console.log(array2minus1); // [5, 6]
                要素の型:
                    配列の型から要素の型を返します:
                        サンプル: |
                            type __ArrayType__ = (string | number | boolean)[]  // string または number または boolean を要素に持つ配列
                            type __ElementType__ = __ArrayType__[number]  // string | number | boolean になる
                        参考: https://qiita.com/suin/items/25588b2beba7a3fcce4f
                            https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html
                文字列変換: #keyword: JavaScript array string
                    配列 → 文字列:
                        array.join("\n");  // 最終行の末尾に改行はありません
                    文字列 → 配列:
                        ____  （未確認）
                継承: #// 配列を継承して、push したとき処理を行うなど
                    サンプル: |
                        export class  OpenPositionArray extends Array<OpenPosition> {
                            push(item: OpenPosition): number {
                                const  returnValue = super.push( item );
                                console.log(`${indent}Add OpenPosition: ${new OpenPosition( item )}`);
                                return  returnValue;
                            }
                        }
                参考: #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#Array
            Map（Map, オブジェクト, 辞書, ハッシュ）:  #keyword: JavaScript Map,  JavaScript hash,  JavaScript dictionary
                #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#hash
                オブジェクトと Map の違い:
                    TypeScript ではオブジェクトのキーは静的です:
                    Map のキーは String 以外もできます:
                    Map の反復処理は要素の挿入順に行われます:
                        順序が入れ替わる例: #search: parseMap
                    Map は簡単にサイズを取得できます:
                    参考: #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Keyed_collections
                オブジェクト, 連想配列:  #keyword: 連想配列  #// {[name: string]: boolean},  object["key1"]
                    型の例: |
                        {[name: string]: boolean}
                        {[__DummyName__: __IndexType__]: __ItemType__}
                    オブジェクトのメンバー名:  #keyword: JavaScript Object fields
                        constructor
                    追加:
                        基本:
                            dic[name] = item;
                        配列の辞書:  #// 指定されたキーが初めて指定された場合、辞書の要素に空の配列を設定する必要があります
                            ECMAScript 2020以降:
                                dic[name] ??= [];  // Set [] only when first item
                                dic[name].push(item);
                            それ以前:
                                dic[name] = dic[name] || [];  // Set [] only when first item
                                dic[name].push(item);
                    ループ:  #keyword: JavaScript map for loop,  JavaScript map hash for loop
                        - |
                            for (const key of Object.keys(__Object__)) {
                                (__Object__ as any)[key];
                            }
                        - for (const value of Object.values(__Object__)) { ____ }
                        - for (const [key, value] of Object.entries(__Object__)) { ____ }
                    キーの有無: #keyword: JavaScript Object exists in
                        #// オブジェクトのメンバー名（例：constructor）でも有りと判定されます
                        有無の判定:
                            - if ("key" in hash) { ...
                            - if ( ! ("key" in hash)) { ...
                        無いときの動作:
                            - hash["new_key"] === undefined
                                // 実行後 Object.keys(hash) に "new_key" は含まれません
                    キーの数:
                        Object.keys(hash).length
                    削除:
                        delete  hash.key;
                        delete  hash["key"];
                        #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/delete
                    readonly のハッシュ: |
                        {readonly [name: string]: boolean}
                    辞書の値の構造を変える: #// 配列の map メソッドや filter メソッドのような処理をします
                        説明:
                            配列の map のようなメソッドはありません。なぜならオブジェクトに map メソッドを予約しないからです。
                            Object.entries を使えば map, filter, forEach などが使えます。
                            for ループで書いた方が可読性が高いかもしれません。
                        Object.fromEntries, Object.entries の場合:  #keyword: Object.fromEntries, Object.entries
                            基本: |
                                const  entries = Object.entries( {a: 1, b: 2} );
                                const  object = Object.fromEntries(entries);
                                console.log(entries);  // [["a", 1], ["b", 2]]
                                console.log(object);   // {a: 1, b: 2}
                            map: |
                                const  key = 0,  value = 1;
                                const  object = Object.fromEntries(Object.entries
                                    ( {a: 1, b: 2} ).map(keyValue=>[ keyValue[key], keyValue[value] * 2 ]));
                                console.log(object);  // {a: 2, b: 4}
                            filter: |
                                const  key = 0,  value = 1;
                                const  object = Object.fromEntries(Object.entries
                                    ( {a: 1, b: 2} ).filter(keyValue => (keyValue[value] === 2)));
                                console.log(object);  // {b: 2}
                            補集合: |
                                const  all = {a: 1, b: 2};
                                const  key = 0,  value = 1;
                                const  object = Object.fromEntries(Object.entries( all )
                                    .filter(keyValue => (keyValue[value] === 2)));
                                const  others = Object.fromEntries(Object.entries( all )
                                    .filter(keyValue => ! (keyValue[key] in object)));
                                console.log(object);  // {b: 2}
                                console.log(others);  // {a: 1}
                        for の場合: |
                            for (const [key, value] of Object.entries(hash)) {
                                newHash[key] = value.lineNum;
                            }
                        forEach の場合: |  #// 非推奨。出力が分かりにくいため
                            Object.entries( hash ).forEach(([key,value])=>{ newHash[key] = value.lineNum; });
                        reduce の場合: |
                            const  inputObject = {a: 1, c: 3};
                            const  outputObject = Object.entries(inputObject).reduce((obj, [key,value]) => {
                                obj[key] = value * 2;  return  obj; }, {});
                            console.log(outputObject);  // {a: 2, c: 6}
                    #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Working_with_Objects
                Map:  #// Map<string, string>,  map.get("key1")
                    TypeScript:
                        サンプル: | #ref: https://www.gesource.jp/weblog/?p=7670
                            const  map = new Map<string, string>();
                            map.set("key1", "value1");
                            map.set("key2", "value2");
                            console.log(map.size); //=> 2
                            console.log(map.get("key1")); //=> value1
                            console.log(map.get("hoge")); //=> undefined キーが存在しないとき
                            console.log(map.has("key1")); //=> true
                            console.log(map.has("hoge")); //=> false
                            console.log(map.keys()); //=> MapIterator { 'key1', 'key2' }
                            console.log(map.values()); //=> MapIterator { 'value1', 'value2' }
                            console.log(map.entries()); //=> MapIterator { [ 'key1', 'value1' ], [ 'key2', 'value2' ] }
                            for (const [key, value] of Array.from(map.entries())) {
                                console.log(key + ' goes ' + value);
                            }
                            map.forEach((value: string, key: string) => {
                                console.log(key + "=" + value)
                            });
                            map.delete("key1");
                            console.log(map.size); //=> 1
                            map.clear();
                            console.log(map.size); //=> 0
                        new:
                            - const  __Map__ = new Map<number, string>();  #// Map<number, string> type
                            - const  __Map__ = new Map<number, string>([ [1, 'value1'], [2, 'value2']]);
                        set: __Map__.set(__Key__, __Value__);
                        get: __Map__.get(__Key__);
                        has: __Map__.has(__Key__);
                        size: __Map__.size;
                        delete: __Map__.delete(__Key__);
                        clear: __Map__.clear();
                        keys: __Map__.keys();  Array.from(__Map__.keys())
                        values: __Map__.values();
                        entries: __Map__.entries();
                        for: for (const [__Key__, __Value__] of Array.from(__Map__.entries())) {
                        forEach: __Map__.forEach( () => {} );
                        merge: |
                            const  map1 = new Map<number, string>([[1, 'A'],  [3, 'B']]);
                            const  map2 = new Map<number, string>([[3, 'BB'], [7, 'C']]);
                            var merged = new Map([...map1, ...map2])
                            console.log(merged);  // [1, 'A'], [3, 'BB'], [7, 'C']]
                    JavaScript:
                        サンプル: |  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Keyed_collections
                            let sayings = new Map();
                            sayings.set('dog', 'woof');
                            sayings.set('cat', 'meow');
                            sayings.set('elephant', 'toot');
                            sayings.size; // 3
                            sayings.get('dog'); // woof
                            sayings.get('fox'); // undefined
                            sayings.has('bird'); // false
                            sayings.delete('dog');
                            sayings.has('dog'); // false

                            for (let [key, value] of sayings) {
                                console.log(key + ' goes ' + value);
                            }
                            // "cat goes meow"
                            // "elephant goes toot"

                            sayings.clear();
                            sayings.size; // 0
                        new: const  __Map__ = new Map();
                        set: __Map__.set(__Key__, __Value__);
                        get: __Map__.get(__Key__);
                        has: __Map__.has(__Key__);
                        size: __Map__.size;
                        delete: __Map__.delete(__Key__);
                        clear: __Map__.clear();
                        for: for (const [__Key__, __Value__] of __Map__) {
                    jest expect:
                        Map の内容を比較します:
                            Array.from, toStrictEqual: expect( Array.from(set1) ).toStrictEqual([ ["key","value"], ["key","value"] ]);
                            toBe (NG): expect(set1).toBe(set2);  #// エラーになります
                            toStrictEqual (NG): expect(set1).toStrictEqual(set2);  #// 順番が違っても Pass してしまいます
                    ソート: #search: JavaScript Map sort
                    関連:
                        Map のキーだけ使って重複しない配列を使うことの代わり: #search: JavaScript Set
                公式:
                    Map: #ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
                    TypeScript Index Signatures: #ref: https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures
            その他のコレクション:
                WeakMap: #// キーがオブジェクトのときの Map  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Keyed_collections#weakmap_object
                    WeakMap にするとガベージコレクションの対象になります。
                    WeakMap のキーであっても他からそのオブジェクトが参照されていなければ、ガベージコレクションの対象になります。
                Set: #keyword: JavaScript Set  #// 重複しない配列  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Keyed_collections#sets
                    関連 >> 重複削除: #search: JavaScript 重複削除
                    重複の判定方法: === で比較します
                    サンプル 1: |
                        const  set1 = new Set<string>();
                        set1.add('A');  // ['A']
                        set1.add('B');  // ['A', 'B']
                        set1.add('A');  // ['A', 'B']
                        set1.size == 2;
                        for (let item of set1) {
                        }
                        if (set1.has('A')) {
                            set1.delete('A');
                        }
                        array1 = Array.from(set1);
                        array2 = [...set1];
                    サンプル 2: |
                        const  set1 = new Set<string>(['A', 'B', 'A']);  // ['A', 'B']
                        const  set2 = new Set<string>(['A', 'C']);
                        var merged = new Set([...set1, ...set2])
                        console.log(merged);  // ['A', 'B', 'C']
                    サンプル 3 (JavaScript): |  #focus: Array.from(new Set(array1))
                        class  ClassA {
                            constructor(name, num) {
                                this.name = name;
                                this.num = num;
                            }
                        }
                        const  a = new ClassA('A', 1);
                        const  b = new ClassA('B', 2);

                        var  array1 = [a, b];
                        array1.push(a);
                        console.log(array1);  // [{ name: "A", num: 1 }, { name: "B", num: 2 }, { name: "A", num: 1 }]

                        array1 = Array.from(new Set(array1));  // #search: cutSameItems
                        console.log(array1);  // [{ name: "A", num: 1 }, { name: "B", num: 2 }]
                WeakSet:
        オブジェクト、クラス:  #keyword: JavaScript object
            リテラル:  #// オブジェクト リテラル。{ property: value, ... } 形式でデータ的なオブジェクトを初期化します
                型:
                    interface の場合:
                        すべて必須の場合: |
                            interface  Staff {
                                name: string;
                                level: number;
                                company: string;
                            }
                            const  staffA: Staff = {
                                name: 'Mario',
                                level: 1,
                                company: '',
                                // type に無いプロパティを指定するとエラーになります（余剰 プロパティ チェック）
                                // #ref: https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html
                            }
                        デフォルト値:  #search: TypeScript object literal default property
                        Partial を使ったプロパティの追加:  #keyword: TypeScript Partial appended property
                            #// オブジェクト リテラル を上位互換にします
                            追加前: |
                                interface  Staff {
                                    name: string;
                                    level: number;
                                }

                                const  staffA: Staff = {
                                    name: 'Mario',
                                    level: 1,
                                }

                                console.log(staffA);  // {name: 'Mario', level: 1}
                            追加後: |
                                interface  Staff {
                                    name: string;
                                    level: number;
                                    job: string;  // 追加
                                }

                                const  staffA: Staff = Staff({  // Staff 関数呼び出しを追加
                                    name: 'Mario',
                                    level: 1,
                                })

                                function  Staff(self: Partial<Staff>): Staff {  // Staff 関数を追加
                                    const  default_ = {
                                        name: 'No name',
                                        level: 0,
                                        job: 'No job'
                                    };
                                    return { ...default_, ...self } as Staff;
                                }

                                console.log(staffA);  // {name: 'Mario', level: 1, job: 'No job'}
                            #search: TypeScript optional properties
                            #ref: https://stackoverflow.com/questions/35074365/typescript-interface-default-values
                    type の場合: |
                        type  Staff = {
                            name: string;
                            level: number;
                            company: string;
                        }
                        const  staffA: Staff = {
                            name: 'Mario',
                            level: 1,
                            company: '',
                            // type に無いプロパティを指定するとエラーになります（余剰 プロパティ チェック）
                            // #ref: https://typescriptbook.jp/reference/values-types-variables/object/excess-property-checking
                        }
                    class の場合: |
                        class  Staff {
                            name !: string;
                            level !: number;
                            company !: string;
                        }
                        const  staffA: Staff = {
                            name: 'Mario',
                            level: 1,
                            company: 'Ninten',
                            // class に無いプロパティを指定するとエラーになります（余剰 プロパティ チェック）
                        }
                        console.log(staffA);  // {name: 'Mario', level: 1, company: 'Ninten'}
                    #ref: https://stackoverflow.com/questions/72088419/how-to-set-default-property-value-in-typescript
                値:
                    書式: |  #// 以下のいずれか
                        - { attribute: value }
                        - { [__NameExpression__]: __ValueExpression__ }
                    デフォルト、オプション: | #keyword: TypeScript object literal default property
                        type User = Required<UserParameters>;
                        interface  UserParameters {
                            firstName: string;
                            lastName?: string;
                        }
                        export function  newUser(parameters: UserParameters): User {
                            const  x = {...parameters};
                            x.lastName ??= "";
                            return  x as User;
                        }
                    値を処理にする: |  #// 以下のいずれか
                        - { attribute: function() { __Operation__ }(),
                        - { attribute: array.map((__Variable__) => { __Operation__ }),
                    サンプル:
                        コード: |
                            const  attribute = 'value';
                            const  object = {
                                attribute: 1,
                                "attribute2": 2,
                                [attribute]: 3,
                            }
                        上記 object の値:
                            {
                                attribute: 1,
                                attribute2: 2,
                                value: 3,
                            }
                ネスト構造:
                    サンプル:  #// 下記は同じ構造です
                        ネストした部分を中に書く場合: |  #// 型名は指定できません
                            interface Member {  // Member インターフェース
                                name: string;  // .name
                                nest: {  // nest は無名ですが型の構造はチェックされます
                                    level: number;  // .next.level
                                }
                            }
                        ネストした部分を外に書く場合: |  #// 型名が必要です
                            interface Member {  // Member インターフェース
                                name: string;  // .name
                                nest: MemberNest;
                            }
                            interface MemberNest {  // MemberNest インターフェース
                                level: number;  // .next.level
                            }
                プロパティ: #search: JavaScript property
                #ref: https://typescriptbook.jp/reference/values-types-variables/object/object-literal
            interface:  #keyword: TypeScript interface  #// シンプルなデータであれば class より オブジェクト リテラル と interface
                概要: オブジェクトに必要なプロパティとその型を指定します。オブジェクト型の一種
                関連 >> class: #search: JavaScript class
                基本サンプル:
                    データ属性: |
                        interface Member {  // Member インターフェース
                            name: string;  // name プロパティ
                            level: number;
                        }

                        let apple: Member = {
                            name: "りんご",
                            level: 1,
                        };

                        let lemon: Member = {  // エラー。name プロパティがないため
                            level: 2,
                        };

                        let melon: Member = {
                            name: "メロン",
                            level: 2,
                            color: "green"  // エラー。Member に color プロパティ がないため
                        };

                        let fruit3 = {
                            name: "メロン",
                            level: 2,
                            color: "green"
                        };
                        let fruit2: Member = fruit3;  // エラーになりません

                        let fruit1 = {
                            name: "メロン",
                        };
                        let fruit2B: Member = fruit1;  // level プロパティ が無いため、エラーになります
                    メソッド:  #ref: https://typescriptbook.jp/reference/object-oriented/interface
                        interface: |
                            interface Person {

                                // プロパティ
                                name: string;
                                age: number;
                                
                                // メソッド
                                greet(): void;                     // 引数なしの基本的なメソッド。interface では、返り値なしの場合、void が必須です
                                introduce(title: string): string;  // 引数と戻り値のあるメソッド
                                
                                // アロー関数形式
                                calculateAge: (birthYear: number) => number;
                                
                                // オプショナルメソッド
                                updateProfile?(newName: string, newAge: number): void;
                            }
                        実装: |  #// メソッド名＋":" ではないことに注意
                            const person: Person = {
                                name: "田中",
                                age: 30,
                                
                                greet() {
                                    console.log(`こんにちは、${this.name}です。`);
                                },
                                
                                introduce(title: string): string {
                                    return `${title}の${this.name}です。${this.age}歳です。`;
                                },
                                
                                calculateAge(birthYear: number): number {
                                    const currentYear = new Date().getFullYear();
                                    return currentYear - birthYear;
                                }
                            };
                オプション引数: #keyword: TypeScript function optional parameter
                    文法:  #ref: https://typescriptbook.jp/reference/functions/optional-parameters#オプション引数の構文
                        書き方:
                            (?): |  #focus: ?
                                function  __FunctionName__(__ArgumentName__?: __TypeName__) {____}
                            (=): |  #focus: =
                                function  __FunctionName__(__ArgumentName__: __TypeName__ = __DefaultValue__) {____}
                        実際の型:  #// __ArgumentName__ 変数の型は __TypeName__ 型ではありません
                            __TypeName__ | undefined
                    応用: #🌟  #keyword: TypeScript function option argument  #// 関数の引数にオプションのオブジェクトを指定するときに interface を使う場合
                        サンプル:
                            型: |
                                interface OptionOfExample {
                                    isDetail?: boolean;
                                    timeOut?: number;
                                }
                            関数定義: |
                                function  getExpectedLine(patameters: string, options: OptionOfExample = {}) {
                                    if (options.isDetail) {  // #search: JavaScript if value only
                                    if ('timeOut' in options) { ____ }
                        書き方:
                            プロパティの末尾に ? を書きます。
                        どれか 1つを必須にする場合:
                            RequireAtLeastOne:  #ref: ${GitHub}/MyPrivateCode/Node_js/tradeBackTest/src/utiityTypes.ts
                        オブジェクトを生成する場合:  #search: getter
                    #search: TypeScript Partial appended property
                extends: #// プロパティを追加したクラス  #keyword: TypeScript extends
                    概要: プロパティを継承します
                    サンプル: |
                        interface Parent {
                            name: string;
                            street: string;
                        }
                            
                        interface Address extends Parent {  // 下記 AddressWithoutExtends と同じプロパティの構成です
                            city: string;
                            country: string;
                        }

                        interface AddressWithoutExtends {
                            name: string;
                            street: string;
                            city: string;
                            country: string;
                        }
                    公式:
                        Extending Types: https://www.typescriptlang.org/docs/handbook/2/objects.html#extending-types
                交差型(&): #keyword: TypeScript 交差型
                    概要: 両者のプロパティを合わせたインターフェース
                    サンプル: |
                        interface Colorful {
                            color: string;
                        }
                        interface Circle {
                            radius: number;
                        }
                        
                        type ColorfulCircle = Colorful & Circle;

                        let circle: ColorfulCircle = {  // 両方のプロパティが必要
                            color: 'a',
                            radius: 9
                        }

                        let circle2: ColorfulCircle = {  // エラー。radius がないため
                            color: 'a'
                        }
                    公式:
                        Intersection Types: https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types
                公式:
                    Object Types: https://www.typescriptlang.org/docs/handbook/2/objects.html
                算出プロパティ: #keyword: TypeScript interface readonly  #search: TypeScript type with accessor
                    サンプル: |  #focus: fullName
                        interface User {
                            firstName: string;
                            lastName: string;
                            readonly fullName: string;  // 読み取り専用プロパティとして定義
                        }
                    説明:
                        算出プロパティ（getter）のインターフェースを上記のように定義できますが、計算は実装できません
                    完全な定義:  #search: TypeScript type with accessor
            class, new 演算子:  #keyword: JavaScript class
                constructor あり: |  #keyword: TypeScript constructor
                    class  Staff {
                        name: string;
                        level: number;

                        constructor() {
                            this.name = 'No name';
                            this.level = 0;
                        }
                    }

                    const  staffA = new Staff();
                    console.log(staffA);  // {name: 'No name', level: 0}
                constructor なし 固定初期値: |
                    class Staff {
                        name = 'No name';
                        level = 0;
                    }

                    const  staffA = new Staff();
                    console.log(staffA);  // {name: 'No name', level: 0}
                interface と同じモデルのクラス:  #search: TypeScript type with accessor
                static from____ メソッド: |  #keyword: JavaScript from,  from method,  JavaScript factory  #// 静的メソッドを追加して、便利なファクトリー関数を提供できます。load なども
                        class  Date {  // interface に static メソッドは定義できません
                            static from(parameters: string): Date {
                                const  this = new Date();
                                return  this;
                            }
                        }
                    #// 包含関係がある場合、親側のメソッドにしないと、定義できません
                    #// 対等なクラス間の変換の場合は、出力側のクラスのファクトリー関数よりも、入力側のメソッドにするほうが良いらしい
                    #// 依存関係は片方だけ持つほうが良い
                    #// GoF の Factory Method のような継承関係はありません  #search: Factory Method パターン
                    #// 子側の static from____ の定義で、引数に指定する親側が循環参照エラーになる場合、親側のインターフェース（型）を指定します
                    #// static to____ メソッドは非推奨
                static: |  #search: JavaScript static method
                    class  BenchmarkCounters {  // interface に static メソッドは定義できません
                        static  keywordHitCount: number = 0;  // : number は省略できます
                        static  reset() {
                            BenchmarkCounters.keywordHitCount = 0;
                        }
                    }
                public: #keyword: TypeScript constructor public  #// コンストラクターに指定した引数を属性にします
                    基本: |  #focus: public, attribute, MyClass
                        class  MyClass {
                            constructor(
                                public  attribute: string,
                            ) {}
                        }
                        const object = new MyClass("Alice", "aaa");
                        console.log(object.attribute);  // "Alice"
                    プライベート, ローカル: #keyword: TypeScript constructor private
                        _: | #focus: private, localUsed
                            class  MyClass {
                                constructor(
                                    public   attribute: string,
                                    private  hidden: string,
                                    localUsed: number
                                ) {
                                    localUsed
                                }
                            }
                プロパティ: #search: JavaScript property
                算出プロパティ: #search: JavaScript computed property
                アクセサーを持つクラス: #keyword: TypeScript type with accessor,  getter,  TypeScript getter,  raw data class
                    （記事）: #ref: https://qiita.com/Takakiri/items/787f3ea8493d22fa75f9
                    基本コード: |  #ref: https://github.com/Takakiriy/Trials/blob/master/try_RelationalGetter/src/accessor1.ts
                        // getter の基本 - fullName getter
                        // 定義例
                        interface  UserData {
                            firstName: string;
                            lastName: string;
                        }
                        class  User implements UserData {
                            firstName: string = "";
                            lastName: string = "";
                            get  fullName(): string {
                                return `${this.firstName} ${this.lastName}`;
                            }
                            constructor(data: UserData) {
                                Object.assign(this, data);
                            }
                        }

                        // 使用例
                        function  main1() {
                            const  user = new User({
                                firstName: 'John',
                                lastName: 'Doe',
                            });

                            console.log(user.firstName);  // "John"
                            console.log(user.fullName);   // "John Doe"
                        }
                        main1();
                    オプションとメモ化の対応コード: |  #ref: https://github.com/Takakiriy/Trials/blob/master/try_RelationalGetter/src/accessor2.ts
                        // メモ化した getter - accessTime getter
                        // 定義例
                        type UserData = Required<UserParameters>;
                        interface  UserParameters {
                            firstName: string;
                            lastName?: string;
                        }
                        class  User implements UserData {
                            // プロパティ一覧：firstName, lastName, fullName, accessTime
                            firstName: string = "";
                            lastName: string = "";
                            get  fullName(): string {
                                return `${this.firstName} ${this.lastName}`;
                            }
                            get  accessTime(): Date {
                                if (this._accessTime === undefined) {

                                    const  accessTime = new Date();
                                    this._accessTime = accessTime;
                                }
                                return  this._accessTime;
                            }
                            clearMemo(): void {
                                this._accessTime = undefined;
                            }
                            _accessTime?: Date;
                            constructor(data: UserParameters) {
                                Object.assign(this, data);
                            }
                        }

                        // 使用例
                        import * as readline from "readline";
                        const stdio = readline.createInterface({input: process.stdin, output: process.stdout});

                        function  main2() {
                            const  user = new User({
                                firstName: 'John',
                                lastName: 'Doe',
                            });

                            console.log(user.firstName);  // "John"
                            console.log(user.fullName);   // "John Doe"
                            console.log(`Now:  ${user.accessTime}`);
                            stdio.question('Push Enter key to continue...', (input: any) => {
                                console.log(`Now?: ${user.accessTime}`);  // Not +n msec, because _accessTime is not overwritten.
                                user.clearMemo()
                                console.log(`Now:  ${user.accessTime}`);
                                stdio.close();
                            });
                        }
                        main2();
                    関連:
                        class を作らないで、オプションに対応する場合:  #search: TypeScript object literal default property
                        Required:  #// すべてのプロパティをオプションでは無くします  #search: TypeScript Required utility type
                        RequireAtLeastOne:  #search: RequireAtLeastOne  #// いくつかのプロパティのうち、どれか 1つが必須
                        bash Ensure 関数:  #search: bash Ensure function  #search: bash getter
                キーの有無:  #search: JavaScript Object exists in
                メソッド:
                    インスタンスのメソッド: |  #focus: greet  #// インスタンスが呼び出せるメソッドです
                        class Greeter {
                            greet(): string {
                                return "Hello";
                            }
                        }
                        console.log(greeter.greet());
                    クラスのメソッド:
                        #search: JavaScript static method
                    オブジェクトリテラルのメソッド: |
                        let obj = {
                            greet() {
                                return "Hello, world!";
                            }
                        };

                        console.log(obj.greet()); // "Hello, world!"
            object 型:  #// または Object 型 
                公式 >> Object Types: #ref: https://www.typescriptlang.org/docs/handbook/2/objects.html
                object 型, Object 型, {}:  #ref: https://typescriptbook.jp/reference/values-types-variables/object/difference-among-object-and-object
                    object 型:  #// TypeScript 2.2 で導入された number などのプリミティブ型を含まない型
                        プロトタイプ ペース のオブジェクト
                    Object 型:  #// JavaScript の型で number などのプリミティブ型も含みます。非推奨  #ref: https://typescriptbook.jp/reference/values-types-variables/object/difference-among-object-and-object
                        概要: インターフェース
                        代入できる: object, number, string, boolean
                        代入できない: null, undefined
                class:  #search: JavaScript class
                オブジェクト リテラル: #keyword: JavaScript object literal
                    基本: |
                        {
                            lineNum: 10,
                            message: 'error',
                        }

                        interface  ErrorMessage {
                            lineNum: number;
                            message: string;
                        }

                        const  errorMessage: ErrorMessage = {
                            lineNum: 10,
                            message: 'error',
                        }
                    メソッドが static しかないクラスに オブジェクト リテラル: |  #keyword: class mapping object literal  #search: JavaScript static method
                        class  ErrorMessage {
                            lineNum: number;
                            message: string;
                        
                            static  method() {
                            }
                        }

                        const  errorMessage: ErrorMessage = {    // OK
                            lineNum: 10,
                            message: 'error',
                        }
                    メソッドが使えるようにする:  #// オブジェクト型リテラルをクラスにマッピングする場合
                        Object.assign(new __Class__, __ObjectTypeLiteral__);
                オブジェクト型リテラル: #keyword: TypeScript object type literal  #// 型のリテラル。属性を並べただけの名前がないオブジェクトの型
                    書式: |
                        { a:string, b: number }
                    サンプル: |  #focus: {lineNum: number, message: string}
                        const  messages: {lineNum: number, message: string}[] = [];
                        messages.push({lineNum: 100, message: "error"});
                関連 >> Map, 辞書, ハッシュ:  #search: JavaScript Map
            type: #//（正式名不明） #keyword: TypeScript type
                概要: type __Type__ = number のように宣言した __Type__。
                    VSCode で __Type__ にカーソルを合わせると、type __Type__ = __PrimitiveTypes__ が表示されます。
                    トランスパイルされたら無くなります
                __Type__[]: __Type__ 型の配列
                __ArrayType__[number]:  #// 配列型の場合  #// __ArrayType__ の要素の型
                    概要: 配列型に対して [number] を付けると、その配列の要素の型になります
                    サンプル: |
                        type __ArrayType__ = (string | boolean)[]
                        type __ElementType__ = __ArrayType__[number] 　// type = string | boolean
                __ObjectType__[__PropertyName__]:  #// __ObjectType__ のプロパティの型
                    オブジェクト型の場合:
                        概要: オブジェクト型に対して ["__PropertyName__"] を付けると、プロパティの型になります
                        サンプル: |
                            type Person = { age: number;  name: string;  alive: boolean };
                            type Age = Person["age"];
                            type I1 = Person["age" | "name"];  // type I1 = string | number
                            type I2 = Person[keyof Person];    // type I2 = string | number | boolean
                        エラー ケース (1): |
                            type Person = { age: number;  name: string;  alive: boolean };
                            Person.age  // エラー
                        エラー ケース (2): |
                            type   Person = { age: number;  name: string;  alive: boolean };
                            const  key1 = "age";
                            type   Age1 = Person[key1];  // エラー
                            type   key2 = "age";
                            type   Age2 = Person[key2];  // エラーではありません。type = number
                    公式:
                        Indexed Access Types: #keyword:  #ref: https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html
            implements, extends: #keyword: TypeScript implements,  TypeScript extends
            プロパティ: #keyword: JavaScript property,  JavaScript attribute  #// 属性とは言いません。データ プロパティ
                #ref: https://typescriptbook.jp/reference/values-types-variables/object/properties-of-objects
                参照: | #// 属性の値を参照します
                    object.attribute  または  object['attribute']
                プロパティの追加:  #search: TypeScript Partial appended property
                有無:  #keyword: hasOwnProperty
                    obj.hasOwnProperty("name")
                    "name" in obj
                プロパティのインターフェース:  #search: TypeScript interface readonly
                修飾子: #keyword: TypeScript property modifier  #// オプション, リード オンリー
                    オプションのプロパティ: #keyword: TypeScript optional properties, TypeScript オプションのプロパティ
                        概要: 無くてもよいプロパティだが、有るときは特定の型であることを指定します
                        サンプル: |  #focus: name,  Member
                            interface Member {
                                name?: string;  // オプションのプロパティ。string | undefined 型になります
                                level: number | undefined;  // undefined との Union 型であってもプロパティは必要です
                            }

                            let apple: Member = {
                                name: "りんご",
                                level: 1
                            };

                            let lemon: Member = {  // name プロパティがなくてもエラーにはなりません。name プロパティは undefined になります
                                level: 2
                            };

                            let melon: Member = {  // エラー。level プロパティがないからです
                                name: "メロン"
                            };
                        Required:  #// すべてのプロパティをオプションでは無くします  #search: TypeScript Required utility type
                        公式:
                            Optional Properties: https://www.typescriptlang.org/docs/handbook/2/objects.html#readonly-properties
                        関連 >> プロパティの有無:  #search: hasOwnProperty
                    リード オンリー プロパティ: #keyword: TypeScript readonly
                        概要:
                            - プロパティに指定できる const のようなものです
                            - constructor の中から値を変更することはできます
                            - メソッドの中から値を変更することはできません
                            - 静的にチェックします。トランスパイルした後は変更できてしまいます
                        サンプル: |  #focus: readonly, name
                            interface Member {
                                readonly  name: string;  // リード オンリー
                            }

                            let apple: Member = {
                                name: "りんご",
                            };

                            apple.name = "アップル";  // エラー
                        コンストラクターに指定する場合: |  #focus: readonly,  rdata,  public readonly
                            class MyClass {
                                constructor( readonly rdata: number,  public readonly pub: number ) {  // public は有っても無くても同じ
                                }
                                get(): number {
                                    return this.rdata;
                                }
                            }
                        公式:
                            readonly Properties: https://www.typescriptlang.org/docs/handbook/2/objects.html#readonly-properties
                        参考: #ref: https://typescript-jp.gitbook.io/deep-dive/type-system/readonly
                    オブジェクト内で変更可能、オブジェクト外から変更不可にするとき:
                        ____.ts : |
                            class  ____ {
                                private  member_: number = 0;
                                get      member() {return this.member_;}
                            }
                    関連 >> ユーティリティ型: #search: TypeScript utility type
                分割代入:  #keyword:
                    配列の分割代入: |  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#array_destructuring
                        let [ a, b, ...c ] = [ 1,2,3,4,5 ];
                    オブジェクトの分割代入: |  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#object_destructuring
                        let { title, width, ...other } = options;
                スプレッド構文: #keyword: JavaScript spread operator, JavaScript スプレッド構文 スプレッド演算子,  JavaScript ...
                    基本: |
                        newObject = { ...oldObject, attr: overwritingValue };
                        newObject = { ...oldObject, attr1: overwritingValue1, attr2: overwritingValue2 };
                        newObject = { ...oldObject, ...overwritingObject };
                        copyObject = { ...sourceObject };
                        copyObject = { ...undefined, ...sourceObject };  // エラーにはなりません
                    説明:
                        ...: オブジェクトの展開を参照します
                    一部を書き換えるサンプル: |
                        const  xyz = { x: 1, y: 2, z: 3 };

                        const  newXyz = { ...xyz,  z: 4 };
                        console.log(newXyz); 　// { x: 1, y: 2, z: 4 };}
                    マージするサンプル: |  #// shallow copy です。 this へマージするときはスプレッド構文は使えません  #search: Object.assign
                        const xy = { x: 1, y: 2 };
                        const yz = { y: 3, z: 4 };

                        const xyz = { ...xy,  ...yz }
                        console.log(xyz);　 // { x: 1, y: 3, z: 4 };}
                    応用サンプル:
                        コード: |
                            const inTheBag = {
                                grape:      { price: 200,  weight: 50, },
                                melon:      { price: 300,  weight: 20, },
                                strawberry: { price: 100,  weight: 10, },
                            };

                            const inTheCar = {
                                ...inTheBag,
                                melon: {
                                    ...inTheBag.melon,
                                    price: 999,
                                }
                            };
                            console.log(inTheCar);
                        出力: |
                            {
                                grape:      { price: 200, weight: 50 },
                                melon:      { price: 300, weight: 20 },
                                strawberry: { price: 100, weight: 10 }
                            }
                            {
                                grape:      { price: 200, weight: 50 },
                                melon:      { price: 999, weight: 20 },
                                strawberry: { price: 100, weight: 10 }
                            }
                    shallow copy: #keyword:
                        概要:
                            配列: 要素の構成だけ複製され、配列要素のオブジェクトはコピーされません
                            オブジェクト: 直下のプロパティの構成だけ複製され、プロパティのオブジェクトはコピーされません
                        対象: #// JavaScript で shallow copy されるメソッド
                            - スプレッド構文
                            - Array.prototype.concat()
                            - Array.prototype.slice()
                            - Array.from()
                            - Object.assign()
                            - Object.create()
                        #ref: https://developer.mozilla.org/ja/docs/Glossary/Shallow_copy
                    #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#spread_syntax1
                    #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#spread_syntax
                    #// ES2018
                    #// 分割代入 https://ja.javascript.info/destructuring-assignment
                デストラクチャリング構文: #keyword: JavaScript destructuring assignment
                    #// 一部のいくつかのプロパティを新しい変数に代入します
                    オブジェクトの場合: |
                        const obj = { a: 1, b: 2, c: 3 };  // 関数の返り値がオブジェクトの場合でも使えます
                        const { a, b } = obj;
                        console.log(a); // 1
                        console.log(b); // 2
                        const obj = { a: 1, b: 2 };
                    デフォルト値がある場合: |
                        const { a, b, c = 3 } = { a: 1, b: 2 };
                        console.log(a); // 1
                        console.log(b); // 2
                        console.log(c); // 3 （objにcプロパティがないため、デフォルト値が使用される）
                    配列の場合: |
                        const arr = [1, 2, 3];
                        const [x, y] = arr;
                        console.log(x); // 1
                        console.log(y); // 2
                    #search: JavaScript オプション引数
                computed, 算出プロパティ (Vue.js): #keyword: JavaScript computed property
                アクセサー: #keyword: accessor, アクセサー getter setter
                    概要:
                        Vue.js で、算出プロパティ（computed:) は、自動的にキャッシュが作られます
                        JavaScript では、getter を定義できますが、キャッシュを持ちません
                    サンプル: |  #focus: computedCount
                        class App {
                            private  count = 0;

                            get  computedCount(): number {
                                this.count += 1;
                                return this.count;
                            }
                        }
                    アクセサーを持つクラス全体:  #search: TypeScript type with accessor
                    参考 >> データ プロパティ:  #ref: https://ja.javascript.info/property-accessors
                コピー, スプレッド構文:  #keyword: copy JavaScript object having computed property
                    - #// エラー destinationObject = {... sourceObject}; missing the following properties
                        手順: |  #focus: sourceObject
                            class  __Class__ {
                                count: number = 0;
                                get  computedCount(): number {
                                    this.count += 1;
                                    return this.count;
                                }
                            }

                            destinationObject = {... sourceObject};
                        エラー: |
                            Type '{ __Properties__ }' is missing the following properties from type '__Class__': __Properties__
                            ts(2739)
                        対処:
                            destinationObject = Object.assign(new __Class__(), sourceObject);
                structuredClone: #keyword: structuredClone,  Deep copy  #ref: https://developer.mozilla.org/ja/docs/Web/API/structuredClone
                    関連 >> Python >> public_dict:  #search: public_dict
                Object.assign: #keyword: Object.assign  #// shallow copy
                    注意: ❗スプレッド構文を使うことを推奨します  #search: JavaScript spread operator
                    #snote: %programming%\スクリプト\JavaScrpt\JavaScript.svg#Object_assign
                    書式: reference = Object.assign(changingObject, addingObject);
                    説明:
                        - 第1引数の内容は変化します
                        - 返り値は第1引数の参照です
                        - 第1引数がリテラルのときは、呼び出すたびにリテラルの内容のオブジェクトが生成されます
                        - shallow copy です
                Partial: #keyword: TypeScript Partial
                    #// すべてのプロパティに ? を付けた型
                    サンプル: |
                        interface  Staff {
                            name: string;
                            level: number;
                        }

                        const  part: Partial<Staff> = {  // エラーになりません
                            name: 'Mario',
                        }

                        const  extra: Partial<Staff> = {
                            ex: '',  // エラー
                        }
                    Partial を使ったプロパティの追加:  #search: TypeScript Partial appended property
                Mapped Types & Mapping Modifiers:  #keyword:
                    書式: |  #keyword: [Property in keyof Type]
                        type ____<Type> = {
                            __Modifiers__  [Property in keyof Type]__Modifiers__: __PropertyType__;
                        };
                    Mapping Modifiers:  #// すべてのプロパティに対して修飾子の有無を変更します
                        サンプル:  #// LockedAccount 型のすべてのプロパティから readonly 修飾子を除いた UnlockedAccount 型を作ります
                            #focus: LockedAccount, UnlockedAccount
                            #ref: https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers
                            Mapping Modifiers のサンプル: |  #focus: CreateMutable,  -readonly
                                type CreateMutable<Type> = {
                                    -readonly [Property in keyof Type]: Type[Property];
                                };
                            Mapping Modifiers を使う場合: |
                                type LockedAccount = {
                                    readonly id: string;
                                    readonly name: string;
                                };
                                type UnlockedAccount = CreateMutable<LockedAccount>;
                            Mapping Modifiers を使わない場合: |
                                type LockedAccount = {
                                    readonly id: string;
                                    readonly name: string;
                                };
                                type UnlockedAccount = {
                                    id: string;
                                    name: string;
                                };
                        #ref: https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as
                    Mapped Types: #// すべてのプロパティに対して型を変更します
                        サンプル:  #// FeatureFlags 型のすべてのプロパティを boolean に変えた FeatureOptions 型を作ります
                            #focus: FeatureFlags, FeatureOptions
                            #ref: https://www.typescriptlang.org/docs/handbook/2/mapped-types.html
                            Mapped Types のサンプル: |  #focus: OptionsFlags
                                type OptionsFlags<Type> = {
                                    [Property in keyof Type]: boolean;
                                };
                            Mapped Types を使う場合: |
                                type FeatureFlags = {
                                    darkMode: () => void;
                                    newUserProfile: () => void;
                                };
                                type FeatureOptions = OptionsFlags<FeatureFlags>;
                                    // すべてのプロパティの型をブール型に変更します:
                            Mapped Types を使わない場合: |
                                type FeatureFlags = {
                                    darkMode: () => void;
                                    newUserProfile: () => void;
                                };
                                type FeatureOptions = {
                                    darkMode: boolean;
                                    newUserProfile: boolean;
                                }
                    as を使ったキーの再定義: #// すべてのプロパティ名を変更します
                        サンプル:  #// テンプレート リテラル 型 との併用
                            #// Person 型のすべてのプロパティの先頭文字を大文字に変えて、get を付けて、関数に変えた LazyPerson 型を作ります
                            #focus: Person, LazyPerson
                            Mapped Types as のサンプル: |  #focus: Getters
                                type Getters<Type> = {
                                    [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]
                                };
                            Mapped Types as を使う場合: |
                                interface Person {
                                    name: string;
                                    age: number;
                                    location: string;
                                }
                                type LazyPerson = Getters<Person>;
                            Mapping Modifiers を使わない場合: |
                                interface Person {
                                    name: string;
                                    age: number;
                                    location: string;
                                }
                                type LazyPerson = {
                                    getName: () => string;
                                    getAge: () => number;
                                    getLocation: () => string;
                                }
            static プロパティ, static メソッド:  #keyword: JavaScript static method  #// インスタンスを生成せずに呼び出せるメソッド
                サンプル: |  #focus: static, ClassA
                    class ClassA {
                        static  property = 'some';
                        static  method() {
                            return 'called.';
                        }
                    }

                    const  returnValue = (ClassA).method();
                    console.log(returnValue);  // called.

                    console.log(ClassA.property);  // some
                static のみのブロック: |  #focus: static {,  property
                    class ClassA {
                        static {
                            console.log(`1: ${ClassA.property}`);  // undefined
                        }
                        static  property = 'some';
                        static {
                            console.log(`2: ${ClassA.property}`);  // some
                        }
                    }
                from メソッド:  #search: JavaScript from
                オブジェクト リテラル:  #search: class mapping object literal
            namespace:  #keyword: JavaScript TypeScript name space
                変数: |
                    // verbVar
                    namespace VerbVariable {
                        export const  file = '${file}';  // namespace の外から見えるようにするには export
                    }
                    const  verbVar = VerbVariable;  // 別名
                関数: |  #focus: NameSpace1, funcA
                    namespace NameSpace1 {
                        export function  funcA() {
                            return  'called';
                        }
                    }

                    function  main() {
                        console.log(NameSpace1.funcA());
                    }
                    main();
            namespace 的な class: |
                class Category {
                    static  method() {
                    }
                }
            キャスト: #keyword: TypeScript cast,  JavaScript cast
                as __Type__  #// 警告されるようなキャストでもキャストします。非推奨
            オブジェクトID:  #keyword: object ID, JavaScript getObjectID
                ライブラリ: #ref: ${GitHub}/typrm/src/lib.ts#getObjectID
                参考: #ref: https://stackoverflow.com/questions/2020670/javascript-object-id
            循環参照: #keyword: JavaScript 循環参照
                サンプル: |  #// ClassA ←→ ClassB  #focus: valueA, valueB, parent
                    class ClassA {
                        valueA: number = 1;
                        objectB: ClassB;  // objectB = new ClassB() は有効なコードですが new ClassB(this) としても this を ClassB.constructor に渡せません。
                        constructor() {
                            this.objectB = new ClassB(this);
                        }
                    }
                    class ClassB {
                        valueB: number = 1;
                        parent: ClassA;
                        constructor(parent: ClassA) {
                            this.parent = parent;
                        }
                        get  valueC(): number {
                            return this.parent.valueA + this.valueB;
                        }
                    }
                マーク アンド スイープ アルゴリズム: #// 循環参照していても解放できる ガーベージ コレクション のアルゴリズム
                    #ref: ${typrm_files}/ref/JavaScript-AI.yaml#label: circular reference
            typeof, instanceof, hasInterfaceOf:
                typeof:
                    書式:
                        typeof __Variable__ === "__TypeName__"
                    __TypeName__:
                        string, number, boolean, object, function, undefined のいずれか
                    （関連）プロパティの型:  #search: TypeScript type
                    #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#typeof
                Array.isArray:  #// 配列かどうかの判定
                    _: if (Array.isArray(items)) { ____ }
                    高度な情報:
                        const iframeArray = iframe.contentWindow.Array.of(1, 2, 3);
                        も期待通り Array.isArray(iframeArray) === true になります
                instanceof:
                    概要:
                        - 変数 var が type に指定された関数（クラス）から生成されたオブジェクトかどうかを boolean で返します。
                        - var がオブジェクト型ではないときは、常に false を返します。
                        - TypeScript でなくても JavaScript でも使えます。
                    サンプル:
                        if ( obj instanceof User ) {
                    使える判定: Array (Array.isArray がベター), Set, Map
                    使えない判定: string
                    #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/instanceof
                    #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#instanceof
                hasInterfaceOf: #keyword: TypeScript ユーザー定義 タイプ ガード hasInterfaceOf
                    概要: 動的にインターフェースを判定します
                    サンプル: |  #// 下記 hasInterfaceOf の中の関数がユーザー定義 タイプ ガード です
                        class MyError {
                            message2: string;
                            stack: string = '/';

                            constructor(message: string) {
                                this.message2 = message;
                            }
                        }
                        interface IMyError {
                            message2: string;
                            stack: string;
                        }

                        import type { Error } from "./____";
                        import type { MyError } from "./____";

                        export namespace  hasInterfaceOf {
                            export function  Error(object: any): object is Error {
                                return (
                                    object.hasOwnProperty('message')
                                );
                            }
                            export function  IMyError(object: any): object is MyError {
                                return (
                                    object.hasOwnProperty('message2') &&
                                    object.hasOwnProperty('stack')
                                );
                            }
                        }
                        const  e = new Error('example');
                        const  me = new MyError('example');

                        const  r1 = e instanceof Error;      // true
                        const  r2 = e instanceof MyError;    // false
                        const  r3 = me instanceof MyError;   // true
                        //var  r4 = me instanceof IMyError;  // エラー。instanceof に interface を指定できないため
                        const  r5 = hasInterfaceOf.Error(e);      // true
                        const  r6 = hasInterfaceOf.IMyError(e);   // false
                        const  r7 = hasInterfaceOf.Error(me);     // false
                        const  r8 = hasInterfaceOf.IMyError(me);  // true
                    参考: #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#user_defined_type_guard
            immutable:  #keyword: immutable, イミュータブル  変更不能な  ReadOnly state status  #// ミュータブル = 変更可能な
                目的:
                    -   変更前を常に参照できること（current____ 変数）
                    -   そのために編集後の変数は一時的な変数(next___)に代入し
                        最後に更新します（current____ が上書きされます）
                    -   新しい値を前提とした関数を呼び出すときは、中間値 next___ を入力値とします  #search: immutable middle value
                Readonly<T>: #keyword: TypeScript Readonly  #ref: https://typescript-jp.gitbook.io/deep-dive/type-system/readonly#readonly-1
                    基本: |
                        const  this_ = this as Readonly<SettingsTree>;
                        this_.attribute = 1;  // ERROR!
                    methodImmutably:  #keyword: methodImmutably, method_Immutably
                        概要: イミュータブルなコードを増やすためのメソッド  #search: immutable
                        サンプル: |  #focus: method_Immutably, Readonly, Example_method, this_, return_
                            class Example {
                                attributeA: string = 'A';
                                attributeB: string = 'B';
                                attributeC: string = 'C';

                                method(x: OtherX, y: OtherY) {
                                    Object.assign(this, this.method_Immutably(x, y));
                                }
                                method_Immutably(x: Readonly<OtherX>, y: Readonly<OtherY>): Example_method {
                                    const  example = this as Readonly<Example>;
                                    const  return_: Example_method = {
                                        attributeB: '',
                                        attributeC: example.attributeC,
                                    };

                                    // example.attributeA = 'ERROR';
                                    // x.attributeA = 'ERROR';
                                    // y.attributeA = 'ERROR';

                                    var  value = example.attributeA + x.attributeA + y.attributeA;
                                    value = value.toUpperCase() + example.attributeB + example.attributeC;
                                    value = value.toLowerCase() + (example.attributeB+'/') + example.attributeC;
                                    return_.attributeB = value;
                                    value = value.length.toString();
                                    value = value.toUpperCase() + example.attributeB + example.attributeC;
                                    value = value.toLowerCase() + (example.attributeB+'/') + example.attributeC;
                                    return_.attributeC = example.attributeC + value;
                                    return  return_;
                                }

                                method_Mutably(x: OtherX, y: OtherY) {
                                    var  value = this.attributeA + x.attributeA + y.attributeA;
                                    value = value.toUpperCase() + this.attributeB + this.attributeC;
                                    value = value.toLowerCase() + (this.attributeB+='/') + this.attributeC;
                                    this.attributeB = value;
                                    value = value.length.toString();
                                    value = value.toUpperCase() + this.attributeB + this.attributeC;
                                    value = value.toLowerCase() + (this.attributeB+='/') + this.attributeC;
                                    this.attributeC += value;
                                }
                            }
                            interface  Example_method {
                                attributeB: string;
                                attributeC: string;
                            };
                            class OtherX {
                                attributeA: string;
                                constructor(attributeA: string) {
                                    this.attributeA = attributeA;
                                }
                            }
                            interface OtherY {
                                attributeA: string;
                            }
                            const  x = new OtherX('X');
                            const  y: OtherY = {attributeA: 'Y'};

                            const  objectIm = new Example();
                            objectIm.method(x, y);
                            console.log(JSON.stringify(objectIm));
                                // {"attributeA":"A","attributeB":"axybcB/C","attributeC":"C8bcB/C"}

                            const  objectM = new Example();
                            objectM.method_Mutably(x, y);
                            console.log(JSON.stringify(objectM));
                                // {"attributeA":"A","attributeB":"axybcB/C/","attributeC":"C8axybcb/ccaxybcB/C/C"}
                        複数のオブジェクトの属性を変更するサンプル: |  #focus: assign, Example_mutate
                            class Example {
                                ...
                                mutate(x: OtherX, y: OtherY): number {
                                    const  r = this.mutate_Immutably(x, y);
                                    Object.assign(this, r.example);
                                    Object.assign(x, r.otherX);
                                    return  r.errorCount;
                                }
                                mutate_Immutably(x: Readonly<OtherX>, y: Readonly<OtherY>): Example_mutate {
                                    const  example = this as Readonly<Example>;
                                    const  return_: Example_mutate = {
                                        example: { // this
                                            attributeB: '-',
                                            attributeC: '-',
                                        },
                                        otherX: {
                                            attributeA: '-',
                                        },
                                        errorCount: 1,
                                    };
                                    return  return_;
                                }
                            }
                            interface  Example_mutate {
                                example: { // this
                                    attributeB: string;
                                    attributeC: string;
                                },
                                otherX: {
                                    attributeA: string;
                                },
                                errorCount: number;
                            }

                            const  objectMu = new Example();
                            const  errorCount = objectMu.mutate(x, y);
                            console.log(JSON.stringify(objectMu));
                                // {"attributeA":"A","attributeB":"-","attributeC":"-"}
                            console.log(JSON.stringify(x));
                                // {"attributeA":"-"}
                            console.log(errorCount);
                                // 1
                        ミュータブルのほうが適するオブジェクトの例:
                            処理中に入出力を繰り返すもの:
                                - エラーログ
                                - 現在位置（行番号や ファイル ポインター など）
                Object.freeze:  #keyword:  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
                    書式: Object.freeze(__Object__)
                    注意:
                        - オブジェクトのプロパティにあるオブジェクトや配列は対象外です  #search: deepFreeze
                    基本サンプル: |  #focus: freeze, ERROR
                        class Example {
                            attribute: number = 0;
                        }
                        const  example = new Example();
                        example.attribute = 1;  // OK

                        Object.freeze(example);
                        // example.attribute = 2;  // ERROR!
                    変更:
                        概要: |  #search: JavaScript spread operator
                            const example1 = {...example, attribute: 1 };
                        サンプル: |  #focus: freeze, ERROR  #keyword: mutate imuutable object
                            class Example {
                                attribute: number = 0;
                                constructor(attribute: number) {
                                    this.attribute = attribute;
                                }
                                setAttribute(x: number) {
                                    // this.attribute = x;  // ERROR!
                                }
                            }

                            var  example = new Example(0);
                            Object.freeze(example);
                            const example1 = {...example, attribute: 1 };  // OK
                            // Object.assign(example, {attribute: 2}); // ERROR!

                            var  example = new Example(0);
                            function useExample(example: Example) {
                                example.attribute = 1;
                                const example_ = Object.freeze({...example}) as Example;
                                // example_.attribute = 2;  // ERROR!
                                // example_.setAttribute(2);  // ERROR!
                            }
                            useExample(example);
                            example.attribute = 2;  // OK
                    トラブルシューティング:
                        発生する例外: |
                            Uncaught TypeError: Cannot assign to read only property '__attribute__' of object '#<__Class__>'
                        例外が発生した場所を調べます:
                            VSCode >> Run and Debug（左）>> BREAK POINT（左下）>> Uncaught Exceptions（にチェック）>>
                            再実行 >> .js のパスが表示されたら、ターミナルで code -g __Path__:__Line__:__Column__ を実行します
                    参考: #ref: https://www.mitsue.co.jp/knowledge/blog/frontend/202002/28_1056.html
                Object.isFrozen:  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
                    const  instance = {};
                    console.log(Object.isFrozen(instance));  // false
                    Object.freeze(instance);
                    console.log(Object.isFrozen(instance));  // true
                deepFreeze:  #keyword:
                    概要: オブジェクトのプロパティにあるオブジェクトも Object.freeze します
                    サンプル: |  #focus: freeze, ERROR
                        function  deepFreeze(object: any) {

                            Object.freeze(object);
                            for (const key in object) {
                                const property = object[key];
                                if (
                                    object.hasOwnProperty(key) &&
                                    typeof property === 'object' &&
                                    property !== null
                                ) {

                                    deepFreeze(property);
                                }
                            }
                        }

                        class ExampleParent {
                            attribute: number;
                            child: Example;

                            constructor(attribute: number) {
                                this.attribute = attribute;
                                this.child = new Example(0);
                            }
                        }

                        class Example {
                            attribute: number;
                            constructor(attribute: number) {
                                this.attribute = attribute;
                            }
                            setAttribute(x: number) {
                                this.attribute = x;  // ERROR!
                            }
                        }

                        const example = new ExampleParent(0);
                        deepFreeze(example);
                        const example2 = {...example, child: { attribute: 2 }};  // OK
                        example.child.attribute = 3;  // ERROR
                        Object.assign(example, {child: { attribute: 4 }});  // ERROR
                freeze デコレーター:  #// インスタンスを全て凍結します。凍結とはすべてのプロパティを更新不能にします
                    参考: #ref: https://qiita.com/suin/items/56dfe7579509d7067e10
                    変更するとき: #search: mutate imuutable object
                    サンプル: |
                        // freeze
                        function freeze(constructor: any): any {
                            const wrapper = function () {
                                const instance = new constructor(...arguments)
                                Object.freeze(instance)
                                return instance
                            }
                            wrapper.prototype = Object.create(constructor.prototype)
                            return wrapper
                        }

                        // MutableExample
                        class MutableExample {
                            attribute: number = 0;
                            constructor(attribute: number) {
                                this.attribute = attribute;
                            }
                            setAttribute(x: number) {
                                // this.attribute = x;   // ERROR!
                            }
                        }

                        // Example
                        @freeze
                        class Example extends MutableExample {
                        }

                        // example
                        const example = new Example(0);
                        console.log(example.attribute);
                        example.setAttribute(1);
                        // example.attribute = 1;   // ERROR!

                        // exampleM
                        const exampleM = new MutableExample(0);
                        exampleM.attribute = 1;   // OK
                中間値:  #keyword: immutable middle value  #// 新しい値を前提とした関数を呼び出すときは、next___ を入力値とします
                    概要:
                        開始時に next____ を current____ で初期化し、
                        関数を呼び出す前に新しい値に更新するなら、next____ を更新し、
                        next____ をオブジェクトの属性やグローバルにし、
                        関数内で、ローカル変数 current____ を next____ の値で初期化し、
                        next____ を更新します。
                    擬似コード: |
                        // global
                        Var = 0;
                        NextVar;

                        function  change() {
                            loop {
                                NextVar = Var;
                                NextVar += 2;
                                sub();
                            }
                        }

                        function  sub() {
                            const  currentVar = NextVar;  // middle value as current value
                            NextVar = currentVar + 1
                        }
                immer: #keyword:
                    公式:
                        Document: #ref: https://immerjs.github.io/immer/
                        GitHub: #ref: https://github.com/immerjs/immer
                    produce: #keyword: immer produce  #// deep copy と一部変更という処理を効率よく行います
                        概要:
                            - 変更前のオブジェクトを deep copy してから一部を変更したときと結果が同じになるような処理を行います
                            - deep copy は行いません
                            - プロパティの値を変更しなかったオブジェクトはコピーされずに変更前と変更後で共有されます
                            - 共有された部分オブジェクトは リード オンリー になります
                        基本サンプル: | #ref: https://immerjs.github.io/immer/produce
                            import produce from "immer";

                            const nextState = produce(baseState, draftState => {
                                draftState.push({title: "Tweet about it"})
                            })
                        完全なサンプル: |  #focus: produce
                            import { produce } from 'immer';

                            // サンプルデータ。変更前
                            const before = {
                                a: "A",
                                b: {b1: "B1", b2: "B2"},
                                c: {c1: "C1", c2: "C2"}
                            };

                            // オブジェクトを deep copy してから before.b = { b1: "B1X" } をしたときと同じ結果になります。
                            const  after = produce(before, draft => {
                                draft.b.b1 = "B1X";
                            });

                            // 変更結果  #focus: B1X
                            console.log(JSON.stringify(before));   // {"a":"A","b":{"b1":"B1","b2":"B2"},"c":{"c1":"C1","c2":"C2"}}
                            console.log(JSON.stringify(after));    // {"a":"A","b":{"b1":"B1X"},"c":{"c1":"C1","c2":"C2"}}

                            // 不変性の確認(1)  #focus: AX  // コピーされた部分 (before 直下) は変更できます
                            before.a = "AX"
                            console.log(JSON.stringify(before));   // {"a":"AX","b":{"b1":"B1","b2":"B2"},"c":{"c1":"C1","c2":"C2"}}
                            console.log(JSON.stringify(after));    // {"a":"A","b":{"b1":"B1X"},"c":{"c1":"C1","c2":"C2"}}

                            // 不変性の確認(2)  #focus: C1X  // 共有された部分 (before.c 以下) は変更できません。この共有によって変更するとき性能が遅くなりません
                            // 共有している部分は リード オンリー になっているので、before から参照するオブジェクトは不変です
                            before.c.c1 = "C1X"   // TypeError: Cannot assign to read only property 'c1' of object '#<Object>'
                        prouce のバリエーション:
                            即時実行: |  #focus: draft  #// 即時に変更を実行します
                                const  after = produce(before, draft => {
                                    draft.b.b1 = "B1X";
                                });
                            変更関数: | #focus: updateBInObject  #// 複雑な変更を行う関数を定義するときは、produce で関数を囲みます。引数（下記 newB）は draft の内部にあるようなデータ構造である必要はありません。
                                // updateBInObject 関数の定義
                                const  updateBInObject = produce((draft, newB) => {  // draft は変更前の内容が入ったオブジェクトです
                                    draft.b = newB;  // draft.b オブジェクトが置き換わります。オブジェクトの内部も置き換わります
                                });

                                // updateBInObject 関数を呼び出します
                                const after = updateBInObject(before, {b1: "B1X"});
                        パッチ: |  #focus: patches  #// 変更箇所を表示します。ただし、変更を行うそれぞれの関数にコードを書く必要があります
                            import { produce, enablePatches, applyPatches } from 'immer';

                            enablePatches();  // これを呼ばないと produce 関数の呼び出しでエラーになります
                                // Error: [Immer] The plugin for 'Patches' has not been loaded into Immer. To enable the plugin, import and call `enablePatches()` when initializing your application.

                            const initialState = { name: "John", age: 30 };

                            const nextState = produce(
                                initialState,
                                draft => {
                                    draft.age = 31;
                                },
                                (patches, inversePatches) => {
                                    console.log(patches);  // [ { op: 'replace', path: [ 'age' ], value: 31 } ]
                                }
                            );

                            console.log(nextState);  // { name: 'John', age: 31 }
                        React との連携: #keyword: React immer  #// React の Stete と immer の連携  #ref: ${typrm_files}/ref/JavaScript-AI.yaml#label: React immer
                Immutable.js:
                関連:
                    #search: Redux
                    #search: 関数型言語
                    #search: Append-only Log
                    #search: Event Sourcing
        ジェネリクス: #keyword: TypeScript JavaScript generics
            #ref: https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html#generics
            効果: any にはできない、静的エラーチェックや、エディタの補完を行います
                TypeScript の仕様です。実行時（JavaScript）では型情報は失われます。
            サンプル:  #// 呼び出し元が指定した引数の型から、呼び出し元は、返り値の型が分かります
                呼び出し元: |  #focus: Type
                    const  initialValue = "";  // string
                    const  returnValue = lazyInit(initialValue);  // Type = string
                    console.log(returnValue.length);  // .length が候補に出てくる
                呼び出し先: |
                    function lazyInit<Type>(init: () => Type): () => Type {
                        let cache: Type;
                        let isInit = false;
                        return function(): Type {
                            if (!isInit) {
                                cache = init();
                                isInit = true;
                            }
                            return cache;
                        }
                    }
            参考: #ref: https://future-architect.github.io/typescript-guide/generics.html#any-unknown
        ユーティリティ型: #keyword: TypeScript utility type  #glossary: TypeScript  #// 既存の型から少し違った型を定義します  #ref: https://typescriptbook.jp/reference/type-reuse/utility-types
            Required<Type>: #keyword: TypeScript Required utility type  #// プロパティをすべてオプションではなくします  #search: JavaScript オプション引数
                _: 中にオプション プロパティ を持つ TypeScript の既存の interface から、すべてのプロパティをオプションでは無くします
                サンプル: |
                    type __NewTypeWithoutOptions__ = Required<__TypeWithOptions__>;

                    export function  to__NewTypeWithoutOptions__(parameters: __TypeWithOptions__): __NewTypeWithoutOptions__ {
                        const  x = {...parameters};
                        x.priority ??= 100;
                        return  x as __NewTypeWithoutOptions__;
                    }
            Readonly<Type>:  #// プロパティをすべて リード オンリー にします
            Partial<Type>:  #// プロパティをすべてオプションにします
            ReturnType<Type>:  #// 関数型からその返り値の型に変換します  #ref: https://www.typescriptlang.org/docs/handbook/utility-types.html#returntypetype
            他:  #ref: https://typescriptbook.jp/reference/type-reuse/utility-types
            関連 >> 修飾子:  #search: TypeScript property modifier 
        条件型:  #// 指定した型がターゲットの型であるときの型と、そうでないときの型。Conditional Types
            書式:
                全体: |
                    type  __NewType__<T> = T extends __TargetType__ ? __TypeIfTrue__ : __TypeIfFalse__
                指定された T 型の値が、__TargetType__ (型)の変数に代入可能なら: __TypeIfTrue__ 型
                そうでないなら: __TypeIfFalse__ 型
            サンプル: | #keyword: TOrReturnType  #// 指定された型が関数型なら、その関数の返り値の型、そうでないなら、その型
                type  TOrReturnType<T> = T extends (...args: any[]) => any ? ReturnType<T> : T;
            infer: #keyword: TypeScript infer
                サンプル:
                    コード: |  #ref: https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types
                        type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;
                        // 読みやすくすると以下の感じになるが、動作未確認
                        type ReturnType<T> = { function: T extends {(...args: any[])): infer R} ? R : any;
                参考:  #ref: https://qiita.com/ehika/items/8f41d4a3c8f9df4af9c3
        null, undefined など: #keyword: TypeScript null
            null: #keyword:
                if ( obj === null ) ...
                undefined !== null  // true
                typeof null == "object"
            undefined: #keyword:
                TypeScript:  #// TypeScript では宣言が必要なので undefined は使われないようです
            null/undefined許容型: | #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#null-_and_undefined-aware_types
                #snip:
                    let  x: number;
                    let  y: number | undefined;
                    let  z: number | null | undefined;
                    type T1 = (x?: number) => string;   // x has type number | undefined
                    const x: string = a!;
            any:  #// 型チェックを完全に無視
            unknown:  #// 後で型チェックやアサーションを行うことを強制します
            object:  #search: JavaScript object
    関数:  #keyword: JavaScript function,  JavaScript 関数
        (?), 引数の省略:  #keyword: TypeScript optional parameter,  TypeScript optional argument
            基本サンプル: |  #focus: ?, myFunction
                function  myFunction(option?: number): number | undefined {
                    return option;
                }
                const  r0 = myFunction();  // r0 の値は undefined, r0 の型は number | undefined
                const  r1 = myFunction(1); // r0 の値は 1,         r0 の型は number | undefined
            (?)付きの引数の後に(?)が無い引数を指定することはできません:  #focus: ?
                OK: |
                    function  myFunction(option1?: number, option2?: number)
                NG: |
                    function  myFunction(option?: number, argument: number)  // エラー A required parameter cannot follow an optional parameter.ts(1016)
        定義位置: #keyword: JavaScript function 巻き上げる,  JavaScript 関数 順序 上下
            上下:
                定義を下に書く場合（巻き上げる）: |  #// 正しく動作します  #focus: function
                    console.log(square(5));
                    return;   // 以後に処理が無いことを明示すると親切です
                    function  square(n) { return n * n }
                定義を下に書けない場合:
                    function: |  #// エラーになります  #focus: const
                        console.log(square(5));
                        const  square = function(n) { return n * n }
                    アロー関数式: |  #// エラーになります
                        console.log(square(5));
                        const  square = (n) => { return n * n }
                参考: #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Functions#calling_functions
            関数内定義: |
                function  area(r) {
                    return  3.14 * _square(r);
                    _square(n) { return n * n }  // これを呼び出せる範囲は area 関数内だけです。
                }
            関数以外の定義位置:
                上下:
                    interface: |  #// 正しく動作します  #focus: OpenPosition
                        var  activeOpenPositions: OpenPosition[] = [];
                        function  setActiveOpenPositions(openPositions: OpenPosition[]): void {
                        }
                        interface  OpenPosition {
                        }
                    class: |  #// new 以外、正しく動作します  #focus: OpenPosition
                        function  a(): Scheduler {return {} as Scheduler}
                        const p: Scheduler = a();    // OK
                        const  a = new Scheduler();  // NG
                        class  Scheduler {
                        }
                        const  a = new Scheduler();
        アロー関数式: #keyword:  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Functions/Arrow_functions
            概要: => で書く名前の付いていない関数
            書式:
                -   (__Argument__) => __ReturnValue__  #// 名前のない関数
                -   __Argument__ => __ReturnValue__    #// 名前のない関数
                -   const  __FunctionName__ = __Argument__ => __ReturnValue__  #// 変数に代入したことで名前が付いた関数
                -   (__Argument1__, __Argument2__) => __ReturnValue__
                -   () => __ReturnValue__  #// 引数なしの関数
                -   () => { __Statement__ }  #// 処理をする関数
                -   () => void  #// 未確認
                -   __Argument1__ => __Argument2__ => __ReturnValue__  #search: JavaScript double arrow
            連続するアロー:  #keyword: JavaScript double arrow
                __Argument1__ => __Argument2__ => __ReturnValue__:
                    意味: 「引数 __Argument2__ を取り __ReturnValue__ を返す関数」を返す関数。その引数は __Argument1__
                    用途:
                        例1: 返される関数の引数は __Argument2__ の 1つですが、その関数の処理内容は引数 __Argument1__ の影響を受けたものにしたいとき
                        例2: オブジェクト __Argument1__ に対する追加メソッドに相当する処理を、オブジェクトの指定なしで呼び出せる関数
                            exMethod = anObject => parameter1 => return_value;
                            exMethod( parameter );
                    参考: #ref: https://teratail.com/questions/71006
        無名関数: #keyword:
            概要: function から書く名前の付いていない関数
            書式:
                -   function (__Argument__) { __Statement__ }  #// 名前のない関数
        返り値:
            複数の値を返す関数:
                型を定義しない場合: |
                    // オブジェクトリテラルの形で返せば、TypeScriptがその型を推論してくれます。
                    function createUser(name: string, age: number) {
                        return {
                            name,
                            age
                        };
                    }

                    const user = createUser("Alice", 25);
                    console.log(user.name);  // "Alice"
                    console.log(user.age);   // 25
                型を定義する場合: |
                    // インターフェイスを定義
                    interface Person {
                        name: string;
                        age: number;
                    }

                    // Person インターフェイスに従ったオブジェクトを返す関数
                    function createPerson(name: string, age: number): Person {
                        return {
                            name: name,
                            age: age
                        };
                    }

                    const john = createPerson("John", 25);
                    console.log(john); // { name: 'John', age: 25 }
                オブジェクト形式の分割代入:  #// object destructuring
                    宣言する変数名を、オブジェクトのプロパティ名に合わせる場合:
                        var { title, width, height } = options;
                        var { title, width, height } = func();
                    そうでない場合: |
                        var { title: t1, width: w, height: h } = options;
                    注意:
                        宣言済みの変数に代入するときは var で宣言してください。
        main 関数で例外をキャッチする: | #keyword: JavaScript main catch
            main().catch((exception) => {
                console.error(exception.message);
            });
        オプション引数, サブルーチン メソッド: #keyword: JavaScript オプション引数
            引数の数が多いとき, interface:
                コードの断片: |  #focus: argumentC,  ??
                    function  bigFunction(arg: BigFunction.Arguments) {
                        funcX({ ...arg,
                            // Optional property defatult values  #keyword: nullish coalescing operator ??
                            argumentC: arg.argumentC ?? "C"
                        });
                    }

                    bigFunction({argumentA: "A", argumentB: 2});  // argumentC is omitted.
                #search: TypeScript option argument full code
            メソッドに分けるとき: #keyword: JavaScript サブルーチン メソッド  #// TypeScript の仕様ではありません
                コードの断片: |  #focus: __sub,  this  #// #__sub の # は ECMAScript の private prefix、__ は、サブルーチンを表します
                    class  Class {

                        bigFunction(): ComputedData {
                            this.returns.returnA = this.argument.argumentA + this.argument.argumentC + this.#__sub(this.temporary);
                            return  this.returns;
                        }

                        #__sub(header: string): string {
                            return  header + this.argument.argumentC + Class.__testableSub(1, 2);
                        }
                #search: TypeScript option argument full code
            サンプル: #keyword: TypeScript option argument full code
                example.ts: |
                    function  tryMethodSubroutine() {

                        const  r = bigFunction({argumentA: "A", argumentB: 2});  // argumentC is omitted.
                        console.log(r);  // {returnA: "ACIC3", returnB: 0}

                        const  r2 = bigFunctionAllRequired({argumentA: "a", argumentB: 2, argumentC: "c"});
                        console.log(r2);  // {returnA: "acIc3", returnB: 0}

                        const  r3 = BigFunction.Class.__testableSub(3, 4);  // Tester calls static method.
                        console.log(r3);  // "7"
                    }

                    interface  ComputedData {
                        returnA: string;
                        returnB: number;
                    }

                    function  bigFunction(arg: BigFunction.Arguments): ComputedData {
                        const  functionObject = new BigFunction.Class({ ...arg,
                            // Optional property defatult values  #keyword: nullish coalescing operator ??
                            argumentC: arg.argumentC ?? "C"
                        });

                        return  functionObject.bigFunction();
                    }

                    function  bigFunctionAllRequired(arg: Required<BigFunction.Arguments>): ComputedData {
                        return  new BigFunction.Class(arg).bigFunction();
                    }
                    namespace  BigFunction {
                    export interface  Arguments {  // #keyword: ArgumentsMainFunction
                        argumentA: string;
                        argumentB: number;
                        argumentC?: string;  // Optional property
                    }
                    export class  Class {

                        bigFunction(): ComputedData {
                            this.returns.returnA = this.argument.argumentA + this.argument.argumentC + this.#__sub(this.temporary);
                            return  this.returns;
                        }

                        #__sub(header: string): string {  // #keyword: ECMAScript private prefix
                            return  header + this.argument.argumentC + Class.__testableSub(1, 2);
                        }

                        static  __testableSub(a: number, b: number): string {  // This function can be called without object.
                            return  (a + b).toString();
                        }

                        constructor(        //    ArgumentsMainFunction は上記  #search: JavaScript オプション引数
                            public  argument: Required<Arguments>,  // Required は argumentC など全てのプロパティを nullable ではなくします
                            public  returns: ComputedData = {returnA: "X", returnB: 0},
                            private  temporary = "I",
                        ) {}
                    }

                    }  // End of namespace
                    tryMethodSubroutine();
                    process.exit();
            古い方法:
                分割代入を使った関数のオプション引数: #keyword:
                    サンプル: |
                        function  configure({title = "Untitled", width = 200, height = 100, items = [] as number[]} = {}) {
                            console.log(`title:  ${title}`);  // Hello
                            console.log(`width:  ${width}`);  // 250
                            console.log(`height: ${height}`); // 100
                            console.log( items );             // 1, 2
                        }
                        configure({width: 250, items: [1, 2], title: "Hello"});
                        configure();
                    参考:
                        Destructuring and Function Arguments: #ref: https://davidwalsh.name/destructuring-function-arguments
                        Destructuring Assignment In A Function Parameter: #ref: https://blog.eligarlo.dev/destructuring-assignment-in-a-function-parameter
                        スマートな関数パラメーター: #ref: https://ja.javascript.info/destructuring-assignment#ref-452
        arguments:  #keyword: js arguments
            関数の引数が入った配列
        関数型: #keyword: TypeScript function type
            サンプル: |
                type LongHand = { (a: number): number; }
                    または
                type LongHand = (a: number) => number;    // = が 2つあるように見えて、読みにくい
            関数の引数に関数を受け取る: |
                function  replaceFileSync( replaceFunction: {(text: string): string})
            関数型かそうでないかの判別: |
                typeof value === 'function';
            返り値の型:  #search: ReturnType<Type>
        メソッド, prototype: #keyword: JavaScript prototype,  JavaScript method
            モジュールの増強: #keyword: TypeScript module augmentation
                概要: 定義済みのクラス（インターフェースではない）にメソッド（等?）を追加します
                注意:
                    インターフェースにメソッドを追加できません:
                        対処A: インターフェースを関数の引数にします
                        対処B: 追加メソッドを持つクラスのコンストラクターにインターフェースを渡します
                        #ref: https://stackoverflow.com/questions/15340662/implementing-prototypes-for-interfaces-in-typescript
                関連:  #search: Swift extension
                #ref: https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation
    import, export, require: #keyword: JavaScript import, TypeScript import, JavaScript TypreScript export require
        import の書き方の一覧（種類を判定します）:  #keyword: JavaScript module type
            tsconfig.json ファイルがあるとき: |
                    // TypeScript  #search: TypeScript support_node.cjs
                    import __FunctionName__ from './__ModuleName__';  #search: JavaScript default export
                    import { Pp } from "./lib";                       #search: JavaScript normal export
                    import * as lib from "./lib";                     #search: JavaScript normal export
                #// pp と lib は同じ "./lib" をインポートしていますが、1行に書くことはできません    
            パッケージの package.json に type = module があるとき: |  #// プロジェクトの package.json ではなく、パッケージの package.json を見ます
                // ES modules
                import __FunctionName__ from './__ModuleName__.js';  #search: JavaScript default export
                import { pp } from "./lib.js";                       #search: JavaScript normal export
                import * as lib from "./lib.js";                     #search: JavaScript normal export

                // CommonJS プロジェクトから
                require = require('esm')(module);  // npm install esm
                module.exports = require('./main.js');
            それ以外のとき:
                // CommonJS
                const { PDFDocument } = require('pdf-lib');  #search: CommonJS
            ファイルの拡張子が .mjs の場合: ES modules
            グローバル変数を参照するだけの import/require: #keyword: JavaScript import global variable  #search: TypeScript global variable
                #// 使えるシンボルを増やしません
                CommonJS の場合:
                    require('@src/programOptions.ts');
                    // ここで、programOptions.ts で定義されたグローバル変数が参照できます
                ES modules の場合:
                    ソース ファイル の中:
                        import '@src/programOptions';
                        // ここで、programOptions.ts で定義されたグローバル変数が参照できます
                    トランスパイルした後:
                        import './programOptions.js';
                        // ここで、programOptions.ts で定義されたグローバル変数が参照できます
                不要なケース:
                    グローバル変数以外のシンボルを import するときに、グローバル変数が定義された ソース ファイル が指定されていれば、
                    グローバル変数を参照するだけの import/require は不要です。
                        import { Time } from '@src/tick';
                        import '@src/tick';                 // 不要
                setupFiles:
                    Jest の setupFiles を使うとモジュール化が崩れてしまいます  #search: Jest setupFiles
        #↓呼び出し元
        TypeScript の場合:  #// ES module に近いです。ES modules と TypeScript の共存
            #// tsconfig.json ファイルがあると TypeScirpt プロジェクトです  #search: JavaScript module type
            基本: #keyword: TypeScript support_node.cjs
                コード:  #ref: ${GitHub}/typrm/src/main.ts
                    import * as lib from "./lib";
                対応手順:  #ref: ${GitHub}/MyPrivateCode/Node_js/tradeBackTest/src/support_node.cjs
                    import from に指定するファイル名に拡張子を付けます
                旧）対応手順:  #// import するモジュールを実行するときに必要です
                    #// TypeScript と Node.js ES modules の仕様の差を解決する必要があります
                    preLaunchTask に Run support_node.cjs を設定します:
                        編集:  #// launch.json の preLaunchTask に書かれた tasks.json の TypeScript Compile Task を Run support_node.cjs に置き換えます
                            __Project__/.vscode/launch.json : |  #focus: Run support_node.cjs
                                {
                                    "version": "0.2.0",
                                    "configurations": [
                                        {
                                            "preLaunchTask": "Run support_node.cjs",
                        サンプル launch.json:  #ref: ${GitHub}/typrm/.vscode/launch.json
                    Run support_node.cjs タスクを tasks.json に追加します:
                        サンプル tasks.json:   #ref: ${GitHub}/typrm/.vscode/tasks.json
                    support_node.cjs ファイルを追加します:  #// 拡張子を変更する処理をするファイルをプロジェクトに追加します
                        #ref: ${GitHub}/typrm/src/support_node.cjs
                    詳細説明:
                        #search: TypeScript import .js
                        #ref: ${typrm_files}/ref/JavaScript-AI.yaml#label: TypeScript import .js
            同じフォルダー内:  #// 古い Node.js では使えない？  v16.20.1 は使えません
                import {__FunctionName__} from ".";
            import from '@/':
                #search: tsconfig.json paths
            ES modules の場合、import に .js を付けないとエラーになる問題:  #keyword: TypeScript import .js,  ES modules ERR_MODULE_NOT_FOUND Cannot find module .js
                解説: #ref: https://blog.zelkova.cc/2021/10/typescript-esmodules.html
                エラー A: |
                    Cannot find module '____.js' from '____.ts'
                    import ____ from "____.js";
                エラー B: |
                    node:internal/modules/esm/resolve:264
                            throw new ERR_MODULE_NOT_FOUND(
                                        ^
                    Error [ERR_MODULE_NOT_FOUND]: Cannot find module 'C:\Users\____' imported from C:\Users\____.js
                            at finalizeResolution (node:internal/modules/esm/resolve:264:11)
                                ....
                    code: 'ERR_MODULE_NOT_FOUND',
                    url: 'file:///C:/Users/____'
                対処A:  #// スクリプト
                    #search: TypeScript support_node.cjs
                対処B:  #// webpack
                    #ref: ${typrm_files}/ref/JavaScript-AI.yaml#label: TypeScript import .js
                その他の対処:
                    babel: 未確認
                        #ref: https://www.npmjs.com/package/babel-plugin-module-extension-resolver
                        #ref: https://www.white-space.work/using-babel-plugin-module-resolver/
                    ブラウザー: 未確認  #ref: https://github.com/WICG/import-maps
                #ref: ${typrm_files}/ref/JavaScript-AI.yaml#label: TypeScript import .js
            名前空間:  #search: JavaScript namespace
        ES modules の場合:  #// import を使います
            #// パッケージの package.json に type = module があると ES module の プロジェクトです  #search: JavaScript module type
            tsconfig.json: |
                "type": "module" #// ESM
            ES modules, ESM: #keyword: ES modules, ESM, JavaScript import, JavaScript export default
                概要:
                    JavaScriptファイルから別のJavaScriptファイルを読み込む仕組み。ES2015以上。
                    Node.jsとブラウザの両方に対応。
                    import __FunctionName__ from './__ModuleName__.js';
                    import * as lib from "./lib";
                手順 >> ES modules のプロジェクトに変更します:  #// CommonJS プロジェクトから
                    package.json: |
                        "type": "module"  // ES modules
                    #search: JavaScript module type
                定義, export: #keyword: JavaScript export
                    メインとなるクラスや関数:  #focus: export default
                            export default function  __FunctionName__() {}
                        #search: JavaScript default export
                    一般的なクラスや関数:
                            default function  __FunctionName__() {}
                        #search: JavaScript normal export
                使用, import:
                    Node.js プロジェクト:  #// Node.js のプロジェクトから ES modules のモジュールを使う場合
                        （判別方法）:  #// ES モジュール形式 のパッケージであるか CommonJS であるかを判別するには  #search: JavaScript module type
                        ES モジュール環境 の場合:  #// import と export
                            default export がある場合: #keyword: JavaScript default export  #// メインとなるクラスや関数を export default している場合
                                ケース:
                                    export default function  __FunctionName__() {}
                                関数呼び出し:  #// 上記で定義されているときにどのように書くか
                                    import __FunctionName__ from './__ModuleName__.js';
                                    __FunctionName__();
                                メモ:
                                    最後に export { __CommonFunction__ }; を書くと、定義にジャンプするときに 2箇所の候補が表示されてしまいます
                            export がある場合: #keyword: JavaScript normal export  #// default ではない定義の場合
                                ケース:
                                    export function  __FunctionName__() {}
                                書き方:  #// 上記で定義されているときにどのように書くか
                                    ライブラリ名とピリオドを書く場合:  #focus: lib
                                        TypeScript の場合:
                                            ____.ts : |
                                                import * as lib from "./lib";
                                                lib.__CommonFunction__();
                                            #search: TypeScript support_node.cjs
                                        JavaScript の場合:
                                            ____.js : |
                                                import * as lib from "./lib.js";
                                                lib.__CommonFunction__();
                                    関数名などを直接書く場合:  #focus: pp
                                        TypeScript の場合:
                                            _____.ts : |
                                                import { pp } from "./lib";
                                                pp('debug');
                                            #search: TypeScript support_node.cjs
                                        JavaScript の場合:
                                            ____.js : |
                                                import { pp } from "./lib.js";
                                                pp('debug');
                                        補足:
                                            （* と { pp } を 1行で書く方法はありません）: |
                                                import * as lib from "./lib";
                                                import * as lib from "./lib";
                                            #ref: https://stackoverflow.com/questions/45867553/es6-typescript-import-import-and-names-on-a-single-line
                            変数:
                                #ref: https://stackoverflow.com/questions/36261225/why-is-export-default-const-invalid
                        CommonJS 環境 の場合:  #// esm  #ref: https://www.npmjs.com/package/esm
                            #// 未確認
                            インストール:
                                npm install esm
                            実行時:
                                node -r esm  __Main__.js
                            書き方:
                                const { PDFDocument } = require('pdf-lib'); 
                    HTML の script:  #// HTML ファイルから ES modules のモジュールを使う場合
                        <script type="module" src="./main.js"></script>
                        <script nomodule src="./nosupport.js"></script>  #// ES modules に対応していないブラウザーの場合
                参考:
                    import 文に拡張子を書いていないとき:  #search: JavaScript import extension
                    ES modules基礎知識: #ref: https://www.codegrid.net/articles/2017-es-modules-1/
                    Customizing ESM specifier resolution algorithm: #ref: https://nodejs.org/api/esm.html#customizing-esm-specifier-resolution-algorithm
            ESM から CJS を読み取る:
                #ref: https://numb86-tech.hatenablog.com/entry/2020/08/07/091142
        CommonJS の場合:  #// require を使います  #keyword CommonJS, CJS, JavaScript require  #// CommonJS は ES module より古い仕様です
            #// パッケージの package.json に type = module がないと CommonJS の プロジェクトです  #search: JavaScript module type
            推奨: ES modules のプロジェクトに変更することを推奨します  #search: ES modules
            基本: const __Target__ = require('./lib');
            定義:
                複数の場合: exports.__ExportingName__ = __ExportingValue__;  #search: CommonJS exports dictionary
                単一の場合: module.exports = __ExportingDefaultValue__;      #search: CommonJS exports single
            使用:
                #↓パッケージにある exports
                exports.__ExportingName__: #keyword: CommonJS exports dictionary  #focus: __ExportingName__  #// 複数 export している場合
                    定義のケース:
                        commonjs-module.js: |
                            exports.__ExportingName__ = __ExportingValue__;
                                // または
                            module.exports = {
                                someFunction: function() { console.log('Hello'); },
                                someValue: 42
                            };
                    使用サンプル:
                        commonjs-main.js: |  #// CommonJS のプロジェクトの場合
                            const __Target__ = require('./lib');
                            __Target__.__ExportingName__;
                        es-module-main.js:  #// ES modules のプロジェクトの場合
                            （{} を使う場合）: |  #// __NameSpace__.__Symbol__ の __NameSpace__. を書かずに参照します
                                import { someFunction, someValue } from './commonjs-module.js';
                                someFunction();
                                someValue;
                            （* を使う場合）: |  #// __NameSpace__.__Symbol__ で参照します
                                import * as defaultImport from './commonjs-module.js';
                                defaultImport.someFunction();
                                defaultImport.someValue;
                            （{} も * も使わない場合）: |  #// Node.js 固有の仕様
                                import defaultImport from './commonjs-module.js';  // export default したシンボルではなく、module.exports が代入されます
                                defaultImport.someFunction();
                                defaultImport.someValue;
                        参考: #ref: https://github.com/facebook/jest/tree/main/packages/pretty-format#usage-with-plugins
                単一の module.exports: #keyword: CommonJS exports single  #focus: __ExportingDefaultValue__  #// 1つを export している場合
                    定義のケース:
                        commonjs-module.js:  #// CommonJS に書く場合
                            書式: |
                                module.exports = __ExportingDefaultValue__;
                            関数のサンプル: |
                                module.exports = function() { console.log('Hello'); };
                            クラスのサンプル: |
                                module.exports = Person;
                                class Person {
                                    constructor(name) {
                                        this.name = name;
                                    }
                                    
                                    sayHello() {
                                        console.log(`Hello, my name is ${this.name}`);
                                    }
                                }
                    使用サンプル:
                        commonjs-main.js:  #// CommonJS に書く場合
                            const Person = require('./lib');
                            new Person();
                        es-module-main.js: |  #// ES modules に書く場合
                            import Person from './commonjs-module.js';
                            new Person();
                module.exports と exports:
                    module.exports は exports と同じオブジェクトを指します
                ES modules:  #// CommonJS のプロジェクトから ES modules のモジュールを参照します
                    esm パッケージ:  #keyword: JavaScript esm
                        CommonJS環境でES Modulesの構文を使用できるようになります。
                        プロジェクトを ES modules のプロジェクトに変更するわけではありません。
            CommonJS 固有のシンボル:  #// ES modules では使えません。代わりの方法はあります
                require, module.exports, __dirname, __filename など
        #↓その他
        lib.ts:  #keyword: lib.ts  #// 筆者独自ライブラリ
            original: #ref: ${steps}/TypeScript.ts
            in typrm: #ref: ${GitHub}/typrm/src/lib.ts  #ref: ${GitHub}/typrm/specifications.yaml#typrm library
            API:
                ファイルの内容: #search: lib.ts file  #glossary: lib.ts
                    copyFolderSync:
                    copyFileSync:
                    replaceFileSync:
                    replaceFileAsync:
                    searchAsTextSub:  #keyword: searchOpen
                    #search: lib.ts string
                ファイル名: #search: lib.ts file name path  #glossary: lib.ts
                    pathResolve:
                    getFullPath:
                    isFullPath:
                    isInFileSystem:
                    getExistingParentPath:
                    withHomeVariable:
                    replacePathToSlashed:
                    replaceToPathForWindows:
                    checkNotInGitWorking:
                    getTestWorkFolderFullPath:
                    getGlobbyParameters:  #search: globby
                文字列: #keyword: lib.ts string
                    部分参照, 位置, 数:  #glossary: lib.ts
                        getStringBefore:
                        getIndentWithoutHyphen:
                        getWordCount:
                    判定:  #glossary: lib.ts
                        checkExpectedTextContents:
                    解析:  #glossary: lib.ts
                        parseCSVColumns:
                        parseCSVColumnPositions:
                        loadDotEnvSecrets:
                        getDotEnvSecrets:
                        getProcessEnvAndDotEnvSecrets:
                    変換, 編集:  #glossary: lib.ts
                        replace:
                            #search: replaceFileSync
                        replaceAsync:
                        escapeRegularExpression:
                        getLocalISOString:
                        coloredDiff:
                        toWordArray:
                        chageToAlphabets:
                        splitIdioms:
                    削除:  #glossary: lib.ts
                        cutLeftOf:
                        cutLast:
                        cutIndent:
                データ:
                    配列:  #glossary: lib.ts
                        isSameArray:
                        isSameArrayOf:  #// 順不同  #ref: ${GitHub}/typrm/src/lib.ts#function  isSameArrayOf<
                            #ref: ${typrm_files}/ref/JavaScript-AI.yaml#label: isSameArrayOf
                        getCommonItems:
                        cutSameItems:
                        stableUniqueFilterFunction:
                        lastUniqueFilterFunction:
                        fastUniqueFilter:
                    Map:  #glossary: lib.ts
                        parseMap:
                    日時:  #glossary: lib.ts
                        getLocalISOString:
                        newDateLoosely:
                        getCurrentTimeZoneIsoFormat:
                    AlphabetIndex:  #glossary: lib.ts
                        isAlphabetIndex:
                        getAlphabetIndex:
                        fromAlphabetIndex:
                    オブジェクト:  #glossary: lib.ts
                        hasInterfaceOf:
                        getObjectID:
                ユーザーインターフェース:  #glossary: lib.ts
                    setInputOption:
                    input:
                    inputPath:
                    inputSkip:
                    cutEscapeSequence:
                    getSnapshot:
                デバッグ: #keyword: lib.ts debug,  lib.ts debug JavaScript  #glossary: lib.ts
                    pp:
                    cc:
                    mark:
                    time:
                        start:
                        end:
                        getTimeFramesString:
                        sleep:  #keyword: sleep lib.ts JavaScript
                            await lib.time.sleep(2000);
        C++ addons: #ref: https://nodejs.org/api/addons.html
        スコープとスタイル:
            TypeScript コーディング スタイル ガイドライン:  #keyword:
                https://github.com/microsoft/TypeScript/wiki/Coding-guidelines
                https://typescript-jp.gitbook.io/deep-dive/styleguide
            ファイルスコープ:
                推奨:
                    - 関数内で定義されたローカル変数と、ファイル スコープ で定義された変数をスタイルで区別する方法は一般的ではありません
                    - 定義へジャンプすることで瞬時に判断できます
                検討結果:
                    ファイルスコープの変数に something.person 形式でアクセス:  #// できません
                        AI Chat:
                            namespace やオブジェクトやモジュールを使わずに、グローバル変数ではなくファイルスコープの変数に something.person 形式でアクセスするには
                            メソッド内のローカル変数への参照とファイルスコープの変数への参照を明確に区別するコードの書き方は
                        _:
                            window.person, globalThis.person は ファイル スコープ ではありません
                    スタイル:
                        TypeScript では、ファイルスコープの変数をPascalケースで書くのは多くありません
                        ローカル変数の末尾にアンダーバーをつけるスタイルは、読みにくくなります
        export されていない関数やクラスを参照します:  #keyword: JavaScript not exported
            間接 export:  #keyword: JavaScript export not exported private_
                概要: private_ という名前の変数を介してアクセスします。
                    言語的には export された状態です。
                    rewire などの Node パッケージに依存しないというメリットがあります。
                indirect.ts : |  #// テスト対象
                    function  notExportedFunction(argument_: string): string {
                        return  `> ${argument_}`;
                    }

                    class  NotExportedClass {
                        argument: string;

                        constructor(argument: string) {
                            this.argument = argument;
                        }

                        get(): string {
                            return  `> ${this.argument}`;
                        }
                    }

                    const  notExportedVariable = 'hello';

                    // private_
                    // For the unit test
                    export const  private_ = {
                        notExportedFunction,
                        NotExportedClass,
                        notExportedVariable,
                    };
                indirect.test.ts : |  #// テスト
                    import * as indirect from './indirect';

                    test('rewire function', () => {
                        const  notExportedFunction = indirect.private_.notExportedFunction;
                        expect(notExportedFunction('hello')).toBe('> hello');
                    });

                    test('rewire class', () => {
                        const  NotExportedClass = indirect.private_.NotExportedClass;
                        const  object = new NotExportedClass('hello');
                        expect(object.get()).toBe('> hello');
                    });

                    test('rewire variable', () => {
                        const  notExportedVariable = indirect.private_.notExportedVariable;
                        expect(notExportedVariable).toBe('hello');
                    });
                参考:
                    #ref: https://golang.hateblo.jp/entry/2021/03/12/214524
                    #search: name mangling
            rewire:  #keyword: JavaScript rewire not exported
                注意: 動作しない 2022-01-02
                公式: #ref: https://www.npmjs.com/package/rewire
                試すときのベースにするプロジェクト:  #ref: ${GitHub}/Trials/try_JestOfConsole
                rewire をプロジェクトにインストールします:
                    #// 以下のいずれか
                    - npm install --save-dev  rewire  @types/rewire
                    - yarn add --dev  rewire  @types/rewire
                example.ts : |  #// テスト対象
                    function  notExportedFunction(argument_: string): string {
                        return  `> ${argument_}`;
                    }

                    class  NotExportedClass {
                        argument: string;

                        constructor(argument: string) {
                            this.argument = argument;
                        }

                        get(): string {
                            return  `> ${this.argument}`;
                        }
                    }

                    const  notExportedVariable = 'hello';
                example.test.ts : |  #// テスト
                    import rewire from 'rewire';

                    // #focus: privateExample.__get__

                    test('rewire function', () => {
                        const privateExample = rewire('./example.ts');
                        const  notExportedFunction = privateExample.__get__('notExportedFunction');
                        expect(notExportedFunction('hello')).toBe('> hello');
                    });

                    test('rewire class', () => {
                        const  NotExportedClass = privateExample.__get__('NotExportedClass');
                        const  object = new NotExportedClass('hello');
                        expect(object.get()).toBe('> hello');
                    });

                    test('rewire variable', () => {
                        const  notExportedVariable = privateExample.__get__('notExportedVariable');
                        expect(notExportedVariable).toBe('hello');
                    });
                package.json : |  #// 起動コマンド
                    {
                        "scripts": {
                            "test": "ts-node node_modules/jest/bin/jest.js --watchAll",
                シェル : |  #// 起動コマンド
                    npm test
                参考: #ref: https://golang.hateblo.jp/entry/2021/03/12/214524
        型だけインポートする場合: #keyword: TypeScript import type  #focus: type
            _: import type { Time } from '@src/tick';
            関連 >> Python の場合:  #search: Python typing.TYPE_CHECKING mutual
        import前のホイスティング:  #search: Jest mock hoisting
    環境変数, コマンドのパラメーター:
        Node.js:
            参照: process.env.__EnvironmentVariableName__  #// 未定義なら undefined
            設定: process.env.__EnvironmentVariableName__ = __Value__
            削除: delete  process.env.__EnvironmentVariableName__
            公式: https://nodejs.org/api/process.html#process_process_env
        process.argv:
        commander: #keyword: commander, Node.js JavaScript option parameters arguments  #// プログラム起動時のパラメーター
            インストール:  #// commander は 2025年でも一般的に使われています
                npm install commander --save  #// @types/commander は不要です
            programOptions.ts: |  #focus: --found-count-max, foundCountMax  #ref: ${GitHub}/MyPrivateCode/Node_js/tradeBackTest/src/programOptions.ts
                import * as commander from 'commander';

                declare global {export const  gProgramOptions: ProgramOptions} (globalThis as any).
                gProgramOptions = {
                    foundCountMax: number,
                };

                export interface  ProgramOptions {
                    foundCountMax: number;
                }
                    // --found-count-max オプションの値が入った変数は programOptions.foundCountMax です
                    // ケバブ スタイル から キャメル スタイル への変換は commander ライブラリ が自動的に行います

                export function  parseProgramOptions() {  // commander.program をグローバルに配置すると、アプリケーション以外（主にテスト）が実行してしまいます。

                    commander.program
                        .version('0.1.0')
                        .exitOverride(exitFromCommander)  #// デバッガー接続時に エラー メッセージ などを表示したいとき
                        .argument('<input-file>')  #// 必須の名前なし引数
                        .argument('[ouput-file]')  #// オプションの名前なし引数
                        .option("-l, --locale <s>")
                        .option("-t, --test")
                        .option("-d, --folder <>", "The root path of searching folder",  process.env.TYPRM_FOLDER)
                        .option("-n, --found-count-max <i>", "Max number of showing found lines in search",  process.env.TYPRM_FOUND_COUNT_MAX || main.foundCountMaxDefault)
                        .parse(process.argv);

                    (globalThis as any).gProgramArguments = commander.program.args;  // argument_1 = gProgramArguments[0];
                    (globalThis as any).gProgramOptions = commander.program.opts<ProgramOptions>();
                }

                // エラー メッセージ など
                function  exitFromCommander(e: commander.CommanderError) {
                    if (e.code !== 'commander.version') {
                        console.log(e.message);
                    }
                }
            gProgramOptions の import 相互依存をなくす: #keyword: gProgramOptions import 相互依存  #search: import 相互依存
                メインは import 階層のトップにあるため、階層の途中（sub.ts）から gProgramOptions を参照すると import が相互依存してしまいます。
                gProgramOptions は共通部分として programOptions.ts ファイルに分離抽出して、階層の下側に移動します。
                共通部分ではあっても、ライブラリではないので、アプリケーションごとに programOptions.ts の内容は変えます。
            実行します:  #// メッセージを確認するときは、デバッガーに接続しないでください
                node build/app.js  --version
                node build/app.js  --help
                node build/app.js  arg1  --test  --found-count-max 1
            指定しなかったとき:  #// 実行開始するときにオプションを指定しなかったとき
                program.option にデフォルトを設定したとき:
                    その値
                program.option にデフォルトを設定しなかったとき:
                    undefined
    その他:
        文末のコロン: #keyword: JavaScript ;
            ; を書かないと、リアルタイム構文チェックが正しくならない
ファイル: #keyword: JavaScript file,  Node.js file
    言語の設定ファイル:
        package.json: #search:  #ref: __Project__/package.json  #// プロジェクトが使うパッケージの設定
        package-lock.json: #search:  #ref: __Project__/package-lock.json  #// 依存するパッケージも含めた全設定
        tsconfig.json: #keyword:  #ref: __Project__/tsconfig.json  #// TypeScript 固有の設定
            サンプル:
                ES2015 Node.js:  #// updated 2021-10-30  #ref: ${GitHub}/Trials/try_TypeScript_Node_js/tsconfig.json
                    package.json: |
                        {
                            "name": "try_typescript_nodfe_js",
                            "version": "0.1.1",
                            "description": "",
                            "scripts": {
                                "setup": "npm ci",
                                "clean": "powershell rm -r -fo node_modules"
                            },
                            "author": "",
                            "license": "ISC",
                            "private": false,
                            "dependencies": {
                                "globby": "^12.0.2"
                            },
                            "type": "module",
                            "devDependencies": {
                                "@types/jest": "^26.0.24",
                                "@types/node": "^13.13.52",
                                "jest": "^27.3.1",
                                "ts-jest": "^27.0.7",
                                "ts-node": "^9.1.1",
                                "typescript": "^4.4.4"
                            },
                            "jest": {
                                "roots": [
                                    "<rootDir>/src"
                                ],
                                "testMatch": [
                                    "**/__tests__/**/*.+(ts|tsx|js)",
                                    "**/?(*.)+(spec|test).+(ts|tsx|js)"
                                ],
                                "transform": {
                                    "^.+\\.(ts|tsx)$": "ts-jest"
                                }
                            }
                        }
                    tsconfig.js: |
                        {
                            "compilerOptions": {
                                "declaration": true,
                                "strict": true,
                                "target": "es2015",
                                "module": "es2015",
                                "lib": [ "es2015" ],
                                "moduleResolution": "node",
                                "experimentalDecorators": true,
                                "inlineSourceMap": true,
                                "inlineSources": true,
                                "outDir": "build"
                            }
                        }
                古い設定:
                    package.json: |
                        {
                            "name": "try_typescript_nodfe_js",
                            "version": "0.1.1",
                            "description": "",
                            "scripts": {
                                "setup": "npm ci",
                                "clean": "powershell rm -r -fo node_modules"
                            },
                            "author": "",
                            "license": "ISC",
                            "private": false,
                            "dependencies": {
                            },
                            "devDependencies": {
                                "@types/jest": "^26.0.16",
                                "@types/node": "^13.13.4",
                                "jest": "^26.6.3",
                                "ts-jest": "^26.4.4",
                                "ts-node": "^9.1.1",
                                "typescript": "^4.1.2"
                            },
                            "jest": {
                                "roots": [
                                    "<rootDir>/src"
                                ],
                                "testMatch": [
                                    "**/__tests__/**/*.+(ts|tsx|js)",
                                    "**/?(*.)+(spec|test).+(ts|tsx|js)"
                                ],
                                "transform": {
                                    "^.+\\.(ts|tsx)$": "ts-jest"
                                }
                            }
                        }
                    tsconfig.js: |
                        {
                            "compilerOptions": {
                                "declaration": true,
                                "strict": true,
                                "lib": [ "es2015", "dom" ],
                                "inlineSourceMap": true,
                                "inlineSources": true,
                                "outDir": "build"
                            }
                        }
            tsconfig.json の各種設定の必要性:
                experimentalDecorators:
                    tsconfig.json: |
                        {
                            "compilerOptions": {
                                "experimentalDecorators": true,
                    設定しないと発生するエラー:
                        Experimental support for decorators is a feature that is subject to change in a future release.
                        Set the 'experimentalDecorators' option in your 'tsconfig' or 'jsconfig' to remove this warning.
                    エラーが発生するケース: |
                        デコレーター（@）を使うとき。
                        example.ts:
                            @immutable
                            class Sample {
                moduleResolution:
                    tsconfig.json: |
                        {
                            "compilerOptions": {
                                "moduleResolution": "node",
                    設定しないと発生するエラー:
                        Cannot find module '@babel/parser'. Did you mean to set the 'moduleResolution' option to 'node', or to add aliases to the 'paths' option?
                        https://qiita.com/macotok/items/3fb60315da9206f9805c
                    エラーが発生するケース:
                        tsconfig.json: |
                            {
                                "compilerOptions": {
                                    "target": "ES2015",
                type module:
                    package.json: |
                        {
                            "type": "module",
                    設定しないと発生するエラー: |
                        Uncaught TypeError [ERR_UNKNOWN_FILE_EXTENSION]: Unknown file extension ".ts" for /Users/totadashi/Desktop/try_TypeScript_Node_js/src/app_test.ts
                        https://stackoverflow.com/questions/62096269/cant-run-my-node-js-typescript-project-typeerror-err-unknown-file-extension
                    エラーが発生するケース:
                        tsconfig.json: |
                            {
                                "compilerOptions": {
                                    "target": "ES2015",
            Node.js のバージョンによる設定:
                #ref: https://qiita.com/suin/items/32f76c9b88b8daa286c4
            その他の設定:
                baseUrl: #keyword: tsconfig.json baseUrl  #// インポートするときのルートにするパス
                    公式: #ref: https://www.typescriptlang.org/docs/handbook/module-resolution.html#base-url
                    サンプル: #keyword: baseUrl, from, src/lib
                        __Project__/src/example.ts: |
                            import {foo} from 'src/lib';
                            foo();
                        __Project__/src/lib.ts: |
                            export function  foo() {
                                console.log('foo');
                            }
                        tsconfig.json: |
                            {
                                "compilerOptions": {
                                    "baseUrl": "."
                    import from 値:
                        baseUrl からの相対パス（絶対パス相当）を指定する場合:
                            - import {foo} from 'src/lib';  #// "." 以外から始めます。baseUrl の設定が必須です
                        .ts ファイルがあるフォルダーからの相対パスを指定する場合:
                            - import {foo} from './lib';  #// "." から始めます
                            - import {foo} from '../lib';
                    baseUrl の値: tsconfig.json ファイルがあるフォルダーからの相対パス
                path alias, paths: #keyword: tsconfig.json paths,  TypeScript path alias,  TypeScript import @  #// インポートするときのパスのベースを変更します
                    公式: #ref: https://www.typescriptlang.org/tsconfig/#paths
                    注意: baseUrl の設定は必須です。絶対パス相当を指定するだけなら baseUrl だけでできます。 #search: tsconfig.json baseUrl
                    サンプル: #keyword: paths, baseUrl, from, @src, lib
                        __Project__/src/example.ts: |  #focus: @
                            import { foo } from '@src/lib';
                            foo();
                        __Project__/src/lib.ts: |
                            export function  foo() {
                                console.log('foo');
                            }
                        tsconfig.json: |
                            {
                                "compilerOptions": {
                                    "baseUrl": ".",
                                    "paths": {
                                        "@src/*": ["src/*"]  // @src を __Project__/src に対応させます
                                    }
                    (@): (@src) のような @ は必須ではありませんが、paths 属性で置き換えられることが分かりやすくなります
                    参考: #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#tsconfig_json_paths
    手順:  #// ファイルを扱うコードの書き方
        ファイル名: #// 文字列操作  #keyword: JavaScript path,  JavaScript file name
            フルパス:
                path.resolve: #keyword:  #// カレント フォルダーを基準としてフルパスを返します
                    サンプル:
                        import * as path from "path";  // or path = require("path")
                        path.resolve(__RelativePath__);
                    引数なしの場合:
                        カレント フォルダー を返します
            カレント フォルダー: #keyword: js current folder directory
                カレント フォルダー のパスを返します:
                    process.cwd():   #keyword: process.cwd
                        const  currentFolder = process.cwd();
                    path.resolve():   #keyword: process.resolve
                        const  currentFolder = path.resolve();
                process.chdir >> カレント フォルダーを変えます: |  #keyword: process.chdir finally
                    const  currentFolder = process.cwd();
                    try {
                        process.chdir(__NewCurrentFolderPath__);
                    } finally {
                        process.chdir(currentFolder);
                    }
                    var  __dirname: string = path.resolve();
                chdirInProject: #keyword:
                    使用サンプル: |
                        test("____", async () => {
                            chdirInProject('src');
                    定義サンプル: |
                        function  chdirInProject(relativePath: string) {
                            const  projectPath = path.dirname(__dirname);
                            process.chdir(projectPath);
                            process.chdir(relativePath);
                        }
                    目的: jest を使う環境にて、テスト コード を実行開始するときの カレント フォルダー を揃えるため。
                        なお、無名関数を呼び出すときの カレント フォルダー は、
                        前回実行終了時の カレント フォルダー になっています。
                関連 >> __filename,  __dirname: #search:
            親フォルダー: #keyword: JavaScript parent path
                path.parse:
                    #search: path.parse
                path.dirname >> 親フォルダー:  #keyword: path.dirname
                    サンプル コード:
                        import * as path from "path";  // or path = require("path")
                        path.dirname(__RelativePath__);
                    補足:
                        共通:
                            path.dirname( '/path/to' )  === '/path'
                            path.dirname( '/path/to/' ) === '/path'
                            path.dirname( '/path' ) === '/'
                            path.dirname( '/' ) === '/'
                        mac:
                            path.dirname( 'c:/' ) === '.'
            ファイル名:
                path.parse: | #keyword:
                    path.parse( '/path/to.html' )  // {root: '/', dir: '/path', base: 'to.html', ext: '.html', name: 'to'}
                    path.parse( 'path/to.html' )   // {root: '',  dir: '/path', base: 'to.html', ext: '.html', name: 'to'}
                    path.parse( 'C:/a/to.html' )   // {root: '',  dir: 'C:/a',  base: 'to.html', ext: '.html', name: 'to'}
                    path.parse( 'C:/to.html' )     // {root: '',  dir: 'C:',    base: 'to.html', ext: '.html', name: 'to'}
                path.basename:
                    サンプル コード:
                        import * as path from "path";  // or path = require("path")
                        path.basename( '/path/to' ) === 'to'
                        path.basename( '/path/to/' ) === 'to'
                        path.basename( '/path' ) === '/'
                        path.basename( '/' ) === ''
                        path.basename( '' ) === ''
            拡張子:
                path.parse:
                    #search: path.parse
                path.extname:
                    サンプル コード:
                        import * as path from "path";  // or path = require("path")
                        path.basename( '/path/to.html' ) === '.html'
                        path.basename( '/path/to.tar.gz' ) === '.gz'
                        path.basename( '/path/to.' ) === '.'
                        path.basename( '/path/to' ) === ''
                        path.basename( '' ) === ''
                拡張子を変更します:
                    サンプル コード: | #keyword: changeExtension
                        import * as path from 'path';
                        // changeExtension
                        // e.g. changeExtension("C:\folder\path.html", ".jpeg");  // "C:\folder\path.jpeg"
                        function  changeExtension(oldPath: string, newExtension: string): string {
                            const  parts = path.parse(oldPath);
                            return  parts.root + parts.dir +'/'+ parts.name + newExtension;
                        }
            フォルダー区切り文字: |  #keyword: path.sep,  Node.js path separator,  Node.js file name folder path separator
                    import * as path from "path";
                    path.sep
                    'path/to/file.txt'.replace(/\//g, path.sep)
                #ref: https://nodejs.org/docs/latest/api/path.html#path_path_sep
        カレント フォルダー: #search: js current folder directory
        ソース ファイル名: #// Node.js
            注意❗: src フォルダーにある TypeScript ファイルをビルドすると build フォルダーに移動するので、下記のパスは変わります。
                __dirname は未定義になります。
            __filename: #keyword:
                ソース ファイル の フル パス
            __dirname: #keyword:
                ソース ファイル を含むフォルダーの フル パス
                #search: ReferenceError __dirname
            ____.d.ts, 型定義ファイル: #keyword: .d.ts, type definition file
                関数の宣言:
                    ____.d.ts: |
                        export function saveHTML(): void;
                        export function anotherFunction(param: string): number;
                変数の宣言:
                    export __Name__:
                        ____.d.cts:
                            書式: |
                                /// <reference types="node" />
                                export declare const __VariableName__: __Type__;
                            サンプル: |
                                /// <reference types="node" />
                                export declare const snapshots: {[key: string]: string};
                        ____.cjs:
                            書式: |
                                var  __Variable__ = __Value;
                                exports.__ExportingName__ = __Variable__;
                            サンプル: |
                                exports.snapshots = snapshots;
                    export default: |
                        /// <reference types="node" />
                        declare var snapshots: {[key: string]: string};
                        export default snapshots;
                <reference types="node" />: #keyword:
                    手動で .d.ts ファイルを作ったときに、.d.ts ファイルの先頭行に書きます。
                    #ref: https://stackoverflow.com/questions/48216163/what-does-reference-types-node-mean
                参考: #ref: https://typescript-jp.gitbook.io/deep-dive/type-system/intro/d.ts
        ファイルの有無:  #keyword: JavaScript file folder directory exists
            ファイルまたはフォルダーがあるかどうか: |
                import fs from "fs";  // or fs = require("fs")  // file system
                const  exists = fs.existsSync('/the/path');
            フォルダーがあるかどうか: |
                import fs from "fs";  // or fs = require("fs")  // file system
                const  folderExists = fs.lstatSync('/the/path').isDirectory();
                // 注意: パスに * を含むとエラーになります
            ファイルがあるかどうか: |
                import fs from "fs";  // or fs = require("fs")  // file system
                const  fileExists = fs.lstatSync(targetFullPath).isFile();
                // 注意: パスに * を含むとエラーになります
            参考: https://stackoverflow.com/questions/4482686/check-synchronously-if-file-directory-exists-in-node-js/4482701
        サイズ: #keyword: JavaScript file size
            基本: |
                fs.statSync(__FilePath__).size;  // byte
            例外なし版: |
                function  getFileSize(filePath: string): number {
                    try {
                        return  fs.statSync(filePath).size;
                    } catch (err) {
                        return  0;
                    }
                }
        ファイルの一覧:
            globby: #keyword:  #// グロブ・バイ と読みます。 Unix, Python の glob が由来らしい #ref: https://ja.wikipedia.org/wiki/グロブ
                使い方: カレント フォルダー に依存したりと使い方が難しいため、ファイルの一覧を作成する関数の中で globby を使います。
                インストール:
                    npm install globby@11.0.4 --save  #// 2022-02 現在、version 12 ではビルドできない問題がるようです
                インポート:
                    globby 11.0.4:
                        import globby from 'globby';
                        const  scanedPaths = await globby(['____']);
                パターン:
                    コード: #ref: ${GitHub}/Trials/try_Node_js_lib/src/example/globby/result.log_
                    公式: #ref: https://github.com/sindresorhus/multimatch/blob/main/test/test.js
                サンプル:
                    #ref: ${GitHub}/typrm/src/main.ts#function  listUpFilePaths
                    #ref: ${GitHub}/MyPrivateCode/image_sharp/src/sharp.ts#function  listUpFiles
        ファイルのコピーや削除: #keyword: JavaScript copy file
            フォルダーを作ります: |  #keyword: mkdirSync, JavaScript fs mkdirSync
                import * as fs from "fs";  // or fs = require("fs")  // file system
                fs.mkdirSync('__Path__', {recursive: true});
            フォルダーを削除します: |  #keyword: rmdirSync
                import * as fs from "fs";  // or fs = require("fs")  // file system
                fs.rmdirSync('__Path__', {recursive: true});
            コピーします:
                ファイル:  #search: copyFileSync
                フォルダー:  #search: copyFolderSync
                その他:  #search: #search: lib.ts file
        ファイルの内容: #🌟
            #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#file
            全体をリードします: #keyword: Node.js readFileSync,  Javascript load file
                Node.js:
                    基本:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#file_I_O
                        コード: |  #// 非推奨。LF CR+LF 混合や BOM に対応していません
                            - const  text: string = fs.readFileSync( "sample.txt",  "utf-8" );
                            - const  text: Buffer = fs.readFileSync( "sample.txt" );
                        推奨:  #search: JavaScript read line
                    LF CR+LF 混合や BOM にも対応したテキストをリードする場合: |  #keyword: JavaScript read line  #focus: readFile
                        import * as fs from 'fs';

                        async function  main() {
                            var  inputLines: string[] = readFile(process.argv[2]);

                            for (const line of inputLines) {
                                console.log(`> ${line}`);
                            }
                        }

                        function  readFile(inputFilePath: string): string[] {
                            const  fileContents = fs.readFileSync(inputFilePath, 'utf-8');
                            const  hasLastLF = (fileContents.slice(-1) === '\n');
                            const  lines: string[] = fileContents.split('\n');
                            if (hasLastLF) {
                                lines.pop();  // cut last empty line
                            }
                            return  lines
                        }
                    関連 >> 1行ずつリードします:  #search: readline.createInterface
                HTML5: |
                    const  reader = new FileReader();
                    reader.readAsText(onChangeEvent.target.files[0]);  // #search: JavaScript file drag and drop
                        // ローカルの HTML を表示している場合、相対パスを指定できません #ref: https://teratail.com/questions/178778

                    reader.onload = function(eventOnLoad){
                        const  list = reader.result.split('\n');
                    }
            1行ずつリードします: #keyword: readline.createInterface, js file read
                #serach: readline.Interface
                注意, 例外対応:  #serach: exampleReadStream
                    #serach: readline.Interface
            1行追記します: #keyword: Node.js appendFileSync,  Javascript save file
                詳細: ファイルが存在しない場合は新規作成し、存在する場合は追記します
                サンプル: |
                    try {
                        fs.appendFileSync(filePath, text + '\n');
                            /
                    } catch (error) {
                        console.error(`ファイルへの書き込み中にエラーが発生しました: ${error}`);
                    }
            ファイルの一部を置き換えます: #keyword: JavaScript file replace  #search: lib.ts replaceFileSync
            文字列をファイルにライトします: #keyword: Node.js writeFileSync
                import fs from "fs";
                fs.writeFileSync( "output.txt", "書き出したい内容" );
            #↓ 文字列（メモリー）
            文字列をファイルのようにリードします:  #keyword: JavaScript string file stream read
                （同様の内容）: #search: readline.Interface
                サンプル: |  #// TypeScript
                    import * as readline from 'readline';
                    import { Readable } from 'stream';

                    async function  tryStringReader() {

                        const stream = new Readable();
                        stream.push('line 1\nline 2\nline 3\n');
                        stream.push('line 4');
                        stream.push('line 4\nline 5');
                        stream.push(null);

                        const  reader = readline.createInterface({
                            input: stream,
                            crlfDelay: Infinity
                        });

                        for await (const line of reader) {
                            // if (breaking) {continue;}  // "reader" requests read all lines
                            console.log(`> ${line}`);
                        }
                    }
                    tryStringReader();
                参考:
                    readline.Interface: #search: readline.Interface
                    使っても大丈夫か: 大丈夫
                        #ref: https://stackoverflow.com/questions/12755997/how-to-create-streams-from-string-in-node-js
                        #// @TrentonD.Adams it appears that that comment is from the v10.x docs.
                        #// The v14.x docs simply say "The readable.push() method is used to push the content into the internal buffer"
                        #// which implies to me that it's a perfectly fine method to use.
            ファイルのように文字列にライトします:  #keyword: JavaScript string file stream write
                WritableMemoryStream: #keyword: WritableMemoryStream
                サンプル: |  #// TypeScript  #focus: WritableMemoryStream
                    import * as readline from 'readline';
                    import { Readable, Writable } from 'stream';

                    async function  tryStringReader() {

                        const stream = new Readable();
                        stream.push('line 1\nline 2\nline 3\n');
                        stream.push('line 4');
                        stream.push('line 4\nline 5');
                        stream.push(null);

                        const  reader = readline.createInterface({
                            input: stream,
                            crlfDelay: Infinity
                        });
                        const  writer = new WritableMemoryStream();

                        for await (const line of reader) {
                            // if (breaking) {continue;}  // "reader" requests read all lines
                            writer.write(`${line}\n`);
                        }
                        console.log(`end: "${writer.toString()}"`);
                    }

                    class WritableMemoryStream extends Writable {
                        private array: string[];

                        constructor() {
                            super();
                            this.array = [];
                        }

                        _write(chunk: any, _encoding: BufferEncoding, callback: (error?: Error | null) => void) {
                            this.array.push(chunk);
                            callback();
                        }

                        toString(): string {
                            return this.array.join('');
                        }
                    }

                    tryStringReader();
            #↓ その他
            ストリーム: #search: Node.js Streams API
        ドラッグ＆ドロップ:  #keyword: JavaScript file drag and drop
            HTML:
                <input type="file" id="inputFileButton">
            JavaScript: |
                const  inputFileButton = document.getElementById("inputFileButton");

                inputFileButton.addEventListener("change", function(onChangeEvent) {
                    onChangeEvent.target.files[0];
                }, false);
        圧縮:  #keyword: Node.js compressed file
            zlib.Gzip:  #keyword: Node.js zlib.Gzip
                サンプル: |  #// 圧縮します  #focus: gzip
                    import * as zlib from 'zlib';
                    import * as fs from 'fs';
                    process.chdir(`${getHomePath()}/Desktop`);

                    const reader = fs.createReadStream('src.txt');
                    const writer = fs.createWriteStream('src.txt.gz');
                    const gzip = zlib.createGzip();  // Gzip extends stream.Transform, Zlib

                    reader.pipe(gzip).pipe(writer);
        パスワードのハッシュ関数:  #keyword: Node.js crypto hash
            公式: #ref: https://nodejs.org/api/crypto.html
            一覧: #// 使えるハッシュ関数の種類を一覧します
                コード (.ts):
                    import * as crypto from 'crypto';
                    console.log(crypto.getHashes().join(', '));  // 使える暗号の種類を一覧します
                出力: #// 2021-11-26 現在
                    RSA-MD4, RSA-MD5, RSA-MDC2, RSA-RIPEMD160,
                    RSA-SHA1, RSA-SHA1-2, RSA-SHA224, RSA-SHA256, RSA-SHA3-224, RSA-SHA3-256, RSA-SHA3-384,
                    RSA-SHA3-512, RSA-SHA384, RSA-SHA512, RSA-SHA512/224, RSA-SHA512/256, RSA-SM3,
                    blake2b512, blake2s256, id-rsassa-pkcs1-v1_5-with-sha3-224, id-rsassa-pkcs1-v1_5-with-sha3-256,
                    id-rsassa-pkcs1-v1_5-with-sha3-384, id-rsassa-pkcs1-v1_5-with-sha3-512,
                    md4, md4WithRSAEncryption, md5, md5-sha1, md5WithRSAEncryption, mdc2, mdc2WithRSA,
                    ripemd, ripemd160, ripemd160WithRSA, rmd160, sha1, sha1WithRSAEncryption, sha224,
                    sha224WithRSAEncryption, sha256, sha256WithRSAEncryption,
                    sha3-224, sha3-256, sha3-384, sha3-512, sha384, sha384WithRSAEncryption,
                    sha512, sha512-224, sha512-224WithRSAEncryption, sha512-256,
                    sha512-256WithRSAEncryption, sha512WithRSAEncryption,
                    shake128, shake256, sm3, sm3WithRSAEncryption, ssl3-md5, ssl3-sha1, whirlpool
            参考:
                パスワード: #search: password
                Node.jsで暗号化とハッシュ: #ref: https://qiita.com/_daisuke/items/990513e89ca169e9c4ad
        暗号化:  #keyword: Node.js crypto encrypt
            公式: #ref: https://nodejs.org/api/crypto.html
            サンプル: |
                import * as crypto from 'crypto';
                import * as fs from 'fs';
                process.chdir(`${getHomePath()}/Desktop`);

                const key = crypto.randomBytes(32);
                const iv = crypto.randomBytes(16);  // Initialization Vector

                const reader = fs.createReadStream('src.txt');
                const writer = fs.createWriteStream('src.txt.encrypted');
                const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(key), iv);
                reader.pipe(cipher).pipe(writer);
            参考:
                暗号: #search: crypto
                Node.jsで暗号化とハッシュ: #ref: https://qiita.com/_daisuke/items/990513e89ca169e9c4ad
        HTML テンプレート エンジン: #keyword:  #// スクリプトはエスケープされるため、使うほうが安全です
            Handlebars:  #keyword: Handlebars
                #ref: https://handlebarsjs.com/guide/
                基本: |
                    <p>{{firstname}} {{lastname}}</p>

                    空行ができないようにするためには、以下のように閉じる部分を次の行に書きます。
                    {{#assign 'num1'}}{{request.pathSegments.[2]}}{{/assign
                    }}
                Visual Studio Code 拡張機能:
                    Handlebars (Adarsh Gourab Mahalik)
                ファイルの拡張子: .hbs, .handlebars
                リファレンス:  #glossary: Handlebars
                    コメント: |  #keyword: Handlebars comment, {{!
                        -   {{! __Comment__ }}
                        -   {{! __Comment__
                            }}
                    ブロック ヘルパー: #keyword: Handlebars block helper
                        (#if):
                            書式: |  #focus: #if, else, /if
                                {{#if __Condition__ }}__ContentsIfTrue__{{else}}__ContentsIfFalse__{{/if}}
                            インデントを考慮した書式: |  #// 出力のインデントが正しくなるようにします
                                ...
                                    {
                                {{#if __Condition__
                                }}        __ContentsIfTrue__
                                {{else
                                }}        __ContentsIfFalse__
                                {{/if}}
                                    }
                            サンプル:
                                #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockResponseTemplate/__files/6a_fields.json.hbs
                        (#each):
                            使えるバージョン: Handlebars 3.0+, Wiremock 2.29.0+
                            配列の書式: |
                                {{#each __Array__ as |value|
                                }}    "{{value}}"
                                {{/each}}
                            辞書の書式: |
                                {{#each __Dictionary__ as |value key|
                                }}    "{{key}}": "{{value}}"
                                {{/each}}
                            サンプル:
                                #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockResponseTemplate/__files/6a_fields.json.hbs
                                #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockResponseTemplate/__files/6a2_fields_compact.json.hbs
                            参考:
                                #ref: https://handlebarsjs.com/guide/builtin-helpers.html#each
                                #ref: https://groups.google.com/g/wiremock-user/c/ynFx_2GN3zw
                        (#assign):
                            使えるバージョン: WireMock
                            サンプル: |
                                {{#assign '__NewVariableName__'}}{{ __Expression__ }}{{/assign
                                }}{{#assign '__NewVariableName__'}}__LiteralValue__{{/assign
                                }}
                    パーシャル構文: #keyword: Handlebars partial  #// ファイルの一部の内容を別のファイルの内容に置き換えます  #ref: https://handlebarsjs.com/guide/partials.html
                        書式:
                            __Main__.hbs ファイル: |
                                {{> __FileNameWithoutExtension__ }}
                            __FileNameWithoutExtension__.hbs ファイル: |
                                （埋め込む内容）
                            __FileNameWithoutExtension__ :
                                （WireMock コンテナー内の）フルパスで指定してください
                                拡張子 .hbs は付けないでください
                        トラブルシューティング:
                            - #// The partial '/test.hbs' at '/test.hbs' could not be foun
                                手順:
                                    Docker 版 WireMock
                                    wiremock/wiremock:3.13.0
                                    wiremock/wiremock:2.35.0
                                __Main__.hbs ファイル: |
                                    {{> test }}
                                        または
                                    {{>test}}
                                ログ: |
                                    The partial '/test.hbs' at '/test.hbs' could not be found
                                対処:
                                    不明
                                ダメだったこと:
                                    docker-compose.yml: |
                                        command: ["--port", "8080", "--root-dir", "/home/wiremock", "--global-response-templating"]
                                        working_dir: /home/wiremock
                                        environment:
                                            - WIREMOCK_ROOT_DIR=/home/wiremock
                                        volumes:
                                            - "../mock:/home/wiremock"
                                            - "../mock/__files/test.hbs:/test.hbs"
                    その他 >> WireMock ヘルパー:  #search: WireMock helper
                関連 >> WireMock:  #search: WireMock .hbs
            Nunjucks:
                Nunjucks は Jinja2 に強く影響を受けた JavaScript 用のテンプレートエンジンです。ブロック継承、自動エスケープ、マクロ、非同期制御などの機能を備えています。ブラウザとサーバー側（Node.js）の両方で動作します。
            EJS: #keyword:
            その他:
                Swig - Django/Jinja のような構文を持つテンプレートエンジンですが、最近はあまりメンテナンスされていないようです。 Stack Overflow
                Twig.js - PHP の Twig テンプレート言語の JavaScript 実装です。 GitHub
                jinja-js - シンプルさとパフォーマンスを重視した Jinja の JavaScript 実装です。Node.js またはブラウザで実行でき、ミニファイ後は 8.3KB / gzip 圧縮後は 3.2KB の軽量なライブラリです。 GitHub Liquidとの互換性もあります。 GitHub
                EJS - Node.js で人気のテンプレートエンジンで、HTML コンテンツに JavaScript を埋め込んで動的コンテンツを生成できます。 GeeksforGeeks Jinja2 ほど機能は豊富ではありませんが、シンプルで使いやすいです。
            参考:
                テンプレートエンジン:  #ref: https://ja.m.wikibooks.org/wiki/テンプレートエンジン/Node.js
                テンプレートリテラルでHTMLを作成したらダメな理由！:  #ref: https://ns-adwork.com/javascript/3578/
    ライブラリ:
        fs: #keyword: TypeScript fs
            最新版:
                import { promises as fs } from 'fs';
                const  contents = (await fs.readFile(`tests/fixtures/contents.json`)).toString();
            バリエーション:
                import * as fs from 'fs';
                const  contents = (await fs.readFileSync(`tests/fixtures/contents.json`)).toString();
ネットワーク, Ajax:  #keyword: JavaScript network
    ブラウザー, React など:
        fetch:  #search: HTTP fetch
        AbortController:
            ボタンを押してダウンロードを開始します, キャンセルにも対応: |  #keyword:
                let  controller;

                function fetchVideo() {
                    controller = new AbortController();
                    fetch(url, {signal: abortController.signal}).then((response) => {
                    });
                }

                abortBtn.addEventListener('click', () => {
                    controller.abort();  // Abort the fetch request.
                });
            参考:
                MDN: #ref: https://developer.mozilla.org/en-US/docs/Web/API/AbortController
                #ref: https://dev.to/pallymore/clean-up-async-requests-in-useeffect-hooks-90h
    Node.js 単体:
        net: #keyword: Node.js net
            サンプル: |
                import * as net from 'net';  // const net = require('net');

                const client = net.connect(80, 'www.yahoo.co.jp');  // client: net.Socket extends stream.Duplex
                client.pipe(process.stdout);  // read
                client.once('connect', () => client.write('GET / HTTP/1.0\r\n\r\n'));  // write
            公式: #ref: https://nodejs.org/api/net.html
        request: #keyword: Node.js request  #// deprecated  #ref: https://www.npmjs.com/package/request
    Ajax: #keyword:
        GET: #search: cypress GET test_target_1.html
ストリーム: #keyword: JavaScript stream
    Web API >> Streams API: #keyword: Web API Streams API
        ReadableStream: #keyword:
            HTTP fetch response.text: #search: HTTP fetch example
                #ref: https://stackoverflow.com/questions/40385133/retrieve-data-from-a-readablestream-object
            #ref: https://developer.mozilla.org/ja/docs/Web/API/ReadableStream
    Node.js >> Steram: #keyword: Node.js Streams API
        公式: #ref: https://nodejs.org/api/stream.html
        reader.on, writer.write:
            書式: |
                reader.on('data', (buffer: string) => {writer.write(buffer);});
                reader.on('end', () => writer.end());
            サンプル (.ts): |  #// ファイルをコピーします  #focus: buffer, data, write, end
                import * as fs from "fs";
                process.chdir(`${getHomePath()}/Desktop`);
                const  readBufferSize = 15;

                const reader = fs.createReadStream('src.txt', { highWaterMark: readBufferSize });
                const writer = fs.createWriteStream('dest.txt');

                reader.on('data', (buffer: string) => {
                    console.log(`> ${buffer}`);
                    writer.write(buffer);
                });
                reader.on('end', () => writer.end());
                console.log('> end');
            src.txt: |
                a23456789
                b23456789
                c23456789
                d23456789
            サンプルの出力: |
                > end
                > a23456789
                b2345
                > 6789
                c23456789

                > d23456789
            補足:
                highWaterMark オプションを指定しない場合、64KB になります  #keyword: Node.js highWaterMark
                    #ref: https://stackoverflow.com/questions/27641571/changing-readstream-chunksize
        pipe:  #keyword: Node.js pipe  #// stream A から stream B へ転送します
            書式: __Reader__.pipe(__Writer__);
            サンプル (.ts): |  #// ファイルをコピーします  #focus: pipe
                import * as fs from "fs";
                process.chdir(`${getHomePath()}/Desktop`);
                const  readBufferSize = 15;

                const reader = fs.createReadStream('src.txt', { highWaterMark: readBufferSize });
                const writer = fs.createWriteStream('dest.txt');

                reader.pipe(writer);
                console.log('> end');
            サンプルの出力: |
                > end
            補足:
                highWaterMark オプションを指定しない場合、64KB になります  #search: Node.js highWaterMark
        process.stdout:  #keyword: Node.js process.stdout  #// 表示します
            サンプル (.ts): |  #// ファイルの内容を表示します  #focus: stdout
                import * as fs from "fs";
                process.chdir(`${getHomePath()}/Desktop`);
                const  readBufferSize = 15;

                const reader = fs.createReadStream('src.txt', { highWaterMark: readBufferSize });

                reader.pipe(process.stdout);
                console.log('> end');
            __Project__/.vscode/launch.json:
                "outputCapture": "std"  #search: VSCode outputCapture
            サンプルの出力: |
                > end
                （ファイルの内容）
        childProcess.stdout:  #keyword: Node.js childProcess.stdout  #// 子プロセスの出力を親プロセスの出力に転送します
            サンプル (.ts): |  #// 子プロセスの出力を親プロセスの出力に転送します  #focus: stdout  #keyword: Node.js childProcess example
                import * as child_process from 'child_process';
                const  scriptPath = '../build/app.js';

                const  childProcess = child_process.exec(`node ${scriptPath}`);
                if (childProcess && childProcess.stdout) {
                    childProcess.stdout.pipe(process.stdout);
                    console.log('> end');
                }
            __Project__/.vscode/launch.json:
                "outputCapture": "std"  #search: VSCode outputCapture
            サンプルの出力: |
                > end
                （子プロセスの出力）
        child_process.exec:  #keyword: Node.js child_process.exec  #// 子プロセスを起動します
            サンプル (.ts): #keyword: Node.js childProcess example
            timeout オプション: プロセスの寿命  #keyword: Node.js child_process.exec timeout
        stream.Duplex:  #// ReadableStream と WritableStream
            net: #search: Node.js net
        stream.Transform:  #// 圧縮や暗号化など
            zlib.Gzip: #search:
            Crypt:
        readline.Interface: #keyword:
            関連 >> 全体をリードします:  #// ファイル全体を一度にリードする場合  #search: Node.js readFileSync
            テキスト ファイル をリードします: #keyword: Node.js read file lines
                #// 一般的な方法。これでリード・ライトすると LF に統一されてしまうので注意  #focus: reader, filePath
                主要コード: |  #// 非推奨。推奨は #search: JavaScript read line
                    import * as readline from 'readline';

                    const  reader = readline.createInterface({
                        input: fs.createReadStream(filePath),
                        crlfDelay: Infinity
                    });
                完全サンプル: |  #keyword: readline.Interface loop  #// 1行ずつリードする場合の完全サンプル。非推奨。推奨は #search: JavaScript read line
                    import * as readline from 'readline';

                    const  reader = readline.createInterface({
                        input: fs.createReadStream(filePath),
                        crlfDelay: Infinity
                    });
                    var  breaking = false;

                    for await (const line of reader) {
                        if (breaking) {continue;}  // "reader" requests read all lines
                        try {

                            console.log(`> ${line}`);
                        }
                        // 書きかけ
                    }
                LF CR+LF 混合や BOM にも対応したテキストをリードする場合:  #search: JavaScript read line
                関連 >> パラメーターがないときは、標準入力から入力します:  #search: Node.js stdin
            標準入力からリードします: #keyword: Node.js stdin
                pause: | #keyword: Node.js pause
                    import * as readline from "readline";
                    const stdio = readline.createInterface({input: process.stdin, output: process.stdout});

                    stdio.question('Push Enter key to continue...', (input: any) => {
                        console.log(`Done`);
                        stdio.close();
                    });
                input に stdin を指定します:
                    主要コード: |
                        const  reader = readline.createInterface({
                            input: process.stdin,
                    全体: | #keyword: readStdInAll,  stdin
                        import * as readline from 'readline';

                        async function  main() {  // tree-breadcrumb
                            console.log("Input text and push Ctrl + D.");

                            const  inputLog: string[] = await readStdInAll();

                            for (const line of inputLog) {
                                console.log(`> ${line}`);
                            }
                        }

                        async function  readStdInAll(): Promise<string[]> {
                            const  reader = readline.createInterface({
                                input: process.stdin,
                                crlfDelay: Infinity
                            });

                            const  inputLog: string[] = [];
                            for await (const line of reader) {
                                inputLog.push(line);
                            }
                            return  inputLog;
                        }

                        main();
                    関連 >> パラメーターがあるときは、ファイルから入力します:  #search: JavaScript read line
            文字列をリードします:
                （同様の内容）:  #search: JavaScript string file stream read
                Readable.from: |
                    const stream = Readable.from('line 1\nline 2\nline 3\n');
                Readable: |  #focus: reader, stream
                    import * as readline from 'readline';
                    import { Readable } from 'stream';

                    const stream = new Readable();
                    stream.push('line 1\nline 2\nline 3\n');
                    stream.push('line 4');
                    stream.push('line 4\nline 5');
                    stream.push(null);

                    const  reader = readline.createInterface({
                        input: stream,
                        crlfDelay: Infinity
                    });
            注意, 例外対応:  #// readline.Interface を使うときの注意
                正しく書かないと例外発生時にファイルを削除できなくなります  #search: Node.js remove file error
            参考:
                文字列をファイルのようにリードします:  #search: JavaScript string file stream
        非推奨:
            memorystream: #keyword: npm memorystream
                注意: メンテナンスされていないらしい  #ref: https://blog.lufia.org/entry/2021/09/26/113000
                公式: #ref: https://www.npmjs.com/package/memorystream
                インストール: npm install memorystream
    console.log: #keyword: console.log, consoleLog
        表示内容をテストするための出力内容:
            tradeBackTest 版:  #ref: ${GitHub}/MyPrivateCode/Node_js/tradeBackTest/src/test/testConsole.ts
            typrm 版:  #ref: ${steps}/TypeScript.ts
暗号化, Web Crypto API: #keyword:  #ref: https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API
    UUID: #keyword: JavaScript UUID  #ref: https://developer.mozilla.org/en-US/docs/Web/API/Crypto/randomUUID
    互換性: ブラウザー, Node.js 19  #ref: https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API#browser_compatibility
JSON:  #keyword: JSON,  JavaScript TypeScript JSON
    JSON:
        公式: #ref: https://www.json.org/json-en.html
        サンプル:  #// キーも文字列です。文字列は " " で囲みます。数値などは "" で囲みません
            {
                "名前": "田中太郎",
                "年齢": 30,
                "メールアドレス": "tanaka@example.com",
                "既婚": false,
                "趣味": ["読書", "旅行", "写真撮影"]
            }
        書式: #keyword: JSON forms  #ref: https://www.json.org/json-en.html
            <object>: |
                :== { <whitespace> }
                :== { <whitespace> <string> <whitespace> : <value> }
            <array>: |
                :== [ <whitespace> ]
                :== [ <value> ]
                :== [ <value> , <value> ]
                :== [ <value> , <value> , <value>, ... ]
            <whitespace>: |
                :== <>                              #// 文字無し
                :== < >                             #// 空白
                :== <\n>                            #// line feed
                :== <\r>                            #// carriage return
                :== <\t>                            #// tab
                :== <whitespace> <whitespace> ...
            <value>: |
                :== <whitespace> <string> <whitespace>
                :== <whitespace> <number> <whitespace>
                :== <whitespace> <object> <whitespace>
                :== <whitespace> <array> <whitespace>
                :== <whitespace> true  <whitespace>     #// 大文字小文字区別なし
                :== <whitespace> false <whitespace>     #// 大文字小文字区別なし
                :== <whitespace> null  <whitespace>     #// 大文字小文字区別なし
            <string>: |
                :== ""
                :== "<characters>"     #// ' ' で囲むのは不正です
            <characters>: |
                :== <any_characters>   #// <any_characters> は " と \ 以外
                :== \"                 #// "
                :== \\                 #// \   "a\"b" は a"b になります
                :== \/                 #// /
                :== \b                 #// back space という値
                :== \f                 #// form feed という値
                :== \n                 #// line feed という値
                :== \r                 #// carriage return という値
                :== \t                 #// tab という値
                :== \u<4_hex_digits>
            <number>: |
                := <integer>
                := <fraction>
                := <exponent>
            <integer>: |
                :== 0
                :== <positive_integer>
                :== - <positive_integer>
            <positive_integer>: |
                :== <1-9>
                :== <1-9> <0-9>
                :== <1-9> <0-9> <0-9> ...
            <fraction>: |
                :== <0-9> . <0-9>
                :== <0-9> ... . <0-9> ...
            <exponent>: |
                :== <fraction> e|E +|- <0-9>
        変換します:
            const  jsonTree = JSON.stringify(flatJSON, null, '    ');
            #search: JSON.stringify
        循環参照している場合: #keyword: 循環参照 object JSON
            #ref: ${HOME}/GitProjects/GitHub/typrm/src/lib.ts#function  jsonStringify
        コメント: #keyword: JSON comment  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#operation
            仕様:
                JSON with comment (JSONC): #keyword: JSONC,  JSON with comment  #// Visual Studio Code の構文チェックで選べます  #search: VSCode JSONC setting
                    // コメントです
                    /* コメントです */
                JSON:
                    1行: |
                        "//": "コメントです"
                    複数行: |
                        "//": [
                            "// コメントです",
                            "// コメントです",
                            "// コメントです"
                        ]
                Hjson: #keyword:  #ref: https://hjson.github.io/
                    # コメントです
                    // コメントです
                    /* コメントです */
            Visual Studio Code:  #// Visual Studio Code の JSON 構文チェックにコメントを警告しないモードに切り替えます
                #search: VSCode JSONC setting
            実装:
                JavaScript:
                    JSON5:  #ref: https://github.com/json5/json5
                Go:
                    JSONC:  #ref: https://pkg.go.dev/search?q=jsonc
                Python:
                    #search: Python JSONC
        JSON をソートして整形します: #keyword: sort-json
            Python + VSCode:  #keyword: sort JSON Python
                Python をインストールします: #search: install Python Visual Studio Code
                ~/_out.json ファイルに整形前の JSON を保存します:
                    bash: |
                        code ~/_out.json
                整形したデータを ~/_out.json ファイルに出力します:
                    bash: |  #// インデントは削除してください
                        pushd ${HOME}
                        python -c "
                        import json
                        data_dictionary = json.load(open('_out.json', 'r')) 
                        print(json.dumps(data_dictionary, indent=4, sort_keys=True))" > ~/_out_sorted.json
                        code ~/_out_sorted.json
                        popd
                作業ファイルを削除します:
                    bash: |
                        rm ~/_out_sorted.json
                        rm ~/_out.json
                参考: #ref: https://docs.python.org/ja/3/library/json.html
            sort_json:  #keyword: sort_json
                #ref: ${GitHub}/sort_json/sort_json.bat
        JSON を整形します:  #keyword: format-json,  JSON 整形
            VSCode:
                インデントと改行を追加します:  #search: VSCode JSON format
                    #snip:  Windows: Shift + Alt + f
                インデントと改行を削除します: #keyword: compact JSON
                    概要: |  #// 正規表現で
                        (^[ \t]+)|([\r\n]+) =>
                        ([A-Za-z0-9])": " => $1":"
                    詳細:
                        準備:
                            VSCode で JSON ファイルを開きます:
                            置き換えビューを開きます: 
                                VSCode >> Ctrl + F >> (>) をクリック
                            正規表現をオンにします:
                                (.*) ボタン
                        インデントと改行を削除します:
                            置き換え前:
                                (^[ \t]+)|([\r\n]+)
                            置き換え後:
                                    #// 空欄
                        フィールド名の右の空白を削除します:
                            置き換え前: |
                                ([A-Za-z0-9])": "
                            置き換え後: |
                                $1":"
            Linux Python + VSCode:
                Python をインストールします: #search: install Python Visual Studio Code
                ~/_out.json ファイルに整形前の JSON を保存します:
                    Linux bash: |
                        code ~/_out.json
                整形したデータを _out.json ファイルに出力します:
                    Linux bash:
                        下記インデントは削除してください: |
                            pushd ${HOME}
                            python -c "
                            import json
                            data_dictionary = json.load(open('_out.json', 'r')) 
                            print(json.dumps(data_dictionary, indent=4, sort_keys=False))" > ~/_out_formated.json
                            code ~/_out_formated.json
                            popd
                作業ファイルを削除します:
                    bash: |
                        rm ~/_out_formated.json
                        rm ~/_out.json
            Windows:
                format_json:  #keyword: format_json Windows  #ref: ${GitHub}/format_json/format_json.bat
            JavaScript:
                JSON.stringify: #keyword: JSON.stringify (stringfy ではない)
                    const  jsonTree = JSON.stringify(flatJSON, null, '    ');
            Python:
                インデントと改行を削除します: #keyword: compact JSON Python
                    json_document = json.loads(json_string)
                    json_string = json.dumps(json_document, separators=(',', ':'))  #// Change to compact
                    #search: escape JSON
        JSON を見やすく表示します: #ref: http://marianoguerra.github.io/json.human.js/
            #// 通信はしていないようです（開発者ツールのネットワークのログより）
        MessagePack から JSON に変換します:  #keyword: MessagePack JSON
            (@CentOS7):
                msgpack-python をインストールします: 
                    pip install  msgpack-python
                _out.pack ファイルに MessagePack 形式のデータを保存します:
                _out.pack ファイルから JSON に変換したデータを _out.json ファイルに出力します: |  #// インデントは削除してください
                    python -c "
                    import msgpack, json
                    for message in msgpack.Unpacker(open('_out.pack', 'rb'), raw=False):
                        print(json.dumps(message, indent=4, sort_keys=False))" > _out.json
                    rm _out.pack
            参考:
                MessagePackを使ったデータ分析のすすめ: #ref: https://qiita.com/m_mizutani/items/c40295549c3368a4257d
        アンエスケープします: #keyword: unescape-json, unescape_json  #// 文字列リテラルの中の JSON を JSON に展開します
            サンプル:
                変換前: "{\"StatusCode\":\"200\"}"
                変換後: { "StatusCode": "200" }
            escape-json コマンド:  #// 以下のいずれか  #search: escape-json
                - escape-json -r  #// ~/_tmp/_tmp.json ファイルの内容をアンエスケープします
                - escape-json -u
                - escape-json --unescape
            古い方法:
                JSON をファイルに保存します:
                    ~/share/response_escaped.json
                新しい bash (unescape JSON): |  #// 実行するときはインデントを削除してください
                    python -c "
                    import os
                    import json
                    with open(os.environ['HOME'] + '/share/response_escaped.json') as file:
                        escaped_json_string = file.read()
                    json_string = json.loads(escaped_json_string)
                    json_objects = json.loads(json_string)
                    print(json.dumps(json_objects, indent=4, sort_keys=False, ensure_ascii=False))" > ~/share/response_unescaped.json
                出力先:
                    ~/share/response_unescaped.json
                #ref: ${GitHub}/unescape_json/unescape_json.bat
        エスケープします: #keyword: escape JSON  #// JSON を「JSON 内に書く文字列」に変換します
            サンプル:
                変換前: { "StatusCode": "200" }
                変換後: "{\"StatusCode\":\"200\"}"
            escape-json コマンド: #keyword: escape-json  #ref: ${GitHub}/MyPrivateCode/ansible_vagrant/single_vm_ansible/GoCD/_local_settings/bin/escape-json
                - escape-json  #// ~/_tmp/_tmp.json ファイルの内容をエスケープします
            古い方法:
                JSON をファイルに保存します:
                    ~/share/response.json
                新しい bash (escape JSON): |  #// 実行するときはインデントを削除してください
                    python -c "
                    import os
                    import json
                    with open(os.environ['HOME'] + '/share/response.json') as file:
                        json_string = file.read()
                    json_document = json.loads(json_string)
                    json_string = json.dumps(json_document, separators=(',', ':'), ensure_ascii=False)  #// Change to compact
                    print(json.dumps(json_string, ensure_ascii=False))" > ~/share/response_escaped.json
                出力先:
                    ~/share/response_escaped.json
    サンプル サーバー:
        "{JSON} Placeholder":  #ref: https://jsonplaceholder.typicode.com/users
    JSON から YAML に変換します:  #search: JSON to YAML, json2yaml
    JSON スキーマ: #keyword: JSON schema  #// YAML でも使えます（内部で JSON に変換している場合）
        参考:
            公式:  #ref: https://json-schema.org/
            JSON Schemaのすゝめ:  #ref: https://qiita.com/g0e/items/9a4f886897fd46f107a8
            JSON スキーマの JSON スキーマ:  #ref: http://json-schema.org/draft-07/schema#
        お試しサイト: #keyword: jsonschemavalidator.net  #ref: https://www.jsonschemavalidator.net/
        基本のサンプル: #keyword: JSON schema properties
            関連:
                厳密にチェックする場合:  #search: JSON schema strict object
            サンプル:  #// スキーマに従った JSON
                {
                    "name": "taro",
                    "level": 1
                }
            schema: |  #focus: properties, name, level  #keyword: JSON schema basic example
                {
                    "properties": {
                        "name": {
                            "type": "string"
                        },
                        "level": {
                            "type": "number"
                        }
                    }
                }
            validation 結果: |  #search: jsonschemavalidator.net  #// 基本形のスキーマがチェックする内容
                {"name": "taro", "level": 1}     // OK. 完全一致
                {"name": "taro"}                 // OK. プロパティが不足しても OK
                {"name": "taro", "hoge": 12345}  // OK. 他のプロパティが追加されても OK
                {"name": 123, "level": "lv1"}    // NG. 型が異なるため
                100  // OK
        子オブジェクト単体の厳密なチェック:  #keyword: JSON schema strict object
            基本:
                サンプル:  #// スキーマに従った JSON
                    {
                        "user": {
                            "name": "taro",
                            "level": 1
                        }
                    }
                schema: |  #focus: properties, user, name, level, object
                    {
                        "type": "object",  // これがないとルートがオブジェクトではない値も許されてしまいます
                        "additionalProperties": false,  // これがないとルートに未定義のプロパティが許されてしまいます
                        "required": [  // これがないとプロパティの省略が許されてしまいます
                            "user"
                        ],
                        "properties": {  // ルート object の要素
                            "user": {  // プロパティ名（＝オブジェクト名）
                                "$ref": "#/class:user/define"  // #/ はルートを表す
                            }
                        },
                        "class:user": { // user オブジェクト単体
                            "define": {
                                "type": "object",  // これがないとオブジェクトではない値も許されてしまいます
                                "additionalProperties": false,  // これがないと未定義のプロパティが許されてしまいます
                                "required": [  // これがないとプロパティの省略が許されてしまいます
                                    "name",
                                    "level"
                                ],
                                "properties": {  // user object の要素
                                    "name": {
                                        "type": "string"
                                    },
                                    "level": {
                                        "type": "number"
                                    }
                                }
                            }
                        }
                    }
                validation 結果: |  #search: jsonschemavalidator.net
                    {user: {name: "taro", level: 1}}  // OK
                    {user: 1}  // NG
                    {user: {name: "taro", level: "a"}}   // NG。level の型が違うため
                    {user: {name: "taro"}}               // NG. プロパティが不足していているため
                    {user: {name: "taro", hoge: 12345}}  // NG. 他のプロパティが追加されていているため
                    {name: "taro", level: "a"}     // NG. ルートのプロパティ名が違うため。＝ルートに他のプロパティが追加されていているため
                    100   // NG. ルートがオブジェクトではないため
            ネストしたクラス:  #keyword: JSON schema nested class
                サンプル:  #focus: product
                    {
                        "user": {
                            "name": "taro",
                            "product": {
                                "price": 1
                            }
                        }
                    }
                schema: |  #focus: properties, user, name, level, array, items, object, properties
                    {
                        "type": "object",  // これがないとルートがオブジェクトではない値も許されてしまいます
                        "additionalProperties": false,  // これがないとルートに未定義のプロパティが許されてしまいます
                        "required": [  // これがないとプロパティの省略が許されてしまいます
                            "user"
                        ],
                        "properties": {  // ルート object の要素
                            "user": {  // プロパティ名（＝オブジェクト名）
                                "$ref": "#/class:user/define"  // #/ はルートを表す
                            }
                        },
                        "class:user": { // user オブジェクト単体
                            "define": {
                                "type": "object",  // これがないとオブジェクトではない値も許されてしまいます
                                "additionalProperties": false,  // これがないと未定義のプロパティが許されてしまいます
                                "required": [  // これがないとプロパティの省略が許されてしまいます
                                    "name",
                                    "product"
                                ],
                                "properties": {  // user object の要素
                                    "name": {
                                        "type": "string"
                                    },
                                    "product": {
                                        "$ref": "#/class:user/class:product/define"
                                    }
                                }
                            },
                            "class:product": {
                                "define": {
                                    "type": "object",
                                    "additionalProperties": false,
                                    "required": [
                                        "price"
                                    ],
                                    "properties": {  // product object の要素
                                        "price": {
                                            "type": "number"
                                        }
                                    }
                                }
                            }
                        }
                    }
                validation 結果: |  #search: jsonschemavalidator.net
                    {user: {name: "taro", product: {price: 1}}}    // OK
                    {user: {name: "taro", product: {price: "x"}}}  // NG。price の型が違うため
            共有するクラス:
                サンプル:  #// product と resource が同じ構造の場合
                    {
                        "user": {
                            "name": "taro",
                            "product": {
                                "price": 1
                            },
                            "resource": {
                                "price": 1
                            }
                        }
                    }
                schema: |  #focus: shared, properties, user, name, object
                    {
                        "type": "object",  // これがないとルートがオブジェクトではない値も許されてしまいます
                        "additionalProperties": false,  // これがないとルートに未定義のプロパティが許されてしまいます
                        "required": [  // これがないとプロパティの省略が許されてしまいます
                            "user"
                        ],
                        "properties": {  // ルート object の要素
                            "user": {  // プロパティ名（＝オブジェクト名）
                                "$ref": "#/class:user/define"  // #/ はルートを表す
                            }
                        },
                        "class:user": { // user オブジェクト単体
                            "define": {
                                "type": "object",  // これがないとオブジェクトではない値も許されてしまいます
                                "additionalProperties": false,  // これがないと未定義のプロパティが許されてしまいます
                                "required": [  // これがないとプロパティの省略が許されてしまいます
                                    "name",
                                    "product",
                                    "resource"
                                ],
                                "properties": {  // user object の要素
                                    "name": {
                                        "type": "string"
                                    },
                                    "product": {
                                        "$ref": "#/class:user/class:product/define"
                                    },
                                    "resource": {
                                        "$ref": "#/class:user/class:resource/define"
                                    }
                                }
                            },
                            "class:product": {
                                "define": {
                                    "$ref": "#/shared/class:product/define"
                                }
                            },
                            "class:resource": {
                                "define": {
                                    "$ref": "#/shared/class:product/define"
                                }
                            }
                        },
                        "shared": {
                            "class:product": {
                                "define": {
                                    "type": "object",
                                    "additionalProperties": false,
                                    "required": [
                                        "price"
                                    ],
                                    "properties": {  // product object の要素
                                        "price": {
                                            "type": "number"
                                        }
                                    }
                                }
                            }
                        }
                    }
                validation 結果: |  #search: jsonschemavalidator.net
                    {user: {name: "taro", product: {price: 1}, resource: {price: 1}}}    // OK
                    {user: {name: "taro", product: {price: "x"}, resource: {price: 1}}}  // NG。price の型が違うため
            参考:
                オブジェクトの厳密なチェック:  #keyword: JSON schema strict root object
                    サンプル:
                        {
                            "name": "taro",
                            "level": 1
                        }
                    schema: |  #focus: properties, object, name, level
                        {
                            "type": "object",  // これがないとオブジェクトではない値も許されてしまいます
                            "additionalProperties": false,  // これがないと未定義のプロパティが許されてしまいます
                            "required": [  // これがないとプロパティの省略が許されてしまいます
                                "name",
                                "level"
                            ],
                            "properties": {
                                "name": {
                                    "type": "string"
                                },
                                "level": {
                                    "type": "number"
                                }
                            }
                        }
                    validation 結果: |  #search: jsonschemavalidator.net
                        {"name": "taro", "level": 1}     // OK. 完全一致
                        {"name": "taro"}                 // NG. プロパティが不足していているため
                        {"name": "taro", "hoge": 12345}  // NG. 他のプロパティが追加されていているため
                        {"name": 123, "level": "lv1"}    // NG. 型が異なるため
                        100  // NG. オブジェクトではないため
        オブジェクトの配列の厳密なチェック:  #keyword: JSON schema strict object array
            サンプル:
                {
                    "user": [
                        {
                            "name": "taro",
                            "level": 1
                        },
                        {
                            "name": "jiro",
                            "level": 2
                        }
                    ]
                }
            schema: |  #focus: properties, user, name, level, array, items, object
                {
                    "type": "object",  // これがないとルートがオブジェクトではない値も許されてしまいます
                    "additionalProperties": false,  // これがないとルートに未定義のプロパティが許されてしまいます
                    "required": [  // これがないとプロパティの省略が許されてしまいます
                        "user"
                    ],
                    "properties": {  // ルート object の要素
                        "user": {  // プロパティ名（＝オブジェクト名）
                            "type": "array",  // これがないと配列ではない値も許されてしまいます
                            "items": {  // array の要素
                                "$ref": "#/class:user/define"  // #/ はルートを表す
                            }
                        }
                    },
                    "class:user": { // user オブジェクト
                        "define": {
                            "type": "object",  // これがないとオブジェクトではない値も許されてしまいます
                            "additionalProperties": false,  // これがないと未定義のプロパティが許されてしまいます
                            "required": [  // これがないとプロパティの省略が許されてしまいます
                                "name",
                                "level"
                            ],
                            "properties": {  // user object の要素
                                "name": {
                                    "type": "string"
                                },
                                "level": {
                                    "type": "number"
                                }
                            }
                        }
                    }
                }
            validation 結果: |  #search: jsonschemavalidator.net
                {"user": [{name: "taro", level: 1}, {name: "jiro", level: 2}]}  // OK
                {"user": [{name: "taro", level: 1}]}  // OK
                {"user": []}   // OK
                {"user": null} // NG
                {"user": [1]}  // NG
                {"user": [{name: "taro", level: "a"}]}  // NG。level の型が違うため
                {"user": {name: "taro", level: 1}}      // NG。オブジェクトが配列の中に無いため
                {"user": {"name": "taro"}}                 // NG. プロパティが不足していているため
                {"user": {"name": "taro", "hoge": 12345}}  // NG. 他のプロパティが追加されていているため
                [{"user": []}, {"user": []}]   // NG. ルートがオブジェクトではない（配列である）ため
                {name: "taro", level: "a"}     // NG. ルートのプロパティ名が違うため。＝ルートに他のプロパティが追加されていているため
                100   // NG. ルートがオブジェクトではないため
        配列, items:  #// items, minItems, maxItems
            配列の値: #keyword: JSON schema items,  JSON schema array
                schema: |  #focus: name, array, items
                    {
                        "properties": {
                            "name": {
                                "type": "array",  // これを省略すると配列以外も受け入れます
                                "items": {  // 配列の要素
                                    "type": "string"
                                }
                            }
                        }
                    }
                validation 結果: |  #search: jsonschemavalidator.net
                    {"name": ["taro", "jiro"]}  // OK
                    {"name": ["taro"]}  // OK
                    {"name": []}   // OK
                    {"name": [1]}  // NG
                参考:
                    ルートの直下のプロパティを厳密にチェックします:  #search: JSON schema strict object
            オブジェクトの配列:
                オブジェクトの配列のみ限定:
                    #search: JSON schema strict object array
                オブジェクトまたはその配列:
                    schema: |  #focus: items
                        {
                            "type": "object",
                            "properties": {  // ルート object の要素
                                "user": {
                                  	"anyOf": [
                                        {
                                          	"$ref": "#/class:user/define"
                                        },
                                        {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/class:user/define"
                                            }
                                        }
                                    ]
                                }
                            },
                            "class:user": {
                                "define": {
                                    "type": "object",  // これがないと [1] が OK になってしまいます
                                    "properties": {  // object の要素
                                        "name": {
                                            "type": "string"
                                        },
                                        "level": {
                                            "type": "number"
                                        }
                                    }
                                }
                            }
                        }
                    validation 結果: |  #search: jsonschemavalidator.net
                        {"user": [{name: "taro", level: 1}, {name: "jiro", level: 2}]}  // OK
                        {"user": [{name: "taro", level: 1}]}  // OK
                        {"user": []}   // OK
                        {"user": [1]}  // NG
                        {"user": [{name: "taro", level: "a"}]}  // NG。level の型が違うため
                        {"user": {name: "taro", level: 1}}      // OK
                ルートの定義も definitions に入れる場合の問題点:
                    schema: |  #// 下記の場合エラーメッセージが少し不適切になります
                        {
                            "$ref": "#/class:root/define",
                            "class:root": {
                                "define": {
                                    "type": "object",
                                    "properties": {  // ルート object の要素
                                        "user": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/class:root/class:user/define"
                                            }
                                        }
                                    },
                                },
                                "class:user": {
                                    "define": {
                                        "type": "object",  // これがないと [1] が OK になってしまいます
                                        "properties": {  // object の要素
                                            "name": {
                                                "type": "string"
                                            },
                                            "level": {
                                                "type": "number"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    エラーメッセージ:  #// 下記の1行目が増えます
                        JSON does not match schema from '$ref'.
                        Invalid type. Expected Number but got String.
            要素数:  #keyword: JSON schema minItems maxItems
                schema: |  #focus: minItems, maxItems
                    {
                        "minItems": 1,
                        "maxItems": 2,
                validation 結果: |
                    {"name": ["taro"]}   // OK
                    {"name": []}         // NG
                    {"name": ["taro", "jiro", ""]}  // NG
        プロパティの必須と追加, required:  #// required, additionalProperties
            参考: #search: JSON schema strict object
            必須プロパティ, required:  #// 必須プロパティ  #keyword: JSON schema required
                schema: |  #focus: required
                    {
                        "type": "object",
                        "required": ["name", "level"],
                    省略部分は: #search: JSON schema basic example
                validation 結果: |
                    {"name": "taro", "level": 1}     // OK
                    {"name": "taro"}                 // NG
            additionalProperties:  #// 他のプロパティが追加されても OK かどうか  #keyword: JSON schema additionalProperties
                schema: |  #focus: additionalProperties  #search: JSON schema basic example
                    {
                        "type": "object",
                        "additionalProperties": false,
                    省略部分は: #search: JSON schema basic example
                validation 結果: |
                    {"name": "taro", "level": 1}     // OK
                    {"name": "taro", "hoge": 12345}  // NG
        値の範囲, pattern, minLength:  #// pattern, minLength, maxLength, enum
            値の型と省略オプション:  #// プロパティの省略不可は required に設定します  #search: JSON schema required
                型: ["string", "number", "null"]
                省略可能:
                    設定:
                        "type": ["string", "null"]
                    エラーメッセージ: |
                        objectA.propA: Invalid type. Expected: string, given: null
            format, 定義済み形式:  #// ipv4, date-time, hostname など
                schema: |  #focus: ipv4
                    {
                        "properties": {
                            "ip_address": {
                                "type": "string",
                                "format": "ipv4"
                            }
                        }
                    }
                validation 結果: |
                    {ip_address: "192.168.0.1"}  // OK
                    {ip_address: "192.168.0.xxx"}  // NG
                #// その他の形式
                "ipv4":
                "ipv6":
                "date-time": 2018-11-13T20:20:39+00:00
                "time": 20:20:39+00:00
                "date": 2018-11-13
                "email": Internet email address, see RFC 5321
                "hostname": Internet host name, see RFC 1123.  例 www.example.com/api はエラーになります
                #// 他にもあります/ #ref: https://json-schema.org/understanding-json-schema/reference/string.html#built-in-formats
            pattern, 文字列, 長さの範囲:  #keyword: JSON schema pattern minLength maxLength
                schema: |  #focus: pattern, minLength, maxLength
                    {
                        "properties": {
                            "name": {
                                "type": "string",
                                "pattern": "^[a-zA-Z0-9]+$",
                                "minLength": 3,
                                "maxLength": 16
                            }
                        }
                    }
                validation 結果: |
                    {name: "taro"}  // OK
                    {name: "ta"}  // NG. 短すぎる
            選択（文字列）:  #keyword: JSON schema enum
                schema: |  #focus: enum
                    {
                        "type": "object",
                        "properties": {
                            "name": {
                                "type": "string",
                                "enum": ["taro", "jiro"]
                    省略部分は: #search: JSON schema basic example
                validation 結果: |
                    {"name": "taro", "level": 1}  // OK
                    {"name": "sabu", "level": 1}  // NG
                省略可能: |  #// プロパティの省略不可は required に設定します
                    "name": {
                        "type": ["string", "null"],
                        "enum": ["taro", "jiro", "", null]
            値の型の参照:  #search: JSON schema value definitions $ref
        依存関係, dependencies:  #// dependencies, oneOf  #// あるプロパティの値と別のプロパティの値の間の条件
            基本のサンプル: #keyword: JSON schema dependencies oneOf
                schema: |  #focus: dependencies, job
                    {
                        "type": "object",
                        "properties": {
                            "job": {
                                "type": "string",
                                "enum": ["manager", "employee"]
                            },
                            "allow": {  // ここになくてもよい
                                "type": "string"
                            }
                        },
                        "dependencies": {
                            "job": {  // 条件式（入力値）に含めるプロパティ名
                                "oneOf": [  // どれか１つに一致するという条件
                                    {
                                        "properties": {
                                            "job": {  // 条件式（dependencies の直下に指定したプロパティであるため）
                                                "enum": ["manager"] 
                                            },
                                            "allow": {  // プロパティの定義（バリデーションの内容）
                                                "enum": ["approval", "reject"]
                                            }
                                        }
                                    },
                                    {
                                        "properties": {
                                            "job": {
                                                "enum": ["employee"] 
                                            },
                                            "allow": {
                                                "enum": ["request", "rest"]
                                            }
                                        }
                                    }
                                ]
                            }
                        }
                    }
                validation 結果: |
                    {"job": "manager", "allow": "approval"}   // OK
                    {"job": "manager", "allow": "rest"}       // NG
        設定の参照, definitions, $ref:  #// definitions, $ref  #// 型定義  #keyword: JSON schema definitions $ref
            値の型の参照: #keyword: JSON schema value definitions $ref
                schema: |  #focus: name, $ref, definitions
                    {
                        "type": "object",
                        "properties": {
                            "owner": {
                                "$ref": "#/type:name"  // #/ はルートを表す
                            },
                            "partner": {
                                "$ref": "#/type:name" 
                            },
                        },
                        "type:name": {
                            "type": "string",
                            "pattern": "^[a-zA-Z0-9]+$",
                            "minLength": 3,
                            "maxLength": 16
                        }
                    }
                validation 結果: |  #search: jsonschemavalidator.net
                    {"owner": "taro", "partner": "jiro"}   // OK
                    {"owner": "taro", "partner": "ji_ro"}  // NG
                    {"owner": "ta_ro", "partner": "jiro"}  // NG
            オブジェクトの型の参照: #search: JSON schema nested class
    JSONC:  #search: JSONC
    JSONP:  #// JSON with padding
        #ref: https://www.tohoho-web.com/ex/jsonp.html
        サンプル:
            my.example.com: |
                <script src="http://bbb.example.com/global1.js"></script>
                <script>
                    alert(global1); // 1
                </script>
            someone.example.com/global1.js:
                global1 = 1;
            脆弱性:
                someone.example.com/global1.js が悪意のあるサイトだった場合、
                my.example.com またはそれを見ている人が被害にあいます。
            #ref: https://gihyo.jp/dev/serial/01/crossbrowser-javascript/0011
YAML:  #// https://yaml.org  #search: steps.yaml  #keyword:
    文法:  #ref: ${programming}/HTML ブラウザ/Wiki.svg#YAML
        マッピング: #keyword: YAML mapping
            #focus: aa, bb, cc
            コード:
                aa.bb = 12
                aa.cc = 34
            YAML >> :を使う場合:
                aa:
                    bb: 12
                    cc: 34
            YAML >> {} を使う場合:
                aa: {bb:12, cc:34}
            解説:
                aa がマッピング（構造体）の場合、
                    aa の中にフィールド名（bb:）を書きます。もしくは、
                    aa の右に { } を書きます
        シーケンス: #keyword: YAML sequence  #ref: https://yaml.org/spec/1.2.2/#21-collections
            #focus: aa
            コード:
                aa[0] = 12
                aa[1] = 34
            YAML >> [] を使う場合:
                aa: [12, 34]
            YAML >> - を使う場合:
                aa:
                    - 12
                    - 34
        マッピングのシーケンス: #keyword: YAML 多重度=多
            #focus: bb, cc, dd
            コード:
                aa.bb[0].cc = 12
                aa.bb[0].dd = 34
                aa.bb[1].cc = 56
                aa.bb[1].dd = 78
            YAML >> - を使う場合:
                aa:
                    bb:
                        -   cc: 12
                            dd: 34
                        -   cc: 56
                            dd: 78
            YAML >> - を使う場合（同じ行にコメントを下記、次の行に値を書く場合）:
                aa:
                    bb:
                        - #// 12,34
                            cc: 12
                            dd: 34
                        - #// 56,78
                            cc: 56
                            dd: 78
            YAML >> [] を使う場合:
                aa:
                    bb: [{cc:12, dd:34}, {cc:56, dd:78}]
            解説:
                bb がマッピングのシーケンス（構造体の配列）の場合、
                    bb の中に - とフィールド名（cc:）を書きます。つまり - の親（bb:）がシーケンスです。もしくは、
                    bb の右に [ ] を書きます。
                    bb のフィールド名（bb:）は 1つだけ書きます。
        複数行の文字列: #keyword: YAML multi lines  #ref: ${programming}/HTML ブラウザ/Wiki.svg#YAML_multi_line
            "|":  複数行の文字列、 最終行に改行あり  #keyword: YAML |
            "|-": 複数行の文字列、 最終行に改行なし  #keyword: YAML |-
            ">-": 1行の文字列、改行は空白に置き換わる、空行は改行に置き換わる。 最終行に改行なし  #keyword: YAML >-
            ">":  1行の文字列、改行は空白に置き換わる、空行は改行に置き換わる。 最終行に改行あり  #keyword: YAML >
            #// >+ などもあります
        anchors: #keyword: YAML anchors
            #ref: https://x.com/__syumai/status/1968976993648578742
    Node.js 用パーサー >> js-yaml:
        インストール: npm install js-yaml --save
        サンプル コード:
            const  text = fs.readFileSync(filename);
            return yaml.load(text);
    JSON から YAML に変換します:  #keyword: JSON to YAML
        DevToys:  #search: DevToys
        json2yaml:  #keyword: json2yaml
            インストールします:
                #Git bash
                - mkdir -p ~/bin/json2yaml
                - cd       ~/bin/json2yaml
                - npm install json2yaml
            変換します:
                #Git bash
                - cd  ~/bin/json2yaml
                - tee  target.json  #// JSON をコピペして Ctrl + C キーを押します
                    #// または start . でフォルダーを開いて target.json を編集します

                - ./node_modules/.bin/json2yaml target.json > target.yaml
                - cat  target.yaml  #// YAML を表示します
        Python:  #keyword: PyYAML
            (@CentOS7):
                PyYAML:
                    pip install  PyYAML
                msgpack-python + PyYAML:
                    msgpack-python をインストールします: 
                        pip install  msgpack-python  PyYAML
                    _out.pack ファイルに MessagePack 形式のデータを保存します:
                    _out.pack ファイルから YAML に変換したデータを _out.yaml ファイルに出力します: |  #// インデントは削除してください
                        pip install  msgpack-python  PyYAML
                        python -c "
                        import msgpack, yaml
                        for message in msgpack.Unpacker(open('_out.pack', 'rb'), raw=False):
                            print(yaml.dump(message, sort_keys=False))"
    YAML Front Matter, gray-matter: #keyword:  #ref: https://github.com/jonschlinkert/gray-matter
        概要: --- から始まるファイルに、YAML 形式でコンテンツのメタデータを書き、
            次の --- の行の下に HTML や　Markdown など任意のコンテンツを書きます。
        サンプル: |
            ---
            title: Hello
            slug: home
            ---
            <h1>Hello world!</h1>
        解析後のサンプル:
            {
                content: '<h1>Hello world!</h1>',
                data: { 
                    title: 'Hello', 
                    slug: 'home' 
                }
            }
        参考: #search: Next.js getStaticProps
    関連 >> HCL:  #search: HCL
    #ref: ${programming}/HTML ブラウザ/Wiki.svg#YAML
    トラブルシューティング:
        Map keys must be unique YAML: #keyword:
            手順: VSCode で YAML を編集中
            ログ: |
                Map keys must be unique YAML
            対処:
                エラーが発生した場所の次のフィールドを、重複しない名前に変えます
CSV:  #keyword: JavaScript CSV
    配列からCSV 文字列へ:
        簡易版: values.join(', ')  #// 値にコンマやダブルクォーテーションがあると正しくありません
        すべて "" で囲む簡易版: #keyword: getAllQuotedCSVLine  #ref: ${GitHub}/typrm/src/lib.ts#function  getAllQuotedCSVLine
    CSV 文字列から配列へ:
        簡易版:
            const rows = csvString.split('\n');
            const csvLines = rows.map(row => row.split(','));
        parseCSVColumns:  #ref: ${GitHub}/typrm/src/lib.ts#function  parseCSVColumns
        その他:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#CSV
    CSV ファイルをパースします:
        parseCSVColumns:  #ref: ${GitHub}/typrm/src/lib.ts#function  parseCSVColumns
        埋め込む場合: |
            import * as fs from 'fs';
            import * as csvParse from 'csv-parse';

            async function load(csvFilePath: string): Promise<void> {
                const  table: string[] = [];
                const  promise = new Promise<void>((resolveFunction, _rejectFunction) => {

                    fs.createReadStream(csvFilePath)
                        .pipe(
                            csvParse({ quote: '"', ltrim: true, rtrim: true, delimiter: ',', relax_column_count: true }))
                        .on('data',
                            (columns) => {
                                table.push(columns);
                            })
                        .on('end', () => {
                            resolveFunction();
                        });
                });
                return  promise;
            }
    トラブル シューティング(CSV):
        - #// CSV_INCONSISTENT_RECORD_LENGTH
            手順: csvParse
            エラー: |
                CSV_INCONSISTENT_RECORD_LENGTH 例外
            対処:
                relax_column_count を true にします: |
                    csvParse({ ___, relax_column_count: true })
クリップボード:  #keyword: Node.js JavaScript npm clipboard
    ローカル用:
        clipboardy:  #// https://github.com/sindresorhus/clipboardy  #keyword:
            サンプル: |
                import * as clipboardy from 'clipboardy';

                function  main() {
                    clipboardy.writeSync('🦄');
                    var d = clipboardy.readSync();
                    d = d;
                }
                main();
            対応: macOS, Windows, Linux, OpenBSD, FreeBSD, Android with Termux, and modern browsers.
            セキュリティ調査結果:
                exe ファイル:
                    内部で clipboard_x86_64.exe などの実行ファイルを呼び出していますが、
                    実行ファイルはウイルス対策ソフトが監視しているので安全です。
                    __Project__/node_modules/clipboady/fallbacks フォルダー内にあります。
                JavaScript ファイル:
                    コード自体は単にプロセス呼び出しをしているだけです。
                    package.json の dependencies にある arch, execa, is-wsl
                arch:  #keyword:
                    OSを判定します。
                    アーチと呼びます。
                    https://www.npmjs.com/package/arch
                execa:  #keyword: 
                    子プロセスを起動します。child_process の改良版。
                    https://www.npmjs.com/package/execa
                is-wsl:  #keyword:
                    WSL (Windows Subsystem for Linux) のユーティリティ
                    https://www.npmjs.com/package/is-wsl
        system call:  #// https://stackoverflow.com/questions/7778539/copy-to-clipboard-in-node-js
        clipboard-event:  #// https://stackoverflow.com/questions/63952819/how-to-detect-the-changes-of-system-clipboard-with-nodejs
    ブラウザー用:
        clipboard :  #// https://www.npmjs.com/package/clipboard
            ブラウザーが必要です:  #// https://stackoverflow.com/questions/38255661/errors-with-clipboard-js-in-react-component
        clipboard-polyfill:  #// https://github.com/lgarron/clipboard-polyfill
            ブラウザーが必要です:
        copy-to-clipboard :  #// https://www.npmjs.com/package/copy-to-clipboard
            ブラウザーが必要です:
        clipboard-copy:  #// https://co.bsnws.net/article/303
            ブラウザーが必要です:
画像: #keyword: Node.js JavaScript image
    sharp: #keyword: Node.js JavaScript sharp  #ref: https://sharp.pixelplumbing.com
        プロジェクト: #keyword: sharp project
            処理手順: #keyword: sharp project steps
                プロジェクトを VSCode で開きます:
                    #ref: ${GitHub}/MyPrivateCode/image_sharp
                _input フォルダーに入力画像ファイルをコピーします:
                    #ref: ${GitHub}/MyPrivateCode/image_sharp/_input
                コードを編集します:
                    #ref: ${GitHub}/MyPrivateCode/image_sharp/src/sharp.ts
                処理を実行します:
                    F5 キー
                _output フォルダーに出力画像ファイルができます:
                    #ref: ${GitHub}/MyPrivateCode/image_sharp/_output
            トリミング: #keyword: sharp trimming
                処理手順: #search: sharp project steps
                サンプル コード: |  #ref: ${GitHub}/MyPrivateCode/image_sharp/src/sharp.ts#function  trimming
                    async function  trimming() {
                        const  files = await listUpFiles('../_input', '../_output');
                        fs.mkdirSync('../_output', {recursive: true});
                        for (const file of files) {

                            sharp(file.inputFilePath)
                                .extract({
                                    left:   100,
                                    top:    100,
                                    width:  100,
                                    height: 100 })
                                .toFile(file.outputFilePath);
                        }
                    }
                座標: #search: mac image width height size
            薄くする: #keyword: image 薄くする,  明るくする brightness
                処理手順: #search: sharp project steps
                linear: |  #ref: ${GitHub}/MyPrivateCode/image_sharp/src/sharp.ts#function  linear
                    sharp(file.inputFilePath)
                        .linear(0.5, 128)
                        .toFile(file.outputFilePath);
                iPhone で試す:  #// linear はありません
                    写真アプリに転送
                brightness: |  #ref: ${GitHub}/MyPrivateCode/image_sharp/src/sharp.ts#function  brightness
                    sharp(file.inputFilePath)
                        .modulate({
                            brightness:1.3,
                        })
                        .toFile(file.outputFilePath);
        プロジェクトに入っていない処理:
            リサイズ, 幅高さ:  #keyword: Node.js sharp resize
                サンプル: |  #focus: resize  #search: sharp project
                    const  imageChain = sharp(inputFilePath);
                    const  resizedImageChain = imageChain.resize( 100, 100, {fit: 'contain', background: {r:0,g:0,b:0,alpha:0}} );
                        // cover:   [ image [ buffer ] ]  (defalut) The buffer has a part of image
                        // contain: [ buffer [ image ] ]  The part of buffer has the image
                    const  image = await imageChain.metadata();
                    const  resizedImage = await resizedImageChain.toBuffer({ resolveWithObject: true });
                    resizedImageChain.toFile(outputFilePath);

                    console.log(image.width, image.height);
                    console.log(resizedImage.info.width, resizedImage.info.height);
                サンプルの説明:
                    - resize メソッドでリサイズします
                    - metadata メソッドはリサイズ前の幅高さなどを返します
                    - toBuffer メソッドに resolveWithObject:true を指定するとリサイズ前の幅高さなどを返します
        コーディングしていない処理:
            ぼかし: #ref: https://blog.kozakana.net/2019/04/sharp-image-operations/
        参考:
            #ref: https://note.affi-sapo-sv.com/nodejs-sharp.php
            #ref: https://blog.kozakana.net/2019/04/sharp-image-processing/
        インストール:
            bash:
                npm install sharp @types/sharp --save
            __Project__/tsconfig.json: |
                {
                    "compilerOptions": {
                        "allowSyntheticDefaultImports": true,
            main.ts: |
                import sharp from 'sharp';

                main();
                async function  main() {
                    sharp('../test/image.png')
                        .extract({ left: 0, top: 0, width: 100, height: 100 })
                        .toFile('./_output.png');
                }
            sharp for Windows をインストールできない:
                Stack overflow: #ref: https://stackoverflow.com/questions/71301821/cant-install-sharp-on-windows-10-x64
                sharp 公式より:  #ref: https://github.com/lovell/sharp/issues?q=is%3Aissue+windows+install
                    v0.30.2 で解決しそう: #ref: https://github.com/lovell/sharp/issues/3086
                    sharp@0.29.3 でも良さそう: #ref: https://github.com/lovell/sharp/issues/3086
キーボード:
    ブラウザーへのキー入力: |
        document.addEventListener('keypress', keypress_ivent);
        function keypress_ivent(e) {
            document.getElementById('output').innerHTML = e.key;
            return false; 
        }
#↓コマンド
node:  #keyword: Node.js  #ref: https://nodejs.org/en
    インストール, 手順:  #search: install Node.js
        Node.js 本体:  #search: nvm
        Node.js プロジェクト:  #search: Node.js projects
        新規プロジェクト:  #search: new Node.js project
        node の場所:  #// 実行ファイルがある場所
            CentOS7:
                nvm なし: /opt/node/bin/node  #// ただし /opt/node は /opt/node-v18.14.1-linux-x64 などへの シンボリック リンク です
                nvm あり: ~/.nvm/versions/node/v12.16.1/bin/node  #// Node.js のバージョンによります
        バージョン:  #search: Node.js version
    コマンド:
        node: #keyword:
            警告を出ないようにする方法:  #// typrm で検証したもの  #search: JavaScript import extension
                import に拡張子 .js をつけた場合:
                    Node.js v20.___:
                        - node  __Script__.js  ____
                    Node.js v16.20.1:
                        - node --experimental-modules --es-module-specifier-resolution=node  __Script__.js  ____
                        - node  __Script__.js  ____   #// ...は未確認
                import に拡張子をつけない場合:
                    Node.js 18.16.1:
                        node --no-warnings  --es-module-specifier-resolution=node  __Script__.js  ____
                    Node.js v16.20.1:
                        node --experimental-modules --es-module-specifier-resolution=node  __Script__.js  ____
            プロファイリング: #keyword: Node.js profile
                Node.js を起動するときのオプションに --prof を追加します:
                    CLI の場合:
                        修正前: node __Parameters__
                        修正後: node --prof __Parameters__
                    VSCode の launch.json の場合: 
                        "runtimeArgs": ["--prof"]
                プロファイルの結果をまとめたファイルを作ります:
                    node.exe --prof-process __RuntimeCurrent__/isolate-_________-v8.log  > _prof.txt
                出力例: |
                    Statistical profiling result from src/isolate-0000024B96C3F290-4548-v8.log, (15300 ticks, 81 unaccounted, 0 excluded).

                    [Shared libraries]:
                    ticks  total  nonlib   name
                    10011   65.4%          C:\Program Files\nodejs\node.exe
                    2193   14.3%          C:\WINDOWS\SYSTEM32\ntdll.dll
                        24    0.2%          C:\WINDOWS\System32\KERNEL32.DLL
                        3    0.0%          C:\WINDOWS\System32\KERNELBASE.dll

                    [JavaScript]:
                    ticks  total  nonlib   name
                    2443   16.0%   79.6%  LazyCompile: *<anonymous> file:///C:/Users/user1/GitProjects/GitHub/typrm/build/lib.js:1149:40
                        199    1.3%    6.5%  RegExp: ^( |¥t)*
                        32    0.2%    1.0%  LazyCompile: *emitInitNative internal/async_hooks.js:190:24
                        32    0.2%    1.0%  LazyCompile: *compareScoreAndSoOnDebug file:///C:/Users/user1/GitProjects/GitHub/typrm/build/main.js:3905:34
                        29    0.2%    0.9%  LazyCompile: *searchSub file:///C:/Users/user1/GitProjects/GitHub/typrm/build/main.js:2878:25
                        19    0.1%    0.6%  LazyCompile: *plusParentMatchScore file:///C:/Users/user1/GitProjects/GitHub/typrm/build/main.js:6418:25
                        18    0.1%    0.6%  LazyCompile: *getKeywordMatchingScore file:///C:/Users/user1/GitProjects/GitHub/typrm/build/main.js:3279:32
                    ...
            インスペクト:  #// 未確認。クラッシュします
                インスペクトできるモードで起動します:
                    #// 以下のいずれか
                    node --inspect  __NodeParameters__
                    node --inspect-brk  __NodeParameters__
                    node --inspect=__PortNum__  __NodeParameters__
                    npx nodemon --inspect-brk  __NodeParameters__
                Chrome のツールを開きます:
                    Chrome >>（アドレスバーに）chrome:inspect >> （Remote Target #LOCALHOST）inspect >> 
            clinic:  #// スクロールができず、拡大縮小が思い通りにできません
                npm install -g clinic
                clinic flame -- node __Target__.js  __Parameters__
npm:  #keyword: npm, Node.js package manager
    公式:
        API: #ref: https://nodejs.org/api/
    手順:
        インストール:  #keyword: install Node.js,  Sinstall npm TypeScript JavaScript Node.js VSCode
            開発用 Node.js プロジェクト: #keyword: Node.js projects
                （新規プロジェクト）: #keyword: new Node.js project  #// 手動で新規プロジェクトを構築します
                    #// 最新の公式テンプレートを試します。
                    #// 通常 try_TypeScript_base または try_TypeScript_Node_js をベースに開発します
                    手順:
                        WSL2 環境の場合:  #search: install WSL2 Node.js
                        汎用手順:  #// 非推奨?
                            注意: バージョンによって使える構文が異なるため非推奨
                                代わりの方法  #search: try_TypeScript_Node_js
                            Node.js 本体をインストールします:
                                #search: install Node.js
                            プロジェクト フォルダー を新規作成します:  #search: npm init
                                cd __ParentOfProject__
                                mkdir -p  __Project__
                                cd  __Project__
                                npm init -y
                                code "."
                            （必要なら）必要なパッケージをインストールします:  #search: npm install
                                npm install [--save-dev] __PackageName__  [@types/__PackageName__]
                            __Command__.js ファイル を作ります:
                                console.log("Hello, world.");
                            実行します:
                                node __Command__.js
                try_TypeScript_base: #keyword:  #// try_TypeScript_Node_js や try_Node_js_lib のベース
                    手順:  #ref: ${GitHub}/Trials/try_TypeScript_base/README.yaml
                try_Node_js_lib: #keyword:  #ref: ${GitHub}/Trials/try_Node_js_lib  #// Node.js サンプル集。といってもまだ hello world と glob しか無い
                try_JestOfConsole: #keyword:  #// コンソール アプリケーション, Jest あり
                    使い方:  #// Windows, mac  #keyword: Node.js project usage
                        try_JestOfConsole プロジェクトのフォルダーをコピーします:
                            #ref: ${GitHub}/Trials/try_JestOfConsole
                        フォルダー名を新しいプロジェク名に変えます:
                        Visual Studio Code で新しいプロジェクトのフォルダーを開きます: #copy: open VSCode
                            Visual Studio Code を右クリック（Windows の タスク バー または mac の Dock）>>
                            New Window >> プロジェクト フォルダー を Visual Studio Code へドラッグ＆ドロップします
                        一部のファイル名をコマンド名に変えます:
                            __Project__/src/app_test.ts:  app をコマンド名に改名します
                            __Project__/src/app.ts:       app をコマンド名に改名します
                        一部のファイルの中にあるコマンド名を変えます:
                            __Project__/.vscode/launch.json: |  #// 下記 app をコマンド名に改名します
                                "program": "${workspaceFolder}/src/app_test.ts",
                        node_modules フォルダーを復活させます:
                            VSCode >> Terminal（メニュー）>> New Terminal >>
                            npm ci
                        Jest のウォッチモードを起動して Visual Studio Code と接続してテストを実行します:  #serach: VSCode Jest command
                try_TypeScript_Node_js: #keyword:  #// コンソール アプリケーション, Jest なし  #ref: ${GitHub}/Trials/try_TypeScript_Node_js
                    プロジェクト: #ref: ${GitHub}/Trials/try_TypeScript_Node_js
                    初期設定: #ref: ${GitHub}/breadcrumb/tree-breadcrumb/specifications.yaml
                （継承関係）:  #search: project with base
                    try_TypeScript_base:
                        try_Node_js_lib:
                        try_TypeScript_Node_js:
                            try_JestOfConsole:
                （プロジェクトが使うバージョン）: #search: project Node.js version
            実行する Node.js 本体:
                nvm を使ったインストール:  #search: nvm
                WSL2: #keyword: install WSL2 Node.js  #ref: https://learn.microsoft.com/en-us/windows/dev-environment/javascript/nodejs-on-wsl
                    WSL2 をインストールします:  #// Ubuntu 20.04
                        PowerShell:  #search: WSL2 restore
                            wsl --import  "Ubuntu-20.04-Node.js" `
                                "${HOME}\WSL_VMs\Ubuntu-20.04-Node.js" `
                                "${HOME}\WSL_back_up\Ubuntu-20.04-1.tar"
                            wsl -d "Ubuntu-20.04-Node.js"
                    Node.js をインストールします:  #// LTS version
                        Ubuntu bash: |
                            cd  $HOME
                            curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/master/install.sh | bash
                            source ~/.bashrc
                            nvm --version
                            nvm ls
                                iojs -> N/A (default)
                                node -> stable (-> N/A) (default)
                                unstable -> N/A (default)
                            nvm install --lts  #// Current stable LTS release
                            nvm ls
                                ...
                                node -> stable (-> v18.16.0) (default)
                                stable -> 18.16 (-> v18.16.0) (default)
                                ...
                            node --version
                    プロジェクトを作る場合:
                        新規プロジェクトを作り、実行します:
                            PowerShell: |
                                cd  $HOME             #// $HOME は サンプル
                                mkdir -p  try_node    #template: mkdir -p  __Project__  #// 後で実行する npm init は、このフォルダー名を使ってプロジェクトを作ります
                                cd  try_node          #template: cd  __Project__
                                npm init -y
                                code  "."
                            VSCode: |
                                code  "./index.js"
                                    console.log("Hello, world.");
                                F5 キー
                                Node.js（を選ぶ）
                                F5 キー
                        ライブラリをダウンロードして実行します: |
                            cd  ~/try_node
                            npm install  immer    #// immer はサンプル
                            code  "./index.js"
                                import { produce } from 'immer';
                                console.log("Hello, world.");
                            code  "./package.json"
                                {
                                    "name": "try_node",
                                    "version": "1.0.0",
                                    "description": "",
                                    "main": "index.js",
                                    "scripts": {
                                        "test": "echo \"Error: no test specified\" && exit 1"
                                    },
                                    "keywords": [],
                                    "author": "",
                                    "license": "ISC",
                                    "type": "module",
                                    "dependencies": {
                                        "immer": "^10.0.3"
                                    }
                                }
                            F5 キー
                    設定:  #settings:
                        __Project__: try_node
                Windows:
                    Windows:  #search: install Node.js
                    Windows に Node.js と Visual Studio Code をインストールします:  #// Jest なし  #keyword: VSCode Node.js
                        Node.js projects:  #search: Node.js projects
                        Node.js プロジェクトをインストールします:  #// 開発環境なし
                            Node.js をインストールします:
                            プロジェクトをコピーします:
                            シェル:
                                npm install --only=production
                                npm start
                        Windows に Node.js と Visual Studio Code をインストールします:  #// Jest なし
                            プロジェクトを作る場合:
                                Node.js をインストールします:  #keyword: install Node.js for Windows
                                    - https://nodejs.org/ja/download/ >> Windows Installer (.msi) >> 64-bit
                                    - ダウンロードしたファイル（例：node-v14.15.0-x64.exe）を開きます
                                    - インストール オプションはデフォルトを使用
                                    - プロキシがある LAN に Windows がある場合:
                                        プロキシの設定をします:
                                            - Windows スタート >> PowerShell
                                            - npm config -g set proxy "http://___.___.___.___:____"
                                            - npm config -g set https-proxy "http://___.___.___.___:____"
                                        （不要になったら）プロキシの設定を解除します:
                                            - npm config -g rm proxy
                                            - npm config -g rm https-proxy
                                Visual Studio Code をインストールします:
                                    - https://code.visualstudio.com/
                                    - ダウンロードしたファイル（例：VSCodeUserSetup-x64-1.55.2.exe）を開きます
                                    - インストール オプションはデフォルトを使用
                                    - （推奨）VSCode (Visual Studio Code をタスクバーにピン止めします:
                                    - （推奨）Ctrl + S キーを押したときに全てのファイルを保存するように設定します: |
                                        VSCode >> File >> Preferences >> Keyboard Shortcuts >> save all （と入力） >>
                                            File: Save All （をダブルクリック） >> Ctrl + S キー >> Enter キー
                                プロジェクトを新規作成します:
                                    Visual Studio Code で新しいフォルダー try_node_js を開きます:  #template: __Project__
                                        VSCode >> File >> Open Folder >> デスクトップ >> 新しいフォルダー >> try_node_js >> フォルダーの選択  #template: __Project__
                                    __Project__/package.json :
                                        npm コマンドを使う場合:
                                            Terminal:  #// VSCode >> Terminal >> New Terminal
                                                npm init -y
                                        npm コマンドを使ったときの内容: |
                                            {
                                                "name": "__FolderName__",
                                                "version": "1.0.0",
                                                "description": "",
                                                "main": "index.js",
                                                "scripts": {
                                                    "test": "echo \"Error: no test specified\" && exit 1"
                                                },
                                                "keywords": [],
                                                "author": "",
                                                "license": "ISC"
                                            }
                                        独自の内容:
                                            __Project__/package.json : |  #// VSCode の EXPLORER（の中を右クリック）>> New File >> package.json
                                                {
                                                    "name": "__FolderName__",
                                                    "version": "0.0.1",
                                                    "description": "",
                                                    "scripts": {
                                                        "setup": "npm ci",
                                                        "clean": "powershell rm -r -fo node_modules"
                                                    },
                                                    "author": "",
                                                    "license": "ISC",
                                                    "private": false,
                                                    "dependencies": {},
                                                    "devDependencies": {}
                                                }
                                            #// ファイルを保存します
                                依存する Node.js モジュールをインストールします:  #// サンプルとして Swagger UI をインストールします
                                    Terminal:  #// VSCode >> Terminal >> New Terminal
                                        npm install swagger-ui-dist  #// 開発用モジュールの場合は --save-dev も付ける
                        既存のプロジェクトを使う場合:
                            #serach: Node.js projects
                        古い手順:
                            Node.js をインストールします:
                                - https://nodejs.org/ja/download/ >> Windows Installer (.msi) >> 64-bit
                                - ダウンロードしたファイル（例：node-v14.15.0-x64.exe）を開きます
                                - インストール オプションはデフォルトを使用
                                - プロキシがある LAN に Windows がある場合:
                                    - Windows スタート >> PowerShell
                                    - npm config -g set proxy "http://___.___.___.___:____"
                                    - npm config -g set https-proxy "http://___.___.___.___:____"
                            __Application__ が使う Node.js パッケージをインストールします:
                                - Windows スタート >> PowerShell
                                - npm install -g  __Package__
                            実行するときは、NODE_PATH を設定します:
                                set NODE_PATH=%USERPROFILE%\AppData\Roaming\npm\node_modules
                                node  ____.js
                    Windows に Node.js と Jest と Visual Studio Code をインストールします:  #keyword: install VSCode Node.js Jest
                        #// Jest の watch を使って VSCode のデバッガーを爆速で起動する
                        #// Jest の詳細については、Test.yaml を参照
                        設定: #settings:
                            __JestProject__: try_jest
                        Node.js をインストールします:
                            - https://nodejs.org/ja/download/ >> Windows Installer (.msi) >> 64-bit
                            - ダウンロードしたファイル（例：node-v14.16.1-x64.msi）を開きます
                            - インストール オプションはデフォルトを使用
                            - プロキシがある LAN に Windows がある場合:
                                - Windows スタート >> PowerShell
                                - npm config -g set proxy       "http://___.___.___.___:____"
                                - npm config -g set https-proxy "http://___.___.___.___:____"
                        Visual Studio Code をインストールします:
                            - https://code.visualstudio.com/
                            - ダウンロードしたファイル（例：VSCodeUserSetup-x64-1.55.2.exe）を開きます
                            - インストール オプションはデフォルトを使用
                            - （推奨）VSCode (Visual Studio Code をタスクバーにピン止めします:
                            - （推奨）Ctrl + S キーを押したときに全てのファイルを保存するように設定します: |
                                VSCode >> File >> Preferences >> Keyboard Shortcuts >> save all （と入力） >>
                                    File: Save All （をダブルクリック） >> Ctrl + S キー >> Enter キー
                        既存のプロジェクトを使う場合:
                            #serach: try_JestOfConsole
                        既存のプロジェクトを使わない場合:
                            プロジェクトを新規作成します:
                                Visual Studio Code で新しいフォルダー try_jest を開きます:  #template: __JestProject__
                                    VSCode >> File >> Open Folder（macの場合 Open）>> デスクトップ >> 新しいフォルダー >> try_jest >> フォルダーの選択  #template: __JestProject__
                                __Project__/package.json : |  #// VSCode の EXPLORER（の中を右クリック）>> New File >> package.json
                                    {
                                        "name": "try_jest",
                                        "version": "0.0.1",
                                        "description": "",
                                        "scripts": {
                                            "setup": "npm ci",
                                            "test":  "jest --watchAll",
                                            "clean": "powershell rm -r -fo node_modules"
                                        },
                                        "author": "",
                                        "license": "ISC",
                                        "private": false,
                                        "dependencies": {},
                                        "devDependencies": {},
                                        "jest": {
                                            "roots": [
                                                "<rootDir>/src"
                                            ],
                                            "testMatch": [
                                                "**/__tests__/**/*.+(ts|tsx|js)",
                                                "**/?(*.)+(spec|test).+(ts|tsx|js)"
                                            ],
                                            "transform": {
                                                "^.+\\.(ts|tsx)$": "ts-jest"
                                            },
                                            "maxWorkers": 1
                                        }
                                    }
                                    #// ファイルを保存します
                                （メモ）:  #keyword: VSCode jest --watchAll
                                    jest --watchAll を ts-node node_modules/jest/bin/jest.js --watchAll にすると、
                                    jest の f ボタンによる再テストをしたときにターミナルの表示がクリアされません。
                                必要な Node モジュールをインストールします:
                                    Terminal:  #// VSCode >> Terminal >> New Terminal
                                        npm install  typescript  ts-node  @types/node  jest  ts-jest  @types/jest  --save-dev
                                __Project__/tsconfig.json : |
                                    {
                                        "compilerOptions": {
                                            "declaration": true,
                                            "strict": true,
                                            "lib": [ "es2015", "dom" ],
                                            "inlineSourceMap": true,
                                            "inlineSources": true,
                                            "outDir": "build"
                                        }
                                    }
                                __Project__/src/lib.ts : |
                                    export function  add(a: number, b: number): number {
                                        return  a + b;
                                    }
                                __Project__/src/lib.test.ts : |
                                    import { add } from './lib';

                                    test('add', () => {
                                        const  a = 2;
                                        const  b = 3;
                                        const  answer = 5;

                                        const  result = add( a, b );
                                        expect(result).toBe(answer);
                                    });
                                Jest のウォッチモードを起動して Visual Studio Code と接続します:  #keyword: VSCode Jest command,  npm test Jest watch
                                    メニュー:
                                        Windows: |
                                            Terminal >> 1: powershell（Terminal の上）>> Create JavaScript Debug Terminal
                                        mac: |
                                            Terminal >> 1: zsh（Terminal の上）>> Create JavaScript Debug Terminal
                                    Terminal:
                                        npm test  #// package.json#scripts/test
                                    #// テストが実行され、テストがパスし、Jest の watch のメニューが表示されます
                                デバッガーに接続して失敗したテストをデバッグします:
                                    テストが失敗するコードにしてみます:
                                        __Project__/src/lib.ts :
                                            変更前: a + b
                                            変更後: a + a
                                        #// 保存するとテストが自動的に開始され、テストに失敗します
                                    ブレークポイントを張ります:
                                        たとえば __Project__/src/lib.test.ts の add 関数を呼び出すコードに張ります:
                                    Terminal:
                                        - Terminal をクリックしてアクティブにします
                                        - f キーを押します
                                        #// ブレークポイントでブレークします
                                        #// F10 キーで ステップ オーバー、F11 キーで ステップ イン します
                                テストを再起動します:
                                    プログラムがブレーク中のとき:
                                        Continue ボタン:
                                            #// Jest の watch のメニューが Terminal に表示されます
                                        Terminal:
                                            - Terminal をクリックしてアクティブにします
                                            - f キーを押します
                                    プログラムが実行中で終わらないとき、Jest の watch のメニューが表示されないとき:
                                        Terminal タブ（下）>> ゴミ箱アイコン（右）:
                                        メニュー: |
                                            Terminal >> 1: powershell（Terminal の上）>> Create JavaScript Debug Terminal
                                        Terminal:
                                            npm test  #// package.json#scripts/test
                                １つのテストのみ実行します:
                                    テストするテストコードがあるファイルを限定します:
                                        Jest watch >> p >> （ファイル名またはその一部にマッチするパターン）
                                    __Project__/src/lib.test.ts:
                                        変更前: test(
                                        変更後: test.only(
                mac（★書きかけ）:
                    - https://nodejs.org/ja/download/ >> macOS Installer (.pkg) >> 64-bit
                    - ダウンロードしたファイル（例：node-v14.15.0.pkg）を開きます
                    - インストール オプションはデフォルトを使用
                    - __Application__ が使う Node.js パッケージをインストールします:
                        - Launchpad >> Terminal
                        - sudo npm install -g  __Package__
                    - 実行するときは、NODE_PATH を設定します:
                        export NODE_PATH=/usr/local/lib/node_modules
                        node  ____.js
                CentOS:
                    CentOS に Node.js をインストールします（IDEなし）:  #keyword: install Node.js CentOS
                        設定: #settings:
                            __Node_js_URL__: https://nodejs.org/dist/v18.14.1/node-v18.14.1-linux-x64.tar.xz
                            __Node_js_FileName__: node-v18.14.1-linux-x64
                        Node.js をインストールします:
                            URL を調べます:
                                - https://nodejs.org/ja/download/ >> Linux Binaries (x64)（の右の 64-bit を右クリック）>>
                                    リンクのコピー
                                - コピーした URL をメモします:
                                    __Node_js_URL__: https://nodejs.org/dist/v18.14.1/node-v18.14.1-linux-x64.tar.xz  #template: __Node_js_URL__
                                    __Node_js_FileName__: node-v18.14.1-linux-x64  #template: __Node_js_FileName__
                            Node.js 本体をインストールします:
                                - cd ${HOME}
                                - curl -L -O https://nodejs.org/dist/v18.14.1/node-v18.14.1-linux-x64.tar.xz  #template: __Node_js_URL__
                                - tar -Jxvf  node-v18.14.1-linux-x64.tar.xz  #template: __Node_js_FileName__.tar.xz
                                - rm  node-v18.14.1-linux-x64.tar.xz  #template: __Node_js_FileName__.tar.xz
                                - sudo mv  node-v18.14.1-linux-x64  /opt  #template: __Node_js_FileName__
                                - cd /opt
                                - ls  #// 他のバージョンがすでにインストールされているか確認します
                                - まだどのバージョンもインストールされていないとき:
                                    - sudo ln -s  node-v18.14.1-linux-x64  node  #template: __Node_js_FileName__
                                    - cd ${HOME}
                                    - PATH=/opt/node/bin:$PATH
                                    - node --version
                                    - echo 'export PATH="/opt/node/bin:$PATH"' >> ~/.bashrc
                                        #// .bashrc は、シェルを再起動するときに実行されます
                                - 他のバージョンがすでにインストールされているとき:
                                    - sudo rm /opt/node
                                    - cd /opt
                                    - sudo ln -s  node-v18.14.1-linux-x64  node  #template: __Node_js_FileName__
                                    - cd ${HOME}
                            （必要なら）npm と yarn をプロキシがある環境でも使えるようにします: #keyword: npm yarn proxy
                                コマンド: |
                                    npm -g config set proxy http://host:port             #template: __Proxy__
                                    npm -g config set https-proxy http://host:port       #template: __Proxy__
                                    npm -g config set registry http://registry.npmjs.org/
                                    npm -g config set strict-ssl=false
                                    yarn config set proxy http://host:port -g            #template: __Proxy__
                                    yarn config set https-proxy http://host:port -g      #template: __Proxy__
                        yarn をインストールします(CentOS7): #keyword: install yarn CentOS7
                            #// node-v18.14 には yarn が付いています
                            - su -
                            - PATH=/opt/node/bin:$PATH
                            - npm install --global yarn
                            - exit
                            - yarn --version
                    CentOS の VM を作り Node.js をインストールします:  #keyword: install Node.js CentOS VM
                        node_js_TypeScript: #ref: ${GitHub}/MyPrivateCode/ansible_vagrant/multi_vm_ansible/branch_node
                            トラブルシューティング:
                                - #// /usr/bin/env: node: No such file or directory
                                    手順: vagrant up
                                    エラー: |
                                        /usr/bin/env: node: No such file or directory
                                    対処:
                                        path: /etc/profile  #// If "/home/vagrant/.bashrc", raises an error /usr/bin/env: node: No such file or directory
                                        line: 'PATH="/opt/node/bin:$PATH"'
                                        #ref: ${GitHub}/MyPrivateCode/ansible_vagrant/multi_vm_ansible/branch_node/playbook.yml#PATH=
                任意のOS:  #// Node.js のプロジェクトをインストールします  #keyword: run-script-os, OS independent npm-scripts Node.js
                    run-script-os:  #// OS に依存しない npm-scripts を作るための補助をします
                        https://qiita.com/yfujita0929-tis/items/24407b8006bf2d1c140a
                    npm-run-all:  #// 並列動作？
                        https://qiita.com/yfujita0929-tis/items/24407b8006bf2d1c140a
                プロジェクトが使うバージョン: #keyword: project Node.js version  #// Node.js のバージョン
                    .nvmrc ファイルがある場合:  #search: .nvmrc
                        nvm use
            新規プロジェクト:  #search: new Node.js project
            古い Node.js の URL:
                Linux:
                    https://nodejs.org/dist/v14.18.0/node-v14.18.0-linux-x64.tar.xz
                    https://nodejs.org/dist/v12.16.1/node-v12.16.1-linux-x64.tar.xz
            古い npm パッケージをインストールします:
                公開されているパージョンを一覧します:
                    npm view __PackageName__ versions
                指定したバージョンをインストールします:
                    npm install __PackageName__@__Version__
                    #// サンプル: npm install jest@26.6.3
            脆弱性の警告:
                エラーメッセージ: found __Number__ high severity vulnerabilities
                脆弱性があるモジュールの詳細:
                    npm audit
        更新:
            node_modules と package-lock.json を削除して npm install
        パッケージの操作:
            追加:  #search: npm install
            削除:  #search: npm uninstall
        package.json scripts に書かれたコマンドを実行します:  #search: package.json scripts
        node_modules 以外をコピーします:
            手動:
                フォルダー（エクスプローラー）で node_modules 以外を選択してコピーする
            locommit:  #search:
            自動:
                #// _destination フォルダーが新しくできます（元の _destination は削除されます）
                #Git bash
                cd  "__SourceFolder__"
                rm -f   "../_bk-__AnyName__.tar.gz"
                rm -rf  "../_destination"
                tar cvzf  "../_bk-__AnyName__.tar.gz"  --exclude "node_modules"  "."
                mkdir  "../_destination"
                tar xvf   "../_bk-__AnyName__.tar.gz"  --directory  "../_destination"
                rm  "../_bk-__AnyName__.tar.gz"
    ファイル:  #glossary:
        package.json: #// プロジェクトが使うパッケージの設定
            サンプル: |
                {
                    "name": "try_node",
                    "version": "1.0.0",
                    "description": "",
                    "main": "index.js",
                    "scripts": {
                        "test": "echo \"Error: no test specified\" && exit 1"
                    },
                    "keywords": [],
                    "author": "",
                    "license": "ISC",
                    "type": "module",
                    "dependencies": {
                        "immer": "^10.0.3"
                    }
                }
            #↓ フィールド
            overrides:
                サンプル: |  #// nightmare が要求する electron を、プロジェクトが要求する electron を参照するようにします
                        "overrides": {
                            "nightmare": {
                                "electron": "$electron"
                            }
                        },
                    #// npm install @plotex/render-image
                    #//     npm ERR! Error: GET https://github.com/electron/electron/releases/download/v2.0.18/electron-v2.0.18-darwin-arm64.zip returned 404
                    #//     npm ERR! /Users/____/GitProjects/GitHub/MyPrivateCode/Node_js/tradeBackTest/node_modules/nightmare/node_modules/electron/install.js:54
                    #//     npm ERR! Error: Failed to find Electron v2.0.18 for darwin-arm64 at https://github.com/electron/electron/releases/download/v2.0.18/electron-v2.0.18-darwin-arm64.zip
                    #ref: https://github.com/segment-boneyard/nightmare/issues/1636#issuecomment-1627501572
            scripts: #keyword: package.json scripts  #// よく使うコマンドを package.json に書いておくことができます
                ファイルの内容:
                    サンプル:
                        package.json : |
                            "scripts": {
                                "setup": "npm ci",
                                "test": "jest --watchAll",
                    書式: |
                        "scripts": {
                            "__Name__": "__CommandLine__"
                手順 >> 実行する:
                    npm run を使う場合:
                        npm run __Name__
                    npx を使う場合:
                        npx __CommandLine__
                    直接呼び出す場合:
                        ./node_modules/.bin/__Command__
            script:
                npm-scripts:  #keyword:
                    OSやシェルの違いを吸収します:  #search: run-script-os
        package-lock.json: #// 依存するパッケージも含めた全設定
    コマンド:  #glossary:
        npm init:  #// package.json ファイルを新規作成します
            デフォルトの設定で作ります:
                mkdir -p  __Project__
                cd  __Project__
                npm init -y
            対話しながら作ります:
                mkdir -p  __Project__
                cd  __Project__
                npm init
            チュートリアル:  #search: install WSL2 Node.js
        npm install:  #// パッケージを追加します
            パッケージをプロジェクトに追加します:
                リリース用:
                    npm install __PackageName__  @types/__PackageName__
                開発用: #// 開発用はリリースするときに含まれません
                    npm install --save-dev __PackageName__  @types/__PackageName__
                バージョン指定:
                    npm install __PackageName__@__Version__
        npm uninstall: #keyword: npm uninstall,  npm delete remove  #// パッケージを除外します
            npm uninstall __PackageName__  @types/__PackageName__
        npm ci:
            node_modules フォルダーを復活します:  #keyword: node_modules
                npm ci
                    #// __Project__/node_modules フォルダーが作られます
            yarn の場合: #search: yarn node_modules
        npm update:
            npm update  __PackageName__  @types/__PackageName__
        npm list:  #// パッケージとバージョンを一覧します
            サンプル:
                $ npm list
                try_sharp@1.0.0 C:\Users\____\Desktop\try_sharp
                └── sharp@0.30.1
        npm config:
            npm config:  #// エラーメッセージと主なコマンドを表示します
            npm config get:
                全部の設定を表示します: npm config get
                １つの設定を表示します: npm config get __Name__
            npm config set:
                ローカルの場合: npm config set __Name__ __Value__
                グローバルの場合: npm -g config set __Name__ __Value__
            npm config delete:
                ローカルの場合: npm config delete __Name__
                グローバルの場合: npm -g config delete __Name__
            設定値の置き場所:
                表示コマンド: npm config get
                ローカル設定: __Project__/.npmrc
                グローバル設定: /etc/npmrc, %APPDATA%\npm\etc\npmrc  #// -g オプションを付けたときの対象
                ユーザー別設定: ~/.npmrc
                ビルトイン設定: C:\Program Files\nodejs\node_modules\npm\.npmrc
                参考: #ref: https://stackoverflow.com/questions/15536872/nodejs-npm-global-config-missing-on-windows/22847156
        npm test:  #// テストを実行します
            手順:
                テストを実行します:
                    すべて: npm test
                    指定: npm test __?__  #// 何を指定するのか不明。main.test.ts なら main ということかも
                デバッガーを起動します:
                    通常モードの場合:
                        VSCode launch.json: |  #ref: ${GitHub}/typrm/.vscode/launch.json
                            {
                                "name": "Debug Posix Jest Tests",
                                "type": "node",
                                "request": "launch",
                                "runtimeArgs": [
                                    "--inspect-brk",
                                    "${workspaceRoot}/node_modules/.bin/jest",
                                    "main",
                                    "--runInBand",
                                    "--coverage", "false"],
                                "cwd": "${workspaceFolder}",
                                "console": "integratedTerminal",
                                "internalConsoleOptions": "neverOpen"
                            },
                            {
                                "name": "Debug Windows Jest Tests",
                                "type": "node",
                                "request": "launch",
                                "runtimeArgs": [
                                    "--inspect-brk",
                                    "${workspaceRoot}/node_modules/jest/bin/jest.js",
                                    "main",
                                    "--runInBand",
                                    "--coverage", "false"
                                ],
                                "cwd": "${workspaceFolder}",
                                "console": "integratedTerminal",
                                "internalConsoleOptions": "neverOpen"
                            }
                    ウォッチモードの場合:  #search: Jest watch mode
            概念:
                Jest のウォッチモード: #keword: Jest watch mode
                    手順:
                        起動:  #search: npm test Jest watch
                        再実行: f コマンド
                    コマンド:
                        f:  #// Press f to quit "only failed tests" mode.
npx:  #keyword:  #// コマンドをダウンロードして実行します  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#npx
    手順 >> 実行する:  #search: package.json scripts  >> npx を使う場合
    設定: #settings:
        __Proxy__: http://__Host__:__Port__
    プロキシ:  #keyword: npx proxy
        CentOS7 にイストールする場合:  #search: CentOS7 proxy React VSCode
        Windows にイストールする場合:  #// 未確認
            コマンド: |  #// 下記は失敗。CentOS7 を使ってください
                #Git bash
                npm -g config set proxy http://__Host__:__Port__             #template: __Proxy__
                npm -g config set https-proxy http://__Host__:__Port__       #template: __Proxy__
                npm -g config set registry http://registry.npmjs.org/
                npm -g config set strict-ssl=false
                npm install --global yarn
                yarn config set proxy http://__Host__:__Port__ -g            #template: __Proxy__
                yarn config set https-proxy http://__Host__:__Port__ -g      #template: __Proxy__
                npm -g install create-react-app
                yarn global add react react-dom react-scripts react-scripts-ts
nvm:  #keyword:  #// Node.js 本体のバージョン管理をします  #glossary:
    #// npm のバージョンも　Node.js のバージョン切り替えに応じて切り替えられます
    手順: #keyword: nvm steps
        nvm のインストール: #keyword: install NVM
            Windows:  #search: install NVM for Windows
            Linux:  #search: install NVM for Linux
            mac:  #search: install NVM for mac
        Node.js のバージョン: #keyword: Node.js version  #// nvm のバージョンではありません
            最新バージョン >> 公式: #keyword: Node.js latest version
                https://nodejs.org/en/download/package-manager  または  https://nodejs.org/en >> Download タブ
            インストール, ダウンロード:
                nvm のインストール:  #search: install NVM
                Node.js のインストール: #keyword: nvm install 
                    nvm install 20.18.1
                    nvm use 20.18.1
            インストール済みバージョン:
                表示:  #// インストールされている Node.js のうち、現在のプロセスが使う Node.js のバージョンを表示します。 nvm によって設定されていない Node.js の可能性もあります
                    -   node --version
                        #// v16.20.1
                    -   nvm alias default
                切り替え: #keyword: nvm change Node.js version
                    切り替えます:
                        今後の全プロセス: #keyword: nvm alias default
                            コマンド:
                                nvm alias default 20
                                #// 以下に続きます
                            VSCode デバッガーを使う場合:
                                VSCode を再起動します
                            VSCode デバッガーを使わない場合:  #// 既存または新しいターミナルを使う場合
                                （VSCode の再起動は不要です）
                            #// 以下へ続きます
                        現在のプロセスのみ:
                            引数指定: | #// 引数に指定するバージョン番号に切り替える場合
                                nvm use 16.20.1  #// または  nvm use v16.20.1
                                node --version
                            .nvmrc 指定:  #// .nvmrc に書かれたバージョン番号に切り替える場合  #search: .nvmrc
                                Linux:
                                    nvm use
                                    node --version
                                Windows:
                                    _v=$( cat .nvmrc )
                                    nvm use $_v
                                    node --version
                    バージョンを確認します:
                        node --version
                            #// v16.20.1
                指定実行: #keyword: nvm run Node.js version  #// Node.js のバージョンを指定して実行します
                    bash script: |
                        #!/bin/bash
                        NodeJsVersion="16.20.1"

                        function  WindowsMain() {
                            local  nodePath="${HOME}/AppData/Roaming/nvm/v${NodeJsVersion}"
                            PATH="${nodePath}:${PATH}"

                            echo  "Node $( node --version )"

                            echo  "$ npx playwright test"
                            npx playwright test
                        }

                        WindowsMain
                    スクリプトで使う場合:  #search: nvm script
                    サンプル:  #ref: ${GitHub}/MyPrivateCode/ansible_vagrant/single_vm_ansible/GoCD/service_example/playwright_example/test.sh
                    #// NVM for Windows では nvm exec を公式にサポートしないようです  #ref: https://github.com/coreybutler/nvm-windows/wiki/Per-Script-Shell-Versions
                一覧:  #// nvm が管理している Node.js のバージョンを一覧します
                    nvm ls  #search: nvm ls
            プロジェクトが使うバージョン:  #search: project Node.js version
    構成 >> 環境別:
        NVM for Windows:  #ref: https://github.com/coreybutler/nvm-windows
            インストール: #keyword: install NVM for Windows
                既に Node.js や npm がインストールされている場合:
                    それらをアンインストールします
                nvm-setup.zip をダウンロードして展開します:
                    https://github.com/coreybutler/nvm-windows/releases  >>  nvm-setup.zip
                nvm-setup.exe を起動します:
                    オプションはすべてデフォルト
                完了したら、nvm-setup フォルダーを削除します:
                nvm がインストールできたことを確認します:
                    PowerShell:
                        nvm version
                        nvm list available
                指定したバージョンの Node.js をインストールします:  #search: nvm install  #search: Node.js latest version
                    PowerShell:  #// 16.20.1 の場合
                        nvm install 16.20.1
        nvm for Linux:  #ref: https://github.com/nvm-sh/nvm/
            インストール: #keyword: install NVM for Linux,  install NVM for mac
                新規:
                    注意: nvm は Linux の全ユーザーで共有することができません  #ref: https://github.com/nvm-sh/nvm/issues/1533
                    インストールする nvm のバージョンを調べます:
                        #ref: https://github.com/nvm-sh/nvm/releases
                    インストール スクリプト が存在することを確認します:  #// v0.39.3 の場合
                        #ref: https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh
                    nvm をインストールします:
                        curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash
                    環境変数を設定します:
                        source ~/.bashrc
                    nvm がインストールできたことを確認します:
                        nvm --version
                        #// nvm の場所は #search: nvm alias
                    指定したバージョンの Node.js をインストールします:  #search: nvm install  #search: Node.js latest version
                        nvm install 16.20.1
                        node --version
                mac の VSCode のターミナル以外でも使えるようにする場合: #keyword: VSCode nvm,  VSCode nvm PATH
                    表示:
                        実際に動作しているバージョン:  #// デバッガーの場合とターミナルの場合で異なることがあります
                            console.log(process.version);   // Node.js のバージョン
                            console.log(process.versions);  // 詳細情報
                    設定:
                        VSCode ターミナル:
                            ~/.zshrc や ~/.bashrc や ~/.zshenv に NVM_DIR などが設定されている内容
                            シェルや OS によります
                        settings.json: |  #// ターミナル？
                            {
                            "terminal.integrated.env.osx": {
                                "PATH": "${env:HOME}/.nvm/versions/node/v20.19.1/bin:${env:PATH}"
                        タスク:  #// Terminal >> Run Task
                            ~/.zshenv に追加します: |  #search: ~/.zshenv  #// settings.json >> terminal.integrated.env.osx でもいいかもしれない
                                export NVM_DIR="$HOME/.nvm"
                                [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
                                [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
                        VSCode デバッガー:
                            #// 未確認
                            launch.json >> runtimeExecutable: |
                                {
                                "configurations": [
                                    {
                                    "type": "node",
                                    "runtimeExecutable": "${env:HOME}/.nvm/versions/node/default/bin/node"
                            node のシンボリックリンクを作ります: #keyword: nvm default symbolic link
                                ln -sf  ./v20.19.1  ${HOME}/.nvm/versions/node/default
                            #// ~/.zshenv や ~/.zshrc や ~/.bashrc の設定は読まれません。
                        （参考）:
                            mac の PATH:  #search: ~/.zshenv
                    node の場所:  #search: nvm path
                更新: #keyword: update nvm Node.js  #// マイナー バージョン を変更します。メジャー バージョン の変更は、アプリケーション（JavaScript）が対応していない可能性があるため注意
                    NewVersion="v16.20.2"
                    nvm install ${NewVersion}
                    nvm alias default ${NewVersion}
                    nvm use ${NewVersion}
                    nvm uninstall "v16.20.1"  #// If not necessary, uninstall old version
            場所: #keyword: nvm path  #// 実行ファイルの場所
                nvm: #keyword: nvm alias  #// nvm エイリアス  #search: Linux alias
                    nvm エイリアスを使えるようにする場合:
                        source $HOME/.nvm/nvm.sh
                Node.js:
                    ~/.nvm/versions/node/v16.20.1/bin/node
                    ~/.nvm/versions/node/v16.20.1/bin/npx
                    #// バージョンを指定して実行する場合: #search: nvm exec
                （参考）システムの Node.js:
                    /usr/local/bin/node
                VSCode の Node.js:  #search: VSCode nvm
            古い情報:
                nvm-sh:
                    nvm のインストール(GitHubから):
                        注意:
                            Git bashでは使えません
                            https://github.com/nvm-sh/nvm/issues/1643
                        参考:
                            - https://github.com/nvm-sh/nvm#git-install
                        以下は未確認:
                        nvm をダウンロード（git clone）します:
                            #Git Bash
                            - cd $HOME
                            - git clone https://github.com/nvm-sh/nvm.git .nvm
                            - cd .nvm
                            - git checkout v0.37.0
                        nvm をインストールします:
                            - . nvm.sh  #// Activate nvm
                        環境変数を設定します:
                            ~/.bashrc: |
                                export NVM_DIR="$HOME/.nvm"
                                [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
                                [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
                    nvm のアンインストール:
                        nvm のフォルダーを削除します:
                            #Git Bash
                            - cd $HOME
                            - rm -rf .nvm
                        環境変数を設定します:
        nvm for mac:  #search: nvm for Linux
    コマンド:
        nvm exec:  #keyword: nvm exec  #// Node.js のバージョンを指定して実行します
            サンプル: |
                    source ~/.bashrc
                    nvm exec v16.20.1  npx playwright test
                #// nvm exec を実行した後の node や npm は元のバージョンで実行します
            スクリプトで使う場合: | #keyword: nvm script  #// Windows と Linux で共通のファイルにする場合
                NodeJsVersion="16.20.1"  #// "16" や "16.20" も指定できます
                if [ "${WINDIR}" == "" ]; then  #// Linux
                    source $HOME/.nvm/nvm.sh  #// set up nvm alias
                    NvmExec="nvm exec --silent v${NodeJsVersion}  "    #// --silent を付けないとバージョン番号が表示されます
                else  #// Windows
                    NodeJSPath="${HOME}/AppData/Roaming/nvm/v${NodeJsVersion}"
                    PATH="${NodeJSPath}:${PATH}"
                    NvmExec=""  #// NVM for Windows does not support nvm exec command
                fi

                echo  "$ PATH=${NodeJSPath}:\${PATH}"
                echo  "$ ${NvmExec}npm ci"

                ${NvmExec}npm ci  #// インストールされていないときは、適切な エラー メッセージが表示されます（下記）
            バージョンがインストールされていないときの エラー メッセージ: |  #// JavaScript は実行されません
                N/A: version "v16.19" is not yet installed.

                You need to run `nvm install v16.19` to install and use it.
        nvm ls:  #keyword:  #// インストール済みの Node.js を一覧します
            サンプル出力: |
                ->     v16.20.1                    ... 意味は、現在使用中の Node.js バージョンが v16.20.1
                        system
                default -> 16.20.1 (-> v16.20.1)
                iojs -> N/A (default)
                unstable -> N/A (default)
                node -> stable (-> v16.20.1) (default)
                stable -> 16.20 (-> v16.20.1) (default)
                lts/* -> lts/iron (-> N/A)         ... 意味は、LTS（Long Term Support）バージョンの最新版がインストールされていません
                lts/argon -> v4.9.1 (-> N/A)
                lts/boron -> v6.17.1 (-> N/A)
                lts/carbon -> v8.17.0 (-> N/A)
                lts/dubnium -> v10.24.1 (-> N/A)
                lts/erbium -> v12.22.12 (-> N/A)
                lts/fermium -> v14.21.3 (-> N/A)
                lts/gallium -> v16.20.2 (-> N/A)   ... 意味は、lts/gallium（コードネーム）は v16 系ですが最新版がインストールされていません
                lts/hydrogen -> v18.19.0 (-> N/A)
                lts/iron -> v20.10.0 (-> N/A)
        nvm use:  #keyword: nvm use  #// Node.js のバージョンを切り替えます
            手順 >> 切り替えます:  #search: nvm change Node.js version
            サンプル:
                #ref: ${GitHub}/MyPrivateCode/ansible_vagrant/single_vm_ansible/GoCD/service_example/playwright_example/test.sh
    ファイル:  #glossary: nvm
        .nvmrc:
            サンプル: |
                18.17.0
            他のサンプル:  #// 以下の 1行ずつは、それぞれ別の .nvmrc ファイルのサンプルです
                メジャーバージョンのみ: 18
                メジャー.マイナーバージョン: 18.17
                最新の LTS バージョン: lts/*
                最新の安定版: node
            アクティベーション:  #// .nvmrc に書かれたバージョンの Node.js を使うようにします  #search: nvm use
                nvm use
yarn:  #keyword:
    概要:
        - npm の代わり。 設定ファイルは package.json。 ロック ファイル は yarn.lock
        - yarn が速く npm が遅いのは昔の話です。VSCode は npm へ完全移行しました  #ref: https://code.visualstudio.com/updates/v1_94#_use-npm-as-default-package-manager
    yarn をインストールします:
        Node.js をインストールします: #search: install Node.js
        yarn をインストールします:
            CentOS7:  #search: install yarn CentOS7
        Node パッケージをインストールします:  #// プロジェクトに追加・削除などします
            インストール:  #keyword: yarn add
                出荷物に含める場合: yarn add  __PachageName__
                開発時だけ含める場合: yarn add --dev  __PachageName__
            アンインストール:  #keyword: yarn remove,  yarn delete
                yarn remove  __PachageName__
    node_modules を復帰します:  #keyword: yarn node_modules,  yarn install
        #// 以下のいずれかで、__Project__/node_modules フォルダーが作られます
        - yarn install --frozen-lockfile  #// yarn.lock に書かれたバージョンを使う場合
        - yarn install  #// 更新も行う場合
    Node パッケージを最新に更新します:
        基本: yarn upgrade-interactive --latest  #// package.json, yarn.lock も更新されます
            #ref: https://classic.yarnpkg.com/en/docs/cli/upgrade-interactive
            #// または yarn upgrade --latest  #// 未確認  #// package.json, yarn.lock も更新されます
        package.json は更新しない場合: yarn upgrade  #// 未確認
        指定したパッケージだけ更新します: yarn upgrade __PackageName__  #// 非推奨  #search: version upgrade debug
        指定したパッケージだけ指定したバージョンに変更します: yarn upgrade __PackageName__@__Version__  #// 非推奨  #search: version upgrade debug
        参考:
            構成のバージョンアップ:  #search: version upgrade debug
    プロキシ:
        参照:
            yarn config get proxy
            yarn config get https-proxy
            yarn config list
        設定:
            全シェル:
                yarn config set proxy http://example.com:port -g
                yarn config set https-proxy http://example.com:port -g
                yarn config set proxy http://username:password@host:port -g
                yarn config delete __Name___
            PowerShell:
                $env:NO_PROXY = "192.168.56.102"
        参考: #ref: https://one-sthead.hatenablog.com/entry/2019/07/02/122304
    yarn コマンド:
        yarn install: #ref: https://classic.yarnpkg.com/en/docs/cli/install
bower:  #keyword:
    公式: #ref: https://github.com/bower/bower
    インストール:
        Git bash など:
            npm install -g bower
    サンプル: #focus: bower
        mkdir -p __Project__
        cd  __Project__
        bower install json-human --save
tsc:  #keyword:  #ref: https://www.typescriptlang.org/docs/handbook/compiler-options.html
    --watch:  #keyword: tsc --watch  #// フォルダーを監視して、ファイルの変更があったら即座にトランスパイルします
        コマンド例:
            node_modules/typescript/bin/tsc --watch
        tsc-watch: #keyword:  #// tsc --watch を実行し、トランスパイルが実行された後に実行するコマンドも指定できます。
            インストール:
                npm install --save-dev tsc-watch
            tasks.json の修正例:  #ref: __Project__/.vscode/tasks.json
                修正前: |  #focus: --watch
                    "command": "node_modules/.bin/tsc  -p tsconfig.json  --watch",
                修正後: |  #focus: tsc-watch
                    "command": "node_modules/.bin/tsc-watch  -p tsconfig.json  --onSuccess \"node src/support_node.cjs\"",
    build, 出力先: #keyword: TypeScript outDir
        相対パスが一致するように .js ファイルが作られない:
            （同下）
        src 以外の .ts もトランスパイルの対象になってしまう:
            ファイル構成:  #focus: example
                現象:
                    build/hello.js
                    src/example/hello.ts
                期待:
                    build/example/hello.js
                    src/example/hello.ts
            対処:
                - .ts ファイルの最もルートに近いファイルが、出力先のルートに対応します
                - 対象は tsconfig.json ファイルがあるフォルダーの中のすべてになりますが、
                    tsconfig.json の 
                - .最もルートに近いファイルが変わったら、出力先フォルダーを削除して作り直してください
            （ボツ）: #// 以下を行っても効果ありません
                cd  src
                ../node_modules/typescript/bin/tsc --watch  --outDir ../build
#↓...
DOM: #keyword:  #// HTML Document Object Model
    HTML の DOM: #glossary:
        getElementById: #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#getElementById_document
            const  result = document.getElementById('result');
        innerHTML:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#innerHTML
            document.getElementById("result").innerHTML = "<A href=\"http://www.example.com/\">web</A>";
        outerHTML:
            outerHTML への代入:  #// 置き換えます
                ソース: |  #focus: replaced
                    <html><body>
                        <p id="myP">I am a paragraph.</p>

                        <script>
                            document.getElementById("myP").outerHTML = "<h1>This H1 replaced a paragraph.</h1>"
                        </script>
                    </body></html>
                実行後: |
                    <html><body>
                        <h1>This H1 replaced a paragraph.</h1>

                        <script>
                            document.getElementById("myP").outerHTML = "<h1>This H1 replaced a paragraph.</h1>"
                        </script>
                    </body></html>
    XML の DOM: #ref: ${programming}/HTML ブラウザ/XML.svg#dom_ref
    仮想 DOM: #keyword: 仮想 DOM,  仮想 HTML ではない
        _: コードで書く HTML とブラウザーが解析する HTML は異なります。ビルド時に変換します
jQuery:  #keyword:
    記号:
        (#): セレクターに指定する id 属性
        (.): セレクターに指定する class 属性
        (@): 古い仕様。属性の前に @ を書いていましたが、jQuery 1.3 以降は不要です  #ref: http://semooh.jp/jquery/cont/doc/release_1.3/
        ([]): セレクターに指定する その他の属性
    本家: #ref: https://jquery.com/
        API: #ref: https://api.jqueryui.com/
        Learning Center: #ref: https://learn.jquery.com/
            jQuery のしくみ: #ref: https://learn.jquery.com/about-jquery/how-jquery-works/
    セレクター:  #keyword: jQuery selector
        基本: |  #focus: $, aTag
            var  aTag = $('a')  #// $ がセレクターです。セレクターの返り値は HTML 要素などを操作するためのオブジェクトです
            aTag[0].text()
        id 属性: $(#__ID__'), $('#test1')  #// <a id="test1">____</a>
        class 属性: $(.__ClassName__'), $('.class1')  #// 非推奨  #// <a class="class1">____</a>
        その他の属性: $('__TagName__[__AttributeName__="__Value__"]'), $('a[name="name1"]')  #// <a name="name1">____</a>
        タグ名: $('a')  #// <a>____</a>
        親要素から指定: $('div > span')  #// <div><span>____</span></div> の <span>
        OR: $('#text1,#text2')  #// コンマ
        NOT: $('@:not(#text2)')  #// @:not(____)
        参考:
            #ref: https://api.jquery.com/category/selectors/
            #ref: https://learn.jquery.com/using-jquery-core/selecting-elements/
            #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#JQuery_selector
Next.js: #keyword: Next.js,  Vercel Next.js HTML React framework
    公式:
        Getting Started: #ref: https://nextjs.org/docs/getting-started
        GitHub issue: #ref: https://github.com/vercel/next.js/issues
        Document: #ref: https://nextjs.org/docs
        Learn: #ref: https://nextjs.org/learn
        Examples:
            #ref: https://github.com/vercel/next.js/tree/master/examples
            #search: vercel/next-learn
        料金: #keyword: Vercel 料金,  Next.js Vercel 料金
            比較表: |
                . | Hobby プラン | Pro プラン | Enterprise プラン
                対象者 | 個人的かつ非営利 |
            #ref: https://vercel.com/blog/simpler-pricing
            #ref: https://zenn.dev/lollipop_onl/articles/eoz-vercel-pricing-2020
        Vercel:  #// Next.js の開発会社。旧 Zeit
    概要:
        高速:
            SSG(getStaticProps, 推奨), SSR(getServerSideProps), SPA(next export):
            client side navigation, プリフェッチ: #ref: https://nextjs.org/learn/basics/navigate-between-pages/client-side
            プリレンダリング: #ref: https://nextjs.org/learn/basics/data-fetching/pre-rendering
                #snip: パフォーマンスとSEOを向上させることができます。プレーン React.js にはない
                #search: Next.js prerendering
            hydration: #keyword: Next.js hydration  #ref: https://nextjs.org/learn/basics/data-fetching/pre-rendering
                初期ロードで静的 HTML をプリレンダリングして表示してから hydration でインタラクティブになります。
        ファイル ベース ルーティング:
        参考: #ref: https://qiita.com/Yuki_Oshima/items/5c0dfd8f7af8fb76af8f
    手順:
        公式:
            プロジェクト生成: #ref: https://nextjs.org/learn/basics/create-nextjs-app
            ナビゲーション:
                create-next-app: #// プロジェクト生成  #ref: https://nextjs.org/learn/basics/navigate-between-pages/setup
                pages フォルダー: #// URL とページの対応関係  #ref: https://nextjs.org/learn/basics/navigate-between-pages/pages-in-nextjs
                <Link>: #// ハイパーリンク  #ref: https://nextjs.org/learn/basics/navigate-between-pages/link-component
                高速化: #// Client-Side Navigation  #ref: https://nextjs.org/learn/basics/navigate-between-pages/client-side
                    Context: Client-Side Navigation したとき、React の Context は保持されています
                    サンプル: #// <Link> で <a> を囲みます
                        import Link from 'next/link'

                        <Link href="/">
                            <a className="foo" target="_blank" rel="noopener noreferrer">
                                Hello World
                            </a>
                        </Link>
            画像、メタデータ、外部スクリプト、CSS: #ref: https://nextjs.org/learn/basics/assets-metadata-css
                <Image>: #ref: https://nextjs.org/learn/basics/assets-metadata-css/assets
                    Web Vitals: #search:  #// Web のパフォーマンス指標の1つ。読み込み速度など
                <Head>: #ref: https://nextjs.org/learn/basics/assets-metadata-css/metadata
                <Script>: #ref: https://nextjs.org/learn/basics/assets-metadata-css/third-party-javascript
                CSS: #ref: https://nextjs.org/learn/basics/assets-metadata-css/css-styling
                レイアウト コンポーネント: #ref: https://nextjs.org/learn/basics/assets-metadata-css/layout-component
                グローバル CSS: #ref: https://nextjs.org/learn/basics/assets-metadata-css/global-styles
                Polishing Layout: #ref: https://nextjs.org/learn/basics/assets-metadata-css/polishing-layout
                スタイリングのヒント: #ref: https://nextjs.org/learn/basics/assets-metadata-css/styling-tips
            プリレンダリング: #keyword: Next.js prerendering  #ref: https://nextjs.org/learn/basics/data-fetching
                Pre-rendering: #ref: https://nextjs.org/learn/basics/data-fetching/pre-rendering
                    パフォーマンスとSEOを向上させることができます。プレーン React.js にはない
                2種類のプリレンダリング: #ref: https://nextjs.org/learn/basics/data-fetching/two-forms
                    #// ページごとに選択できます
                    静的生成: ビルド時に生成
                    サーバーサイドレンダリング: oneachリクエスト。開発時（npm run dev）はこちら
                getStaticProps:  #ref: https://nextjs.org/learn/basics/data-fetching/with-data
                ビルド時に実行する getStaticProps:  #ref: https://nextjs.org/learn/basics/data-fetching/getstaticprops-details
                リクエスト時に実行する getServerSideProps:  #ref: https://nextjs.org/learn/basics/data-fetching/request-time
                SWR:  #ref: https://nextjs.org/learn/basics/data-fetching/request-time
        TypeScript のプロジェクト: #keyword: new Next.js TypeScript
            新規作成済みプロジェクト: #keyword: next_js_minimum
                #ref: ${GitHub}/MyPrivateCode/Next_js/next_js_minimum
                編集箇所:
                    main タグの中
                    #ref: ${GitHub}/MyPrivateCode/Next_js/next_js_minimum/pages/index.tsx#<main
                編集したプロジェクトのサンプル:
                    #search: next_js_sass
            新規作成:
                cd __ParentOfProject__
                npx create-next-app@latest --ts __ProjectName__
                cd __ProjectName__
                npm run dev
                http://localhost:3000
                #ref: https://nextjs.org/docs/api-reference/create-next-app
            その他サンプル:
                プロジェクト:
                    独自サンプル:  #glossary:
                        next_js_minimum:  #search: next_js_minimum
                        rows_text:  #// テキスト表示  #ref: ${GitHub}/MyPrivateCode/Next_js/rows_text/_base.yaml
                            public のテキストを表示:  #search: Next.js public
                        keyword_pop_up:  #//　キーワード入力ボックスのポップアップ  #ref: ${GitHub}/MyPrivateCode/Next_js/keyword_pop_up/_base.yaml
                        next_js_zip_file_reader: #keyword:  #ref: ${GitHub}/MyPrivateCode/Next_js/next_js_zip_file_reader
                    公式:  #glossary:
                        typescript-final:
                            local: #ref: ${GitClone}/GitHub/vercel/next-learn/basics/typescript-final
                            internet: #ref: https://github.com/vercel/next-learn/tree/master/basics/typescript-final
                        vercel/next-learn:
                            #ref: ${GitClone}/GitHub/vercel/next-learn
                            #ref: https://github.com/vercel/next-learn
                プロジェクトから起動します:
                    npm install
                    npm run dev
                    http://localhost:3000
            #ref: https://nextjs.org/learn/excel/typescript
        チュートリアル: #keyword: install Next.js
            Next.js アプリを新規作成します: #ref: https://nextjs.org/learn/basics/create-nextjs-app/setup
                #// 新規作成済みプロジェクト: #search: next_js_minimum
                - cd ~/Desktop
                - npx create-next-app nextjs-blog --use-npm --example "https://github.com/vercel/next-learn/tree/master/basics/learn-starter"
                - cd nextjs-blog  #// __Project__
                - npm run dev
                - http://localhost:3000  #// Welcome to Next.js! と表示されます
                    #// npm run dev を実行したターミナルで Ctrl+C を押します
            ページを編集します: #keyword: Next.js pages  #// __Project__/pages
                HTML が書かれたファイルを開きます:
                    - code  __Project__  #// Visual Studio Code を開きます
                    - code  __Project__/pages/index.js
                編集します:
                    変更前: Welcome to
                    変更後: Learn
                ブラウザーに表示されていたページが自動的に更新されます:
                    Fast Refresh: #ref: https://nextjs.org/docs/basic-features/fast-refresh
            <Link>, ハイパーリンクを作ります: #keyword: Next.js <Link>  #ref: https://nextjs.org/learn/basics/navigate-between-pages/link-component
                機能: ページ間の遷移がクライアントサイドで行われます
                書式: <Link href="____"><a>____</a></Link>
                pages/index.js :
                    編集前:  |
                        <h1 className="title">
                            Learn <a href="https://nextjs.org">Next.js!</a>
                        </h1>
                    編集後: |  #focus: Link
                        import Link from 'next/link'
                            ...
                        <h1 className="title">
                            Read{' '}
                            <Link href="/posts/first-post">
                                <a>this page!</a>
                            </Link>
                        </h1>
                ボタンの場合: #search: Next.js <button>
            <Image>, 画像: #keyword: Next.js <Image>, Next.js public image  #ref: https://nextjs.org/docs/api-reference/next/image
                機能 >> 自動画像最適化:
                    WebPなどの最新の形式で画像のサイズ変更、最適化、および提供が可能になります
                    デフォルトで遅延ロードされています。
                    #ref: https://nextjs.org/docs/basic-features/image-optimization
                サンプル: |
                    import Image from 'next/image'
                        ...
                    <Image
                        src="/images/profile.jpg"                  // __Project__/public/images/profile.jpg
                        height={144} width={144} alt="Your Name"
                    />
            <Head>, ページのメタ属性. タイトルなど: #keyword: Next.js <Head> <title>  #ref: https://nextjs.org/learn/basics/assets-metadata-css/metadata
                __Public__/pages/posts/first-post.js : |  #focus: Head
                    import Head from 'next/head'

                    export default function FirstPost() {
                        return <>
                            <Head>
                                <title>First Post</title>
                            </Head>
                            <h1>First Post</h1>
                        </>
                    }
                #ref: https://nextjs.org/docs/api-reference/next/head
            <Script>: #keyword: Next.js <Script>  #ref: https://nextjs.org/learn/basics/assets-metadata-css/third-party-javascript
                __Public__/pages/posts/first-post.js : |  #focus: Script
                    import Script from 'next/script'
                        ...
                    <Head>
                        <title>First Post</title>
                    </Head>
                    <Script
                        src="https://connect.facebook.net/en_US/sdk.js"
                        strategy="lazyOnload"
                        onLoad={() =>
                            console.log(`script loaded correctly, window.FB has been populated`)
                        }
                    />
            public フォルダー: #ref: __Project__/public/  #// URL から直接参照できるファイル
                #search: Next.js public
            CSS: #keyword: Next.js CSS tutorial
                <style jsx>: #keyword: Next.js style jsx  #ref: https://nextjs.org/learn/basics/assets-metadata-css/css-styling
                    __Project__/pages/index.js : |  #focus: style
                        <Head>
                            ...
                        </Head>

                        <style jsx>{`
                            .container {
                                min-height: 100vh;
                                padding: 0 0.5rem;
                            }
                        `}</style>
                    CSS: #ref: https://nextjs.org/docs/basic-features/built-in-css-support
                    styled-jsx: #keyword: styled-jsx, CSS-in-JS  #ref: https://github.com/vercel/styled-jsx
                        概要: CSS-in-JS の1種。Next.js は styled-components や emotion も選べます。
                            CSSスタイルはスコープ付けされます。
                        関連:
                            styled-components: #ref: https://github.com/vercel/next.js/tree/canary/examples/with-styled-components
                            emotion: #ref: https://github.com/vercel/next.js/tree/canary/examples/with-emotion
                    .css, .scssファイル: #// インポートできます
                        関連:
                            Tailwind CSS: #ref: https://github.com/vercel/next.js/tree/canary/examples/with-tailwindcss
                import styles from, ローカル CSS ファイルのインポート: #keyword: Next.js import styles from  #ref: https://nextjs.org/learn/basics/assets-metadata-css/layout-component
                    #// 下記は div 要素に相当する Layout コンポーネントに CSS を設定しています
                    __Project__/components/layout.js : |  #focus: container, styles, Layout
                        import styles from './layout.module.css'

                        export default function  Layout({ children }) {
                            return <div className={styles.container}>{children}</div>
                        }
                    __Project__/components/layout.module.css : |  #// ファイル名の末尾は .module.css であること
                        .container {
                            max-width: 36rem;
                            padding: 0 1rem;
                            margin: 30rem auto 6rem;
                        }
                    __Project__/pages/posts/first-post.js : |  #focus: Layout
                        import Layout from '../../components/layout'

                        export default function FirstPost() {
                            return (
                                <Layout>
                                    <Head>
                                        ...
                                </Layout>
                            )
                        }
                    作られるスコープ付きの CSS のクラス名:
                        <div class="layout_container__fbLkO">  #// layout は CSS ファイル名の一部, fbLkO は CSS ファイルごとに一意のハッシュ
                App コンポーネント, グローバル CSS:  #keyword: Next.js App global.css  #ref: https://nextjs.org/learn/basics/assets-metadata-css/global-styles
                    __Project__/pages/_app.js : |  #// パスは固定
                        import '../styles/global.css'

                        export default function App({ Component, pageProps }) {  // App is common component in all pages.
                            return <Component {...pageProps} />
                        }
                    __Project__/styles/global.css : |
                        html,
                        body {
                            padding: 0;
                            margin: 0;
                            font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu,
                                Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
                            line-height: 1.6;
                            font-size: 18px;
                            color: green;
                        }

                        * {
                            box-sizing: border-box;
                        }

                        a {
                            color: #0070f3;
                            text-decoration: none;
                        }

                        a:hover {
                            text-decoration: underline;
                        }

                        img {
                            max-width: 100%;
                            display: block;
                        }
                    上記 App を追加したとき:
                        エラーになります:
                            ブラウザー内:
                                About to perform a full refresh
                        サーバーの再起動でエラーは解消されます:
                            Ctrl + C >> npm run dev
                .scss, .sass:  #ref: https://nextjs.org/learn/basics/assets-metadata-css/styling-tips
                    コマンド: npm install sass --save-dev
                    プロジェクト: #keyword: next_js_sass
                        #ref: ${GitHub}/MyPrivateCode/Next_js/next_js_sass
                classnames:  #keyword: JedWatson classnames  #// プロパティの値に応じて CSS のクラスを切り替えます
                    __Project__/pages/____.jsx : |  #focus: success, cn
                        import styles from './alert.module.css'
                        import cn from 'classnames'

                        <div
                            className={cn({
                                [styles.success]: type === 'success',
                                [styles.error]: type === 'error'
                            })}
                        >
                    __Project__/pages/alert.module.css : |
                        .success {
                            color: green;
                        }
                        .error {
                            color: red;
                        }
                    #ref: https://nextjs.org/learn/basics/assets-metadata-css/styling-tips
                PostCSSの設定:  #ref: https://nextjs.org/learn/basics/assets-metadata-css/styling-tips
                    __Project__/postcss.config.js: |
                        module.exports = {
                            plugins: {
                                tailwindcss: {},
                                autoprefixer: {}
                            }
                        }
            bootstrap: #keyword: Next.js bootstrap
                react-bootstrap:
                    #search: Next.js react-bootstrap
                    #ref: ${GitHub}/MyPrivateCode/Next_js/next_js_bootstrap
                    #ref: https://react-bootstrap.github.io/getting-started/introduction
                with-react-bootstrap:
                    #ref: ${GitClone}/GitHub/vercel/next.js/examples/with-react-bootstrap
                    #ref: https://github.com/vercel/next.js/tree/canary/examples/with-react-bootstrap
            Pre-rendering: #keyword: Next.js pre-rendering tutorial  #ref: https://nextjs.org/learn/basics/data-fetching/pre-rendering
                getStaticProps: #keyword: Next.js getStaticProps  #ref: https://nextjs.org/learn/basics/data-fetching/with-data
                    概要:
                        データの流れ: getStaticProps の返り値が Home コンポーネントの引数に渡ります。
                        実行環境: サーバー。ビルド時？  #// Node.js でできる DB クエリーなどができます  #ref: https://nextjs.org/learn/basics/data-fetching/getstaticprops-details
                        定義場所: __Project__/pages 内
                    プロジェクト: #ref: ${GitHub}/Trials/try_Next_js_pre_rendering
                        npm ci
                        npm run dev
                        http://localhost:3000
                    手順:
                        gray-matter をインストールします:
                            npm install gray-matter
                        __Project__/pages/index.js: |  #focus: getStaticProps, allPostsData, getSortedPostsData
                            import { getSortedPostsData } from '../lib/posts'

                            // This return value will be passed to Home component
                            export async function  getStaticProps() {
                                return {
                                    props: {
                                        allPostsData: getSortedPostsData()
                                    }
                                }
                            }

                            export default function  Home({ allPostsData }) {
                                return (
                                    <Layout home>
                                        <Head>

                                            ...

                                        </Head>
                                        <section className={utilStyles.headingMd}>

                                            ...

                                        </section>
                                        <section className={`${utilStyles.headingMd} ${utilStyles.padding1px}`}>
                                            <h2 className={utilStyles.headingLg}>Blog</h2>
                                            <ul className={utilStyles.list}>
                                                {allPostsData.map(({ id, date, title }) => (
                                                    <li className={utilStyles.listItem} key={id}>
                                                        {title}
                                                        <br />
                                                        {id}
                                                        <br />
                                                        {date}
                                                    </li>
                                                ))}
                                            </ul>
                                        </section>
                                    </Layout>
                                )
                            }
                        __Project__/lib/posts.js : |  #focus: getSortedPostsData, allPostsData, matter
                            import fs from 'fs'
                            import path from 'path'
                            import matter from 'gray-matter'

                            const postsDirectory = path.join(process.cwd(), 'posts')

                            export function  getSortedPostsData() {
                                const  fileNames = fs.readdirSync(postsDirectory)

                                const  allPostsData = fileNames.map(fileName => {
                                    const id = fileName.replace(/\.md$/, '')
                                    const fullPath = path.join(postsDirectory, fileName)
                                    const fileContents = fs.readFileSync(fullPath, 'utf8')

                                    // Use gray-matter to parse the post metadata section
                                    const matterResult = matter(fileContents)

                                    // Combine the data with the id
                                    return {
                                        id,
                                        ...matterResult.data
                                    }
                                })

                                return  allPostsData.sort(({ date: a }, { date: b }) => {
                                    if (a < b) {
                                        return 1
                                    } else if (a > b) {
                                        return -1
                                    } else {
                                        return 0
                                    }
                                })
                            }
                        __Project__/posts/pre-rendering.md : |
                            ---
                            title: 'Two Forms of Pre-rendering'
                            date: '2020-01-01'
                            ---

                            Next.js has two forms of pre-rendering: **Static Generation** and **Server-side Rendering**. The difference is in **when** it generates the HTML for a page.

                            - **Static Generation** is the pre-rendering method that generates the HTML at **build time**. The pre-rendered HTML is then _reused_ on each request.
                            - **Server-side Rendering** is the pre-rendering method that generates the HTML on **each request**.

                            Importantly, Next.js lets you **choose** which pre-rendering form to use for each page. You can create a "hybrid" Next.js app by using Static Generation for most pages and using Server-side Rendering for others.
                        __Project__/posts/ssg-ssr.md : |
                            ---
                            title: 'When to Use Static Generation v.s. Server-side Rendering'
                            date: '2020-01-02'
                            ---

                            We recommend using **Static Generation** (with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request.

                            You can use Static Generation for many types of pages, including:

                            - Marketing pages
                            - Blog posts
                            - E-commerce product listings
                            - Help and documentation

                            You should ask yourself: "Can I pre-render this page **ahead** of a user's request?" If the answer is yes, then you should choose Static Generation.

                            On the other hand, Static Generation is **not** a good idea if you cannot pre-render a page ahead of a user's request. Maybe your page shows frequently updated data, and the page content changes on every request.

                            In that case, you can use **Server-Side Rendering**. It will be slower, but the pre-rendered page will always be up-to-date. Or you can skip pre-rendering and use client-side JavaScript to populate data.
            URL: #keyword: Next.js URL tutorial
                参考 >> 基本: #search: Next.js file system routing
                dynamic URL static page: #keyword: Next.js dynamic URL static page  #ref: https://nextjs.org/learn/basics/dynamic-routes/page-path-external-data
                    概要:
                        URL の中にある ID の部分を展開したページをビルド時に作ります
                    基本:
                        ファイルの置き場所: __Project__/pages/__Type__/[id].js  #// [id] はそのままファイル名にします。[id] の部分はビルド時に展開されます
                        getStaticPaths: id のリストを返すコールバック関数。
                        getStaticProps: id に対応したコンテンツを返すコールバック関数。定義したファイルの default function に渡されます。
                        サンプル:
                            pages/posts/[id].js : |  #focus: getStaticPaths, params, getStaticProps, postData
                                import Layout from '../../components/layout'
                                import { getAllPostIds, getPostData } from '../../lib/posts'

                                export async function  getStaticPaths() {
                                    return {
                                        paths: getAllPostIds(),
                                            // [ { params: { id: 'pre-rendering' } }, { params: { id: 'ssg-ssr' } } ]
                                        fallback: false
                                    }
                                }

                                export async function  getStaticProps({ params }) {
                                        // 1st call: { id: 'ssg-ssr' }
                                        // 2nd call: { id: 'pre-rendering' }
                                    return {
                                        props: {
                                            postData: getPostData(params.id)
                                        }
                                    }
                                }

                                export default function  Post({ postData }) {
                                    return (
                                        <Layout>
                                            {postData.title}
                                            <br />
                                            {postData.id}
                                            <br />
                                            {postData.date}
                                        </Layout>
                                    )
                                }
                            lib/posts.js : |
                                export function  getAllPostIds() {
                                    const fileNames = fs.readdirSync(postsDirectory)

                                    return fileNames.map(fileName => {
                                        return {
                                            params: {
                                                id: fileName.replace(/\.md$/, '')
                                                    // e.g. 'ssg-ssr', 'pre-rendering'
                                            }
                                        }
                                    })
                                }

                                export function  getPostData(id) {
                                    const fullPath = path.join(postsDirectory, `${id}.md`)
                                    const fileContents = fs.readFileSync(fullPath, 'utf8')

                                    const matterResult = matter(fileContents)

                                    return {
                                        id,
                                        ...matterResult.data
                                    }
                                }
                            開く:
                                #ref: http://localhost:3000/posts/ssg-ssr
                                #ref: http://localhost:3000/posts/pre-rendering
                    キャッチ オール ルート: #// [...id]
                        ファイルの置き場所: __Project__/pages/__Type__/[...id].js
                        概要: "[...id] の部分は / も含みます。a だけでなく、a/b、a/b/cなどにも一致します。"
                        getStaticPaths 関数のサンプル: |
                            export async function  getStaticPaths() {
                                return {
                                    paths: getAllPostIds(),
                                        // [
                                        //    { params: { id: ['a', 'b', 'c'] } },  // /__Type__/a/b/c
                                        //    { params: { id: ['a', 'b', 'x'] } },  // /__Type__/a/b/x
                                        // ]
                                    fallback: false
                                }
                            }
                Dynamic Routes: #keyword: Next.js dynamic routes  #ref: https://nextjs.org/docs/routing/dynamic-routes
                    概要: http://__Domain__/__Name__?foo=bar の __Name__, foo, bar を辞書変数で受け取ります
                    pages/__Name__.js :  #focus: useRouter, router  #keyword: Next.js useRouter query
                        URL => query object: |
                            http://__Domain__/__Name__?foo=bar => { "foo": "bar" }
                        コード: |
                            import { useRouter } from 'next/router'

                            const Post = () => {
                                const router = useRouter();

                                return <p>__Name__.tsx: {Object.entries(router.query).toString()}</p>
                            }

                            export default Post
                    pages/[__Name__].js :  #// __Name__ と一致しない場合
                        URL => query object: |
                            http://__Domain__/abc => { "__Name__": "abc" }
                            http://__Domain__/abc?foo=bar => { "__Name__": "abc", "foo": "bar" }
                        コード: |
                            import { useRouter } from 'next/router'

                            const Post = () => {
                                const router = useRouter();

                                return <p>[__Name__].tsx: {Object.entries(router.query).toString()}</p>
                            }

                            export default Post
                API routes: #keyword: Next.js API routes  #ref: https://nextjs.org/learn/basics/api-routes
                    pages/api/hello.js : |
                        // http://localhost:3000/api/hello
                        export default function  handler(req, res) {
                            res.status(200).json({ text: 'Hello' });
                        }
                    pages/api/post/[id].js : |
                        export default function  handler(req, res) {
                            const { id } = req.query;  // id はファイル名に含まれる [ ] の中と同じ名前にします
                            res.end(`Post: ${id}`);
                        }
                404ページ:  #// Not found page  #ref: https://nextjs.org/learn/basics/dynamic-routes/dynamic-routes-details
                    __Project__/pages/404.js : |
                        export default function Custom404() {
                            return <h1>404 - Page Not Found</h1>
                        }
                ルーター: #// Next.js ルーター
                    useRouter フック  #ref: https://nextjs.org/learn/basics/dynamic-routes/dynamic-routes-details
            remark: #search: remark  #// Markdown を HTML に変換します
            date-fns: #search:  #// 日付の表示形式
        その他の サンプル ページ: #ref: https://nextjs.org/learn/basics/dynamic-routes/dynamic-routes-details >> More Examples
        デバッガーと接続します:  #keyword: Next.js debugger
            参考: #ref: https://nextjs.org/docs/advanced-features/debugging
            Visual Studio Code の場合:
                __Project__/.vscode/launch.json ファイルを以下の内容で作ります: |
                    {
                        "version": "0.2.0",
                        "configurations": [
                            {
                                "name": "Next.js: debug server-side",
                                "type": "node-terminal",
                                "request": "launch",
                                "command": "npm run dev"
                            },
                            {
                                "name": "Next.js: debug client-side",
                                "type": "pwa-chrome",
                                "request": "launch",
                                "url": "http://localhost:3000"
                            },
                            {
                                "name": "Next.js: debug full stack",
                                "type": "node-terminal",
                                "request": "launch",
                                "command": "npm run dev",
                                "console": "integratedTerminal",
                                "serverReadyAction": {
                                    "pattern": "started server on .+, url: (https?://.+)",
                                    "uriFormat": "%s",
                                    "action": "debugWithEdge"
                                }
                            }
                        ]
                    }
                Run and Debug ビュー（左）を表示します:
                    Windows: Shift + Ctrl + D キー
                    mac: Shift + Command + D キー
                デバッガーを接続する位置を選びます:
                    debug full stack: 通常、これを選びます。 pages/*.tsx (client), pages/api/*.tsx (server)
                    debug server-side:
                    debug client-side:
                デバッグを開始します:
                    F5 キーを押します。
                    npm run dev が実行中だったら終了してから開始します
            Chrome 開発者ツールの場合:
                #// クライアント側のコードであっても Visual Studio Code で普通にデバッグできます
                Chrome >> F12 キー >> ソース タブ >> Ctrl + P（mac は command + P）>>（パスの一部.tsx） 
                webpack://_N_E/./____.tsx（をクリック）
                #ref: https://nextjs-ja-translation-docs.vercel.app/docs/advanced-features/debugging
        Vercel にデプロイ: #ref: https://nextjs.org/learn/basics/deploying-nextjs-app
            #// GitHub アカウントがあり、GitHub にログインしてから  #search: GitHub new repository
            Vercel を開きます:
                https://vercel.com/signup
            （初回のみ）サイン アップ します:
                Continue with GitHub ボタン（右上）:
                Authorize Vercel ボタン（下）:
                #// https://vercel.com/import/git が開きます
            プロジェクトを Vercel にインポートしてデプロイします:
                （初回の場合）:
                    Import Git Repository（の下）>> Add GitHub Account >>（アカウント名）
                    （続く）
                （2回目以降で久しぶりの場合）:
                    Configure GitHub App
                    （続く）
                共通:
                    Only select repositories >>（リポジトリ名）>> Install または Save（下）>>
                    Import（対象リポジトリの右）>> Deploy ボタン（右下）
            デプロイしたページを開きます:
                https://vercel.com/takakiriy/nextjs-blog
                Overview タブ >> Visit（右上）
            プロジェクトを Vercel から削除します:
                URL の例: https://vercel.com/takakiriy/nextjs-blog
                メニュー: Settings タブ >> Advanced（左下）>> Delete Project（右下）
    機能:
        ルーティング: #keyword: Next.js routing  #// URL とページの対応関係
            ルーティング:  #search: Next.js URL tutorial
            ハイパーリンク:  #keyword: Next.js hyperlink
                useRouter:  #keyword: Next.js useRouter
                    useRouter.push: | #// pre-rendering に対応。今までいたページに戻れます
                        import { useRouter } from 'next/router'
                        const router = useRouter();  // #keyword: Next.js router

                        router.push(`/about`);  // __Project__/pages/about.tsx を表示します
                    useRouter.replace: | #// pre-rendering に対応。今までいたページに戻れません
                        router.replace(`${baseURL}/index.html`);  // #search: Next.js router
                    現在と同じURLを指定するとエラーになります:
                        エラー メッセージ: |
                            Error: Cancel rendering route
                        対処:
                            router.replace(router.asPath.replace('#','?#'));  // asPath.replace is required from router.replace.
                            router.replace(router.asPath.replace('?#','#'));
                    関連:
                        #search: React Router Redirect
                ファイル システム ルーティング: #keyword: Next.js file system routing, Next.js file base routing, 統合ファイルシステムルーティング
                概要: #// URL はコードのパスにあわせて決まります
                    たとえば、URL
                        __Domain__/api
                    は、
                        __Project__/pages/api/index.js
                    または
                        __Project__/pages/api.tsx
                    にソースがあります。
                    pages の右がドメインの右に対応します。
                公式: #ref: https://nextjs.org/docs/routing/introduction
                URL パラメーター: |  #// URL の一部を変数で受け取ります
                    たとえば、
                        __Project__/pages/api/[id].tsx
                    というファイルがあるときに、URL
                        __Domain__/api/1
                    にアクセスすると、
                        [id].tsx:
                    に
                        {"id": "1"}
                    が渡ります
                特殊なファイル名:
                    404.tsx: ファイルが存在しない URL にアクセスしたときに表示される内容
                    _app.tsx: アプリケーションエントリーポイント, Context Provider などを書きます
                    _document.tsx: HTMLドキュメント構造記述用, HTML のヘッダーを書きます
            型安全ルーティング: #keyword:
                概要: |
                    たとえば、
                        <Route path="/user/:userId">
                    の
                        "/user/:userId"
                    から
                        const params = useParams<{ userId: string }>();
                    の
                        { userId: string }
                    を自動的に定義します。
                    userId の部分は必ず string 型ですが、
                    params.userId が存在することは "/user/:userId" を解析しなければ分かりません。
                参考: #ref: https://zenn.dev/uhyo/articles/type-safe-routing-2021#文字列ベースのルーティングの危険性
        高速化: #keyword: Next.js 高速化
            #search: Next.js pre-rendering tutorial
            高速リロードの対応条件:
                条件: 名前付き関数コンポーネント(React)を export default すること
                サンプル:
                    const Index = () => <div/>;
                    export default Index;
            ビルド時に画像サイズを調整します:
                条件: next/image を使います
                サンプル: | #focus: Image
                    import Image from 'next/image'

                    function Home() {
                    return (
                        <>
                            <h1>My Homepage</h1>
                            <Image
                                src="/me.png"
                                alt="Picture of the author"
                                width={500}
                                height={500}
                            />
                            <p>Welcome to my homepage!</p>
                        </>
                        )
                    }

                    export default Home
            SSG(getStaticProps, 推奨), SSR(getServerSideProps), SPA(next export):
            client side navigation, プリフェッチ: #ref: https://nextjs.org/learn/basics/navigate-between-pages/client-side
            プリレンダリング: #ref: https://nextjs.org/learn/basics/data-fetching/pre-rendering
                #snip: パフォーマンスとSEOを向上させることができます。プレーン React.js にはない
                #search: Next.js prerendering
            hydration: #keyword: Next.js hydration  #ref: https://nextjs.org/learn/basics/data-fetching/pre-rendering    構成, ファイル:
    構造:
        プロジェクト:  #search: Next.js project folder
        HTML ファイル, CSS ファイル:  #search: Next.js HTML
        ルーティング:  #search: Next.js routing
    ファイル: #keyword: Next.js files
        HTML ファイル: #keyword: Next.js HTML
            コンポーネント:  #// HTML タグのように使える React コンポーネント
                Next.js コンポーネント:
                    <Link>: #search: Next.js <Link>
                親コンポーネント:
                    __Project__/pages/posts/[id].tsx: |
                        import Date from '@components/date'
                        <Date dateString={postData.date} />
                    #ref: ${GitHub}/MyPrivateCode/Next_js/next_js_bootstrap/pages/posts/[id].tsx#<Date
                    #// @components については #search: import @ TypeScript
                子コンポーネント:
                    __Project__/components/date.tsx: |
                        export default function Date({ dateString }: { dateString: string }) {
                    #ref: ${GitHub}/MyPrivateCode/Next_js/next_js_bootstrap/components/date.tsx#Date
            CSS: #keyword: Next.js CSS  #// Next.js では CSS と Sass が使えます
                CSS Modules, .module.css ファイル:  #keyword: CSS Modules, .module.css  #ref: https://www.npmjs.com/package/typescript-plugin-css-modules
                    同じフォルダーに置く場合:
                        ファイル構成: |
                            components/
                                Button.tsx
                                Button.module.css
                                Header.tsx
                                Header.module.css
                        内容:  #focus: primaryButton
                            Button.tsx: |
                                import styles from './Button.module.css';

                                export default function Button() {
                                    return <button className={styles.primaryButton}>Click me</button>
                                }
                            Button.module.css: |
                                .primaryButton {
                                    background-color: blue;
                                    color: white;
                                }
                            tsconfig.json: |
                                {
                                    "compilerOptions": {
                                        "plugins": [{ "name": "typescript-plugin-css-modules" }],
                            package.json: |
                                {
                                    "devDependencies": {
                                        "typescript-plugin-css-modules": "^5.1.0",
                    種類ごとに分ける場合:  #// 未調査
                    グローバル:  #// 未調査
                コンポーネント埋め込み:  #// CSS の書き方が標準的ではなくなります
                    #// 動作未確認
                    CSS Modules を使う場合: #keyword: CSS Modules
                        #// CSS Modules は React とは別物ですが、一緒に使われることが多いです
                        サンプル: |  #focus: okButton
                            import { CSSProperties } from 'react';

                            export default function Button() {
                                return (
                                    <button className={styles.okButton as string}>
                                        Click me
                                    </button>
                                )
                            }

                            const styles = {
                                okButton: {  // キャメル ケース で書きます
                                    backgroundColor: 'blue',  // キャメル ケース で書きます
                                    color: 'white',
                                } as CSSProperties,
                            }
                        複数のクラス（複合クラス）を指定する場合: #keyword: CSS Modules compound classes
                            button className={`${styles.button} ${styles.buttonPrimary}`}>
                    CSS-in-JS（Styled JSX）を使う場合: |  #focus: button
                        export default function Button() {
                            return (
                                <>
                                    <button className="button">Click me</button>
                                    <style jsx>{`
                                        .button {
                                            background-color: blue;
                                            color: white;
                                            padding: 10px 20px;
                                            border: none;
                                            border-radius: 5px;
                                        }
                                    `}</style>
                                </>
                            )
                        }
                Sass サンプル プロジェクト: #search: Sass
                公式チュートリアル: #search: Next.js CSS tutorial
        プロジェクト フォルダー: #keyword: Next.js project folder  #glossary: Next.js
            （新規作成）:  #search: new Next.js TypeScript
            __Project__/pages/:   #// HTML ファイルに相当する .tsx ファイルなど  #search: .tsx
                URL とコンポーネントの対応関係は、__Project__/pages/ 以下のファイルの位置に対応して決まります。
                    #search: Next.js URL
            __Project__/pages/index.tsx:  #// URL のルート（http://localhost:3000/）に対応する React コンポーネント
            __Project__/pages/_app.tsx:  #// 全ページ共通のルートの React コンポーネント。MyApp 関数
                Next.js 9.3以降:
                    MyApp 関数:
                        サンプル コード: |  #focus: MyApp
                            import '../styles/globals.css'

                            function MyApp({ Component, pageProps }) {
                                return <Component {...pageProps} />
                            }
                            export default MyApp;
                        Component:
                            URL に応じてコンポーネントが変わります。
                            URL とコンポーネントの対応関係は、__Project__/pages/ 以下のファイルの位置に対応して決まります。
                            #serach: Next.js __Project__/pages/
                        全ページ共通部分:
                            サンプル: |  #focus: Header  #// Header コンポーネントが全ページの共通部分です
                                import '../styles/globals.css'
                                import Header from '../components/Header'

                                function MyApp({ Component, pageProps }) {
                                    return (
                                        <>
                                            <Header />
                                            <Component {...pageProps} />
                                        </>
                                    );
                                }
                                export default MyApp;
                Next.js 9.3より前: App 関数
            __Project__/public/: #keyword: Next.js public,  Next.js static  #// URL から直接参照できるファイル。画像ファイルなど
                場所:
                    URL: https://__Domain__/__Path__
                    開発環境: __Project__/public/__Path__
                    HTML: /__Path__
                    サーバー: #// ビルド時に .js パッケージに含まれないので、サーバーにコピーしてください
                サンプル:
                    next_js_minimum プロジェクト, SVG ファイル:
                        index.tsx:  #ref: ${GitHub}/MyPrivateCode/Next_js/next_js_minimum/pages/index.tsx#<Image
                            # <Image src="/vercel.svg" alt="Vercel Logo" width={72} height={16} />
                            vercel.svg:  #ref: ${GitHub}/MyPrivateCode/Next_js/next_js_minimum/public/vercel.svg
                    Image タグ:  #search: Next.js public image
            __Project__/styles/:  #// CSS  #search: CSS
            __Project__/next.config.json:  #// Next.js の設定
            __Project__/package.json:  #// Node.js パッケージの設定
            __Project__/tsconfig.json:  #// TypeScript の設定
        URL: #keyword: Next.js URL
            サーバー内: https://__Domain__/____
            ローカル:   http://localhost:3000/____
            HTML の対応関係: |  #serach: Next.js __Project__/pages/
                |              URL                  |      開発環境                    |
                | --------------------------------- | -------------------------------- |
                | http://localhost:3000/            | __Project__/pages/index.js       |
                | http://localhost:3000/about       | __Project__/pages/about.js       |
                | http://localhost:3000/contact     | __Project__/pages/contact.js     |
                | http://localhost:3000/blog        | __Project__/pages/blog/index.js  |
                | http://localhost:3000/blog/1 など | __Project__/pages/blog/[id].js   |
            ファイル の対応関係: |  #// 画像ファイルなど  #serach: Next.js __Project__/public/
                |              URL                  |      開発環境                    |
                | --------------------------------- | -------------------------------- |
                | https://localhost:3000/__Path__   | __Project__/public/__Path__      |
        アプリケーション:  #// ユーザーが扱うファイル
            Zip ファイル: #keyword: Next.js zip file  #search: next_js_zip_file_reader
    コード >> API: #keyword: Next.js API
        #↓フロントエンドからバックエンドへ
        read する API:
            Pre-rendering:
                概要: getStaticProps 関数を定義します  #search: getStaticProps
                サンプル: |  #ref: ${GitClone}/GitHub/vercel/next-learn/basics/typescript-final/pages/posts/[id].tsx
                    import { GetStaticProps, GetStaticPaths } from 'next'
                    export const getStaticProps: GetStaticProps = async ({ params }) => {
            Dynamic Routes: #keyword: Next.js Dynamic Routes API
                #search: Next.js dynamic routes 
                #// useEffect の中で fetch API を呼び出します  #search: useEffect, onLoad
                呼び出すとき: | #ref: ${GitHub}/typrm-html/pages/search.tsx
                    import { useRouter } from 'next/router';
                    import { useState, useEffect } from 'react';

                    const Post = () => {
                        const [contents, setContents] = useState<string>('');

                        useEffect(() => {
                            const asyncFunction = async () => {

                                const response = await fetch('/api/search');  // __Project__/pages/api/search.ts
                                const aJSON = JSON.stringify(await response.json(), null, '    ');
                                setContents(aJSON);
                            }

                            asyncFunction()
                                .catch(console.error);
                        }, []);

                        return <>
                            <p>{contents}</p>
                        </>;
                    }

                    export default Post
                呼び出される関数:
                    API routes: #search: Next.js API routes
        write する API:
            #search: Next.js Dynamic Routes API
React:
    React:  #keyword:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#React
        概要: #keyword: React .tsx .jsx
            - SPA。HTML が JavaScript のリテラルになる（.tsx, .jsx）
            - Reactが覇権を握るまでの知られざる物語  #ref: https://qiita.com/Sicut_study/items/ab4d6ba9da63d71a6c50
        手順:
            React をインストールします:  #keyword: install React,  install React VSCode  #// Jest + TypeScript + React + Visual Studio Code の開発環境を構築します
                プロキシが無い環境 for Windows: #keyword: install Windows React VSCode
                    参考:
                        Jest - TypeScript Deep Dive 日本語版:
                            https://typescript-jp.gitbook.io/deep-dive/intro-1/jest
                        React × TypeScript環境にJestを導入してみて:
                            https://tech.willgate.co.jp/entry/2019/12/12/130000
                    設定: #settings:
                        __RepositoryName__: react1_jest
                        __GitCollaboratorName__: Your Name  #search: Git username
                        __GitCollaboratorMail__: you@example.com
                    注意: React のプロジェクト名に使える文字に制限があるので、
                        先に React のプロジェクトを作ってから、GitHub のプロジェクトを作ります。
                        npm に登録されているパッケージ名は、小文字とハイフンだけ使われているようです。
                    準備:
                        Node.js をインストールします（React が使います）:
                            - https://nodejs.org/ja/download/ >> Windows Installer (.msi) >> 64-bit
                            - node-v14.15.0-x64.exe をダブルクリックします
                            - インストール オプションはデフォルトを使用
                        Git for Windows をインストールします（シェルとして使います）:
                            - https://git-scm.com/ >> Downloads >> Windows
                            - ダウンロードしたファイル（例：Git-2.29.2.2-64-bit.exe）を開きます
                            - Next を8回押す
                            - Configuring the line ending conversions: Checkout as-is, commit as-is
                            - 他のインストール オプションはデフォルトを使用
                            - デスクトップを右クリック >> Git Bash Here
                            - git clone  "https://github.com/githubtraining/hellogitworld.git"
                            - 成功したら、デスクトップにある hellogitworld フォルダーを削除します ( rm -rf hellogitworld )
                        （ダウンロード（クローン）するリポジトリにコミットする可能性があるとき）Git のユーザー名を設定します:
                            - git config --global user.email "you@example.com"  #template: "__GitCollaboratorMail__"
                            - git config --global user.name  "Your Name"        #template: "__GitCollaboratorName__"
                            - Git bash を閉じます:
                        Visual Studio Code をインストールします:
                            - https://code.visualstudio.com/
                            - インストール オプションはデフォルトを使用
                            - （推奨）Visual Studio Code をタスクバーにピン止めします:
                            - （推奨）Ctrl + S キーを押したときに全てのファイルを保存するように設定します: |
                                File >> Preferences >> Keyboard Shortcuts >> save all （と入力） >>
                                    File: Save All （をダブルクリック） >> Ctrl + S キー >> Enter キー
                            - 下記の拡張機能をインストールします :
                                - Jest Runner
                    React のプロジェクトを新規作成します:
                        プロジェクトを作ります:
                            #Git bash
                            - cd  "__ParentOfProject__"
                            - （TypeScript を使う場合）:
                                - npx create-react-app --template typescript  "react1_jest"  #template: "__RepositoryName__"
                            - （JavaScript を使う場合）:
                                - npx create-react-app  "react1_jest"  #template: "__RepositoryName__"
                        Visual Studio Code でプロジェクトを開きます:
                            - code  "react1_jest"  #template: "__RepositoryName__"
                        動作確認します:
                            Terminal を開きます:
                                VSCode >> Terminal >> New Terminal
                            コマンドを入力します:
                                #Git bash
                                npm start
                                #// Windows Defender によって警告されたときは、アクセス許可します
                                #// ブラウザーが開いたら閉じます
                            Web サーバーを終了します:
                                Ctrl + C
                                #// ウィンドウをクローズすると node.exe のプロセスが残ってしまいます
                    GitHub にアップロードします:
                        リポジトリを新規作成します:
                            URL: https://github.com >>（サインインしていなかったらサインイン）
                            New ボタン（Repositories:左上）:
                            リポジトリ名: react1_jest  #template: __RepositoryName__
                        git push します: |  #keyword: git first commit push
                            cd  "react1_jest"  #template: __RepositoryName__
                            git remote add origin https://github.com/Your Name/react1_jest.git
                                #template: __GitCollaboratorName__/__RepositoryName__
                            git branch -M main  #// 必要ならブランチ名を main に変更します
                            git config user.name
                            git config user.email
                            git push --set-upstream origin main  #// main に変更していなかったら master
                        参考: #ref: リポジトリを新規作成した後の「…or create a new repository on the command line:」
                    Visual Studio Code でデバッグできるようにします:
                        Visual Studio Code で __Project__ フォルダーを開きます（エディターとして使うため）:
                            メニュー: File >> Open Folder >> react1_jest  #template: __RepositoryName__
                        必要な Node パッケージをインストールします:
                            #VSCode >> Terminal >> New Terminal
                            - npm install  "ts-jest" --save-dev
                        __Project__/package.json に下記の jest キーを追加します: |
                            "jest": {
                                "transform": {
                                    "^.+\\.tsx?$": "ts-jest",
                                    "^.+\\.jsx?$": "babel-jest"
                                }
                            }
                    テスト対象のコードを作成します:
                        （TypeScript を使う場合）:
                            __Project__/src/foo.ts: |
                                export const sum = (...a: number[]) =>
                                    a.reduce(
                                        (acc, val) => acc + val,
                                        0);
                        （JavaScript を使う場合）:
                            __Project__/src/foo.js: |
                                export const sum = (...a) =>
                                    a.reduce(
                                        (acc, val) => acc + val,
                                        0);
                    テスト コードを作成します:
                        __Project__/src/foo.test.ts (または .js) : |
                            import { sum } from './foo';

                            test('basic', () => {
                                expect(sum()).toBe(0);
                            });

                            test('basic again', () => {
                                expect(sum(1, 2)).toBe(3);
                            });
                    デバッグできることを確認します:
                        Visual Studio Code で __Project__ フォルダーを開きます:
                            メニュー: File >> Open Folder >> react1_jest  #template: __RepositoryName__
                        __Project__/src/foo.test.ts (または .js) ファイルを開きます:
                        test 関数の中にブレークポイントを張ります:
                            行番号の左をクリックします:
                        デバッグを開始します:
                            test 関数の上に表示されている Debug をクリックします:
                        ブレークできることを確認します:
                    すべてのテストを実行できることを確認します:
                        #VSCode Node Debug Console など
                        - cd  "__Project__"
                        - npm test
                    Web アプリケーションのサーバーが動くことを確認します:
                        #VSCode Node Debug Console など
                        - cd  "__Project__"
                        - npm start
                    トラブルシューティング:
                        - ケース:
                            エラー: |
                                The react-scripts package provided by Create React App requires a dependency:
                                "jest": "26.6.0"
                                Don't try to install it manually: your package manager does it automatically.
                                However, a different version of jest was detected higher up in the tree:
                                C:\Users\ts-ne\Desktop\own\node_modules\jest (version: 26.6.1)
                            対処:
                                React が要求している Jest のバージョンに合わせます:
                                    npm install --global  "jest@26.6.0"
                                    npm install  "jest@26.6.0" --save-dev
                        - ケース:
                            エラー: |
                                We detected setupFilesAfterEnv in your package.json.
                                Remove it from Jest configuration, and put the initialization code in src/setupTests.js.
                                This file will be loaded automatically.
                            対処:
                                __Project__/package.json の json キーの中から下記のキーを削除します:
                                    roots, preset, testEnvironment, setupFilesAfterEnv
                                        #// エラーメッセージに削除すべきキーが一覧されます
                プロキシがある環境 for CentOS7: #keyword: install CentOS7 proxy React VSCode
                    生成済みのプロジェクトを使う場合:  #ref: ${GitHub}/MyPrivateCode/react_examples/branch_create_ts_only
                        プロジェクト(node_modules)を復帰します:  #keyword: resume React CentOS7
                            yarn install --frozen-lockfile  #search: yarn node_modules
                    手動でプロジェクトを生成する場合:
                        VM を作り CentOS7 をインストールします:  #search: install Ansible project
                        VM のメモリーサイズを 2GB に変更します:
                        CentOS に Node.js と yarn をインストールします（IDEなし）:  #search: Node.js CentOS
                        create-react-app をインストールします: #keyword: install create-react-app
                            失敗するコマンド: npx create-react-app --template typescript  "react1_jest"
                            コマンド: |
                                npm -g install create-react-app
                                yarn global add react react-dom react-scripts react-scripts-ts
                        React のプロジェクトを生成します:
                            create-react-app --template typescript  "react1ts_jest"  #// 起動まで 2分半かかります
                        （必要なら）プロジェクトをバックアップとしてコピーします:
                        React を使う Web サーバーを起動します:
                            - cd  "react1ts_jest"
                            - yarn start  #// ブラウザーが自動的に開きます
                        コードを変更してすぐに反映されることを確認します:
                            OSに設定されている監視するファイルの最大数を 524288 に変更します:  #search: max_user_watches
                            Web サーバーを再起動します:
                                - Ctrl + C
                                - yarn start
                            表示内容を変更します:
                                src/App.tsx :
                                    変更前: Learn React
                                    変更後: Learn React !
                                #// 保存するとブラウザーに反映されます
                        （試してみたいなら）子コンポーネントを作ります:  #search: React component example
                        React を使う Web サーバーを終了します:
                            - (Ctrl + C で Web サーバーを終了します)
                    参考:
                        Windows企業内プロキシ配下でcreate-react-app（yarnを使う）: #ref: https://qiita.com/otagaisama-1/items/aa559345644e73bb6ac5
                        プロキシがない環境でのインストール: #search: React VSCode
                    トラブルシューティング:
                        - #// ReferenceError: Hook is not defined
                            手順: React の Web サーバーを起動
                            エラー: |
                                ブラウザー内に ReferenceError: Hook is not defined と赤字で表示される
                            対処:
                                React の Web サーバーを再起動します
                プロキシがある環境 for WSL2 Ubuntu20.04: #keyword: install Ubuntu20.04 proxy React VSCode
                    #// CentOS7 と同じです
                    Ubuntu を初期化します:  #search: WSL2 restore
                        wsl --import  "Ubuntu-20.04-React" `
                            "${HOME}\WSL_VMs\Ubuntu-20.04-React" `
                            "${HOME}\WSL_back_up\Ubuntu-20.04-1.tar"
                        wsl -d  "Ubuntu-20.04-React"
                    root ユーザーにログインできるようにします:
                        #search: WSL2 root password
                    React:  #search: install CentOS7 proxy React VSCode
                        Node.js と yarn をインストールします（IDEなし）:
                            Node.js:
                                #search: Node.js CentOS
                            yarn:
                                #search: install yarn CentOS7
                    作成済みプロジェクトの場合:
                        新規用: #search: try_ReactTypeScript_5-0-1
                    新規プロジェクトを作り直す場合:  #// 新規プロジェクトをダウンロードする場合
                        create-react-app をインストールします:
                            #search: install create-react-app
                        create-react-app を実行します:
                            #search: install create-react-app
            React プロジェクト:
                try_ReactTypeScript_5-0-1: #keyword:  #ref: ${GitHub}/Trials/try_ReactTypeScript_5-0-1
                    #// copy try_ReactTypeScript_5-0-1
                    npm ci
                    npm start
            エラー ハンドリング:  #keyword: React error handling, ErrorBoundary
                参考:
                    基本: #ref: https://stackoverflow.com/questions/67319864/react-redirect-to-an-error-page-with-error-message-stack-trace-using-react-rout
                    リダイレクト:
                        ErrorBoundary: #ref: https://pretagteam.com/question/how-do-i-redirect-to-error-page-after-receiving-status-404-from-api-call-in-react
            #// 構成を参照
        コメント:  #search: JSX comment
        構成, 概念:
            ページ:
                リロード: #keyword: React reload
                    window.location.reload()
                React Routerを使っている場合の最適方法: |  #focus: navigate
                    import { useNavigate } from 'react-router-dom';

                    const MyComponent = () => {
                        const navigate = useNavigate();

                        const handleReload = () => {
                            navigate(0); // 現在のページをリロード
            コンポーネント, React Hooks:  #// .tsx, .jsx ファイル
                基本形:  #keyword: React component
                    個人的推奨形式: |
                        import TextView from '@components/TextView'

                        export default Example;

                        function  Example(): JSX.Element {
                            return (
                                <TextView>
                                </TextView>
                            )
                        }
                    一般に使われている形式: |  #// 問題点：関数だと気づかない。React.FC は関数型で分かりにくい
                        import TextView from '@components/TextView'

                        const Example: React.FC = () => {
                            return (
                                <TextView>
                                </TextView>
                            )
                        }

                        export default Example;
                    ステート:
                        Component<, State>:
                            サンプル, 初期化: |  #focus: State, state
                                import React, { Component } from 'react';
                     
                                class Counter extends Component<Props, State> {
                                    constructor(props: Props) {
                                        super(props);
                                        this.state = {  // コンストラクターで state を初期化します
                                            count: props.initialCount || 0
                                        };
                                    }
                                }

                                interface State {
                                    count: number;
                                }
                            参照:
                                this.state.__State__
                            設定: |  #// 変更するステートのみ指定します
                                this.setState({__State__: __Value__});
                        useState:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#React_useState
                    プロパティ, 引数:
                    関連:  #search: React 関数コンポーネント
                        内容の変更:  #// useState, props
                            useState:  #search: useState
                            property:  #search: React property
                        イベント:  #// useEffect
                            #search: useEffect  #// ページを開いたらすぐに実行します（コンポーネントがマウントされたとき）
                子コンポーネントを使います:  #keyword: React component example
                    React をインストールします:  #search: install React VSCode
                    子コンポーネント MyComponent を作ります:
                        __Project__/src/App.tsx: |
                            import React from 'react';
                            import './App.css';
                            import MyComponent from './MyComponent';  // <--------------- 追加
                            
                            function App() {
                                return (
                                    <div className="App">
                                    <header className="App-header">
                            
                                        <MyComponent/>            {/* <-------------- <header> の中をこれだけにします */}
                                    </header>
                                    </div>
                                );
                            }
                            export default App;
                        __Project__/src/MyComponent.tsx: |
                            import React from 'react';

                            export default function  MyComponent() {
                                return (
                                    <div>MyComponent</div>
                                );
                            }
                    React の Web サーバーを再起動します:  #// ファイルが増えたため
                        Ctrl + C
                        yarn start  または  npm start
                関数コンポーネントと クラス コンポーネント:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#import_JSX
                    関数コンポーネント + Hooks:  #keyword: React 関数コンポーネント
                        useState:  #keyword: useState, React onClick useState  #// 表示に影響する数値や文字列の変数
                            サンプル: | #focus: useState, count, setCount  #ref: ${GitHub}/MyPrivateCode/react_examples/branch_component_hooks/src/2_useState.tsx#useState
                                import React from 'react';

                                export default UseState;

                                function  UseState(): JSX.Element {  // or const  UseState: React.FC = () => {
                                    const [count, setCount] = React.useState(0);

                                    return (
                                        <div>
                                            2. You clicked {count} times &nbsp;
                                            <button onClick={() => setCount(count + 1)}>
                                                Click me
                                            </button>
                                        </div>
                                    );
                                }
                            参考:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#React_useState
                        useEffect:  #keyword: useEffect, React useEffect onLoad  #// ページを開いたらすぐに実行します（コンポーネントがマウントされたとき）
                            基本: |
                                useEffect(() => {
                                    // onLoad, componentDidMount

                                    return () => {
                                        // onUnload, componentWillUnmount
                                    };
                                }, []);
                            async 関数の場合: #keyword: async useEffect  #// useEffect などに指定する関数が、内部の都合で async 関数にしなければならない場合
                                #// useEffect に async 関数を直接指定することはできません
                                サンプル:
                                    基本: |  #focus: async
                                        useEffect(() => { async function  asyncFunction() {
                                            const response = await fetch('/text.txt');
                                        }; asyncFunction(); }, []);
                                    仕組をが分かりやすくした表現: |  #focus: async
                                        useEffect(() => {
                                            async function  asyncFunction() {
                                                const response = await fetch('/text.txt');
                                            };
                                            asyncFunction();
                                        }, []);
                                エラー, '() => Promise<void>' is not assignable:  #// useEffect に async 関数を直接渡せません
                                    サンプル: |
                                        useEffect( async () => {
                                            const response = await fetch('/text.txt');
                                        }, []);
                                    ログ: |
                                        Argument of type '() => Promise<void>' is not assignable to parameter of type 'EffectCallback'.
                                        Type 'Promise<void>' is not assignable to type 'void | Destructor'.ts(2345)
                                    対処:
                                        上記  #search: async useEffect
                                エラー, Did you mean to mark this function as 'async'?:  #// await を使うと async 関数にする必要があります
                                    サンプル: |
                                        useEffect(() => {
                                            const response = await fetch('/text.txt');
                                        }, []);
                                    ログ: |
                                        'await' expressions are only allowed within async functions and at the top levels of modules.ts(1308)
                                        TextView.tsx(10, 13): Did you mean to mark this function as 'async'?
                                    対処:
                                        アロー関数に async を付けます:
                                            useEffect( async () => {
                                        他のエラーも対処します:
                                            #search: useEffect( async () => {
                            依存関係, 第2引数:  #// useEffect(() => {}, []) の [] 。コンパイル時に警告されたら設定します
                                '[]': コンポーネントがマウントされたとき
                                '[count]': コンポーネントがマウント または count が更新されたとき
                                '[count, name]': コンポーネントがマウント または count または name が更新されたとき
                            クリーンアップ関数:  #// 第1引数に指定する関数の中で返す関数は、クリーンアップ（キャンセル）するときに呼ばれます
                                サンプル: |
                                    useEffect(() => {
                                        console.log('opened');
                                        return function cleanUp() {
                                            console.log('clean up');
                                        };
                                    }, []);
                                呼ばれるタイミング:
                                    コンポーネントのアンマウント時:
                                        たとえばリクエストをキャンセルする処理を書きます
                                fetch のキャンセル: |  #focus: abortController
                                    useEffect(() => {
                                        const abortController = new AbortController();  #search: AbortController

                                        fetch(url, {signal: abortController.signal}).then((response) => {
                                        });

                                        return () => {
                                            abortController.abort();
                                        };
                                    }, []);
                        React.FC:  #keyword: React.FC, React.FunctionComponent
                            React.FunctionComponent: React.FC のフルネームです
                            サンプル: | #focus: FunctionComponent  #ref: ${GitHub}/MyPrivateCode/react_examples/branch_component_hooks/src/1_FunctionComponent.tsx#React.FC
                                import React from 'react';

                                // #focus: FunctionComponent
                                // const FunctionComponent: React.FC = () => {  // https://stackoverflow.com/questions/36261225/why-is-export-default-const-invalid
                                export default function  FunctionComponent() {
                                    return (
                                        <div>1. Function Component</div>
                                    );
                                }
                                // export default FunctionComponent;  // Besause "export default const" is invalid syntax
                        プロパティ: #keyword: React property (old),  React.FunctionComponent property
                            サンプル: | #focus: PropertyProps  #ref: ${GitHub}/MyPrivateCode/react_examples/branch_component_hooks/src/3_property.tsx#PropertyProps
                                // これは古いスタイルです  #search: React property

                                import React from 'react';

                                // #focus: PropertyProps
                                let Property: React.FC<PropertyProps>;  export default  Property = (props) => {
                                // export default function  Property(props: PropertyProps) {
                                    const [count, setCount] = React.useState(props.count);

                                    return (
                                        <div>
                                            3. You clicked {count} times &nbsp;
                                            <button onClick={() => setCount(count + 1)}>
                                                Click me
                                            </button>
                                        </div>
                                    );
                                }

                                interface  PropertyProps {
                                    count: number;
                                }
                        デバッグ, StrictMode: #keyword: React StrictMode  #// React 16.3 以降  #ref: https://ja.reactjs.org/docs/strict-mode.html
                            2回呼ばれます:
                                StrictMode のときは、関数コンポーネントの関数が最低でも 2回呼ばれます。
                                副作用がないことをチェックすることなどの効果があります。
                                #ref: https://ja.reactjs.org/docs/strict-mode.html
                            有効にします: |
                                ReactDOM.render(
                                    <React.StrictMode>
                                        <App />
                                    </React.StrictMode>,
                                    document.getElementById('root')
                                )
                            参考:
                                #ref: https://www.ey-office.com/blog_archive/2021/06/30/i-found-out-why-the-component-is-drawn-twice-in-the-react/
                    クラス コンポーネント:  #keyword: React クラス コンポーネント
                        サンプル: |
                            class Form<FormFields> extends React.Component<
                                Props<FormFields>,
                                State<FormFields>
                            > {

                                constructor(props: Props<FormFields>) {
                                    super(props);
                                    this.state = { fields: props.initialValues };
                                }

                                public onChange: OnChangeHandler<FormFields> = (field, value) => {
                                    // Use your favorite method to merge objects
                                    this.setState({ fields: merge(this.state.fields, { [field]: value }) });
                                };

                                public render() {  #keyword: React render
                                    const { FormComponent } = this.props;
                                    const { fields } = this.state;

                                    return <FormComponent onChange={this.onChange} fields={fields} />;
                                }
                            }
                        Component<Props, State>:
                            #// class の行は、以下のいずれか
                            import React, { Component } from 'react';
                            class __Component__ extends Component {
                            class __Component__ extends Component<__PropsClass__> {
                            class __Component__ extends Component<__PropsClass__, __StateClass__> {
                        参考: #ref: https://www.mojotech.com/blog/typescript-generic-react-components/ >> A form component
                組み込みコンポーネント:  #keyword: React defined components  #// React が提供するコンポーネント、HTML タグ名
                    React.StrictMode:  #keyword:  #// ReactDOM.render() に渡すルート要素
                        ReactDOM.render(
                            <React.StrictMode>
                                <App />
                            </React.StrictMode>,
                            document.getElementById('root')
                        );
                    React.Fragment:  #keyword: React.Fragment, <>, </>  #// 複数のコンポーネントを返すときのダミー的な ルート タグ
                        サンプル: |
                            import * as React from 'react';
                            <React.Fragment>
                                <div/>
                                <div/>
                            </React.Fragment>
                        サンプル 短縮形: |
                            <>
                                <div/>
                                <div/>
                            </>
                        公式: #ref: https://ja.reactjs.org/docs/fragments.html
                Hooks:  #// React.useRef, React.useHistory
                    React.useRef:  #search: React.useRef
                    React.useHistory: #keyword: useHistory,  React URL href  #// URL の変更  #// history.push
                        URL にジャンプします:
                            通常: |  #// ブラウザーの戻る履歴に登録してからジャンプします
                                const Component: React.FunctionComponent<Props> = props => {
                                    const history = useHistory();
                                    const handleTabChange = (event: React.ChangeEvent<{}>, newValue: string) => {
                                        history.push(newValue);
                                    };
                            現在の履歴を上書き:
                                history.replace('/target-url');
                    React.useLocation: | #keyword:  #// URL
                        const Component: React.FunctionComponent<Props> = props => {
                            const location = useLocation();  // URL
                    カスタム フック: #keyword: React custom hooks
                        命名の慣例: use から始めます
                        サンプル: |  #focus: useFormInput, name
                            import React, { useState } from 'react';

                            // カスタムフック
                            function  useFormInput(initialValue) {
                                const [value, setValue] = useState(initialValue);

                                function handleChange(e) {
                                    setValue(e.target.value);
                                }

                                return {
                                    value,
                                    onChange: handleChange
                                };
                            }

                            // コンポーネント
                            function MyForm() {
                                const name = useFormInput('');
                                const email = useFormInput('');

                                function handleSubmit(e) {
                                    e.preventDefault();
                                    console.log('Name:', name.value);
                                    console.log('Email:', email.value);
                                }

                                return (
                                    <form onSubmit={handleSubmit}>
                                        <div>
                                            <label>
                                                Name:
                                                <input type="text" {...name} />
                                            </label>
                                        </div>
                                        <div>
                                            <label>
                                                Email:
                                                <input type="email" {...email} />
                                            </label>
                                        </div>
                                        <button type="submit">Submit</button>
                                    </form>
                                );
                            }

                            export default MyForm;
                        子コンポーネントとの違い:
                            コンポーネントとカスタムフックはまったく別個の概念ではない
                            #ref: https://qiita.com/uhyo/items/cb6983f52ac37e59f37e
                props:   #keyword: React property,  React.ClassComponent property
                    props:  #// 親コンポーネントに書かれた HTML 属性を子コンポーネントに渡します  #focus: props, prop1
                        親コンポーネント:  #// 子コンポーネントを参照する親コンポーネントの書き方
                            基本:
                                <__ChildComponent__ prop1="aaa"/>
                            変数や関数を渡す場合: |  #focus: isOpen, useState, handleClose  #search: useState
                                import { useState }  from 'react';
                                import __ChildComponent__ from '@components/__ChildComponent__'
                                export default  __ParentComponent__;

                                function  __ParentComponent__(): JSX.Element {
                                    const [isOpen, setIsOpen] = useState(true);

                                    function  handleClose() {
                                        setIsOpen( ! isOpen);
                                    }

                                    function  handleSubmit(keyword: string) {
                                        setIsOpen( ! isOpen);
                                    }

                                    return (
                                        <__ChildComponent__ isOpen={isOpen} onClose={handleClose} onSubmit={handleSubmit}>
                                        </__ChildComponent__>
                                    )
                                }
                        子コンポーネント:  #keyword: React property
                            TypeScript: |  #focus: __ChildComponent__
                                import React, { useState, useEffect, useRef } from 'react';
                                export default  __ChildComponent__;

                                function  __ChildComponent__({ isOpen, onClose, onSubmit }: __ChildComponent__Props): JSX.Element {
                                    return  <div>{isOpen}</div>;
                                }

                                interface  __ChildComponent__Props {
                                    isOpen: boolean;
                                    onClose: () => void;
                                    onSubmit: (keyword: string) => void;
                                }
                            JavaScript: |
                                export default  __ChildComponent__(props) {
                                    return  <div>{props.prop1}</div>;
                                }
                        関数定義の 1行目:
                            アロー関数: |
                                const PopupInput: React.FC<PopupInputProps> = (props: PopupInputProps) => {
                            function: |
                                function  PopupInput(props: PopupInputProps): JSX.Element {
                    defaultProps: | #keyword: React defaultProps,  React default property
                        interface Props {
                            value: any;
                            propA?: boolean; // ? を付けてオプショナルにする
                        }
                        Component.defaultProps = {
                            propA: false,
                        }
                    props.children:  #keyword: React props.children  #// 親コンポーネントに書かれた子 HTML 要素を子コンポーネントに渡します  #focus: props.children, __Children__
                        親コンポーネント:
                            <__ChildComponent__><__Children__/></__ChildComponent__>
                        子コンポーネント: |
                            export default  __ChildComponent__(props) {
                                return  <div>{props.children}</div>;  // <div><__Children__/></div>
                            }
                        #// <__Children__/> の部分は <a><b>c</b></a> のようなツリー構造も渡すことができます
                        公式: #ref: https://ja.reactjs.org/docs/composition-vs-inheritance.html#containment
                    参考:
                        Snap Note:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#JSX_prop
                HOC, 上位コンポーネント:  #keyword: React HOC,  React 上位コンポーネント  高階コンポーネント  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#React_HOC
                    概要: HigherOrderComponent。 Mix-in ができそうな似たクラスがあるとき、異なる部分をパラメーターにした共通部分の関数が HOC です。
                    サンプル:
                        HOC を使う場合:  #// 上位コンポーネントは withSubscription
                            HOC を使う CommentListWithSubscription クラス: |
                                const CommentListWithSubscription = withSubscription(
                                CommentList,
                                (DataSource) => DataSource.getComments()
                                );
                            HOC を使う BlogPostWithSubscription クラス: |
                                const BlogPostWithSubscription = withSubscription(
                                BlogPost,
                                (DataSource, props) => DataSource.getBlogPost(props.id)
                                );
                            HOC: |
                                // This function takes a component...
                                function withSubscription(WrappedComponent, selectData) {
                                // ...and returns another component...
                                return class extends React.Component {
                                    constructor(props) {
                                    super(props);
                                    this.handleChange = this.handleChange.bind(this);
                                    this.state = {
                                        data: selectData(DataSource, props)
                                    };
                                    }
                                
                                    componentDidMount() {
                                    // ... that takes care of the subscription...
                                    DataSource.addChangeListener(this.handleChange);
                                    }
                                
                                    componentWillUnmount() {
                                    DataSource.removeChangeListener(this.handleChange);
                                    }
                                
                                    handleChange() {
                                    this.setState({
                                        data: selectData(DataSource, this.props)
                                    });
                                    }
                                
                                    render() {
                                    // ... and renders the wrapped component with the fresh data!
                                    // Notice that we pass through any additional props
                                    return <WrappedComponent data={this.state.data} {...this.props} />;
                                    }
                                };
                                }
                        HOC を使わない場合:  #// this.state と this.setState だけ差分があります
                            HOC を使わない CommentList クラス: |
                                class CommentList extends React.Component {
                                constructor(props) {
                                    super(props);
                                    this.handleChange = this.handleChange.bind(this);
                                    this.state = {
                                    comments: DataSource.getComments()
                                    };
                                }
                                
                                componentDidMount() {
                                    DataSource.addChangeListener(this.handleChange);
                                }
                                
                                componentWillUnmount() {
                                    DataSource.removeChangeListener(this.handleChange);
                                }
                                
                                handleChange() {
                                    this.setState({
                                    comments: DataSource.getComments()
                                    });
                                }
                                
                                render() {
                                    return (
                                    <div>
                                        {this.state.comments.map((comment) => (
                                        <Comment comment={comment} key={comment.id} />
                                        ))}
                                    </div>
                                    );
                                }
                                }
                            HOC を使わない BlogPost クラス: |
                                class BlogPost extends React.Component {
                                constructor(props) {
                                    super(props);
                                    this.handleChange = this.handleChange.bind(this);
                                    this.state = {
                                    blogPost: DataSource.getBlogPost(props.id)
                                    };
                                }
                                
                                componentDidMount() {
                                    DataSource.addChangeListener(this.handleChange);
                                }
                                
                                componentWillUnmount() {
                                    DataSource.removeChangeListener(this.handleChange);
                                }
                                
                                handleChange() {
                                    this.setState({
                                    blogPost: DataSource.getBlogPost(this.props.id)
                                    });
                                }
                                
                                render() {
                                    return <TextBlock text={this.state.blogPost} />;
                                }
                                }
                Ref, 子コンポーネントの参照:  #// コードで操作できるようにします
                    フック, React.useRef:
                        サンプル プロジェクト:  #// useRef, ref, forwardRef, useImperativeHandle
                            #ref:
                        React.useRef: #keyword:
                            サンプル:  #ref: ${GitHub}/MyPrivateCode/react_examples/branch_useRef/src/2_UseRef.tsx#useRef
                            参考:
                                公式:  #ref: https://ja.reactjs.org/docs/hooks-reference.html#useref
                                Snap Note:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#React_useRef
                        React.forwardRef: #keyword:
                            サンプル:  #ref: ${GitHub}/MyPrivateCode/react_examples/branch_useRef/src/5_ForwardRef.tsx#forwardRef
                            参考:
                                公式: #// 不明
                                Snap Note:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#forwardRef
                        React.useImperativeHandle: #keyword:  #ref: https://ja.reactjs.org/docs/hooks-reference.html#useimperativehandle
                            サンプル:
                                #ref: ${GitHub}/MyPrivateCode/react_examples/branch_useRef/src/6_UseImperativeHandle.tsx#useImperativeHandle
                                #ref: ${GitHub}/MyPrivateCode/react_examples/branch_useRef/src/7_UseImperativeHandleDeps.tsx#useImperativeHandle
                        React.createRef: #keyword: #ref: https://ja.reactjs.org/docs/refs-and-the-dom.html
                        ref:  #keyword: React ref
                        React.createRef との違い:
                            TypeScriptのもとでuseRefを使うときに知るべきRefObjectとMutableRefObjectについて:
                                #ref: https://zenn.dev/berlysia/articles/624bc1aaffda58
                    クラス コンポーネント: #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#React_ref
                ループ, 繰り返し, 条件分岐: #keyword: React loop,  React map,  React for while array
                    ループ:
                        アロー関数で書く場合: |
                            <ul>
                                {this.state.datas.map((data,i) => {
                                    return <li key={i}>{data.text}</li>;
                                })}
                            </ul>
                        アロー式で書く場合: |
                            <ul>
                                {this.state.datas.map((data,i) =>
                                    <li key={i}>{data.text}</li>
                                )}
                            </ul>
                    条件分岐: | #keyword: React 条件演算子 三項演算子,  React if
                        <ul>
                            {this.condition
                                ? <li key={i}>{data.text}</li>
                                : <></>
                            }
                        </ul>
                ライブラリ >> Material-UI:  #search: Material-UI
            HTML プロパティ:  #// 組み込み HTML タグ プロパティ
                （HTML タグ名）:  #keyword: React defined components
                値を持たない HTML 属性, disable 属性など:
                    React:  #// boolean 値 を指定します
                        <button disabled={!isFormValid}>
                style 属性: |  #// プロパティ名は camelCase
                    <div style={{ color: 'red', fontSize: '16px' }}>
                        Hello World
                    </div>
                ref 属性:  #search: React ref
            CSS: #keyword: React CSS
                サンプル: |  #focus: cell, classes, createStyles
                    const styles = (theme: Theme) => createStyles({
                        cell: {
                            paddingRight: 0,
                            paddingLeft: 8,
                        },
                        alignRight: {
                            textAlign: "right",
                        }
                    });

                    const Component: React.FunctionComponent<Props> = props => {
                        const { classes, onChange } = props;
                        <TableCell className={classes.cell}>HTTP</TableCell>
                Material-UI:  #search: makeStyles
            コンテキスト, グローバル変数: #keyword: React context,  React global variable
                #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#React_context
                React Context: #focus: __Context__,  setValue
                    コンテキスト:  #// コンテキストの内容を入れる箱のようなもの
                        __Context__: |
                                const  __Context__ = React.createContext<__ContextType__>({value: 'default'});
                            #// 他のファイルから参照するときは  #search: JavaScript export
                    コンシューマー:  #// コンテキストの内容を参照します
                        関数コンポーネントの場合:
                            useContext(__Context__): | #keyword: React useContext
                                const { value, setValue } = useContext(__Context__);
                                setValue('新しい値')
                        クラス コンポーネント の場合:
                            1つの場合: | #keyword: React contextType,  React this.context  #focus: context  #// 複数のコンテキストを扱う場合は <__Context__.Consumer>
                                class MyClassComponent extends React.Component {
                                    static  contextType = __Context__;  // これにより this.context でコンテキストの値にアクセスできるようになる
                                    context!: React.ContextType<typeof __Context__>;  // TypeScript 用の型定義
                                    componentDidMount() {
                                        console.log(this.context);
                                    }
                                    render() {
                                        return (
                                            <div>
                                                <h1>値: {this.context.value}</h1>
                                                <button onClick={() => this.context.setValue('新しい値')}>
                            複数の場合:
                                <__Context__.Consumer>: |
                                    <MyContext.Consumer>
                                        {value => (/* valueを使用 */)}
                                    </MyContext.Consumer>
                    プロバイダー:  #// コンテキストの内容を設定します
                        関数コンポーネントの場合:
                            <__Context__.Provider>: |
                                function App() {
                                    const [value, setValue] = useState('初期値');
                                    return (
                                        <__Context__.Provider value={{ value, setValue }}>
                                            {children}
                                        </__Context__.Provider>
            ESLint を無効にする:  #search: disable ESLint
        ファイル:
            .tsx, .jsx ファイル:  #search: React component
                コメント:  #search: JSX comment
        （公開文書）:  #ref: ${GitHub}/Trials/try_Jest_TypeScript_React_VisualStudioCode/steps.yaml#Visual Studio Code
    React Router:  #keyword:  #// URL の変更から、表示するページの変更や、ページの一部の表示を変更します
        手順:  #keyword: install React Router
            インストールしてサンプルを表示します:
                React をインストールします:  #search: install React
                React Router をインストールします:  #// プロジェクトにインストールします
                    yarn add  react-router-dom  @types/react-router-dom  #// 1分
                子コンポーネントを 2つ作ります:  #search: React component example
                    MyComponent.tsx: |
                        import React from 'react';

                        export default function  MyComponent() {
                            return (
                                <div>MyComponent</div>
                            );
                        }
                    MyComponent2.tsx: |
                        import React from 'react';

                        export default function  MyComponent2() {
                            return (
                                <div>MyComponent2</div>
                            );
                        }
                ルート要素を置き換えます:
                    __Project__/src/index.tsx :  #focus: HashRouter
                        import { HashRouter } from 'react-router-dom';

                        ReactDOM.render(
                            <HashRouter>
                                ____
                            </HashRouter>
                        );
                React Router を設置します:
                    __Project__/src/App.tsx : |  #focus: Route
                        import React from 'react';
                        import './App.css';
                        import { Switch, Route } from 'react-router-dom';
                        import MyComponent  from './MyComponent';
                        import MyComponent2 from './MyComponent2';

                        function App() {
                            return (
                                <div className="App">
                                    <header className="App-header">

                                        <Switch>
                                            <Route exact path="/"  component={MyComponent}/>
                                            <Route exact path="/2" component={MyComponent2}/>
                                        </Switch>
                                    </header>
                                </div>
                            );
                        }

                        export default App;
                React の Web サーバーを再起動します:  #// ファイルが増えたため
                    - Ctrl + C
                    - yarn start
                ２つの URL で表示されるコンポーネントが異なることを確認します:
                    - http://localhost:3000/#/
                    - http://localhost:3000/#/2
            404 エラー を返します: #keyword: React 404,  React page not found
                CSR の場合:  #// 通常の場合。Client-Side Rendering
                    HTTP ステータスは 200 を返します。
                    見た目だけ 404 ページにします。
                    条件によってページが見つからないエラーを表示する場合、既存の無効な URL を入力したときにどうなるか確認します。
                    空欄のページであれば、関数コンポーネントであれば、reutrn <></> すればいいです
                SSR の場合:  #// Server-Side Rendering
                    HTTP ステータスは 404 を返すことができます。
                    SEOやクローラーを考慮する場合はSSRが必要。
        機能:
            基本動作:  #keyword: React Router basic
                サンプル コード: |  #focus: dashboard
                    ...
                            <Link to="/">Home</Link>
                            <Link to="/about">About</Link>
                            <Link to="/dashboard">Dashboard</Link>

                    <div>
                        <Switch>
                            <Route exact path="/" component={Home}/>
                            <Route path="/about" component={About}/>
                            <Route path="/dashboard" component={Dashboard}/>
                        </Switch>
                    </div>
                動き:
                    <Link to="/dashboard">Dashboard</Link> をクリックします:
                    URL が __Domain__/dashboard に変わります:
                    <Switch> の中は、URL にマッチする <Route> だけ表示されます:
                        #// Switch や Route は React コンポーネントです
                参考:
                    #search: React Router Link
                    #search: React Router Switch
                    #search: React Router Route
        構成:
            URL パラメーター:  #keyword: React Router URL parameters, React Route
                サンプル コード: |  #focus: group, __id__, __ChildComponent__
                    ...
                                <Link to="/group/about">About</Link>
                                <Link to="/group/dashboard">Dashboard</Link>

                    <Route path="/group/:__id__" children={__ChildComponent__} />

                    function __ChildComponent__() {
                        const { __id__ } = useParams();
                動き:
                    <Link to="/dashboard">Dashboard</Link> などをクリックします:
                    URL が __Domain__/dashboard に変わります:
                    path="/:__id__" にマッチします:  #// : はパラメーターであることを表します
                参考:
                    #search: React Router children
                    #search: React Router :
            routes.tsx, 変数への代入:  #// React コンポーネントと同じ扱いです
                サンプル:  #focus: root
                    routes.tsx: |
                        export const  root = (
                            <Switch>
                                <Route path="/____" component={____} />
                                <Route path="/____" component={____} />
                            </Switch>
                        );
                    App.tsx: |
                        import { root } from './routes';

                        function App(props: Props) {
                            return (
                                <div>
                                    {root}
                                </div>
                            );
                        }
                サイトマップ的に 1つのファイルにまとめます:
                    （参考）:
                        <Swtich>:  #search: React Router Switch
                        <Route>:   #search: React Router Route
                    routes.tsx: | #keyword: routes.tsx
                        export const  root = (
                            <Switch>
                                <Route path="/group1"  component="Group1" />
                                <Route path="/group2"  component="Group2" />
                            </Switch>
                        );

                        export const  group1 = (
                            <Switch>
                                <Route path="/____" component={____} />
                                <Route path="/____" component={____} />
                            </Switch>
                        );

                        export const  group2 = (
                            <Switch>
                                <Route path="/____" component={____} />
                                <Route path="/____" component={____} />
                            </Switch>
                        );
                    Group1.tsx: |
                        function Group1() {
                            return (
                                <div>
                                    {group1}
                                </div>
                            );
                        }
                    Group2.tsx: |
                        function Group1() {
                            return (
                                <div>
                                    {group2}
                                </div>
                            );
                        }
            コンポーネント:  #// ReactRouter のコンポーネント
                ReactRouter 名前空間:  #keyword: ReactRouter tag
                    タグ名を <ReactRouter.Route> などで指定する場合: |
                        import * as ReactRouter from 'react-router-dom';
                        const  child = (
                            <ReactRouter.Switch>
                                <ReactRouter.Route path="/____"> ____ </ReactRouter.Route>
                                <ReactRouter.Route path="/____"> ____ </ReactRouter.Route>
                            </ReactRouter.Switch>
                        );
                    タグ名を <Route> などで指定する場合: |
                        import { Switch, Route } from "react-router-dom";
                        const  child = (
                            <Switch>
                                <Route path="/____"> ____ </Route>
                                <Route path="/____"> ____ </Route>
                            </Switch>
                        );
                Link: #keyword: React Router Link  #// クリックする場所に配置します
                    参考:
                        Material-UI の Tab に React Router を使います:  #search: Material-UI Tab Router
                Switch: #keyword: React Router Switch  #// Route コンポーネントなどの親コンポーネントの位置に配置します
                    サンプル:  #search: React Router basic
                        <Switch>
                            <Route path="/____" component={____} />
                            <Route path="/____" component={____} />
                        </Switch>
                Route など Switch の子要素:  #// Route, Redirect
                    Route:  #keyword: React Router Route  #// URL によって表示または非表示になるコンポーネント
                        関連 >> タグ名を <ReactRouter.Route> などで指定する場合:  #search: ReactRouter tag
                        基本サンプル, element, component:  #keyword: React Router element
                            element:  #// React Router v6
                                <Route path="/:tab" element={<TabsWithParams />} />
                            component:  #keyword: React Router component  #// React Router v5
                                <Switch>
                                    <Route path="/____" component={____} />
                                    <Route path="/____" component={____} />
                                </Switch>
                        exact:  #// URL の全体一致  #focus: exact  #keyword: React Router exact
                            <Route exact path="/" component={____} />
                            #// exact がないと前方一致になり、URL が /about などでもマッチします
                        コンポーネント以外のとき:  #// component 属性を削除します
                            修正前: <Route path="/____" component={__Conponent__} />
                            修正後: <Route path="/____"> <__Tag__> ____ </__Tag__> </Route>
                        変数 __id__, path="/____/:__id__":  #// コロン(:)から始まるとき、続くシンボルは変数名です。対応するコンポーネントが変数値を受け取ります
                            children:  #// URL パラメーターを受ける子コンポーネント  #keyword: React Router children
                                <Route path="/group/:__id__" children={__ChildComponent__} />
                                #search: React Router URL parameters
                            Tabs ごとの URL:  #keyword: React Router Tabs
                                サンプル1:  #focus: tab, value
                                    JavaScript 部分:
                                        useState を使う場合: |  #// タブの選択状態を URL に入れない場合
                                            const [tab, setTab] = React.useState("contract" as ContractTab);
                                        URL (React Router) を使う場合:
                                            React Router v5.1 以降:  #keyword: React Router useParams
                                                const { tab } = useParams();
                                            React Router v5.0 以前: |  #focus: React Router match.params.tab
                                                import { withRouter, RouteComponentProps, useHistory } from 'react-router-dom';
                                                interface  Props { ____ }
                                                type  ComponentProps = Props & RouteComponentProps<{ tab: string }>;
                                                const  Component: React.FunctionComponent<ComponentProps> = props => {
                                                    const tab = match.params.tab;
                                                    ____
                                                }
                                                export const Contracts = withRouter(Component);
                                    routes.tsx:  #// URL (React Router) を使う場合
                                        <ReactRouter.Route exact path="/____/:tab" component={__Component__} />
                                    HTML 部分: |
                                        <__Component__>
                                            <Tabs
                                                value={tab}
                                                onChange={handleTabChange}
                                            >
                                                <Tab label="契約情報" key="contract" value="contract" />
                                                <Tab label="FQDN" key="site" value="site" />
                                            </Tabs>
                                            <div>
                                                {tab === "contract" && (
                                                    <Typography component="div">
                                    value:
                                        Tabs の value に一致する value を持つ Tab がアクティブになります
                                    label:
                                        表示内容
                                    key:
                                        静的なら、通常不要
                                    動作:
                                        1: URL 変更要求。const history = useHistory(); history.push(`/${newValue}`);
                                        2: URL 変更
                                        3: コンポーネントに URL の一部（変数）が渡る
                                        4: Tabs, Tab 要素の value 属性 でアクティブを選択
                                サンプル2:
                                    HTML 部分: |  #focus: Tabs, TabPanel, value
                                        <Box sx={{ width: '100%' }}>
                                            <Tabs 
                                                value={getTabValue()} 
                                                onChange={handleTabChange}
                                                aria-label="navigation tabs"
                                            >
                                                <Tab label="Home" />
                                                <Tab label="Profile" />
                                                <Tab label="Settings" />
                                            </Tabs>

                                            <TabPanel value={getTabValue()} index={0}>
                                                Home Content
                                            </TabPanel>
                                            <TabPanel value={getTabValue()} index={1}>
                                                Profile Content
                                            </TabPanel>
                                            <TabPanel value={getTabValue()} index={2}>
                                                Settings Content
                                            </TabPanel>
                                        </Box>
                                    getTabValue: |
                                        const getTabValue = () => {
                                            switch (location.pathname) {
                                                case '/home': return 0;
                                                case '/profile': return 1;
                                                case '/settings': return 2;
                                                default: return 0;
                                            }
                                        };
                                サンプル3: #keyword: Material-UI Tab Router
                                    サンプル コード:
                                        <Tab value="/contracts" label="契約情報" component={Link} to="/contracts"/>
                                    サンプル プロジェクト:  #ref: ${GitHub}/MyPrivateCode/react_examples/branch_react_router_material_ui
                                        プロジェクト(node_modules)を復帰します:  #search: resume React CentOS7
                                    関連:
                                        React Router をインストールします:  #search: install React Router
                        条件分岐:
                            有無: |  #focus: &&
                                {condition &&
                                    <Route path="/____" component={____} />
                                }
                            切り替え: |  #focus: ?, :
                                {condition ?
                                    <Route path="/____" component={____} />
                                ...
                                    <Route path="/____" component={____} />
                                }
                        Not Found (404):  #// 最後の Route に exact path="/*"
                            <Route exact path="/*" render={() => 'Not found.'} />
                    Redirect:  #keyword: React Router Redirect  #// URL をリダイレクトする設定
                        <Redirect to="/new" from="/old" />
                            #// /old にアクセスすると /new にリダイレクトされます。ブラウザーの URL も /new に変わります
                            #search: Next.js useRouter
                ルート要素: #// HashRouter, BrowserRouter
                    HashRouter:     #keyword: React Router HashRouter  #// URL のドメイン名の直後に # を入れる場合、ルートに配置します
                        import { HashRouter } from 'react-router-dom';

                        ReactDOM.render(
                            <HashRouter>
                                ____
                            </HashRouter>
                        );
                    BrowserRouter:  #keyword: React Router BrowserRouter  #// URL のドメイン名の直後に # を入れない場合、ルートに配置します
                        ReactDOM.render(
                            <BrowserRouter>
                                ____
                            </BrowserRouter>
                        );
                    StaticRouter:   #keyword: React Router StaticRouter  #// サーバーサイド レンダリング の場合、ルートに配置します
                内部定義コンポーネント:  #// Router.Cosumer, Router.Provider  #// React Router が自動的に作る内部コンポーネント
                    Router.Provider, Router.Cosumer:  #keyword:
                        概要: React Developer Tools で見ることができますが、コードには現れません
                        サンプル:
                            ...
                            <Switch>
                                <Router.Cosumer>                                       ← 内部定義
                                    <Route path="/____" component={__Component__} />
                                        <Router.Cosumer>                               ← 内部定義
                                            <Router.Provider>                          ← 内部定義
                                                <Container>                            ← 内部定義
                                                    <__Component__>
            その他:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#ReactRouter
        Snap Note:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#ReactRouter
        公開部分:  #ref: ${GitHub}/Trials/try_Jest_TypeScript_React_VisualStudioCode/steps.yaml#React Router
    Redux:  #keyword:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#Redux
        公開部分:  #ref: ${GitHub}/Trials/try_Jest_TypeScript_React_VisualStudioCode/steps.yaml#Redux
        注意:
            Reduxは大規模なアプリケーションで状態管理を予測可能にするのに役立ちますが、
            小さなプロジェクトではReactのuseReducerやuseContextなどの代替手段も検討すると良いでしょう。
        機能:
            - dispatch(action);
                Store が Reducer を呼び出します
            - immutable  #ref: ${typrm_files}/ref/JavaScript/ResuxStateManagement.html
            - ルート Reducer が状態ツリーの各部分を適切なサブ Reducer に渡す
            - ルート Reducer が各サブ Reducer からの結果を組み合わせて新しい状態ツリーを作成
            - Store が新しい状態ツリーを保存し、すべてのリスナーに通知
        構成:
            #↓ 状態遷移
            Store: #keyword: Redux store  #// 状態を保持します。変数に相当します
                サンプル コード: |  #focus: store
                    import { createStore } from 'redux';
                    import rootReducer from './reducers';
                    const store = createStore(rootReducer);
                    ReactDOM.render(
                        <Provider store={store}>
            Dispatch: #keyword: Redux dispatch  #// アクションをストアに送信するメソッド
                サンプル コード: |  #focus: dispatch
                    import { useSelector, useDispatch } from 'react-redux';
                    const dispatch = useDispatch();
                    dispatch({ type: 'ADD_TODO', payload: { text, id: Date.now() } });
                dispatch の引数:
                    Action です。type プロパティ を持つ オブジェクト リテラル が Action です
            Action: #keyword: Redux action  #// 変更内容のオブジェクト。type プロパティを持ちます
                dispatch の引数に指定します。
                詳細は dispatch の説明を参照  #search: Redux dispatch
            Reducer:  #// 現在の状態とアクションから新しい状態を計算する純粋関数。状態を直接変更せず、新しい状態オブジェクトを返す
                _: createStore の引数に指定します。状態の変更は純粋関数によってのみ行われます
                純粋関数: 同じ入力には常に同じ出力を返し、副作用がない関数
                サンプル: |  #focus: rootReducer
                    import { createStore } from 'redux';
                    import rootReducer from './reducers';
                    const store = createStore(rootReducer);

                    const initialState = {
                        todos: []
                    };

                    function rootReducer(state = initialState, action) {
                        switch (action.type) {
                            case 'ADD_TODO':
                                return {
                                    ...state,
                                    todos: [...state.todos, action.payload]
                                };
                            case 'REMOVE_TODO':
                                return {
                                    ...state,
                                    todos: state.todos.filter(todo => todo.id !== action.payload.id)
                                };
                            default:
                                return state;
                        }
                    }

                    export default rootReducer;
                Redux.combineReducers: #keyword:
            #↓ その他
            connect 関数: #keyword: Redux connect  #// React コンポーネントと Redux を接続します。React Hooks 登場前の主流な方法。最新は useSelector と useDispatch
                サンプル: |  #focus: connect,  MyComponent,  mapStateToProps,  mapDispatchToProps
                    import { connect } from 'react-redux';

                    const  MyComponent = ({ count, increment }) => (
                        <div>
                            <p>Count: {count}</p>
                            <button onClick={increment}>+1</button>
                        </div>
                    );

                    const  mapStateToProps = (state) => ({
                        count: state.counter.count
                    });

                    const  mapDispatchToProps = (dispatch) => ({
                        increment: () => dispatch({ type: 'INCREMENT' })
                    });

                    export default  connect(mapStateToProps, mapDispatchToProps)(MyComponent);
            Subscription:  #// Store の状態を監視します
        Redux logger:  #// redux middleware の 1つ
            ブラウザーのコンソールで値の変化の様子を確認できます
            #ref: https://qiita.com/tatapopo/items/3bdf2f3132948e3d75e3
    JSX, TSX:  #keyword: #// JavsScript と HTML を融合したソース  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#JSX
        コメント:  #keyword: JSX comment
            JavaScript 部分:
                // comment
            HTML タグ外: |
                {/* __Comment__ */}
                { // __Comment__
                }
            HTML タグ内: |
                <img  // __Comment__
                />
    デバッグ:
        React Developer Tools:  #keyword:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#ReactDeveloperTools
            インストール:
                Chrome, Edge: https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=ja
            ツールが使えるページ:
                公式: #ref:  https://ja.reactjs.org/docs/optimizing-performance.html
                ツールが使えるページかどうかを確認します:
                    メニュー: ブラウザー >> React Developer Tools のアイコン
                    赤い背景のアイコンのとき: フル機能が使えるページです
                    黒い背景のアイコンのとき: #// 一部の機能が使えないページです
                        できること:
                            コンポーネントを探します:
                                Edge >> F12 キー >> Components（タブ）>> Select an element in the page to inspect it ボタン（左上）
                                #search: React Developer Tools GUI source
                        できないこと:
                            source プロパティを表示します:
                                #search: React Developer Tools GUI source
            コンポーネントのツリーを表示します:  #// HTML のツリーは表示されません
                Edge >> F12キー >> 要素（タブの左の矢印ボタン） >> （HTML 要素をクリック） >> Components タブ
            UI部品に対応するコードの場所を探します (React Developer Tools):
                開発環境で React が表示される Web サーバーを起動します:  #// ビルドした後の Web サーバーではコードが書かれているパスは分かりません
                React Developer Tools で対象のコンポーネントの source プロパティを表示します:  #keyword: React Developer Tools GUI source
                    Edge >> F12 キー >> Components（タブ）>> Select an element in the page to inspect it ボタン（左上）>>
                    （対象の GUI 部品をクリック）>>（フォーカスされたツリーの項目をクリック）>>
                    source のグループ（右下）が表示されるまで左カーソルキーを押して親方向にたどります
                    #// source が全く存在しない場合、webpack-dev-server で React を起動すると source は表示されないようです
                コピーする場合:  #// 対象のコンポーネントのコードが書かれているフルパスと行番号をクリップボードにコピーします
                    Copy to clipboard ボタン（source の右上）
                表示する場合:  #// ソース コード をブラウザーに表示します
                    < > ボタン（右半分のビューの右上、クラスのコードが表示されます）
        値変更:  #// useState フックまたは props の値を変更します:
            useState を呼び出しているコンポーネントを探します:
                Edge >> F12 キー >> Components（タブ）>> Select an element in the page to inspect it ボタン（左上）>>
                （対象の GUI 部品をクリック）>>（フォーカスされたツリーの項目をクリック）>>
                hooks または props のグループ（右）が表示されるまで左カーソルキーを押して親方向にたどります
            useState の返り値を格納している変数の名前を表示します:
                Parse hook names ボタン（魔法のステッキ：hooks の右上）
            対象の hooks または props 値を変更します:
                値をクリック >> 値を入力 >> Enter キー
        ブレークポイントを張ります:  #keyword: React break point debug
            ソースマップが含まれている場合:
                ソース ファイルのパスが分かっている場合:
                    #// React Developer Tools は不要
                    対象のソース ファイルを表示します:
                        Edge >> F12キー >> Source タブ >> Ctrl + P (Open File)（全部閉じたときに Ctrl + P であることが表示されます）>>
                            （ソース ファイルがあるマシーンの中でのフルパスを入力します）（コピペします）>>
                            （すぐ下に表示された候補をクリックします）
                        #// フルパスで見つからないときは、ファイル名やパスの後半だけ入力します
                    ブレークポイントを張る行番号の左をクリックします:
                例外が発生した場所でブレークさせる場合:
                    例外で一時停止する ボタン（ステップ実行などのボタンの並びの最も右）
                GUI から探す場合:
                    React Developer Tools をインストールします:
                    対象のソース ファイルを表示します:  #search: React Developer Tools GUI source
                    ブレークポイントを張る行番号の左をクリックします:
            ソースマップが含まれていない場合:
                TypeScript: 表示できません
                JavaScript: ____.bundle.js を開くと、すべての JavaScript が表示できます
        コード変更:  #// TypeScript JavaScript をすぐに変更します
            Hot Module Replacement (HMR) を使う場合:  #// 変更した場所だけ置き換えます
                プロジェクト内のコードを変更して保存すると自動的にコンパイルしてブラウザーの内容を置き換えます
            ブラウザの開発者ツール を使う場合:  #// 未確認
                TypeScript の場合、対応する JavaScript を編集してください。
            #ref: ${typrm_files}/ref/JavaScript-AI.yaml#label: debug code edit
        関連 >> Chrome 開発者ツール:  #search: Chrome developer tools
    テスト: #keyword: React test
        Jest:
        React Testing Library (RTL):  #// ReactTestingTool
        関連 >> E2E test tools: #search:
    トラブルシューティング:
        - #// コードを変更したら Property 'newAttr' does not exist on type
            手順: コードを変更
            ログ: |
                Property 'newAttr' does not exist on type ____
            対処: React のプロセスを再起動します
        - #// 脆弱性情報（ほとんどありません） #ref: https://reactjs.org/blog/2018/08/01/react-v-16-4-2.html
        - #// ブラウザーにエラー、Error: Objects are not valid as a React child (found: [object Promise]).
            手順:
                サーバー起動後に初めてページを表示しようとしたとき
            ログ: | #keyword: Promise React child object
                Error: Objects are not valid as a React child (found: [object Promise]).
                If you meant to render a collection of children, use an array instead.
                    エラー: オブジェクトは React の子として有効ではありません (見つかりました: [オブジェクト Promise])。
                    子のコレクションをレンダリングするつもりだった場合は、代わりに配列を使用してください。
                This error happened while generating the page. Any console logs will be displayed in the terminal window.
                Call Stack
                    renderNodeDestructive
                        file:///C:/Users/aa/GitHub/MyPrivateCode/Next_js/next_js_zip_file_reader/node_modules/react-dom/cjs/react-dom-server.browser.development.js (5956:11)
                    renderIndeterminateComponent
                        file:///C:/Users/aa/GitHub/MyPrivateCode/Next_js/next_js_zip_file_reader/node_modules/react-dom/cjs/react-dom-server.browser.development.js (5598:7)
                    ...
            対応:
                _: 新しく追加した React コンポーネントについて Promise を返していないか確認します。
                修正前: |  #focus: Promise, async
                    async function  __Component__(): Promise<void> {
                修正後: |  #focus: __Handler__
                    function  __Component__() {
                        async function  __Handler__(event: any): Promise<void> {
                            ...
                        }
                        return (
                            <input type="file" onChange={ __Handler__ } accept=".zip" />
                        )
                async __Handler__:
                    async が付いた関数は、onChange などに直接指定します。
                    onChange={ __Handler__() } や
                    onChange={ return __Handler__ } ではエラーになります。
            補足:
                このエラーメッセージからどの React コンポーネント に問題があるかは分かりません。
        - #// ほとんどのコンポーネントが Anonymous と表示される
            手順: 
            エラー: ほとんどのコンポーネントが Anonymous と表示される
            対処:
                ビルドした React プロジェクトでは Anonymous と表示されるようです。
                開発環境で実行してください。
Vue.js: #keyword:
    #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#Vue_js
    computed 算出プロパティ: #keyword: JavaScript Vue.js computed property
        TypeScript:  #serach: JavaScript computed property
        Vue.js:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#Vue_computed
ESLint:  #keyword: ESLint
    参考: https://eslint.org/
    ESLint を無効にする:  #keyword: disable ESLint
            package.json: |
                {
                    "eslintConfig": {
                        "ignorePatterns": ["src/*", "!src/test.js"],
    ESLint の警告のルールの制御:
        参考: https://eslint.org/docs/user-guide/configuring/rules
        サンプル: |
            /* eslint eqeqeq: "off" */
        ルール:
            eqeqeq:
                内容: ==, != は NG、===, !== は OK。
                サンプル: |
                    /* eslint eqeqeq: ["off", "smart"] */
                smart（設定値）:
                    null との比較は == で OK（undefined でも true にするため）など
                    https://eslint.org/docs/rules/eqeqeq#smart
            その他: https://eslint.org/docs/rules/
        設定値: [ "off", "warn", "error" ]
        プロジェクト全体に対する警告の制御:
            注意: React の場合、設定を変更したら、サーバーの再起動が必要です
            package.json: |
                {
                    "eslintConfig": {
                        "rules": {
                            "eqeqeq": "off",
        １つのファイル全体に対する警告の制御:
            ファイルのどこかに下記のようなコメントを書きます:
                eqeqeq ルールを警告しない: |
                    /* eslint eqeqeq: "off" */
                eqeqeq ルールを警告、curly ルールをエラーにします: |
                    /* eslint eqeqeq: "warn", curly: "error" */
lodash:  #// 基本的なユーティリティ。最新 JavaScript の基本機能と重複しているものが多い  #keyword: lodash
    uniqueId: #keyword: lodash.uniqueId
        互換コード: |
            let uniqueId = (function() {
                let id = 0;
                return function(prefix = '') {
                    return prefix + (++id);
                }
            })();

            console.log(uniqueId('id_')); // id_1
            console.log(uniqueId('id_')); // id_2
    find: #keyword: lodash.find
        サンプル:  #focus: customers
            lodash.find(customers, x => x.name == keyword);
        互換コード: |
            customers.find(x => x.name == keyword)
    参考:
        基本: #ref: https://qiita.com/sonishimura/items/a08e28def541c28458a0
        lodash やめ方: #ref: https://qiita.com/mizchi/items/af17f45d5653b76f6751
Storybook:  #keyword: Storybook
    Storybook + React + TypeScript の環境構築:
        参考:
            - Storybook V5+React+TypeScriptで環境構築(古い情報): https://qiita.com/otanu/items/dd06d6702f673268c74e
            - 公式変更履歴: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#source-loader
        設定: #settings:
            __Project__: taskbox-ts
        Storybook をインストールします:
            #Git bash
            - cd  "__ParentOfProject__"
            - npx create-react-app "taskbox-ts" --typescript  #template: "__Project__"
            - cd "taskbox-ts"  #template: "__Project__"
            - yarn add --dev @storybook/cli
            - yarn sb init
        コンポーネント エクスプローラー(Storybook)を起動します（しなくてもよい）:
            #Git bash
            - cd  "__Project__"
            - yarn storybook
            - 自動的にブラウザー内で コンポーネント エクスプローラーが起動します
            - コンポーネント エクスプローラー（ブラウザーのタブ）を閉じます
            - シェルで Ctrl + C を押して「コンポーネント エクスプローラー」を終了します
        TypeScript に対応させ、推奨のアドオンを追加します:
            yarn add を実行します: |
                #Git bash
                cd  "__Project__"
                yarn add --dev @storybook/addon-knobs \
                    @storybook/addon-viewport \
                    @storybook/addon-storysource \
                    babel-loader@8.1.0 \
                    typescript \
                    react-docgen-typescript-loader \
                    @types/storybook__react \
                    @storybook/source-loader \
                    @storybook/addon-info \
                    @storybook/addon-console \
                    @types/storybook__addon-info \
                    @types/storybook__addon-actions \
                    @types/storybook__addon-knobs
            __Project__/.storybook/addons.js ファイルを新規作成します: |
                import '@storybook/addon-actions/register';
                import '@storybook/addon-links/register';
                import '@storybook/addon-knobs/register';
                import '@storybook/addon-viewport/register';
                import '@storybook/addon-storysource/register';
                import '@storybook/addon-console';
            __Project__/.storybook/webpack.config.js ファイルを新規作成します: |
                const path = require("path");

                // TypeScriptのソースをアドインに渡します
                module.exports = ({ config }) => {
                    config.module.rules.push({
                        test: /\.(ts|tsx)$/,
                        use: [
                        {
                            loader: require.resolve("react-docgen-typescript-loader")
                        },
                        {
                            loader: require.resolve('@storybook/source-loader'),
                            options: { parser: 'typescript' }
                        }
                        ]
                    });
                    config.resolve.extensions.push(".ts", ".tsx");
                    return config;
                };
            __Project__/.storybook/preview.js ファイルに下記を追加します: |
                import { configure } from '@storybook/react';
                import { setConsoleOptions } from '@storybook/addon-console';

                // コンソールログをActionsタブに表示します
                setConsoleOptions({
                    panelExclude: []
                });

                // TypeScriptで作成したストーリーを読み込みます
                function loadStories() {
                    let req = require.context("../src/stories", true, /.(tsx|js)$/);
                    req.keys().forEach(filename => req(filename));

                    req = require.context("../src", true, /.stories.(tsx|js)$/);
                    req.keys().forEach(filename => req(filename));
                }

                configure(loadStories, module);
        サンプルのコンポーネントを追加します:
            __Project__/src/components/Example/index.tsx にサンプルのコンポーネントを新規作成します: |
                import React, { useState, useCallback } from "react";

                export interface ExampleProps {
                    /** 表示するテキスト */
                    text: string;
                    /**
                    * true: テキスト表示 false: テキスト非表示
                    * @default false
                    */
                    flag?: boolean;
                    /** ボタンを押した時のイベントハンドラ */
                    action(): void;
                }

                const Example = (props: ExampleProps) => {
                    const { text, flag, action } = props;
                    const [count, countChg] = useState(0);
                    const countUp = useCallback(() => countChg(prev => prev + 1), []);
                    const countDown = useCallback(() => countChg(prev => prev - 1), []);

                    return (
                        <div>
                            {flag && <p>{text}</p>}
                            <button onClick={action}>ボタン</button>
                            <p>count:{count}</p>
                            <button onClick={countUp}>+</button>
                            <button onClick={countDown}>-</button>
                        </div>
                    );
                };

                export default Example;
            __Project__/src/components/Example/index.stories.tsx にストーリーを新規作成します: |
                import React from "react";

                import { storiesOf } from "@storybook/react";
                import { withKnobs, text, boolean } from "@storybook/addon-knobs";
                import { action } from "@storybook/addon-actions";

                import Example from "../Example";

                const components = storiesOf("Components", module);
                components
                    .addDecorator(withKnobs)
                    .add("Example", () => (
                        <Example
                            text={text("テキスト", "ああああ")}
                            flag={boolean("テキスト表示", true)}
                            action={action("ぽちっとな")}
                        />
                    ));
        コンポーネント エクスプローラー(Storybook)を起動します:
            #新しい Git bash
            - cd  "__Project__"
            - yarn storybook  #// 1回目約 2分、2回目約 1分半
            #// Conponents（左）の中にサンプルのコンポーネント Example があることを確認します
            #// コンポーネント エクスプローラー（ブラウザーのタブ）を閉じます
            #// シェルで Ctrl + C を押して コンポーネント エクスプローラー を終了します
        React アプリケーションを起動できることを確認します:
            #新しい Git bash
            - cd  "__Project__"
            - yarn start
            #// アプリケーションは React の初期状態 です
            #// エラーにならないことを確認します
            #// React アプリケーション（ブラウザーのタブ）を閉じます
            #// シェルで Ctrl + C を押して React アプリケーションを終了します
        テスト モード（Jest）が使えることを確認します:
            #新しい Git bash
            - cd  "__Project__"
            - yarn test --watchAll
            #// Tests:  __ passed, __ total と表示されることを確認します
    React 向け Storybook のチュートリアル:
        参考:
            - 公式: https://www.learnstorybook.com/intro-to-storybook/react/ja/get-started/
            - ReactでStorybook チュートリアルをやってみました。: https://qiita.com/fufujimoto/items/112fafc332df8bf3a55d
        準備:
            上記「Storybook + React + TypeScript の環境構築」を行います
    Chromatic: #keyword:  #ref: https://www.chromatic.com/docs/setup
        CLI: #keyword: https://www.chromatic.com/docs/cli
Atomic Design:  #keyword:  #glossary: Atomic Design  #ref: https://bradfrost.com/blog/post/atomic-web-design/
    #keyword: Atoms, Molecules, Organisms, Templates, Pages  #ref: ${programming}/ユーザインターフェイス/使い勝手.svg#AtomicDesign
    Atoms: #// 原子
    #// Atoms: 単独コンポーネント, Molecules: 複数組合せコンポーネント
    Molecules: #// 分子, 「モレキュール」, Atoms を組み合わせて作る部品。ほとんどない
    #// Molecules: ～が変わる, Organisms: 組み合わせによって意味/意図が変わらない
    Organisms:  #// 有機体, 「オーガニズム」（エッチなオーガズムではないw）,  ほとんどの部品はこれ
    #// Organisms: ～ができない, Templates: 配置を自由に変えることができる
    Templates:
    #// Templates: ～に依存しない, Pages: 実際のデータに依存する
    Pages:  
    参考:
        Atomic Design と、弊チームで扱うためのカスタマイズについて: #ref: https://qiita.com/putan/items/ec312314698087fca5b2
用語: #glossary:
    client side navigation: JavaScript でページが変わったように見せること。リンク先の HTML をロードしないため高速
    SPA: Single Page Application。複数のページをまとめることで、動作が素早くなったホームページ。
        クライアントサイドReactアプリ
    SSR: #search: サーバーサイド レンダリング
        関連:  #search: React Server Components  #search: React Server Functions
    SSG: Static Site Generation。ビルド時にレンダリングすることで、ダウンロードを早くしたホームページ
設定: #settings:
    __Proxy__: http://host:port
    __Project__: try_node_js
トラブルシューティング:
    VSCode:  #search: TypeScript VSCode debugger
    console.log が表示されない: #keyword: console.log
        Node.js:
            Visual Studio Code に表示されます
        React:
            ブラウザーのコンソールに表示されます
        オブジェクトの内容を表示する:
            toString:
                呼び出し側:
                    console.log(object);
                オブジェクト側: |
                    class Person {
                        toString(): string {
                            return `Person: ${this.name}, ${this.age} years old`;
                        }
            toJSON:
                呼び出し側:
                    console.log(JSON.stringify(object, null, 4));
                    #// property '____' closes the circle
                    #// というエラーになることがあります
                オブジェクト側: |
                    class  User {
                        toJSON() { return {
                            name: this.name,
                            point: this.point
                        }}
    throughCounter:
        #search: cc
    React Developer Tools:  #search: React Developer Tools
    デバッガーがブレークした後、勝手に終了する:
        #search: Node.js child_process.exec timeout
    ファイルを削除できなくなる: #keyword: Node.js remove file error  #// test_data/_checking を削除できなくなる fs.rmdirSync
        -   Windows で、正しくアクセスしなかったファイルを含むフォルダーを fs.rmdirSync
            すると、エクスプローラーからそのフォルダーの中に入れなくなります。
        -   処理しない範囲を狭めるときは、break や return ではなく /* */ で狭めてください。
            Node.js が許さないため
        -   Node.js の createReadStream の行のループで例外が発生するなどして全ての行をリードしないと不正なアクセスになります。
            #serach: exampleReadStream
            #keyword: Node.js file loop exception
    TypeScript の出力先:  #search: TypeScript outDir
    エラーメッセージ:
        - #// '____.js' implicitly has an 'any' type.ts(7016)
            手順: JavaScript のファイルを import する TypeScript を書いたとき
            ログ: |  #// from の右に
                '____.js' implicitly has an 'any' type.ts(7016)
            対処:
                .d.ts ファイルを JavaScript のファイルの隣に作ります  #search: .d.ts
        - #// UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block,
            手順: node JavaScript 実行
            ログ: |
                (node:7664) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 1)
            翻訳: |
                (node:7664) UnhandledPromiseRejectionWarning: UnhandledPromiseRejectionWarning: 未処理のプロミス拒否。このエラーは、catch ブロックのない非同期関数内でスローされたか、.catch() で処理されなかったプロミスを拒否したことで発生しました。未処理のプロミス拒否でノード プロセスを終了するには、CLI フラグ `--unhandled-rejections=strict` を使用します。 (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 1)
            対処:
                _____
        - #// [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated.
            手順: node JavaScript 実行
            ログ: |
                (node:7664) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
            翻訳:
                (node:7664) [DEP0018] 処理されない promise の拒否は非推奨です。今後、処理されない promise の拒否は、ゼロ以外の終了コードで Node.js プロセスを終了します。
            対処:
                _____
        - #// npm ERR! code ERESOLVE
            手順: npm ci
            ログ: |
                npm ERR! code ERESOLVE
                npm ERR! ERESOLVE could not resolve
                npm ERR! 
                npm ERR! While resolving: ts-jest@27.0.7
                npm ERR! Found: @types/jest@26.0.24
                npm ERR! node_modules/@types/jest
                npm ERR!   dev @types/jest@"^26.0.24" from the root project      // package.json に書いてある "@types/jest": "^26.0.24",
                npm ERR! 
                npm ERR! Could not resolve dependency:
                npm ERR! peerOptional @types/jest@"^27.0.0" from ts-jest@27.0.7  // ts-jest 27.0.7 は @types/jest ^27.0.0 を要求
                npm ERR! node_modules/ts-jest
                npm ERR!   dev ts-jest@"^27.0.7" from the root project           // package.json に書いてある "ts-jest": "^27.0.7",
                npm ERR! 
                npm ERR! Conflicting peer dependency: @types/jest@27.5.2
                npm ERR! node_modules/@types/jest
                npm ERR!   peerOptional @types/jest@"^27.0.0" from ts-jest@27.0.7
                npm ERR!   node_modules/ts-jest
                npm ERR!     dev ts-jest@"^27.0.7" from the root project
                npm ERR! 
                npm ERR! Fix the upstream dependency conflict, or retry
                npm ERR! this command with --force, or --legacy-peer-deps
                npm ERR! to accept an incorrect (and potentially broken) dependency resolution.
                npm ERR! 
                npm ERR! See /Users/totadashi/.npm/eresolve-report.txt for a full report.
                npm ERR! A complete log of this run can be found in:
                npm ERR!     /Users/totadashi/.npm/_logs/2024-07-21T23_53_38_979Z-debug-0.log
            __Project__/package.json: |
                "devDependencies": {
                    "@types/jest": "^26.0.24",
                    "@types/node": "^13.13.52",
                    "jest": "^27.3.1",
                    "ts-jest": "^27.0.7",
                    "ts-node": "^9.1.1",
                    "typescript": "^4.4.4"
            対処:  #focus: root project,  @types/jest
                #// package.json に書いてある問題があるモジュールのバージョンを、他のモジュールが要求するバージョン条件を満たすように変えます
                バージョンを上げる場合: npm install --save-dev @types/jest@^27.0.0  #focus: @types/jest
                    #// ^ があるので 27.0.0 またはそれより新しいバージョンがインストールされます
                バージョンを下げる場合: npm install --save-dev ts-jest@^26.5.6
                警告を無視する場合: npm ci --legacy-peer-deps
        - #// Cannot write file __Project__/build/____.d.ts' because it would overwrite input file
            手順: VSCode で tsconfig.json に対してエラー
            エラー: |
                Cannot write file __Project__/build/____.d.ts' because it would overwrite input file
            対処:
                TypeScript の出力フォルダー（上記の場合 build）を exclude します:
                    tscondif.json: |
                        {
                            "exclude": ["src/test_data", "node_modules", "build"]
        - #// EPERM: operation not permitted, lstat
            手順: ファイルを操作する Node.js の関数呼び出し
            エラー: |
                EPERM: operation not permitted, lstat '__FilePath__'
            対処:
                #search: Node.js remove file error
        - #// ReferenceError: Cannot access '__Class__' before initialization
            手順: new 演算子の実行時  #// オブジェクト生成時
            エラー: |
                ReferenceError: Cannot access '__Class__' before initialization
            対処:
                new 演算子 がグローバルにあるとき:
                    new を含む処理を関数の中に入れます
            原因:
                関数やインターフェースと違って、クラスはクラス定義に処理が通った後でそのオブジェクトを生成できます。
                関数呼び出しやインターフェースの参照は、コードをロードするときより後、実行前にできます。
        - #// SyntaxError: Cannot use import statement outside a module
            手順: node ____.js
            エラー: |
                SyntaxError: Cannot use import statement outside a module
                Error [ERR_REQUIRE_ESM]: Must use import to load ES Module: ____.js
            対処:
                __Project__/package.json に type module を追加します:
                    修正前: |
                        {
                        ...
                            "dependencies": {
                    修正後: |
                        {
                        ...
                            "type": "module",
                            "dependencies": {
        - #// SyntaxError: The requested module '__Module__' does not provide an export named 'default'
            手順: node ____.js
            エラー: |
                SyntaxError: The requested module '__Module__' does not provide an export named 'default'
            対処:
                修正前:
                    import __Symbol__ from '__Module__';
                修正後:
                    import { __Symbol__ } from '__Module__';
            原因:
                __Module__ が デフォルト エクスポート をサポートしていません。
        - #// CORS エラー
            エラー: |
                Access to fetch at '__TargetURL__' from origin '__CallerURL__' has been blocked
                by CORS policy: No 'Access-Control-Allow-Origin' header is present
                on the requested resource. If an opaque response serves your needs,
                set the request's mode to 'no-cors' to fetch the resource with CORS disabled.
            対処:
                express サーバーを CORS に対応する:
                    #search: express CORS
                no-cors を指定する場合:
                    注意: エラーではなくなりますが、データを取得できないので注意してください。
                    コード: |  #focus: no-cors, text
                        fetch('__TargetURL__', {mode: 'no-cors'})
                            .then(response => {
                                console.log(response);
                                response.text().then((text)=>{
                                    console.log(text);
                                });
                            });
        - #// esModuleInterop
            手順: VSCode 静的チェック
            エラー: |
                Module '"____"' can only be default-imported using the 'esModuleInterop' flagts(1259)
            対処:
                tsconfig.json : |
                    {
                        "compilerOptions": {
                            "esModuleInterop": true,
        - #// allowSyntheticDefaultImports
            手順: VSCode 静的チェック
            エラー: |
                This module can only be referenced with ECMAScript imports/exports by turning on the
                'allowSyntheticDefaultImports' flag and referencing its default export.ts(2497)
            対処:
                tsconfig.json : |  #keyword: allowSyntheticDefaultImports
                    {
                        "compilerOptions": {
                            "allowSyntheticDefaultImports": true,
        - #// Cannot find module 'node:url'
            手順: ビルド時
            エラー: |
                import {URL} from 'node:url';
                Cannot find module 'node:url' or its corresponding type declarations.ts(2307)
            対処:
                globby の場合:
                    バージョンを 11 に戻します
        - #// Cannot find module '____.cjs'  #keyword: import .cjs error
            手順: テキスト エディター で編集しているとき
            エラー: |
                Cannot find module '____.cjs' or its corresponding type declarations. ts(2307)
            対処:
                // @ts-ignore
                import ____ from './____.cjs';
            (@ts-ignore): #keyword:
                概要: 次の行の警告を無視します
                #// tsconfig.json の allowJs を true にしても .cjs はコンパイルされません
        - #// File '____/lib-cjs.js' not found. Matched by include pattern '**/*'
            手順: Node.js のプロセスを起動したとき
            エラー: |
                File '____/lib-cjs.js' not found.
                The file is in the program because:
                    Matched by include pattern '**/*' in '__Project__/tsconfig.json'
                File not found. The file is in the program because Matched by include pattern '**/*'
            対処:
                ファイルの拡張子 .cjs を .js に変更します
        - #// '____.ts' is not a module. ts(2306)
            手順: テキスト エディター で編集しているとき
            エラー: |
                File '__Project__/src/__snapshots__/main.test.ts.snap.ts' is not a module. ts(2306)
            対処A:
                export する関数などを 1つ以上定義します
            対処B:
                ____.d.ts ファイルを作り、export します  #search: .d.ts
        - #// Uncaught Error Error [ERR_REQUIRE_ESM]: require() of ES Module
            手順: const __Variable__ = require(__ModuleName__);
            エラー: |
                Uncaught Error [ERR_REQUIRE_ESM]: require() of ES Module ____/node_modules/__Module__/dist/index.js from __CallerJsPath__ not supported.
                ReferenceError: require is not defined in ES module scope, you can use import instead
            原因:
                __CallerJsPath__ が使っている __Module__ は ES モジュールですが、 CommonJS の require が使われています
            対処:
                ES モジュール に require を使わないようにします  #search: ES modules
                #search: JavaScript module type
        - #// ReferenceError: __dirname is not defined in ES module scope  #keyword: ReferenceError __dirname
            手順: Node.js のプロセスを起動したとき
            エラー: |
                ReferenceError: __dirname is not defined in ES module scope
            対処A:
                bash または PowerShell:
                    npm install --save-dev @types/node
                        #// @types/node をインストールしたときに Visual Studio Code が開いていたら閉じてください
            対処B:
                ファイル スコープ 変数 の場合:
                    import * as url from 'url';
                    import * as path from 'path';
                    const __filename = url.fileURLToPath(import.meta.url);
                    const __dirname = path.dirname(__filename);
                   #ref: https://stackoverflow.com/questions/64383909/dirname-is-not-defined-in-node-14-version
                注意:
                    Playwright Test for VSCode 拡張機能は、使えなくなります
            対処C:
                グローバル変数に定義する場合:  #keyword: g__dirname  #// __dirname はすでに定義されています
                    注意:
                        CommonJS の __dirname は、書かれているファイルによって値が変わりますが、
                        下記 g__dirname の定義がトランスパイルされたファイルがある場所と、同じ場所にあるトランスパイルされたファイルでは、問題なく使えます。
                    コード:  #keyword: file_esm.mts, file_esm.mjs  #ref: ${GitHub}/MyPrivateCode/Node_js/tradeBackTest/src/file_esm.mts  #search: support_node.cjs
                        file_esm.mts: |  #// アプリ用
                            import * as url from 'url';
                            import * as path from 'path';

                            declare global {export const  g__dirname: string} (globalThis as any).
                            g__dirname = path.dirname(url.fileURLToPath(import.meta.url));

                            export {}
                        file_esm.mjs: |  #// Jest 用
                            globalThis.g__dirname = __dirname;
            参考: |  #// カレント フォルダー
                    import * as path from "path";
                    var  currentFolder: string = path.resolve();
                #ref: https://stackoverflow.com/questions/64383909/dirname-is-not-defined-in-node-14-version
        - #// ReferenceError: require is not defined in ES module scope, you can use import instead
            手順: Node.js のプロセスを起動したとき
            エラー: |
                ReferenceError: require is not defined in ES module scope, you can use import instead
                This file is being treated as an ES module
                because it has a '.js' file extension and '__PackageJSON__' contains "type": "module".
                To treat it as a CommonJS script, rename it to use the '.cjs' file extension.
            対処: #// 以下のいずれか
                - ES module の中では require は使えません。import を使ってください。
                    #search: ES modules
                - 拡張子を .cjs に変更して CommonJS とし、require をお使いください。
                    #search: import .snap
        - #// Uncaught Error [ERR_MODULE_NOT_FOUND]: Cannot find module '__TargetPath__' imported from __SourcePath__
            手順: Node.js のプロセスを起動したとき
            エラー: |
                Uncaught Error [ERR_MODULE_NOT_FOUND]: Cannot find module '__TargetPath__' imported from __SourcePath__
            エラー type B: |
                (node:17084) ExperimentalWarning: The Node.js specifier resolution flag is experimental. It could change or be removed at any time.
            対処:
                import 文に拡張子を書いていないとき:  #keyword: JavaScript import extension
                    import 文の例: import * as lib from "./lib";  #// ./lib.ts ファイルや　./lib.js ファイルはある
                    対処:
                        node コマンドを使って起動するとき:  #// --no-warnings --experimental-specifier-resolution オプションを使います
                            Node.js 18.x:
                                node --no-warnings --es-module-specifier-resolution=node  build/app.js
                            Node.js 14.x:
                                node --experimental-modules --es-module-specifier-resolution=node  build/app.js
                        VSCode の JavaScript Debug Terminal で npm test を起動するとき:
                            tsconfig.json: |
                                {
                                    "compilerOptions": {
                                        "moduleResolution": "node"
                    ES2015 での対策, ES2020 では非推奨の対策:
                        .ts ファイルに書く import 文に ____.ts の代わりに ____.js を指定します:
                            import ____ from '___.js';
                            #// node コマンドを使って起動するときは動作しますが、TypeScript の開発環境ではエラーになります
                    参考:
                        Node.js v12のES Modulesと、Babel/TypeScriptの対応について:
                            #ref: https://qiita.com/shimataro999/items/8a63ec06f33ccd2ea9ca
                        ES modules では、ファイル拡張子の自動解決は行われません。:
                            #ref: https://stackoverflow.com/questions/63459159/omit-the-file-extension-es6-module-nodejs
                            #ref: https://stackoverflow.com/questions/51452743/importing-using-relative-paths-in-node-js-with-es-modules
                        最近のTypeScriptのES Modules対応事情: #ref: https://blog.zelkova.cc/2021/10/typescript-esmodules.html
        - #// error TS18003: Build:No inputs were found in config file '____/tsconfig.json'. Specified 'include' paths were '["**/*"]' and 'exclude' paths were '____'.
            手順: VSCode を開いたとき
            エラー:
                tsconfig.json ファイルの先頭: |
                    error TS18003: Build:No inputs were found in config file '____/tsconfig.json'. Specified 'include' paths were '["**/*"]' and 'exclude' paths were '____'.
            対処:
                VSCode を再起動します
        - #// FATAL ERROR: invalid array length Allocation failed - JavaScript heap out of memory
            手順: テキスト エディター で編集しているとき
            エラー: |
                FATAL ERROR: invalid array length Allocation failed - JavaScript heap out of memory
            対処:
                無限ループや無限再帰しないようにコーディングします
        - #// json_parse_exception Invalid UTF-8 start byte
            手順: Java による JSON パース。 Ascii 文字以外の文字を含む JSON データをシェルから指定  #keyword: shell JSON Invalid UTF-8
            エラー: |
                {"error":{"root_cause":[{"type":"json_parse_exception","reason":"Invalid UTF-8 start byte 0x8d\n
                at [Source: (org.elasticsearch.common.io.stream.InputStreamStreamInput); line: 2, column: 41]"}]
            対処:
                kuromoji プラグインをインストールしてください:  #search: kuromoji
                JSON データを UTF-8 形式でファイルに書き、コマンドにファイル名を指定します: |
                    curl -X  GET  http://localhost:9200/museum/_search  -H "Content-Type: application/json" --data-binary @sample_query.json
            メモ:
                成功します: |
                    curl -X  GET  http://localhost:9200/museum/_search  -H "Content-Type: application/json" -d '{
                        "query": {"match_phrase": { "city_id": "13101" } }
                    }'
                失敗します: |
                    curl -X  GET  http://localhost:9200/museum/_search  -H "Content-Type: application/json" -d '{
                        "query": {"match_phrase": { "name": "国立" } } 
                    }'
        - #// The 'arguments' object cannot be referenced
            手順: arguments に対する警告  #search: js arguments
            エラー: |
                The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5.
                Consider using a standard function expression.
            対処:
                処置前:
                    () => { argurments }
                処置後:
                    function () { argurments }
        - #// ECMAScript 5 and higher.
            手順: TypeScript の文法エラー
            エラー: |
                Accessors are only available when targeting ECMAScript 5 and higher.ts(1056)
                https://stackoverflow.com/questions/41010780/accessors-are-only-available-when-targeting-ecmascript-5-and-higher
            対処:
                __Project__/tsconfig.json: |
                    {
                        "compilerOptions": {
                            "target": "es5",
        - #// Must use import to load ES Module
            ケース: node のスクリプトを起動
            Error: |
                Error [ERR_REQUIRE_ESM]: Must use import to load ES Module:
            対処法A: ES modules のプロジェクトに変更します  #search: ES modules
            対処法B: node_modules を作り直してください
            対処法C:  #// CommonJS に戻す
                indent-string:
                    node_modules/indent-string/package.json :
                        変更前: |
                            "type": "module"
                        変更後: |
                            "type": "commonjs"
                    node_modules/indent-string/index.js :
                        変更前: |
                            export default function indentString
                        変更後: |
                            module.exports.default = function indentString
        - #// Error: EISDIR: illegal operation on a directory
            ケース: VSCode に Jest 拡張機能を追加
            Error: |
                Error: EISDIR: illegal operation on a directory, realpath '__Path__'
            対処法: プロジェクトを RAM ディスクの外に移動します
            メモ: RAM ディスク imdisk は使うべきではないらしい
            参考: https://github.com/nodejs/node/issues/6861
        - #// Jest file 0 matches
            ケース: VSCode に Jest 拡張機能を追加した環境で、コード中に追加された Debug ボタンを押した
            Error: |
                testMatch: **/__tests__/**/*.+(ts|tsx|js), **/?(*.)+(spec|test).+(ts|tsx|js) - 0 matches
            対処法: テストのファイル名を *.test.ts などに修正してください。
                成功したテストの上の Debug ボタンは消えますが、テストに失敗すると Debug ボタンが現れます。
        - #// TypeScript emitted no output for ____.tsx
            エラー: TypeScript emitted no output for ____.tsx
                .js ファイルなどを出力できなかった
            原因: |
                tsconfig.jsonで["noEmit": true]と記載していると、発生します。
                noEmitとは、ファイルを出力しないようにするための設定で、TypeScriptからもファイルを出力する場合、削除します。
            対処法A:
                tsconfig.json の noEmit を 削除します。
            対処法B: |
                tsconfig.jsonで["noEmitOnError": true] を設定している場合、他のエラーを直すと、このエラーが直りそうです
            参考:
                - https://thomasjs8.hatenablog.com/entry/2019/09/13/010457
                - https://stackoverflow.com/questions/55304436/webpack-with-typescript-getting-typescript-emitted-no-output-error/55304691
        - #// can only be directly nested in external modules or ...
            エラー: Augmentations for the global scope can only be directly nested in external modules or ambient module declarations.
            対処: グローバル スコープの拡張は、外部モジュールまたはアンビエント モジュール宣言内でのみ直接入れ子にすることができます。
            修正前: |
                declare global {
            修正後: |
                export {};
                declare global {
            参考: https://stackoverflow.com/questions/57132428/augmentations-for-the-global-scope-can-only-be-directly-nested-in-external-modul
        - #// Type 'Map<number, string>' is not an array type or a string type. Use compiler option '--downlevelIteration' to allow iterating of iterators.ts(2569)
            手順: |  #// new Map の中の map1, map2 にコーディング時エラー
                const  map1 = new Map<number, string>([[1, 'A'],  [3, 'B']]);
                const  map2 = new Map<number, string>([[3, 'BB'], [7, 'C']]);
                var merged = new Map([...map1, ...map2]);
            エラー: |
                Type 'Map<number, string>' is not an array type or a string type. Use compiler option '--downlevelIteration' to allow iterating of iterators.ts(2569)
            対処:
                tsconfig.json: |
                    {
                        "compilerOptions": {
                            "target": "es2015",
                            "module": "es2015",
                            "lib": [ "es2015" ],
        - #// Warning: Each child in a list should have a unique "key" prop.
            手順: Next.js でレンダリングしたとき
            エラー: |  #// ブラウザーのコンソール
                Warning: Each child in a list should have a unique "key" prop.
            対処:
                map で繰り返し HTML 要素を並べているときは、map に指定した関数の返り値の中で最も親のタグのプロパティに key を追加します。
                <li> タグとは限りません。
        - #// Fix the upstream dependency conflict, or retry
            手順: npm install
            エラー: |
                npm ERR! While resolving: ts-jest@27.1.5
                npm ERR! Found: @types/jest@26.0.24
                npm ERR! node_modules/@types/jest
                npm ERR!   dev @types/jest@"^26.0.24" from the root project
                npm ERR! 
                npm ERR! Could not resolve dependency:
                npm ERR! peerOptional @types/jest@"^27.0.0" from ts-jest@27.1.5
                npm ERR! node_modules/ts-jest
                npm ERR!   dev ts-jest@"^27.0.7" from the root project
                npm ERR! 
                npm ERR! Conflicting peer dependency: @types/jest@27.5.2
                npm ERR! node_modules/@types/jest
                npm ERR!   peerOptional @types/jest@"^27.0.0" from ts-jest@27.1.5
                npm ERR!   node_modules/ts-jest
                npm ERR!     dev ts-jest@"^27.0.7" from the root project
                npm ERR! 
                npm ERR! Fix the upstream dependency conflict, or retry
            package.json: |
                "devDependencies": {
                    "@types/jest": "^26.0.24",
                    "jest": "^27.3.1",
                    "ts-jest": "^27.0.7",
            対処:
                package.json を編集します
                    @types/jest@26.0.24 => @types/jest@27.0.7
        - #// EPROTO: protocol error, symlink '____' -> '____'
            手順:
            エラー: |
                npm ERR! code EPROTO
                npm ERR! syscall symlink
                npm ERR! path ../@babel/parser/bin/babel-parser.js
                npm ERR! dest /vagrant/try_TypeScript_Node_js/node_modules/.bin/parser
                npm ERR! errno -71
                npm ERR! EPROTO: protocol error, symlink '../@babel/parser/bin/babel-parser.js' -> '/vagrant/try_TypeScript_Node_js/node_modules/.bin/parser'
            状況:
                npm を実行した VM のホスト OS が Windows で共有フォルダーで実行している場合
            対処:
                Linux の 共有フォルダーの外にプロジェクトを移動し、npm を実行します
        - #// Conversion of type '__Type1__' to type '__Type2__' may be a mistake because neither type sufficiently overlaps with the other.
            手順: interface に返す、または渡す
            エラー: |
                Conversion of type '__Type1__' to type '__Type2__' may be a mistake because neither type sufficiently overlaps with the other.
                    タイプ '__Type1__' からタイプ '__Type2__' への変換は、どちらのタイプも他方と十分にオーバーラップしないため、誤りである可能性があります。
                If this was intentional, convert the expression to 'unknown' first.
                    これが意図的なものである場合は、最初に式を「unknown」に変換してください。
                Type '__Type1__' is missing the following properties from type '__Type2__': __Property1__, __Property2__
                    タイプ '__Type1__' には、タイプ '__Type2__' の次のプロパティがありません: __Property1__, __Property2__
            対処:
                __Property1__, __Property2__ を追加します
        - #// Object is possibly 'undefined'
            手順: process.env.HOME.replace(...)
            エラー: |
                Object is possibly 'undefined'
                オブジェクトはおそらく未定義です
            対処: |
                if (process.env.HOME) {
                    process.env.HOME.replace(...)
                }
            原因:
                オブジェクトは未定義になる場合があるためです。
                （「おそらく未定義」は適切な和訳ではないかも）
