#keyword: Git.yaml, Git  #ref: ${programming}/方法論/CVS/Git.svg
サンプルのテンプレート: 
    一般: #search: release branch
    一時リポジトリあり:  #search: git rebase commit
    .git フォルダーをバックアップします: #search: git backup example
概念: #keyword: Git concept  #glossary: Git  #// ブランチ、タグ、サブモジュール、Git が定義する概念
    リポジトリ:  #keyword: Git repository,  Git server,  Git origin
        ローカル, リモート: #keyword: Git local reposiroty, Git remote repository
            ローカル: ワーキング フォルダー があるマシンにあるリポジトリ  #search: Git local repository
            リモート:  #// サーバーにあるリポジトリ
                場所:  #search: show Git repository
            アップストリーム: #keyword: Git upstream  #// ブランチの上流（upstream）に設定されている リモート ブランチ
        作成:  #serach: Git new repository
        場所: #keyword: show Git repository
            参照: git remote -v
            設定:  #search: git remote set-url
    コミット: #keyword: git commit  #serach: git commit command  #ref: https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History
        ❗注意: プライベート リポジトリ のコミットのハッシュ値は外部に漏らすと、そのコミットやブランチが外部に漏れる可能性があります。
            （署名付き URL と同様の扱いが必要です）
            #ref: https://gigazine.net/news/20240725-github-anyone-can-access-hidden-repository/
        手順:
            基本 >> 作成: git commit -m "__CommitMessage__"  #search: git commit
            コミットする:
                メッセージのサンプル: #keyword: git commit message example
                    - Add ____ function.
                    - Support ___ing
                    - Fix typo.
                    - Address reviewers comments. Address feedback.   #keyword: Address reviewers comments
                違うブランチでファイルを編集した場合: #keyword: Git incorrect branch edit
                    git commit する前の場合:
                        ブランチの切り替え:
                            - git status  #// add する前（赤い表示）がある状態であること
                            - git checkout __CorrectBranch__  #// add する前の差分がそのまま切り替えた後のブランチにできます
                    git diff で作ったパッチを適用する場合: #search: git apply
                    一部の変更を別のブランチに適用する場合: #keyword: Git part commit another branch
                        git cherry-pick を使う場合:  #search: git cherry-pick
                        git apply を使う場合:
                            概要:
                                あるブランチ ours を編集している間に、他のブランチ theirs でも編集すべき編集があった場合、
                                一部の編集については、両方のブランチで同じ編集を行い、theirs から ours へのマージを記録します。
                            手順:
                                ours をコミットします:
                                    適当なタイミングで編集内容をコミットします  #// theirs で編集すべき内容も含みます。編集内容を失わないために。
                                theirs をコミットします:
                                    パッチを作ります:
                                        ours のコミットの差分に相当するパッチを作ります
                                        #search: make git diff
                                    theirs にパッチを適用します:
                                        コマンド:
                                            git checkout __Theirs__
                                            git apply ~/_git_patch.diff
                                            #search: apply git diff
                                        No such file or directory エラーが出たとき:
                                            ~/_git_patch.diff を テキスト エディタ― で開いて、エラーが出たファイルについての差分を削除します。
                                    適用しない編集内容を元に戻します:  #// 行単位ではなく、ファイル単位で git add を取り消す機能を活用して効率よく戻します
                                        #search: VSCode source control old commit
                                    theirs をコミットします:
                                マージを記録します:
                                    theirs から ours へのマージを行います（記録します）。
                                    #// こうすることで、theirs の変更（ours で変更しない内容）を受け入れるマージが後でもできるようになります。
                git commit、署名付きコミット:  #// git commit コマンドの実行、または、署名付きコミットを行います
                    git commit -m "__CommitMessage__"
                    #serach: git commit command
                    #search: Git signed commit
                （必要なら）コミットをまとめます:
                    git reset コマンドを使う場合:
                        WIP のコミットが直前であれば、コミットをキャンセルしてからまとめてコミットすることができます
                        #search: git commit cancel
                    git rebase コマンドを使う場合:
                        #search: git rebase commit
                    git diff で作ったパッチを適用する場合:
                        #search: git apply
                git push コマンドを実行します:
                    #serach: git push
                コミット日時を証明します:
                    #search: Git commit date
                Shift-JIS のファイルをコミットします: #keyword: Git Shift-JIS
                    _: .gitattributes ファイルに __FileName__ diff=sjis を設定します
                    ____/.gitattributes:
                        example.csv diff=sjis
                    ____/example.csv:
                        (Shift-JIS のファイル)
                前回のコミットのメッセージなどを変更します:  #search: git commit --amend
                同じ内容のコミットを追加します:  #keyword: git commit --allow-empty
                    git commit --allow-empty  -m "__CommitMessage__"
                    #// 新しくコミットが作られます
                変更します:  #search: git commit --amend  #// 前回のコミットのメッセージを変更します
            更新があるときだけ自動的にコミットします:
                git status が clean でないときに git commit するスクリプト:
                    #search: git commit back up
            コミットをまとめます:  #keyword: Git commit squash
                新しいブランチを作る場合:  #// git push した後の場合
                    git diff を使わない場合:  #// まとめるコミットが少ない場合
                        ローカルのコミットを削除します:  #// 以下のいずれか
                            - git reset --soft HEAD^   #// 末尾の ^ は必要です
                            - git reset --soft HEAD~3  #// 3つのコミットをキャンセルします
                        stash 経由で新しいブランチを作ります:
                            git stash
                            git checkout -b __NewBranch__
                            git stash pop
                            git add "."
                            ...
                git reset を使う場合: #keyword: git soft reset commit  #// まとめるコミットが多い場合
                    まとめた結果の内容があるコミットにします:
                        git checkout __ContentsCommitID__
                    新しくコミットを作る場所に、内容を変えずに、HEAD を移動します:
                        git reset --soft __PreviousCommitID__
                    コミットします:
                        git commit -m "____"
                        git push
                git diff を使う場合:  #// まとめるコミットが多い場合  #search: git apply
                    ❗非推奨: 推奨→ #search: git soft reset commit
                    WIP ブランチに最新の内容をコミットします:
                    パッチを作ります:
                        git diff __OldCommitID__ __NewestWipCommitID__ > ~/_git_patch.diff
                    __OldCommitID__ から（WIPではない）ブランチを新規作成するか、そのブランチに切り替えます:
                    パッチを適用します:
                        git apply ~/_git_patch.diff
                    コミットします:
                    __NewestWipCommitID__ と内容に違いが無いことを確認します:
                        git diff  __NewestWipCommitID__               
                git rebase を使う場合:  #search: git rebase commit
            コミットを分けます:  #keyword: split Git commit
                適用する内容を選んでコピーする場合:
                    最新コミットの一時ブランチを作ります:
                        git checkout -b __YourBranch__-new
                    分けた 1つ目のコミットを作ります:
                        普段作業していたブランチを、1つ目のコミットに移動します:
                            git branch -D __YourBranch__
                            git checkout -b __YourBranch__ __PreviousCommitID__
                        一時ブランチ(new)と比較を開始します:
                            #search: VSCode source control old commit
                        分けたコミットに入れる内容をコピーします:  #// 分けたコミット = 1つ前のコミットの新しい次のコミット
                            内容の確認:  #// 最新ファイルとの差分を表示します
                                左: 最新のコミット
                                右: 編集中のコミット
                            コピーします:
                                左から右へコピーするボタンを押します（左右の真ん中の → ボタン）
                                ファイルの内容を全部採用する場合は全部コピペします
                                    左半分をクリック >> Ctrl + A >> Ctrl + C >> 右半分をクリック >> Ctrl + V
                            関連:  #search: VSCode git diff branch commit merge
                        できたらコミットします:  #// 分けたコミットを、1つ目のコミットとします
                    分けた残りをマージします:
                        リベースします:
                            git checkout __YourBranch__-new
                            git rebase __YourBranch__
                        普段作業していたブランチを最新に戻します:
                            git checkout __YourBranch__
                            git merge __YourBranch__-new  #// Fast-forward
                        一時ブランチを削除します:
                            git branch -D __YourBranch__-new
                適用しない内容を選んでコピーする場合:
                    #// 書きかけ
                    分けた 1つ目のコミットを作ります:  #// 一時的に最新コミットの次に作ります
                        分けるコミットに新しいブランチを作ります:
                            git checkout -b __SplittingBranch__
                        1つ前のコミットと比較を開始します:
                            #search: VSCode source control old commit
                        分けたコミットに入れない内容に戻します:  #// 分けたコミット = 1つ前のコミットの新しい次のコミット
                            内容の確認:  #// 分ける前のファイルの差分を表示します
                                左: 1つ前のコミット
                                右: 編集中のコミット
                            戻します:
                                左から右へコピーするボタンを押します（左右の真ん中の → ボタン）
                                ファイルの内容を全部採用する場合は全部コピペします
                                    左半分をクリック >> Ctrl + A >> Ctrl + C >> 右半分をクリック >> Ctrl + V
                            関連:  #search: VSCode git diff branch commit merge
                        できたらコミットします:  #// 分けたコミットを、1つ目のコミットとします
                    分けたコミットを正しい位置に移動します:  #// 分けた 1つ目のコミットを、1つ前のコミットの次に移動します
                        普段作業していたブランチを、1つ目のコミットに移動します:
                            git branch -D __YourBranch__
                            git checkout -b __YourBranch__ __PreviousCommitID__
                        git diff でパッチを作り、適用します:  #search: git apply
                        （補足）分けた 1つ目のコミットを cherry-pick することはできません: |
                            $ git cherry-pick __FirstPartCommitID__
                                On branch ct_wag_2484
                                You are currently cherry-picking commit __FirstPartCommitID__.
                                    (all conflicts fixed: run "git cherry-pick --continue")
                                    (use "git cherry-pick --skip" to skip this patch)
                                    (use "git cherry-pick --abort" to cancel the cherry-pick operation)

                                nothing to commit, working tree clean
                                The previous cherry-pick is now empty, possibly due to conflict resolution.
                                If you wish to commit it anyway, use:

                                        git commit --allow-empty

                                Otherwise, please use 'git cherry-pick --skip'
            コミットを禁止します:  #search: disabled git commit
            コミットのメッセージなどを変更します:  #search: git commit --amend
        情報表示:
            コミットIDを表示します: #keyword: Git rev-parse commit ID
                bashlib:  #search: GetCommitID
                git:
                    コマンド:
                        #// 以下のいずれか
                        - git rev-parse --short HEAD
                        - git rev-parse --short __BranchName__
                        - git rev-parse __ShortCommitID__   #// 完全な commit ID。 GitHub の URL には短いコミットIDも指定できます
                        #// - git symbolic-ref --short -q __BranchName__  ||  git rev-parse --short __BranchName__
                    __BranchName__:
                        - ローカルに存在しないブランチ名を指定するとエラーになります
                        - タグ名を指定するとエラーにならず何かのハッシュ値が表示されます
                    #ref: https://stackoverflow.com/questions/47592077/show-git-branch-name-or-commit-id
                マージ ベース:  #// 枝分かれしたコミット、共通の祖先のコミット  #search: git merge-base
            コミットの情報を表示します: git show __CommitID__  #search: git show
            ファイルを表示します:  #search: GitHub code file  #// 指定したコミットのファイルの内容を GitHub で表示します
            VSCode で表示します: #keyword: VSCode git show commit,  VSCode commit,  git show VSCode,  VSCode git lens show commit diff
                コミット ID から:
                    コミット ID をコピーします >> VSCode >> F1 >> git lens show >>（コミットID）>> Inspect Commit Details
                関連 >> コミットの一部をコピーします:  #search: copy VSCode git diff commit
            コミット日時の一覧: #keyword: list git commit date  #// 指定のワイルドカードにマッチするファイルの最終コミット日時を一覧します
                git ls-files "__WildCard__" | xargs -I{} git log -1 --format="%ad %h %s - {}" --date=iso -- {}  |  sort -r
                    __Date__ __Time__ __TimeZone__ __CommitID__ __Action__ - __RPMFileName__
            コミット日時を証明します: #keyword: Git commit date
                概要:
                    証明するもの: コミット日時  #// クラウド ストレージ の更新日時で証明します
                    証明しないもの: コミットした人  #// コミットした人の証明は、署名付きコミット  #search: Git signed commit
                    背景: コミットの日時や、コミットに付いた署名の日時を詐称できてしまうため  #search: false Git commit date
                手順:
                    署名するとき, 日時を記録するとき: #keyword: save time stamp  #// タイムスタンプを付けてコミットの情報をクラウドに保存します
                        （サンプル）:  #search: Git push kaikei
                        （必要なら）署名付きコミットをします:  #// コミットした人を証明します
                            #search: Git signed commit
                        保存先を開きます:  #// 保存先の OneDrive または Google ドライブのフォルダーを開きます
                            https://onedrive.live.com/  >> （署名の保存先のフォルダー）
                            https://drive.google.com/   >> （署名の保存先のフォルダー）
                            #// OneDrive のほうが後で確認するときの手順が簡単です
                        コミットの情報を出力します:
                            - cd  __GitWorkingFolder__
                            - git log > ~/Desktop/2023-11-21.log  #// ファイル名を今日の日付に変えてください  #template: __Today__
                            #// すべてのコミットを出力します。もし途中のファイルを誤って編集したときでも証明できる可能性が高くなります
                        アップロードします:
                            出力ファイルがあるフォルダーを開きます:
                                open  ~/Desktop
                            アップロードします:  #// フォルダーの中からブラウザーへドラッグ＆ドロップします
                                2023-11-21.log  #// ファイル名を今日の日付に変えてください  #template: __Today__
                            #// 以後、このファイルを編集・削除しないでください。別のフォルダーへの移動はできますが、動作確認してから作業してください
                        ローカルに出力したファイルを削除します:
                            rm  ~/Desktop/2023-11-21.log  #template: __Today__
                    日時を証明するとき:  #// 過去に記録した日を確認します
                        保存先を開きます:  #// 保存先の Google ドライブまたは OneDrive のフォルダーを開きます
                            https://onedrive.live.com/  >> （署名の保存先のフォルダー）
                            https://drive.google.com/   >> （署名の保存先のフォルダー）
                        更新日時をチェックします:  #// ファイル名に含まれる日付が改ざんされていないことをチェックします
                            Google ドライブの場合:
                                リストレイアウト（表形式：右上）で一覧します。
                                詳細（(i)：右上）>> 履歴 タブ を表示します。
                                ファイル名に書かれた日付と、履歴の最新の日付に違いがないことをチェックします。
                                #// 最終更新の列に表示された日付は、ファイルのアップロード日ではなく更新日なので詐称できてしまいます。
                            OneDrive の場合:
                                リスト（右上）で一覧します。
                                ファイル名に書かれた日付と、更新日時の列に表示された日付（アップロード日）に違いがないことをチェックします
                                #// 情報（右上）>> 作成日（下へスクロール）でもチェックできます
                        コミット ID をチェックします:  #// git リポジトリにあるファイルの内容や、コミット日時が改ざんされていないことをチェックします
                            過去から現在までのファイルをダウンロードします。
                            それぞれのファイルに書かれた過去のコミットの コミット ID に変化がないことをチェックします。
                            最新の git log で表示される コミット ID にも過去から変化がないことをチェックします。
                                git log  > ~/Desktop/2022-12-24.log  #// ファイル名を今日の日付に変えてください
                    文書設定: #settings:
                        __Today__: 2023-11-21
                補足:
                    - コミットの内容だけでなく、コミット メッセージ やコミット日時だけを変えるだけでも、コミットID は変わります。
                    - 保存先が クラウド ストレージ の場合、日時を詐称することはできません
                        #ref: ${typrm_files}/ref/Git-AI.yaml#label: Git commit date
                関連:
                    コミット日時を詐称します:  #search: false Git commit date
                        #// 上記で証明する方法と異なる、コミット日時の詐称が無いことを厳密には証明できていない方法
                    みんなの電子署名:  #ref: https://es.vector.co.jp
            コミット日時を詐称します: #keyword: false Git commit date,  --amend --date  #// コミット日時の証明では対策済みです
                概要:
                    コミットするときに限り、コミットした OS の時計をずらすことで詐称できてしまいます。
                    ただし、手間がかかりますが、後から全部のコミットを置き換えることもできてしまいます。
                    証明する場合は  #search: Git commit date
                git push 前:
                    OS の日時を変更して、コミットに付いた署名の日時を詐称する場合:
                        制限:
                            OS の日時を変更した場合、コミットに付いた署名の日時も詐称できてしまいます
                        OS の時計の自動調整機能をオフにして、OS の日時を変更します:
                        コミット、または署名付きコミットをします:
                        署名の日時を確認します:
                            #search: git log --show-signature
                    --date オプションを使って、コミットの日時を詐称する場合:
                        制限:
                            --date オプションでは、コミットに付いた署名の日時を変更できません。OS の時計の日時になります  #search: git log --show-signature
                        コミット:
                            git commit --amend --no-edit --date="2022-12-23 19:00:00 +0900"
                                #// 現在より後でも前でも設定できます。前のコミットより前でもできます
                        git reflog --date=iso: |  #// reflog は日時の詐称はできないようですが、reflog はローカルにしか存在しません
                            1112222 HEAD@{2022-12-23 19:59:09 +0900}: commit (amend): __Message__
                            1113333 HEAD@{2022-12-23 19:58:54 +0900}: commit: __Message__
                        （メモ）:
                            下記のコマンドでは日時を変更できません:
                                GIT_COMMITTER_DATE="2022-12-23 21:00:00 +0900" git commit -m upp
                            #ref: https://stackoverflow.com/questions/68764231/can-someone-check-i-changed-the-date-of-git-commits
            コミットがブランチに含まれているか調べます:  #search: Git commit branch contains
        概念:
            コミットの属性:  #search: Git rev-parse commit ID
            前回のコミット, 親コミット:  #// マージしたときは複数の親が存在することになります
                #ref: https://stackoverflow.com/questions/38239521/what-is-the-parent-of-a-git-commit-how-can-there-be-more-than-one-parent-to-a-g
                前回のコミットのメッセージを変更します:  #keyword: git commit --amend,  git amend,  Git commit message
                    git push 前の場合:
                        git commit --amend -m "__NewCommitMessage__"
                    git push 後の場合:
                        --force-with-lease オプションを使う場合:
                            git commit --amend -m "__NewCommitMessage__"
                            git push --force-with-lease origin "__Branch__"
                        --force オプションを使う場合:
                            git commit --amend -m "__NewCommitMessage__"
                            git push --force origin "__Branch__"
                                #// この --forceオプションを使うと、同じブランチを他の人が編集した場合に、他の人の編集が削除されます。
                                #// コミットID は変わります。同じ位置にあったブランチやタグは コミットID が変わらず別のブランチになります。
                    日付は変わりません:
                        git commit --amend を実行してもコミットの日時や署名の日時は変わりません
                    過去の コミット メッセージ もまとめて変更する場合:  #search: git rebase reword
                過去の コミット メッセージ を変更します:  #search: git rebase reword
                編集者を修正します:  #// 前回のコミットの編集者を修正します
                    git push 前の場合:
                        Git に設定されている編集者を修正します:
                            #search: Git username example
                        コミットに設定されている編集者を修正します: #keyword: git amend author   #// Git に設定されている編集者に修正します
                            git commit --amend --author="$( git config user.name ) <$( git config user.email )>" --no-edit
                前回のコミットをキャンセルします: #keyword: git commit cancel  #// git reset --soft HEAD^
                    #search: git cancel
                    概要:
                        - 前回のコミットをキャンセルします
                        - コミットしていたファイルはステージ状態に戻ります。
                            それ以外は変わりません。たとえば、キャンセルする前のステージ状態はステージ状態のままになります
                        - ファイルの内容は変わりません。過去のコミットの内容に戻りません（--soft オプションを指定しているため）
                        - コミットが 1つ以下のブランチでは使えません
                    git push する前の場合:
                        git reset を使う場合:
                            コマンド:
                                - git reset --soft HEAD^   #// 末尾の ^ は必要です。ファイルの内容は変わりません
                                - git reset --soft HEAD~3  #// 3つのコミットをキャンセルします
                            詳細サンプル: |  #focus; reset
                                #// set up
                                    rm *
                                    #// 1st commit
                                        git init
                                        echo a > a.txt
                                        echo b > b.txt
                                        git add "."
                                        git commit -m 1st
                                    #// 2nd commit
                                        echo bb > b.txt
                                        git commit -m 2nd
                                #// Make working folder
                                    echo aaa > a.txt
                                    echo bbb > b.txt
                                    echo c > c.txt
                                    git add a.txt

                                #// Cancel previous commit
                                    git reset --soft HEAD^
                                #// Show the status
                                    git status
                                #// Output

                                    Changes to be committed:
                                    (use "git restore --staged <file>..." to unstage)
                                            modified:   a.txt
                                            new file:   b.txt

                                    Changes not staged for commit:
                                    (use "git add <file>..." to update what will be committed)
                                    (use "git restore <file>..." to discard changes in working directory)
                                            modified:   b.txt

                                    Untracked files:
                                    (use "git add <file>..." to include in what will be committed)
                                            c.txt
                            参考: #ref: https://qiita.com/shuntaro_tamura/items/06281261d893acf049ed
                        git reflog を使う場合:
                            #search: git cancel
                    git push した後の場合:
                        バックアップします:  #// ワーキング フォルダー の内容が変わってしまうため
                            cd  __ParentOfGitWorking__
                            cp  -ap  __Repository__  __Repository__-back-up
                            cd  __GitWorking__
                        ローカルのコミットcpを１つ破棄します:
                            git reset --hard HEAD^
                        # 念のため、変更前のブランチを作ります:
                        #     git branch  develop_old  __NewestCommitID__
                        #     git push origin  develop_old
                        リース付き強制プッシュします:  #// リモートのコミットをローカルのコミットに合わせます  #// 同様に最新のコミットが削除されます
                            _:  git push --force-with-lease
                            エラーになる場合:  #// 通常、リース無しの強制プッシュの場合に発生します
                                - #// You are not allowed to force push code to a protected branch on this project.
                                    手順: git push origin +develop
                                    エラー: |  #// GitLab の場合
                                        remote: GitLab: You are not allowed to force push code to a protected branch on this project.
                                        To https://gitlab.com/my/project/
                                        ! [remote rejected]   develop -> develop (pre-receive hook declined)
                                        error: failed to push some refs to 'https://gitlab.com/my/project/'
                                    対処:
                                        ブランチ保護を一時的に解除します:
                                            GitHub:  #search: GitHub branch protect
                                            GitLab:  #search: GitLab branch protect
                        # 成功したら、変更前のブランチを削除します:
                        #     #search: git branch delete
                        バックアップを復帰します:
                    指定のコミットと同じ内容にする場合:  #// .git フォルダーを置き換えます。
                        ❗注意：非推奨。編集者がすべて自分に置きかわってしまいます
                        対象の Git ワーキング フォルダー が VSCode で開いていないこと
                        cd _tmp
                        git clone  __URL__
                        cd  __Project__
                        git checkout  "__CommitID__"
                        git clone --no-checkout  __URL__  "_temporary"
                        rm -rf  ".git"
                        mv  "_temporary/.git"  "."
                        rm -rf  "_temporary"
                        git add  "."
                        git diff  "__CommitID__"
                        git commit -m "____"
                        gitlog
                        git push
                前のバージョン: #search: git log --follow
                コミットをまとめます: #search: Git commit squash
                マージ ベース:  #// 枝分かれしたコミット、共通の祖先のコミット  #search: git merge-base
                矢印の方向:  #// Git の解説では昔のコミットに向かって矢印を指します
                    理由: 内部構造がそうであるため。ドキュメントでは Gitの歴史を時間の経過として追う場合に直感的。
                        #ref: ${typrm_files}/ref/Git-AI.yaml#arrow
            HEAD: #keyword: Git HEAD  #// 最新コミットのステージング（git add したもの）
                HEAD:
                    clean 状態の場合: 現在のコミット
                    編集中の場合: 前回コミットしたときのコミット
                    git add した場合: 現在のワークの内容
                HEAD~, HEAD^:  #keyword: Git HEAD~, Git HEAD^
                    clean 状態の場合: 前回のコミット
                    編集中の場合: 前前回コミットしたときのコミット
                HEAD~2:  #keyword: Git HEAD~2  #// HEAD^2 は不可
                    clean 状態の場合: 2つ前のコミット
            ドロップ: #keyword: Git drop  #// 受け入れるコミットと同様の編集が済んでいるので、そのコミットを受け入れない（マージしない）こと
                マージするときの ソース ブランチ に含まれる受け入れるコミット（マージしようとしているコミット）のうち、
                同様の編集がすでに済んでいた場合、そのコミットのマージについてはスキップします。
                それをドロップと言います。git merge コマンドなどのメッセージに時々 drop と表示されます。
    ステージ, インデックス: #keyword: Git stage, Git index
        git add コマンドでファイルをステージに入れると、内部的にはファイルの内容（ハッシュ値等）を git のインデックスに反映します
    ブランチ: #keyword: Git branch,  branch  #// 作成コマンドの例： git checkout -b "__NewBranch__"
        現在のブランチの表示:  #search: Git current branch
        切り替え: #keyword: switch Git branch,  git checkout __Branch__  #// 現在のブランチを切り替えます
            コマンド: git checkout __BranchName__
            Visual Studio Code:  #keyword: VSCode current branch
                Git ブランチ名（ウィンドウ左下）>> 切り替え先のブランチ名
                #// 編集したファイルがあるときは stash するか破棄するかなどを選ぶように聞かれます
            切り替え後:
                git pull が必要な場合:  #keyword: Git behind
                    以下のメッセージが表示されます
                        Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded.
                git push がまだの場合:  #keyword: Git ahead
                    以下のメッセージが表示されます
                        Your branch is ahead of 'origin/master' by 1 commit.
            現在のブランチを切り替えずにローカルで使えるようにする場合:
                -   git branch __RemoteBranchName__  origin/__RemoteBranchName__
            現在のブランチを切り替えずにブランチを新規作成する場合:
                #search: git branch __NewBranchName__
        作成: #keyword: Git new branch, create Git branch  #// ブランチを作ります:
            新しいブランチを作り、そのブランチに変わります:
                現在位置からブランチを作ります:
                    設定: #settings:
                        __BaseBranchName__: develop
                        __NewBranchName__: test
                    (シェル):
                        - git status  #// クリーンな状態であることをチェックしてください
                        - git checkout  "develop"  #// ブランチの開始位置  #template: __BaseBranchName__
                        - git pull  #// 開始位置とするブランチの最新に移動

                        - git checkout  -b  "test"  #// ローカルにブランチを作成  #template: __NewBranchName__
                        - git push --set-upstream origin "test"  #// ブランチを push  #template: __NewBranchName__
                指定したタグからブランチを作ります:
                    git checkout  -b "__TemporaryBranchName__"  "__TagName__"  #// 通常 __TemporaryBranchName__ = __TagName__
                指定したコミットからブランチを作ります:
                    git checkout  -b "__TemporaryBranchName__"  "__CommitID__"
            カレント ブランチ を変えずに、新しいブランチを作ります:
                #// ワーキング フォルダー が編集中のときでも使えます
                -   git branch  __NewBranchName__  __TargetCommitID__  #keyword: git branch __NewBranchName__
                -   git branch  __NewBranchName__
        削除: #keyword: delete Git branch  #// ブランチを削除します。git branch -D __Branch__ と git push  --delete origin __Branch__
            注意: ブランチが作ってきた過去のコミットも削除されてしまいます。タグを作れば削除されません。
                ただし、2週間は完全削除（ガベージコレクション）されることはありません  #search: Git deleted branch commit
            ローカルのブランチを削除します:
                - git checkout  "__NotDeletingBranchName__"
                - git branch -D  "__DeletingBranchName__"
            リモートのブランチを削除します: #// ローカルのブランチも削除します
                - git checkout  "__NotDeletingBranchName__"  #// ブランチを切り替える
                - git branch -D  "__DeletingBranchName__"
                - git push --delete origin  "__DeletingBranchName__"
                #// 下記のエラーが出る場合  #search: git remote prune
                #// error: failed to push some refs to 'https://github.com/Takakiriy/patch-o'
            削除済みリモート追跡ブランチを削除します: #keyword: git prune branch  #// リモートで削除済みのブランチがローカルで表示されてしまうときに削除します
                git remote prune origin  #// または #search: git fetch -p
            リジェクトしたブランチ: #keyword: Git rejected branch
                #ref: ${typrm_files}/ref/Git-AI.yaml#label: removed branch
                削除したブランチを参照できるようにします:
                    #// 以下のいずれか
                    タグをつける:  #// 推奨
                        git tag archive/__BranchName__ pull-0000-last-commit
                    コミットID を別途メモする:
                ブランチを削除したときの動き:
                    - ブランチを削除してもコミットは残ります
                    - ただし、コミットのツリーには表示されなくなります
            復帰: #keyword: Git deleted branch commit  #// 削除したブランチのコミットの復帰
                _: ブランチが作ってきた過去のコミットも削除されてしまいます。タグを作れば削除されません。
                    ただし、2週間は完全削除（ガベージコレクション）されることはありません
                    #search: git gc
                復帰:
                    git checkout -b __NewBranch__ __DeletedCommitID__
                    #ref: ${typrm_files}/ref/Git-AI.yaml#label: git gc auto
            拒否されるとき:
                ブランチ名を変えてから削除します  #search: rename Git branch
            関連 >> ブランチがマージ済みか調べます:  #// マージ済みのブランチであれば削除してもブランチのコミットは残ります
                #search: git merge commit message
        アーカイブ: #keyword: Git branch archive,  Git old branch  #// 長い間更新が無い古いブランチの内容を一応残しておくためにタグに置き換えます
            _: 長い間更新が無い feature-A ブランチをアーカイブするときは、archive/feature-A というタグを作ります。
                タグがある限りコミットが ガーベージ コレクション (git gc) によって消えることはありません。
                    git gc tries very hard not to delete objects that are referenced anywhere in your repository. In particular, it will keep not only objects referenced by your current set of branches and tags
                    https://git-scm.com/docs/git-gc
                GitHub では以下の警告が出ます。この警告は無視できます。
                This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.
            コマンド: |
                git checkout __OldBranch__
                git tag  git tag -a  "archive/__OldBranch__"  -m "Change old branch to tag."
                git push origin  "archive/__OldBranch__"  #// git push だけ（パラメーターなし）ではサーバーに反映されません
                git ls-remote --tags | grep "archive/__OldBranch__"  #// サーバーにあることをチェックします
                git push --delete origin  "__OldBranch__"
                git checkout  "__YourBranch__"
                git branch -D  "__OldBranch__"
            ワンライナー コマンド:
                古いブランチを archive/ 付きの Git タグに置き換えます:  #// 古いブランチのプルリクはクローズされます
                    -   gitssh  #// SSH 接続に設定すること（gitssh はトグルです）
                    -   Branch="__OldBranch__"  &&  git tag -a  "archive/${Branch}"  -m "archive/${Branch}"  "origin/${Branch}"  &&  git push origin  "archive/${Branch}"  &&  git ls-remote --tags | grep "archive/${Branch}$"  &&  GIT_SSH_COMMAND="ssh -i $HOME/.ssh/hopgate_id_rsa" git push --delete origin  "${Branch}"  &&  git branch -D  "${Branch}"
                タグがリポジトリにあることをチェックします:
                    Branch="__OldBranch__"  &&  git ls-remote --tags | grep "archive/${Branch}$"
                ブランチがリポジトリにあることをチェックします:
                    Branch="__OldBranch__"  &&  git branch -r | grep "origin/${Branch}$"
            ブランチに戻す場合:
                git checkout -b "__OldBranch__"  "archive/__OldBranch__"
        改名: #keyword: rename Git branch  #// ブランチの名前を変えます (git branch -m)
            設定: #settings:
                __OldBranchName__: old
                __NewBranchName__: new
            シェル: |
                #// コミット後
                git pull
                git checkout  "old"  #// ブランチを切り替えます  #template: "__OldBranchName__"
                git branch -m  "old" "new"   #// ローカルのブランチ名を変更  #template: "__OldBranchName__" "__NewBranchName__"
                git push  "origin"  "new"  #// サーバーにブランチを作成  #template: "__NewBranchName__"
                #// 必要ならここでデフォルトブランチを変更します  #search: change Git default branch
                git push --set-upstream  "origin"  "new"  #// サーバーに push  #template: "__NewBranchName__"
                git push  --delete origin  "old"  #template: "__OldBranchName__"
        移動: #keyword: Git branch move,  remake Git branch  #// ブランチ（のHEAD）を移動します。古いコミットに戻すなど
            移動するブランチの現在のコミット以下を削除して ... いい場合:
                #// リモートにあるブランチも作り直します
                設定: #settings:
                    __DestinationBranchName__: develop
                    __SourceBranchName__: feature
                手順:
                    コミットします:
                        git status など
                    コマンド: |
                        git checkout  develop              #template: git checkout  __DestinationBranchName__
                        git branch -D  feature                    #template: git branch -D  __SourceBranchName__
                        git push --delete origin  feature         #template: origin  __SourceBranchName__
                        git checkout -b  feature                  #template: git checkout -b  __SourceBranchName__
                        git push --set-upstream origin  feature   #template: origin  __SourceBranchName__
            移動するブランチの現在のコミット以下を削除して ... いけない場合:
                #// ブランチを同じ名前で作り直します。指定の コミットID に作ります。
                設定: #settings:
                    __BranchName__: main
                    __CommitID__: 1111111
                    __BackUpBranchName__: master_old  #// このバックアップは重要です。無いとコミットが消えます
                シェル:
                    コミットします:
                        - git status など
                    共通の手順:
                        - git pull
                        - git checkout  "main"    #template: "__BranchName__"
                        - git branch -m  "main" "master_old"   #// ローカルのブランチ名を変更  #template: "__BranchName__" "__BackUpBranchName__"
                        - git push --set-upstream origin "master_old"  #template: "__BackUpBranchName__"
                    （デフォルト ブランチ を移動する場合）デフォルト ブランチ を master_old に変更します:  #template: __BackUpBranchName__
                        - #search: change Git default branch
                        - git pull
                    共通の手順 (2):
                        - git push  --delete origin  "main"  #template: "__BranchName__"
                        - git checkout -b  "main" 1111111  #// ローカルにブランチを作成       #template: "__BranchName__" __CommitID__
                        - git push --set-upstream origin "main"  #// ブランチを push  #template: "__BranchName__"
                    （デフォルト ブランチ を移動する場合）デフォルト ブランチ を main に変更します:  #template: __BranchName__
                        - #search: change Git default branch
                        - git pull
                    （バックアップのブランチを削除する場合）:
                        - git branch -D  "master_old"              #template: "__BackUpBranchName__"
                        - git push  --delete origin  "master_old"  #template: "__BackUpBranchName__"
                参考:
                    Gitのデフォルト・ブランチ名を変更する方法:
                        #ref: https://parashuto.com/rriver/tools/change-git-default-branch-name#push-to-remote
                    GitリモートHEADをマスター以外のものを指すように変更する:
                        #ref: https://stackoverflow.com/questions/1485578/change-a-git-remote-head-to-point-to-something-besides-master
        一覧: #keyword: list Git branch
            ローカル:  git branch  #// ローカルにあるブランチを一覧します:
            ローカルとサーバー（リモート）:  #// git branch --all  #// ローカルにあるブランチとサーバーにあるブランチを一覧します
                サンプル: |
                    $ git branch --all
                    *   main
                        remotes/origin/HEAD -> origin/main
                        remotes/origin/main
            サーバー:  #// サーバーにブランチがあるかどうかを確認します
                local  branchExists="${False}"
                git branch --all | grep "remotes/origin/__BranchName__"  &&  branchExists="${True}"
            全ブランチと全タグ:
                git fetch --all --tags  &&  git show-ref
                    __Hash1__ refs/heads/__LocalBranch__
                    __Hash2__ refs/remotes/origin/__RemoteBranch__
                    __Hash3__ refs/tags/__Tag__
            特定ユーザー: #keyword: Git author branches  #// 特定ユーザーが編集したブランチを一覧します
                _: 全ブランチの最新コミットのうち、特定の編集者が作成したコミットのブランチを一覧します
                スクリプト git-branches-from-author: | #keyword: git-branches-from-author
                    #!/bin/bash
                    AuthorName="$1"

                    if [ "$1" == "" ]; then
                        echo  "git-branch-from-author"
                        echo  "This lists up branches edited by specfied author."
                        echo  "usage: git-branch-from-author __AuthorName__"
                        exit
                    fi

                    git fetch --all

                    git branch -a --sort=-committerdate | while read Branch; do
                        CommitAuthor=$(git log -1 --format='%an' "${Branch}");

                        if [[ "${CommitAuthor}" == "${AuthorName}" ]]; then
                            echo "${Branch}"
                        fi
                    done
            全ブランチをチェックアウト: #keyword: extract_git_branches  #// ブランチをすべてチェックアウトします。 branch_____ フォルダーを更新します
                .git フォルダーを復活します:
                    新しく extract_git_branches フォルダーを作ります:
                    .git.zip を extract_git_branches フォルダーにコピーします:
                    Git bash:
                        - cd  ____/extract_git_branches
                        - unzip  .git.zip
                        - rm  .git.zip
                ブランチをすべてチェックアウトします:
                    PowreShell:  #// Git bash ではフォルダーを見つけることができません
                        - cd  ____/extract_git_branches
                        - extract_git_branches
                        - .git  #// .git folder path> への入力
                            #// ____/extract_git_branches/branch_____ フォルダーが作られます
                        - Ctrl + C キー #// extract_git_branches を終了します
            マージしたブランチ:  #search: git merged branches  #// あるブランチにマージしたブランチを一覧します
        デフォルト ブランチ を変更します:  #keyword: change Git default branch
            #// ブランチ名を指定しないで git clone するときにダウロードされるブランチ
            #// デフォルト ブランチを変更すると、新しいプル リクエストやクローンに影響を与える可能性のある予期しない結果が生じる可能性があります。
            GitHub:
                GitHub Web UI:
                    メニュー:
                        https://github.com/__RepositoryUser__/__Project__/  >>
                        Settings タブ >> Branches（左）
                    Default branch: ←→ ボタン >> __NewBranchName__ >> Update
                ローカル:  #// origin/HEAD の位置を変更します
                    git remote set-head origin __NewBranchName__
            aws CodeCommit:
                https://console.aws.amazon.com/codecommit/  >> （リポジトリ） >> 設定 >> デフォルトブランチ
            git branch -m:  #// 下記のコマンドでは下記のエラーになるためできません
                コマンド:
                    git branch -D  "master"
                    git push  --delete origin  "master"  #// エラー
                エラー メッセージ: |  #keyword: refs/heads/master
                    ! [remote rejected] master (refusing to delete the current branch: refs/heads/master)
                    error: failed to push some refs to 'https://github.com/__RepositoryUser__/__Project__'
                #ref: https://stackoverflow.com/questions/1485578/change-a-git-remote-head-to-point-to-something-besides-master
        リモート追跡ブランチ: #keyword:
            不要なものを削除する:  #search: git fetch -p
        ブランチを別のブランチにマージします:  #search: git merge
        git-flow: #keyword: git-flow,  git ブランチ 設計  #ref: ${programming}/方法論/CVS/Git.svg#git_flow
            ブランチ:
                git-flow:
                    - main/master ブランチ
                    - develop ブランチ  #search: develop branch  #search: multi develop branch
                    - hotfix ブランチ   #// 緊急修正用。メインブランチから派生し、修正後に main ブランチと develop ブランチの両方にマージ
                    - feature ブランチ  #// 新機能開発用。通常修正用。develop ブランチから派生。ローカルでテスト後に、develop ブランチへマージ
                    - release ブランチ  #search: release branch
                    - support ブランチ
                    - temporary ブランチ
                    - topic ブランチ  #keyword: topic branch  #search: feature ブランチ
                git-flow 以外:
                    - WIP ブランチ   #search: WIP branch
                    - develop-wip ブランチ  #search: develop-wip branch  #// DEV 環境にデプロイするためのブランチ
                    - features ブランチ  #search: features branch
                    - test ブランチ  #search: test branch
            応用:  #// git-flow ではありません
                develop ブランチ: #keyword: develop branch
                    概要: feature のマージ先。
                        ただし、develop ブランチにマージしなくても DEV 環境へリリースできます。
                        開発環境用の feature はすぐに develop へマージしても構いません。
                    マージ: #keyword: merge to develop
                        #// ❗ 他との整合性を未確認
                        短いテストでのマージ: #keyword: short test merge
                            基本的にテストを通してから develop ブランチにマージするが、全テストに 1日とかかかるときは、
                            重要なテストだけ通してマージし、全テストが失敗したらパッチをあてるかリバートします。
                        複数の feature が、リリースするパッケージ（RPM など）に含まれる場合:
                            PRD リリースする可能性が高い場合:
                                develop ブランチにマージして DEV 環境へリリースします
                            PRD リリースされない可能性が高い場合:  #keyword: dev_release
                                dev_release ブランチにマージして DEV 環境へリリースします
                    関連:
                        複数の develop ブランチ:  #search: multi develop branch
                        develop-wip ブランチ:  #search: develop-wip branch
                        develop-sync ブランチ:  #search: develop-sync branch
                        dev:  #// develop の略
                        deve:  #// develop の略  #search: Git VSCode deve
                        devel: #keyword:  #// develop の略  #search: python3-devel
                CI/CD 環境のブランチ: #keyword: CI/CD test branch
                    概要: 通常、プルリクのマージ元ブランチに対して CI/CD が動きます。一般的には、feature ブランチです
                        feature ブランチ で開発を進めながら、時間がかかるテストを行うとき、test ブランチ（testing ブランチ）を作ります
                    関連 >> 環境別ブランチ: 例：staging, production  #// 通常不要
                リリース ブランチ: #keyword: release branch,  リリース手順  #// 特定のリリースに向けての最終調整を行います。develop ブランチ から派生。CI/CD 環境では通常使いません
                    ブランチ名の例: release-1.0.x
                    内容: PRD リリースまでは STG の内容。PRD リリース以後は PRD の内容。
                    ルール, 手順:
                        - develop ブランチ、または、これまでの最新の release ブランチから分岐します。基本的には develop ブランチの現在または過去のコミット
                        - release ブランチにコミットを追加するのは、リリースしたものにフィードバックを受けたときです
                        - STG/PRD 固有のコードも、release ブランチにコミットを追加します
                        - バグ修正のコミットだけ追加できます。機能開発は許可されていません（機能変更要望も禁止）
                        - ドキュメントやバージョン番号を更新します
                            #ref: ${typrm_files}/ref/Git-AI.yaml#label: release branch
                        - リリースしたら develop ブランチにマージします。master ブランチがあればそちらにもマージします
                        - 同じバージョンの release を追加するときは、最新 develop へ release ブランチをマージしてから行います
                            #ref: https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/Gitflow-release-branch-process-start-finish
                    タグ: リリースしたらタグを付けます。タグが付いていたらブランチを削除しても消えません（未確認）
                    リバート: #search: git revert
                    リバートを含む PRD リリース後の STG リリース: #// 次のバージョンのリリースブランチを作ります
                        概要: develop ブランチの中でリリースに含まれる最新のマージのコミットをベースに
                            リリース ブランチ を作り、不要なマージをリバートします。
                            既存の リリース ブランチ にマージを追加する場合、develop からマージして、不要なマージをリバートします。
                        サンプル:
                            状況を作ります:  #// リバートを含む PRD リリースをします。
                                初回:
                                    作業フォルダーを作り、移動します:
                                        cd  try_release_branch
                                    リリース1を作ります:  #// 内容は merged_1 のみ
                                        作った後の状態:
                                            gitlog1: |  #focus: Merge branch
                                                (HEAD -> release-1.0.x, tag: v1.0.0, tag: merged_1) Merge branch 'feature_1' into develop
                                                (feature_1) commit 1B
                                                commit 1A
                                                base
                                            gitlog: |  #focus: release-1
                                                *   2222222  (tag: merged_2, develop) Merge branch 'feature_2' into develop
                                                |\
                                                | * 2222BBB  (feature_2) commit 2B
                                                | * 2222AAA  commit 2A
                                                |/
                                                *   1111111  (HEAD -> release-1.0.x, tag: v1.0.0, tag: merged_1) Merge branch 'feature_1' into develop
                                                |\
                                                | * 1111BBB  (feature_1) commit 1B
                                                | * 1111AAA  commit 1A
                                                |/
                                                * 0000000  base
                                        コマンド: |
                                            #// develop ブランチのベースを作ります:
                                                rm -rf .git;  rm *
                                                git init
                                                git checkout -b "develop"
                                                echo "
                                                    Line1
                                                    feature 1A before
                                                    Line2  #// この行が必要な理由はコンフリクトしないためです
                                                    feature 1B before
                                                    Line3  
                                                    feature 2A before
                                                    Line4  
                                                    feature 2B before
                                                    Line5  
                                                    feature 3A before
                                                    Line6  
                                                    feature 3B before
                                                    Line7  
                                                    feature 4A before
                                                    Line8  
                                                    feature 4B before
                                                    Line9  
                                                    feature 5A before
                                                    Line10 
                                                    feature 5B before
                                                    Line11 
                                                "   >  file.txt
                                                git add .
                                                git commit -m "base"
                                            #// merge_1 を作ります:
                                                git checkout -b "feature_1"
                                                _c="$(sed "s/feature 1A before/feature 1A after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                                git add .
                                                git commit -m "commit 1A"
                                                _c="$(sed "s/feature 1B before/feature 1B after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                                git add .
                                                git commit -m "commit 1B"
                                                git checkout "develop"
                                                git merge  "feature_1" --no-edit --no-ff
                                                git tag -a  "merged_1"  -m ""
                                            #// merge_2 を作ります:
                                                git checkout -b "feature_2"
                                                _c="$(sed "s/feature 2A before/feature 2A after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                                git add .
                                                git commit -m "commit 2A"
                                                _c="$(sed "s/feature 2B before/feature 2B after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                                git add .
                                                git commit -m "commit 2B"
                                                git checkout "develop"
                                                git merge  "feature_2" --no-edit --no-ff
                                                git tag -a  "merged_2"  -m ""
                                            #// リリース1 を作ります:
                                                git checkout -b "release-1.0.x" "merged_1"
                                                git tag -a  "v1.0.0"  -m ""
                                    リバートを含むリリース2を作ります:  #// 内容は merged_1, merged_3 です。 merged_2 はリバートします
                                        作った後の状態:
                                            gitlog1: |  #focus: Merge branch
                                                (HEAD -> release-2.0.x, tag: v2.0.0) Revert "Merge branch 'feature_2' into develop"
                                                (tag: merged_3) Merge branch 'feature_3' into develop
                                                (feature_3) commit 3B
                                                commit 3A
                                                (tag: merged_2) Merge branch 'feature_2' into develop
                                                (feature_2) commit 2B
                                                commit 2A
                                                (tag: v1.0.0, tag: merged_1, release-1.0.x) Merge branch 'feature_1' into develop
                                                (feature_1) commit 1B
                                                commit 1A
                                                base
                                            gitlog: |  #focus: release-2, feature_2
                                                * A200000  (HEAD -> release-2.0.x, tag: v2.0.0) Revert "Merge branch 'feature_2' into develop"
                                                | *   5555555  (tag: merged_5, develop) Merge branch 'feature_5' into develop
                                                | |\
                                                | | * 5555BBB  (feature_5) commit 5B
                                                | | * 5555AAA  commit 5A
                                                | |/
                                                | * 4444444  (tag: merged_4) Merge branch 'feature_4' into develop
                                                |/|
                                                | * 4444BBB  (feature_4) commit 4B
                                                | * 4444AAA  commit 4A
                                                |/
                                                *   3333333  (tag: merged_3) Merge branch 'feature_3' into develop
                                                |\
                                                | * 3333BBB  (feature_3) commit 3B
                                                | * 3333AAA  commit 3A
                                                |/
                                                *   2222222  (tag: merged_2) Merge branch 'feature_2' into develop
                                                |\
                                                | * 2222BBB  (feature_2) commit 2B
                                                | * 2222AAA  commit 2A
                                                |/
                                                *   1111111  (tag: v1.0.0, tag: merged_1, release-1.0.x) Merge branch 'feature_1' into develop
                                                |\
                                                | * 1111BBB  (feature_1) commit 1B
                                                | * 1111AAA  commit 1A
                                                |/
                                                * 0000000  base
                                        コマンド: |
                                            #// develop ブランチをベースにします:
                                                git checkout develop
                                            #// merge_3 を作ります:
                                                git checkout -b "feature_3"
                                                _c="$(sed "s/feature 3A before/feature 3A after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                                git add .
                                                git commit -m "commit 3A"
                                                _c="$(sed "s/feature 3B before/feature 3B after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                                git add .
                                                git commit -m "commit 3B"
                                                git checkout "develop"
                                                git merge  "feature_3" --no-edit --no-ff
                                                git tag -a  "merged_3"  -m ""
                                            #// merge_4 を作ります:
                                                git checkout -b "feature_4"
                                                _c="$(sed "s/feature 4A before/feature 4A after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                                git add .
                                                git commit -m "commit 4A"
                                                _c="$(sed "s/feature 4B before/feature 4B after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                                git add .
                                                git commit -m "commit 4B"
                                                git checkout "develop"
                                                git merge  "feature_4" --no-edit --no-ff
                                                git tag -a  "merged_4"  -m ""
                                            #// merge_5 を作ります:
                                                git checkout -b "feature_5"
                                                _c="$(sed "s/feature 5A before/feature 5A after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                                git add .
                                                git commit -m "commit 5A"
                                                _c="$(sed "s/feature 5B before/feature 5B after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                                git add .
                                                git commit -m "commit 5B"
                                                git checkout "develop"
                                                git merge  "feature_5" --no-edit --no-ff
                                                git tag -a  "merged_5"  -m ""
                                            #// リリース2 のブランチを作ります:
                                                git checkout -b "release-2.0.x" "merged_3"
                                            #// リリースしないマージ(merged_2)をリバートします:
                                                git revert merged_2  --mainline 1  --no-edit
                                                git tag -a  "v2.0.0"  -m ""
                                        ファイルの内容:  #focus: after
                                            コマンド: cat file.txt
                                            出力: |
                                                Line1
                                                feature 1A after
                                                Line2  #// この行が必要な理由はコンフリクトしないためです
                                                feature 1B after
                                                Line3  
                                                feature 2A before
                                                Line4  
                                                feature 2B before
                                                Line5  
                                                feature 3A after
                                                Line6  
                                                feature 3B after
                                                Line7  
                                                feature 4A before
                                                Line8  
                                                feature 4B before
                                                Line9  
                                                feature 5A before
                                                Line10 
                                                feature 5B before
                                                Line11 
                                    .git フォルダーをバックアップします:
                                        圧縮します:
                                            tar cvzf  "../try_release_branch.git.tar.gz"  ".git"
                                2回目以降:
                                    リバートを含むリリース2 をリストアします:  #// リリース2 = リリース ブランチ 2
                                        バックアップのファイルをコピーします:
                                            cp "../try_release_branch.git.tar.gz" "./.git.tar.gz"
                                        .git フォルダーとファイルをリストアします: #copy: restore .git commands
                                            mv ".git" ".git_bk"
                                            tar xvf ".git.tar.gz"
                                            git checkout "."
                                            rm -rf ".git_bk"
                                            rm ".git.tar.gz"
                                            git status
                                            gitlog
                            #// 以下は STG リリースする リリース ブランチ の作り方です。
                            唯一 revert されたマージを再マージした リリース ブランチ 3 を作る場合:  #// 内容は merged_1, merged_2, merged_3
                                概要: merged_2 は revert された唯一のマージ。
                                    develop ブランチの中でリリースに含まれる最新のマージのコミットをベースに リリース ブランチ 3 を作り、
                                    不要なマージをリバートします。
                                #// 以下はリリース2 にリストアした状態から始めます
                                merged_2 をマージします:
                                    merged_3 にリリース3 を作ります: |  #// merged_3 までのすべてをリリースに含まれることになるので
                                        git checkout "develop"
                                        git checkout -b "release-3.0.x" "merged_3"
                                        git tag -a  "v3.0.0"  -m ""
                                    #// develop ブランチには merged_2 のリバートは含まれていないので、リバートのリバートは不要です
                                結果:
                                    gitlog1: |  #focus: Merge branch 
                                        (HEAD -> release-3.0.x, tag: v3.0.0, tag: merged_3) Merge branch 'feature_3' into develop
                                        (feature_3) commit 3B
                                        commit 3A
                                        (tag: merged_2) Merge branch 'feature_2' into develop
                                        (feature_2) commit 2B
                                        commit 2A
                                        (tag: v1.0.0, tag: merged_1, release-1.0.x) Merge branch 'feature_1' into develop
                                        (feature_1) commit 1B
                                        commit 1A
                                        base
                                    gitlog: |  #focus: release-3
                                        * A200000  (tag: v2.0.0, release-2.0.x) Revert "Merge branch 'feature_2' into develop"
                                        | *   5555555  (tag: merged_5, develop) Merge branch 'feature_5' into develop
                                        | |\
                                        | | * 5555BBB  (feature_5) commit 5B
                                        | | * 5555AAA  commit 5A
                                        | |/
                                        | * 4444444  (tag: merged_4) Merge branch 'feature_4' into develop
                                        |/|
                                        | * 4444BBB  (feature_4) commit 4B
                                        | * 4444AAA  commit 4A
                                        |/
                                        *   3333333  (HEAD -> release-3.0.x, tag: v3.0.0, tag: merged_3) Merge branch 'feature_3' into develop
                                        |\
                                        | * 3333BBB  (feature_3) commit 3B
                                        | * 3333AAA  commit 3A
                                        |/
                                        *   2222222  (tag: merged_2) Merge branch 'feature_2' into develop
                                        |\
                                        | * 2222BBB  (feature_2) commit 2B
                                        | * 2222AAA  commit 2A
                                        |/
                                        *   1111111  (tag: v1.0.0, tag: merged_1, release-1.0.x) Merge branch 'feature_1' into develop
                                        |\
                                        | * 1111BBB  (feature_1) commit 1B
                                        | * 1111AAA  commit 1A
                                        |/
                                        * 0000000  base
                                    ファイルの内容:  #focus: after
                                        コマンド: cat file.txt
                                        出力: |
                                            Line1
                                            feature 1A after
                                            Line2  #// この行が必要な理由はコンフリクトしないためです
                                            feature 1B after
                                            Line3
                                            feature 2A after
                                            Line4
                                            feature 2B after
                                            Line5
                                            feature 3A after
                                            Line6
                                            feature 3B after
                                            Line7
                                            feature 4A before
                                            Line8
                                            feature 4B before
                                            Line9
                                            feature 5A before
                                            Line10
                                            feature 5B before
                                            Line11
                            新しい merged_4 を含む リリース ブランチ 3 を作る場合: #keyword: merged_134  #// 内容は feature_1, feature_3, feature_4
                                概要: merged_4 はリリース2 の後のマージ。merged_2 は revert されたまま。
                                    develop ブランチの中でリリースに含まれる最新のマージのコミットをベースに リリース ブランチ 3 を作り、
                                    不要なマージをリバートします。
                                #// 以下はリリース2 にリストアした状態から始めます
                                merged_4 をマージしたリリース3 を作ります:
                                    merged_4 にリリース3 を作ります: |  #// merged_4 が最新なので
                                        git checkout "develop"
                                        git checkout -b "release-3.0.x" "merged_4"
                                    マージを確認します:  #// リバートすべきマージを探します
                                        gitlog1 | grep  "Merge branch": |  #focus: feature_2  #// 現在の内容は feature_1, feature_2, feature_3, feature_4
                                            (HEAD -> release-3.0.x, tag: merged_4) Merge branch 'feature_4' into develop
                                            (tag: merged_3) Merge branch 'feature_3' into develop
                                            (tag: merged_2) Merge branch 'feature_2' into develop
                                            (tag: v1.0.0, tag: merged_1, release-1.0.x) Merge branch 'feature_1' into develop
                                    merged_2 をリバートします:  #// リリース ブランチ に含めないため
                                        git revert merged_2  --mainline 1  --no-edit
                                        git tag -a  "v3.0.0"  -m ""
                                結果:
                                    gitlog1: |  #focus: Merge branch   #// 内容は feature_1, feature_3, feature_4  #// feature_2 は含まない
                                        (HEAD -> release-3.0.x, tag: v3.0.0) Revert "Merge branch 'feature_2' into develop"
                                        (tag: merged_4) Merge branch 'feature_4' into develop
                                        (feature_4) commit 4B
                                        commit 4A
                                        (tag: merged_3) Merge branch 'feature_3' into develop
                                        (feature_3) commit 3B
                                        commit 3A
                                        (tag: merged_2) Merge branch 'feature_2' into develop
                                        (feature_2) commit 2B
                                        commit 2A
                                        (tag: v1.0.0, tag: merged_1, release-1.0.x) Merge branch 'feature_1' into develop
                                        (feature_1) commit 1B
                                        commit 1A
                                        base
                                    gitlog: |  #focus: release-3, feature_2, Merge branch
                                        * A300000  (HEAD -> release-3.0.x, tag: v3.0.0) Revert "Merge branch 'feature_2' into develop"
                                        | * A200000  (tag: v2.0.0, release-2.0.x) Revert "Merge branch 'feature_2' into develop"
                                        | | * 5555555  (tag: merged_5, develop) Merge branch 'feature_5' into develop
                                        | |/|
                                        |/| |
                                        | | * 5555BBB  (feature_5) commit 5B
                                        | | * 5555AAA  commit 5A
                                        | |/
                                        |/|
                                        * |   4444444  (tag: merged_4) Merge branch 'feature_4' into develop
                                        |\ \
                                        | |/
                                        |/|
                                        | * 4444BBB  (feature_4) commit 4B
                                        | * 4444AAA  commit 4A
                                        |/
                                        *   3333333  (tag: merged_3) Merge branch 'feature_3' into develop
                                        |\
                                        | * 3333BBB  (feature_3) commit 3B
                                        | * 3333AAA  commit 3A
                                        |/
                                        *   2222222  (tag: merged_2) Merge branch 'feature_2' into develop
                                        |\
                                        | * 2222BBB  (feature_2) commit 2B
                                        | * 2222AAA  commit 2A
                                        |/
                                        *   1111111  (tag: v1.0.0, tag: merged_1, release-1.0.x) Merge branch 'feature_1' into develop
                                        |\
                                        | * 1111BBB  (feature_1) commit 1B
                                        | * 1111AAA  commit 1A
                                        |/
                                        * 0000000  base
                                    ファイルの内容:  #focus: after
                                        コマンド: cat file.txt
                                        出力: |
                                            Line1
                                            feature 1A after
                                            Line2  #// この行が必要な理由はコンフリクトしないためです
                                            feature 1B after
                                            Line3
                                            feature 2A before
                                            Line4
                                            feature 2B before
                                            Line5
                                            feature 3A after
                                            Line6
                                            feature 3B after
                                            Line7
                                            feature 4A after
                                            Line8
                                            feature 4B after
                                            Line9
                                            feature 5A before
                                            Line10
                                            feature 5B before
                                            Line11
                            既存の リリース ブランチ 3 に新しい merged_6 をマージする場合:  #// 内容は merged_1, merged_3, merged_4, merged_6
                                概要: merged_6 はdevelop ブランチに追加されたマージ。merged_2 は revert されたまま。merged_5 をリバート。
                                    既存の リリース ブランチ に、develop ブランチに追加されたマージをマージする（追加する）場合、
                                    develop からマージして、
                                    不要なマージをリバートします
                                #// 以下は merged_4 を含む リリース ブランチ 3 を作った状態から始めます  #search: merged_134
                                マージを確認します:
                                    gitlog1 | grep  "Merge branch": |  #focus: feature_2  #// 現在の内容は feature_1, feature_3, feature_4
                                        (HEAD -> release-3.0.x, tag: v3.0.0) Revert "Merge branch 'feature_2' into develop"
                                        (tag: merged_4) Merge branch 'feature_4' into develop
                                        (tag: merged_3) Merge branch 'feature_3' into develop
                                        (tag: merged_2) Merge branch 'feature_2' into develop
                                        (tag: v1.0.0, tag: merged_1, release-1.0.x) Merge branch 'feature_1' into develop
                                merge_6, merge_7 を作り develop ブランチにマージします: |
                                    #// merge_6
                                        git checkout "develop"  #// The base branch of feature_6
                                        git checkout -b "feature_6"
                                        echo "
                                            feature 6A after
                                            Line12
                                        "  >>  file.txt
                                        git add .
                                        git commit -m "commit 6A"
                                        echo "
                                            feature 6B after
                                            Line13 
                                        "  >>  file.txt
                                        git add .
                                        git commit -m "commit 6B"
                                        git checkout "develop"
                                        git merge  "feature_6" --no-edit --no-ff
                                        git tag -a  "merged_6"  -m ""
                                    #// merge_7
                                        git checkout "develop"  #// The base branch of feature_7
                                        git checkout -b "feature_7"
                                        echo "
                                            feature 7A after
                                            Line14
                                        "  >>  file.txt
                                        git add .
                                        git commit -m "commit 7A"
                                        echo "
                                            feature 7B after
                                            Line15 
                                        "  >>  file.txt
                                        git add .
                                        git commit -m "commit 7B"
                                        git checkout "develop"
                                        git merge  "feature_7" --no-edit --no-ff
                                        git tag -a  "merged_7"  -m ""
                                リリース ブランチ 3 に merged_6 をマージします: |  #// merged_6 はマージする最新マージ。merged_7 はリリースに含めないため
                                    git checkout "release-3.0.x"
                                    git merge  "merged_6" --no-edit --no-ff   #// 本番では、一時的に merged_6 タグをつけてから
                                マージを確認します(2):  #// リバートすべきマージを探します
                                    gitlog1 | grep  "Merge branch": |  #focus: feature_6, feature_5
                                        (tag: merged_6, develop) Merge branch 'feature_6' into develop
                                        (tag: v3.0.0) Revert "Merge branch 'feature_2' into develop"
                                        (tag: merged_5) Merge branch 'feature_5' into develop
                                        (tag: merged_4) Merge branch 'feature_4' into develop
                                        (tag: merged_3) Merge branch 'feature_3' into develop
                                        (tag: merged_2) Merge branch 'feature_2' into develop
                                        (tag: v1.0.0, tag: merged_1, release-1.0.x) Merge branch 'feature_1' into develop
                                merged_5 をリバートします:  #// merged_5 はリリース ブランチ に含めないため
                                    git revert merged_5  --mainline 1  --no-edit
                                    git tag -a  "v3.0.1"  -m ""  #// 本番は v3.0.0 の張り替えのほうがよい
                                結果:
                                    gitlog1 | grep  "Merge branch": |  #focus: feature_6, feature_5  #// 内容は merged_1, merged_3, merged_4, merged_6
                                        (HEAD -> release-3.0.x, tag: v3.0.1) Revert "Merge branch 'feature_5' into develop"
                                        (tag: merged_6, develop) Merge branch 'feature_6' into develop
                                        (tag: v3.0.0) Revert "Merge branch 'feature_2' into develop"
                                        (tag: merged_5) Merge branch 'feature_5' into develop
                                        (tag: merged_4) Merge branch 'feature_4' into develop
                                        (tag: merged_3) Merge branch 'feature_3' into develop
                                        (tag: merged_2) Merge branch 'feature_2' into develop
                                        (tag: v1.0.0, tag: merged_1, release-1.0.x) Merge branch 'feature_1' into develop
                                    ファイルの内容:  #focus: after
                                        コマンド: cat file.txt
                                        出力: |
                                            Line1
                                            feature 1A after
                                            Line2  #// この行が必要な理由はコンフリクトしないためです
                                            feature 1B after
                                            Line3
                                            feature 2A before
                                            Line4
                                            feature 2B before
                                            Line5
                                            feature 3A after
                                            Line6
                                            feature 3B after
                                            Line7
                                            feature 4A after
                                            Line8
                                            feature 4B after
                                            Line9
                                            feature 5A before
                                            Line10
                                            feature 5B before
                                            Line11
                                            feature 6A after
                                            Line12
                                            feature 6B after
                                            Line13
                        参考 >> リバート: #search: git revert
                RC ブランチ:  #keyword: release candidate branch,  rc branch
                    通常、リリースブランチを RC リリースする。
                    rc-__Date__ ブランチが 3カ月経ったらリリース。
                    それまでにバグフィックスが追加されていても良い。
                WIP 開始タグ: #keyword: WIP start tag,  WIP branch
                    _:
                        -   個人で区切りがつく前に毎日のようにコミットを作る場合、WIP コミットを開始するコミットに Git 開始タグを一時的に設置します  #search: Git tag
                        -   区切りがついたら git rebase -i __WIPStartTag__ でコミットをまとめます
                        -   リベースすると、GitHub の File chaanged タブのレビュー記録が一部正しくなくなりますが、
                            File chaanged タブでレビューした記録は、同時に Conversation タブに書かれているので、その記録はそのまま残ります
                            #search: GitHub review logs
                    WIP 開始タグを扱うコマンド: #keyword: __BranchName__-wip-start,  wip-  #snippet-depth: 1
                        設置: |  #search: create git tag
                            git tag -a  "wip-start"  -m "wip-start"  #// or "__Branch__-wip-start"
                            git push origin  "wip-start"             #// or "__Branch__-wip-start"
                        除去: | #search: delete git tag
                            git tag -d  "wip-start"               #// or "__Branch__-wip-start"
                            git push origin :refs/tags/wip-start  #// or "__Branch__-wip-start"
                    WIP ブランチ:
                        -   CI テスト を動かしたくない場合は、__Feature__-wip ブランチを作ります
                        -   ただし、レビュー記録は、__Feature__ ブランチ のプルリクのレビュー記録と別のプルリクのレビュー記録に分かれます。
                                もし、WIP ブランチ にプルリクを作らなければ、レビュー記録は残りません。
                                コミットへのレビューは git rebase で コミット ID が変わると コミットへのレビューも消えます
                        -   個人で毎日のようにコミットを作るブランチ。バックアップや環境のリセットに対応するため。
                            中途半端なときでもバックアップできるブランチ。区切りがついたら feature ブランチに反映します  #search: git diff patch
                develop-wip ブランチ: #keyword: develop-wip branch,  develop-wip  #// DEV 環境にデプロイするためのブランチ
                    概要:
                        - develop ブランチにはまだマージしない複数の feature ブランチを含む DEV リリースのためのブランチ。
                        - プルリクによる develop ブランチへのマージは STG リリース時まで実施しない
                        - DEV 環境のベースとなるブランチ（STG 環境とは異なる場合あり）を develop ブランチとする（CI テストを実施するブランチにする）
                        - DEV リリースは develop-wip ブランチで行い、develop-wip ブランチへの feature ブランチのマージは CLI で DEV リリース時に実施
                        - STG リリース開始のタイミングで、feature を develop と release へマージ  #search: git merge develop and ]STG release
                        - マージした feature ブランチは、develop-wip ブランチから除く。
                            具体的には develop-wip ブランチを新しい develop ブランチから作り直す（リバートでは複雑になる）
                            #search: git merged branches
                    develop-wip ブランチに集めます: #keyword: merge develop-wip  #// マージします。または、作り直します。または、develop/release ブランチに移動します
                        初めて develop-wip ブランチを作る場合:
                            develop ブランチに develop-wip ブランチを作ります:
                            各種 feature ブランチをリベースします:
                            各種 feature ブランチを develop-wip ブランチにマージしていきます:
                        更新またはリベースする, コンフリクトが少ない場合:
                            ブランチを一覧します:  #// 現在の develop-wip ブランチがどのブランチからできているかを一覧します
                                git log --merges --oneline  develop-wip
                                （出力内容をメモします）
                                #search: git merged branches
                            （初回のみ）rerere を有効にします:  #search: git rerere
                                git config --local  rerere.enabled  true
                                git config --local  rerere.autoupdate  true
                            リベースしてリリースします:
                                develop-wip の中を release する場合:  #// develop → develop-wip の間に「ある」ブランチを、develop/release（または STG 環境）へ移動する場合
                                    マージ先として develop が正しいか release が正しいかをチェックします:
                                        - プルリクのページを開きます
                                        - 変更する場合  #search: change GitHub pull requests target
                                    リベースします:  #// feature ブランチをマージ先に対してリベースします
                                        - git rebase します  #// git cherry-pick も使えます  #search: Git rebase cherry-pick
                                        - git push します  #// feature ブランチを git push します。ローカルでリベースしただけで次に進まないでください
                                    （プルリクを使って）マージします:
                                    release ブランチに移動した場合:
                                        develop ブランチを release ブランチに対してリベースします:
                                            no-ff マージを含むブランチをリベースする場合: #search: Git rebase no-ff
                                            それ以外の場合:  #search: git rebase branch
                                    #// feature ブランチをrelease ブランチに移動する際に develop-wip ブランチの一部をリバートすると、
                                    #// リバートするコミットが追加されてしまうため、複雑なグラフになってしまいます
                                develop-wip の外を release する場合:  #// develop → develop-wip の間に「ない」ブランチを、develop/release（または STG 環境）へ追加する場合
                                    正解の内容として一時的にマージします: #keyword: git rebase reference merge  #// リベース中にコンフリクトが発生したときに正解の内容を明らかにするため
                                        git checkout  "develop-wip"
                                        git checkout -b  "develop-wip-next"
                                        git merge  __FixBranch__
                                    develop ブランチを release ブランチに対してリベースします:
                                        develop と release の間にブランチやタグがある場合:
                                            最も長いブランチから作業する場合:
                                                develop をリベースしてから、ブランチやタグを張り替え、
                                                develop を release に張り替え、
                                                git merge --no-ff します
                                            最も短いブランチから作業する場合:
                                                最初はリベースします
                                                後は、複数のコミットをまとめて cherry-pick します  #search: git cherry-pick range
                                                #// 一部を共有していたブランチにリベースしてもコンフリクトが大量発生します
                            #// develop-wip ブランチを作り直します
                            develop-wip ブランチをリセットします: |  #// develop ブランチの位置に戻します
                                cd  ~/__Project__
                                git checkout  develop
                                git branch -D  develop-wip   #// 2回目以降。リモートの develop-wip の削除は後で行います
                                git checkout -b develop-wip  #// develop から枝分かれ
                            #// ブランチのループ開始
                            ブランチをリベースしてマージ: |  #// feature ブランチを 1つマージします
                                git checkout  __FeatureBranchA__
                                git pull
                                git rebase  develop   #// または git cherry-pick など  #search: Git rebase cherry-pick
                                git checkout  develop-wip
                                git merge --no-edit --no-ff  __FeatureBranchA__
                            コンフリクトした場合: #keyword: Git conflict develop-wip
                                初めてマージする場合:
                                    手動で解消します  #search: Git conflict
                                2回目以降のマージの場合: #keyword: Git resolve conflict again
                                    #// 前回 develop-wip にマージした結果（git log --oneline --merges  develop-wip の各コミットのファイルの内容）と比較してどのようにマージすべきか判断できます。
                                    未確認）record-conflict-resolution スクリプト で既存の編集を集めます:
                                        前回 develop-wip をマージしたときの編集内容
                                        さきほどブランチをマージしたときの編集内容
                                        record-conflict-resolution __EditingBranch__ __BaseBranch__ __OutputFolder__  #// --stop __MergeNumber__
                                    コンフリクトしたファイルを表示します:
                                        VSCode >> Source Control ビュー >> Merge Changes（の中のファイル）
                                    マージでコンフリクトした場合:
                                        Incoming を適用します:  #// 仮に適用します。違っていたら Ctrl+Z で戻ります
                                            Merge Changes（の中のファイルを右クリック）>> Accept All Incoming
                                    リベースでコンフリクトした場合:
                                        Incoming を適用します: #keyword: Git Accept All Incoming  #// 仮に適用します。違っていたら Ctrl+Z で戻ります
                                            Merge Changes（の中のファイルを右クリック）>> Accept All Incoming
                                        #// 関連 → #search: Git resolve complex develop-wip conflict
                                    前回のマージ結果を表示します:
                                        前回と同じ、受け入れ元のブランチと、受け入れ先のブランチを、マージした結果のコミット(ID)を GitHub などで表示します。
                                        #search: GitHub code file
                                    前回のマージ結果のファイルの内容をすべてコピーします:
                                        コピー ボタン
                                    一致することを確認します:
                                        クリップボードの内容と Incoming を適用した内容を比較します
                                    （一致しなかった場合）:
                                        #search: Git conflict
                                    コンフリクトが解消したことを登録します:
                                        git add __FilePath__
                                全てのファイルのコンフリクトを解消します:
                                コミットします:
                                    git commit -m "Merge branch '__FeatureBranchA__' into develop-wip"  #// コミットメッセージは前回と同じ内容をコピペします
                                    #// VSCode の Source Control ビュー に前回のコミットメッセージが表示されています
                            済マークを付けます:
                                git log --merges の出力のうち、develop-wip ブランチに入ったコミットに 済）を付けます
                            次のブランチをマージ:
                                （上へ）
                            #// ブランチのループ終了
                            内容をチェックします:
                                develop-wip の中を release した場合:
                                    git checkout  "develop-wip"
                                    git diff  "origin/develop-wip"
                                develop-wip の外を release した場合:  #search: git rebase reference merge
                                    git checkout  "develop-wip"
                                    git diff  "develop-wip-next"
                                    git branch -D  "develop-wip-next"
                            git push: |
                                git checkout  __FeatureBranchA__
                                git push --force-with-lease  #// rebase した __FeatureBranchA__  #search: git rebase
                                git checkout  __FeatureBranchB__
                                git push --force-with-lease  #// rebase した __FeatureBranchB__  #search: git rebase
                                git checkout  develop-wip
                                git push --force-with-lease  --set-upstream origin develop-wip  #// 新しい develop-wip
                        更新またはリベースする, コンフリクトが多い場合: #keyword: Git resolve complex develop-wip conflict   #// コンフリクトの再解消を避ける方法
                            マージのコンフリクト解消状況:
                                #// 不完全なコンフリクト解消を行った途中のマージという概念の追加によって、リベース時の複雑なコンフリクトの再解消を避けることができます
                                不完全, incomplete conflict resolution: #keyword:
                                    不完全なコンフリクトの解消をした（リベース途中の）マージがあります。
                                    簡易な Accept All Incoming で暫定的に解消します。
                                    コミット メッセージに (incomplete conflict resolution)
                                    このマージは動作保証されません。complete conflict resolution のマージで動作保証されます。
                                完全, complete conflict resolution: #keyword:
                                    リベース前＋リベース分 と同じ内容でコンフリクトが解消されたコミットと同じ内容のコミットです。
                                    develop-wip をリベースしたコミットのメッセージに（complete conflict resolution）と
                                    「リベース前のマージベースのバージョン番号と、マージした日付」を追加します。
                                    このマージは動作保証されます。
                            検証, develop-wip を release でリベースした結果の目標（を作ります）: #keyword: Git rebase 検証,  Git rebase の正解 目標
                                説明: #keyword: develop-wip-old (complex develop-wip conflict),  develop-wip-new-contents,  develop-wip-new-contents-branch
                                    目標は、develop-wip に release の更新分を cherry-pick したものです。
                                    なぜなら、B=base, D=develop-wip, R=rebase targets としたとき、
                                        B + D     ≠ B + R + D であり、
                                        B + R + D =  B + D + R であるため。
                                    このため、develop-wip-new-contents-branch ブランチを作り、develop-wip (B + D) に + R します。
                                        すべてすでに develop-wip に入っていた場合、+ R はありません。
                                コマンド: |
                                    git checkout  develop-wip
                                    git tag -a  "develop-wip-old"  -m "develop-wip-old"  &&  git push origin  "develop-wip-old"

                                    git checkout  develop-wip-new-contents-branch   #// git tag では後で git soft reset commit ができなくなります
                                    git cherry-pick __OldVersion__..__NewVersion__  #search: git cherry-pick range
                                        #// コンフリクトの解消
                                    git tag -a  "develop-wip-new-contents"  -m "develop-wip-new-contents"  &&  git push origin  "develop-wip-new-contents"
                                    git push
                                #// なお、release の更新分のうち、すでに develop-wip に入っているコミットは、cherry-pick してもすでに適用済みとしてコミットは追加されません。
                            プルリクでマージしていきます: #keyword: pull request complex merge
                                #// リリース決定後、プルリクのマージ先である（通常 develop）ブランチへリベースしてから、プルリクでマージします。
                                #// コンフリクトは、マージ前のリベース時に発生します。
                                develop ブランチと release ブランチが分かれている場合:  #search: git shared develop branch
                                    今までの develop ブランチの位置に、develop-old ブランチを作ります:
                                    新しい develop ブランチをリベースする対象（最新 release）に配置します:
                                        まだ develop ブランチをプッシュしません
                                        #// 以下で、新しい develop にリベース＆マージしていきます
                                #// develop-wip に含まれる feature ブランチ（プルリク）について、それぞれ以下を繰り返します。
                                #// ただし、最初は develop ブランチ（共有コード）を構成する各種 feature ブランチ（develop ブランチへマージする前）です
                                リベースをテストします:
                                    リベースします:
                                        コマンド:
                                            git checkout  __FeatureBranch__
                                            git rebase  develop
                                            #// git push は検証後、または、マージするので push しません
                                        コンフリクトが発生した場合:
                                            簡易的な incomplete conflict resolution を行います: |
                                                    git checkout --theirs  "."    #// Incomming を採用します
                                                    git add "."
                                                    GIT_EDITOR=:  git rebase --continue
                                                #search: Git checkout --theirs
                                                #search: Git Accept All Incoming
                                                #// コンフリクトの正しい解消は、すべてマージした後で行います
                                        コミット数が増えた場合:
                                            他のブランチが混ざっている可能性があります
                                    マージします:
                                        コマンド:
                                            git checkout  develop
                                            git merge --no-edit --no-ff  __FeatureBranch__
                                        コミット メッセージ に必要な情報（上記）を追記します:
                                            git commit --amend  -m "Merge branch '__FeatureBranch__' into develop (incomplete conflict resolution)"
                                #// 以上を繰り返します。
                                コンフリクトの正しい解消をします:
                                    B + D + R の内容で git soft reset commit を行い、それを conflict resolution とします:
                                        #search: Git rebase 検証
                                        #search: git soft reset commit
                                        まとめた結果の内容があるコミットにします:
                                            git checkout  develop-wip-new-contents-branch
                                        新しくコミットを作る場所に、内容を変えずに、HEAD を移動します: |
                                            git reset --soft  develop
                                            git stash
                                            git checkout  develop
                                            git stash pop
                                            git branch -D  develop-wip-new-contents-branch   #// （未確認）develop-wip-new-contents-branch が develop の位置に移動するため、リモートにあれば、削除する
                                            git add "."
                                        差分の確認:
                                            ここで編集内容が『コンフリクトが発生した部分だけ』に限定されていることを確認します
                                        コミットします:
                                            git commit -m "(complete conflict resolution)"
                                            #// git push はまだ行いません
                                    develop ブランチの内容が目標と一致することを確認します: |
                                        git checkout  develop-wip-new-contents-branch    #// git diff が使えるようにするために、リモートの位置と同じ位置にローカルのブランチを作ります
                                        git checkout  develop
                                        git diff  develop-wip-new-contents-branch
                                        git tag -a  "develop-wip-new"  -m "develop-wip-new"  &&  git push origin  "develop-wip-new"
                                （未対応）三点比較が一致することを確認します:  #// ピリオド 3つを指定します
                                    コマンド: |
                                        git diff -w  v4.1.3...develop-wip > ~/_diff_1
                                        git diff -w  v4.1.4...develop     > ~/_diff_2
                                        diff  ~/_diff_1  ~/_diff_2
                                    差分内容:
                                        < + から始まる行は、既存の develop-wip 側に存在するコードです。
                                        古いベースに元々無くて追加された部分が、新しいベースにある場合、古いほうだけに差分があることになります。
                                    ボツ）:
                                        git range-diff  v4.1.3..develop-wip  v4.1.4..develop
                                            それぞれのコミットの差分の内容で比較するため、コンフリクトの解消方法に差があると、差が表示されてしまいます
                                リベースしたものをプッシュします:
                                    目標のコミットに develop-target ブランチを作ります:
                                        git checkout  develop
                                        git checkout  -b develop-target
                                        git branch -D  develop    #// 以下で新しくするため、削除します
                                    develop ブランチをリベース対象（最新 release）に戻します:
                                        git checktout  __ReleaseBranch__
                                        git checkout -b develop
                                        git push
                                    #// develop-wip に含まれる feature ブランチ（プルリク）について、それぞれ以下を繰り返します。
                                    プッシュしながらマージします:
                                        プルリクが無いブランチの場合:
                                            マージ後に fast-forward します:
                                                未確認
                                            プッシュします:  #// プルリクによるマージがあるため
                                                git push
                                        プルリクがあるブランチの場合:
                                            ブランチをリベースしてプッシュします:
                                                git checkout  __FeatureBranch__
                                                git rebase  develop
                                                git push  --force-with-lease     #// 古い リモート ブランチ が更新されます
                                            #// CI テスト が動きます。そのまま動作させて失敗しても構いません。マージ前に CI テストが通っていることを確認してあればよい
                                            コミットの内容をチェックします:
                                                マージ先が develop であることをチェックします
                                                Commits タブの内容が、ブランチ固有のコミットだけになっていることを確認します
                                            プルリクのコメントに、以下を書きます:
                                                このマージ単体は、簡易的に incomplete conflict resolution が行われたマージです。
                                                動作させるときは、同時期にマージしたすべてのマージをした後のコミットを使ってください。
                                                マージ前に CI テストが通っていることは確認済みです。
                                            プルリクでマージします:
                                                Merge pull request ボタン
                                                #// fast-forward できるマージなので、コンフリクトは発生しません。
                                            develop ブランチをプルします:
                                                git checkout  develop
                                                git pull
                                            （develop ブランチに force push していい GitHub の設定なら）:
                                                コミット メッセージ に必要な情報（上記）を追記します: |
                                                    git commit --amend  -m "Merge pull request #__Number__ from __FeatureBranch__ (incomplete conflict resolution)"
                                                    git push --force-with-lease
                                    #// 以上を繰り返します。
                                    目標のコミットに合わせます:
                                        git checkout  develop
                                        git cherry-pick __CommitID__
                                        git diff  develop-target
                                            差分が無いこと
                                        git push
                                一時ブランチを削除します:
                                    develop-old
                                    develop-target
                                    develop-wip-new-contents-branch
                            DEV 環境へ追加デプロイします: #keyword: fix branch DEV deploy
                                + R の cherry-pick があった場合、DEV 環境にデプロイします
                    develop ブランチ, 共有コード: #keyword: git shared develop branch  #// DEV 環境の共有コード、DEV 環境のベースとなるブランチ
                        develop に共有コードを追加します:  #// STG リリース前の DEV 環境の各種 feature ブランチの共有コードを develop ブランチに追加します
                            共有コードのブランチ（複数のブランチをまとめてもよい）のプルリクを作り、develop ブランチへマージ（git merge --no-ff）
                        develop に共有コードがあるときと無いときの STG リリースの違い: #keyword: git merge develop and STG release  #// STG リリース開始のタイミングで develop と release へマージします
                            develop と release が同じ位置の場合:  #// または release ブランチ（release-_._.x という名前のブランチ）を新規作成する場合
                                feature を develop に対してリベース、
                                feature ブランチ → develop ブランチへマージ（git merge --no-ff）、
                                release-_._.x ブランチ を develop ブランチへ fast foward マージ、または release-_._.x ブランチ を新規作成
                            develop と release が違う位置の場合: |  #// 未確認。DEV 環境の各種 feature ブランチがベースとするブランチ（共有するブランチ）がある場合
                                feature を develop に対してリベース、
                                develop ブランチ → release ブランチへマージ（git merge --no-ff）、
                                    Merge branch 'develop' into release-_._.x: merge
                                feature ブランチ → develop ブランチへマージ（git merge --no-ff）、
                                release ブランチ を develop ブランチへ fast foward マージ
                        次のバージョンが小刻みになった場合:   #// 次のバージョンで共有コードを使わなくなった場合は、
                            既存の develop ブランチを改名し、develop ブランチを新しく作り直す。
                    #search: GitHub pull request template
                features ブランチ: #keyword: features branch  #// 複数の feature ブランチをマージしたもの
                    個人で features ブランチで作業し、feature ブランチを更新し、features ブランチにマージする
                    feature, features は任意の名前に変えます
                    #search: brebase
                    #search: merge to develop
                複数の develop ブランチ: #keyword: multi develop branch
                    #// 非推奨
                    概要: 複数のメジャーバージョンを並列してリリースする場合、
                        機能フラグや条件付きコンパイルができないときは、
                        メジャーバージョンごとに develop ブランチを分けます
                    採用基準:
                        コードベースの共通性
                        リリースサイクル
                        メンテナンスの簡易性
                    ターゲット別ブランチ: #search: specific target branch  #// develop ブランチの メジャー バージョン アップ など
                        ターゲットが異なる develop ブランチや develop-wip ブランチ
                common ブランチ: #keyword: common branch  #// feature ブランチに共通する部品
                    develop から枝分かれした featureA と featureB に共通する部品は common ブランチ（名前は適切に変える）に作ります。
                    develop => common => featureA => develop と
                    develop => common => featureB => develop の方向でマージします。
                develop-sync ブランチ: #keyword: develop-sync branch  #// 複数の develop ブランチ を双方向マージした後のテスト前。扱いは feature ブランチ と同じ
                    双方向マージ:  #search: git mutual merge
                    テスト範囲:
                        - 変更箇所を通るケース
                        - develop-wip ブランチにマージしたものをテストします。必要ならプルリクを作ります
                        - テストをパスしたら develop ブランチにマージします
                issues-doc ブランチ: #keyword: issues-doc  #// 構造化ドキュメンテーションでチケットの状況を共有するためのブランチ
                ボツ）test ブランチ: #keyword: test branch  #// develop ブランチにマージしたものをマージする前にテストするブランチ。マージ先のブランチから派生
                    #// リベースする場合（通常）は test ブランチは不要です。feature ブランチを CI/CD 環境でテストします  #search: CI/CD test branch
                    - test ブランチと feature ブランチ等の同期は cherry-pick で行います
                    - test ブランチでテストが通ったら WIP コミットを整理して、develop へマージします  #search: WIP branch  #search: git diff patch
                    - テストが通ったら feature ブランチ等をリベースします
                pass タグ:  #keyword: pass Git tag  #// 一部の評価が通ったもの。全体的に安定しないプロジェクトで使います
                リリース状況の管理:  #keyword: release status
                    以下の列などを持つ表で管理します。
                        Issue
                        Pull Request
                        DEV リリース
                        STG リリース
                        PRD リリース
                修正版:
                    #ref: https://twitter.com/ts_neko/status/1546514539784519681
            マージかチェリーピックか:
                比較: |
                    /              | マージ      | チェリーピック  #search: git cherry-pick
                    ------------------------------------------------
                    git グラフ     | 斜め線あり  | 斜め線なし
                    マージの有無   | グラフ      | コミット メッセージ（自動では付きません）
            ツール:
                git-flow:  #// git-flow という Git のプラグイン
                gradle-ospackage-plugin によるバージョン番号更新:  #search: nebula.ospackage version number
        コミットがブランチに含まれているか調べます:  #keyword: Git commit branch contains,  コミットがブランチに含まれているか
            コマンド: git merge-base --is-ancestor  __CommitID__  __BranchOrCommitID__  &&  echo yes  ||  echo no
        コミットID:  #search: Git rev-parse commit ID
        ベース ブランチ:  #keyword: Git base branch  #// 分岐する元のブランチ、例えば feature branch にとっての develop branch のこと
            - 親ブランチ とも言います  #// Parent Branch
            #search: マージ ベース
        マージ ベース: #keyword:  #// 枝分かれしたコミット、各ブランチに共通の祖先のコミット  #search: git merge-base
            枝分かれ: #keyword:  #// 派生
        マージやプルリクエストがブランチに含まれているか調べます: #search: GitHub list pull request merge
        ブランチを使ったコンポーネント:  #keyword: Git branch multi component projects
            設定: #settings:
                __FeatureBranch__: java  #original: feature_A
            Git common branch: #keyword:  #// フレームワークやサンプルを管理する場合。プロジェクトのルートからの相対パスが変わらない場合
                手順, サンプル:  #ref: ${GitHub}/MyPrivateCode/ansible_vagrant/multi_vm_ansible/branch_all/.git.zip
                    概要:
                        新規作成:
                            新規環境, common ブランチ:
                                - 最初の common ブランチは何もファイルが入っていません
                                - ファイルを共有しようとしたときに common ブランチにファイルを追加します
                            新規ブランチ:
                                - feature_A ブランチの新規作成は common ブランチから枝分かれさせて作ります
                                    （最初に common ブランチを入力するマージをすることに相当します）
                                - ベースにする feature ブランチから枝分かれさせてはいけません。
                                    （feature ブランチのすべてのファイルを同期する場合を除き）
                                - multi_vm_ansible の .git.zip を使う場合: #search: multi_vm_ansible,  .git.zip new branch
                        同期:
                            - feature_A ブランチを編集して共通部分ができたら common ブランチにファイルを追加し、内容は共通部分だけにする
                            - common ブランチを編集したら、feature_A ブランチ（元のブランチ）へマージする
                            - このとき初めての共通ファイルがあったら必ず、固有部分でコンフリクトするが、固有部分はそのまま残す。
                                以後、固有部分はマージしても common ブランチから反映されず残り続ける
                            - feature_A ブランチと common ブランチの同期（以上の操作）をした後に
                                すぐに feature_B ブランチと同期する必要はない。
                                後でまとめて feature_B ブランチと同期しても問題ない
                    基本サンプル:
                        作業フォルダーを作り、移動します:
                            cd  try_common_framework
                        feature_A ブランチと feature_B ブランチを作ります:
                            common ブランチを作ります: |
                                #// dummy_common
                                    rm -rf .git;  rm *
                                    git init
                                    git checkout -b "common"
                                    echo  "dummy" > dummy.txt
                                    git add "."
                                    git commit -m "dummy_common"
                                #// common_0
                                    rm dummy.txt
                                    git add "."
                                    git commit -m "common_0"
                                    git tag -a "common_0" -m ""
                            feature_A ブランチと feature_B ブランチを作ります: |
                                #// feature_A branch
                                    git checkout "common"
                                    git checkout -b "feature_A"
                                    #// 下記 Line__Num__ の行が必要な理由はコンフリクトしないためです
                                    echo "
                                        Line1
                                        common 1 before
                                        Line2
                                        feature_A 2 before
                                        Line3
                                    "   >  file1.txt
                                    echo "
                                        Line1
                                        feature_A 1 before
                                        Line2
                                        feature_A 2 before
                                        Line3
                                    "   >  file2.txt
                                    git add "."
                                    git commit -m "feature_A_1"
                                #// feature_B branch
                                    git checkout "common"
                                    git checkout -b "feature_B"
                                    echo "
                                        Line1
                                        common 1 before
                                        Line2
                                        feature_B 2 before
                                        Line3
                                    "   >  file1.txt
                                    echo "
                                        Line1
                                        feature_B 1 before
                                        Line2
                                        feature_B 2 before
                                        Line3
                                    "   >  file2.txt
                                    git add "."
                                    git commit -m "feature_B_1"
                        共通ファイルを追加します:
                            common ブランチに共通ファイルを追加します: |
                                    git checkout "common"
                                    echo "
                                        Line1
                                        common 1 before
                                        Line2
                                    "   >  file1.txt
                                    git add "."
                                    git commit -m "common_1"
                            common ブランチから feature_A ブランチと feature_B ブランチにマージします: |
                                #// feature_A branch
                                    git checkout "feature_A"
                                    git merge  "common"  --no-edit
                                    git checkout --ours  "file1.txt"  #// 基本は feature_A のままにする
                                    git add "."
                                    git commit -m "feature_A_2"
                                #// feature_B branch
                                    git checkout "feature_B"
                                    git merge  "common"  --no-edit
                                    git checkout --ours  "file1.txt"  #// 基本は feature_B のままにする
                                    git add "."
                                    git commit -m "feature_B_2"
                        同期します: #// feature_A ブランチで共通部分と固有部分を変更し、共通部分を common ブランチと feature_B ブランチにも反映します
                            feature_A ブランチで共通部分と固有部分を変更します: |
                                #// feature_A branch
                                    git checkout "feature_A"
                                    _c="$(sed "s/common 1 before/common 1 after/g"  file1.txt)";  echo "$_c" > file1.txt;  unset _c
                                    _c="$(sed "s/feature_A 2 before/feature_A 2 after/g"  file1.txt)";  echo "$_c" > file1.txt;  unset _c
                                    git add "."
                                    git commit -m "feature_A_3"
                            common と feature_A を比較します:  #// common ブランチにフィードバックする部分が有るか無いかを判定します。編集はここではしません
                                コマンド: |
                                    git diff common feature_A --diff-filter=CMRTUXBD
                                出力: |  #focus: common, feature_A
                                    | Line1
                                    - common 1 before
                                    + common 1 after
                                    | Line2
                                    + feature_A 2 after
                                    + Line3
                                出力の説明:
                                    - 共通部分のコードに変更があった。feature_A で common 1 after に変更した
                                    - feature_A は共通ではない部分。差分ではなく + として表示されます
                            feature_A で変更した共通部分だけを common に反映させます:
                                -   git checkout "common"
                                    git diff feature_A --diff-filter=ACMRTUXB  #// - が feature_A, + が common
                                -   _c="$(sed "s/common 1 before/common 1 after/g"  file1.txt)";  echo "$_c" > file1.txt;  unset _c
                                    git diff feature_A --diff-filter=ACMRTUXB
                                -   git status
                                    git diff
                                    git add "."
                                    git commit -m "common_2"
                            common ブランチから feature_A ブランチと feature_B ブランチにマージします:
                                コマンド: |
                                    #// feature_A branch
                                    -   git checkout "feature_A"
                                        git merge  "common"  --no-edit    #// マージされたことが記録されるため必要
                                            #// 違いがあったら基本的に ours を採用してコミットします
                                        git diff HEAD   #// 違いなし
                                            #// 編集していたら
                                            #// git add "."
                                            #// git commit -m "Merge branch 'common' into feature_A: merge"
                                    -   gitlog
                                    #// feature_B branch
                                    -   git checkout "feature_B"
                                        git merge  "common"  --no-edit    #// マージされる。clean 状態になる
                                        git diff HEAD  #// 違い（下記）を確認すること
                                    -   gitlog
                                feature_B ブランチに自動的に反映された内容: |  #// 共通部分だけ自動的に変更されている
                                    | Line1
                                    - common 1 before
                                    + common 1 after
                                    | Line2
                                    | feature_B 2 before
                                    | Line3
                    後でまとめてマージするサンプル: #🌟
                        作業フォルダーを作り、移動します:  #// 上記
                        feature_A ブランチと feature_B ブランチを作ります:
                            common ブランチを作ります:  #// 上記
                            feature_A ブランチと feature_B ブランチを作ります:  #// 上記
                        共通ファイルを追加します:
                            common ブランチに共通ファイルを追加します: |
                                #// common branch
                                    git checkout "common"
                                    echo "
                                        Line1
                                        common 1 before
                                        Line2
                                    "   >  file1.txt
                                    git add "."
                                    git commit -m "common_1"
                        #// ここまで基本サンプルと同じ
                            common ブランチから feature_A ブランチだけにマージします: |
                                #// feature_A branch
                                    git checkout "feature_A"
                                    git merge  "common"  --no-edit
                                    git checkout --ours  "file1.txt"  #// 基本は feature_A のままにする
                                    git add "."
                                    git commit -m "feature_A_2"
                        同期: #🌟 #keyword: update common branch  #// feature_A ブランチで共通部分と固有部分を変更し、共通部分を common ブランチにも反映します:
                            現在の feature ブランチ: java  #template: __FeatureBranch__  
                            feature_A ブランチで共通部分と固有部分を変更します: |  #// 通常の開発によるコードの変更
                                #// java branch            #template: __FeatureBranch__
                                    git checkout "java"    #template: __FeatureBranch__
                                    _c="$(sed "s/common 1 before/common 1 after/g"  file1.txt)";  echo "$_c" > file1.txt;  unset _c
                                    _c="$(sed "s/feature_A 2 before/feature_A 2 after/g"  file1.txt)";  echo "$_c" > file1.txt;  unset _c
                                    git add "."
                                    git commit -m "feature_A_3"
                            feature_A で変更した共通部分だけを common にフィードバックします:
                                コマンド >> common ブランチの編集を開始します:
                                    -   git status  #// clean 状態であること
                                    -   git checkout "common"  #// feature ブランチが枝分かれしたコミットより、common ブランチが枝分かれしたコミットが過去であること
                                    -   _c="$(sed "s/common 1 before/common 1 after/g"  file1.txt)";  echo "$_c" > file1.txt;  unset _c
                                        #// この編集を行う場所は下記
                                詳細 >> common ブランチと feature_A ブランチを比較します:  #keyword: Git compare common branch
                                    _:
                                        ファイル名一覧: #// feature_A で更新したファイルのうち、common にもあるファイルを一覧します
                                                （bash):
                                                    comm -12  <(git diff  java  common  --name-only | sort)  <(find "." -type f | sed "s/^\.\///g" | sort)
                                                        #template: comm -12  <(git diff  __FeatureBranch__  common  --name-only | sort)  <(find "." -type f | sed "s/^\.\///g" | sort)
                                        ファイルの内容を比較しながら編集します:
                                            （端末左半分）feature の更新内容:
                                                （新しい bash または PowerShell):
                                                    git diff  common  java  __FilePath__    #template: common  __FeatureBranch__
                                            （端末右半分）common の更新内容:
                                                    git diff  common  __FilePath__
                                        common ブランチの内容を更新します:
                                            code __FilePath__
                                        以上を全てのファイルに対して行います:
                                    旧）ファイルの内容:
                                        （左）feature の更新内容:  #// HEAD と HEAD~ の比較内容
                                            （新しい bash または PowerShell):
                                                git diff  java~  java  __FilePath__    #template: __FeatureBranch__~  __FeatureBranch__
                                        （右）common と feature~ の比較内容:
                                            （左右分割された新しい bash または PowerShell）:
                                                git diff  java~  common  __FilePath__       #template: __FeatureBranch__~  common
                                        （右）common の更新内容:
                                                git diff  common  __FilePath__
                                コマンド >> common ブランチをコミットします:
                                    -   git status
                                        git diff
                                        git add "."
                                        git commit -m "common_2"
                                    #// まだ下記に続きがあります
                                （旧）:
                                    common と feature_A を比較します:  #// common ブランチにフィードバックする部分が有るか無いかを判定します。編集はここではしません
                                        コマンド: |
                                            git diff common java --diff-filter=CMRTUXBD    #template: __FeatureBranch__
                                        出力: |  #focus: common, feature_A
                                            | Line1
                                            - common 1 before
                                            + common 1 after
                                            | Line2
                                            + feature_A 2 after
                                            + Line3
                                        出力の説明:
                                            - common に変更があった
                                            - feature_A は共通ではない部分。差分ではなく + として表示されます
                                    （もしあれば）feature_A で変更した共通部分だけを common にフィードバックします:
                                        -   git status  #// clean 状態であること
                                        -   git checkout "common"
                                            git diff java --diff-filter=ACMRTUXB                #template: __FeatureBranch__
                                        -   _c="$(sed "s/common 1 before/common 1 after/g"  file1.txt)";  echo "$_c" > file1.txt;  unset _c
                                            git diff java --diff-filter=ACMRTUXB                #template: __FeatureBranch__
                                        -   git status
                                            git diff
                                            git add "."
                                            git commit -m "common_2"
                            common ブランチから feature_A ブランチにマージします: #// common にフィードバックしなかったときも実行します。同期した日の記録に相当します
                                コマンド: |
                                    #// java branch                        #template: __FeatureBranch__
                                    -   git checkout "java"                #template: __FeatureBranch__
                                        git merge  "common"  --no-edit    #// マージされたことが記録されるため必要
                                            #// 違いがあったら基本的に ours を採用してコミットします
                                        git diff HEAD   #// 違いなし
                                            #// 編集したら
                                            #// git status
                                            #// git add "."
                                            #// git commit -m "Merge branch 'common' into java: merge"    #template: __FeatureBranch__
                                    -   gitlog2 HEAD common  #// マージしたことを確認します
                                #// コンフリクトが発生したときは、マージされないことがあります。その場合、もう一度マージしてください。
                        同期 >> feature_B ブランチで共通部分と固有部分を変更し、共通部分を common ブランチと feature_A ブランチにも反映します:
                            feature_B ブランチで共通部分と固有部分を変更します: |
                                #// feature_B branch
                                    git checkout "feature_B"
                                    _c="$(sed "s/common 1 before/common 1 after B/g"  file1.txt)";  echo "$_c" > file1.txt;  unset _c
                                    _c="$(sed "s/feature_B 2 before/feature_B 2 after/g"  file1.txt)";  echo "$_c" > file1.txt;  unset _c
                                    git add "."
                                    git commit -m "feature_B_2"
                            common と feature_B を比較します:
                                コマンド: |
                                    git diff common feature_B --diff-filter=CMRTUXBD
                                出力: |  #focus: common, feature_A
                                    | Line1
                                    - common 1 after
                                    + common 1 after B
                                    | Line2
                                    + feature_B 2 after
                                    + Line3
                                出力の説明:
                                    - common に変更があった。コンフリクトしたかどうかは分からない。
                                    - feature_B は共通ではない部分。差分ではなく + として表示されます
                            feature_B で変更した共通部分だけを common に反映させます:
                                -   git checkout "common"
                                    git diff feature_B --diff-filter=ACMRTUXB
                                -   _c="$(sed "s/common 1 after/common 1 after B/g"  file1.txt)";  echo "$_c" > file1.txt;  unset _c
                                    git diff feature_B --diff-filter=ACMRTUXB
                                -   git status
                                    git diff
                                    git add "."
                                    git commit -m "common_3"
                            common ブランチから feature_A ブランチと feature_B ブランチにマージします:
                                コマンド: |
                                    #// feature_A branch
                                    -   git checkout "feature_A"
                                        git merge  "common"  --no-edit    #// マージされたことが記録されるため必要
                                        git diff HEAD  #// 違い（下記）を確認すること
                                    -   gitlog
                                    #// feature_B branch
                                    -   git checkout "feature_B"
                                        git merge  "common"  --no-edit    #// マージされる。file1.txt は初マージなのでコンフリクトになる
                                    -   git checkout --ours  "file1.txt"  #// 基本は feature_B のままにする
                                        git status  #// both added
                                        git diff    #// 違いなし
                                        git add "."
                                        git commit -m "feature_B_3"    #// マージされたことが記録されるため必要
                                        git diff HEAD  #// 違いなし
                                    -   gitlog
                    古い方法:
                        新しくリポジトリを作る場合:  #keyword: install Git newroot branch
                            サーバーなしの .git フォルダーを作ります:  #search: Git local work
                            newroot ブランチを作ります:
                                -   git checkout -b newroot
                                    echo "a" > "dummy"
                                    git add "."
                                    git commit -m "root"
                                    rm "dummy"
                                    git add "."
                                    git commit -m "newroot"
                            メイン ブランチに移動します:
                                -   git checkout master  #// または main
                            ブランチの位置を確認します:  #// メイン ブランチは、ファイルを追加してコミットしたら現れます
                                -   gitlog  #search: gitlog
                        既存のリポジトリ(.zip)から始める場合:
                            参考:
                                .git.zip: #search: .git.zip
                                    #// common ブランチを使う場合 .git.zip を作る必要はありません。
                                    #// サンプルが .git.zip を使う理由は .git.zip の目的を参照
                            branch_all または branch_all_of_____ フォルダーにファイルが既にある場合:  #search: start .git.zip
                            newroot ブランチをベースに新しいブランチを作ります:  #search: .git.zip new branch
                        リポジトリを保存する場合:  #search: make .git.zip
                newroot ブランチ: #// すべてのブランチの起源となるブランチ  #keyword: Git newroot branch
                    ファイルが全くないコミットのみ。
                    これがないとパーツを追加することができなくなります。
                common ブランチ: #// バージョン管理する共通部分（プロジェクトの一部）のブランチ。無くてもよい
                    common にはブランチによっては使わないフォルダーを入れ、ブランチで削除します:
                    common にはブランチによって異なるファイルは入れません:
                    複数のコンポーネントを入れる場合:  #// 推奨  #// フレームワーク内コンポーネントが複数ある場合
                        メリット: 管理対象が少なくなります。
                            すべてのコンポーネントを最新のコミットにすることや最新とマージすることができます。
                        デメリット: 一部のコンポーネントのコミットだけ変えるときに Git merge が使えません。
                    コンポーネントごとにブランチを作る場合:  #// 非推奨
                        メリット: Git merge の対象がコンポーネントごとにできます
                        デメリット: ブランチが大量にできるので、サブモジュールと同様にブランチの管理が必要になります
                dependency.yaml: #// common ブランチに完全対応するまでの依存関係情報。無くてもよい  #keyword:
                    #ref: ${GitHub}/MyPrivateCode/ansible_vagrant/multi_vm_ansible/dependency.yaml
            コンポーネントを管理する場合: #// コンポーネントのフォルダーの中に別の管理対象がない場合
                管理対象のファイルの数が多い場合:
                    #search: Git submodules
                管理対象の数が多い場合:
                    親プロジェクトの __Project__/.components で独自に管理します:  #keyword: .components
                        参考: #search: .gitmodules
    ワーキング ツリー: #keyword: Git working tree  #// git clone してローカルにできたフォルダー。 Worktree とは異なります  #search: Git worktree
    Worktree: #keyword: Git worktree  #// ワーキング ツリーとは異なります  #search: Git working tree
        サンプル:
            フォルダー構成:  #// 下記のコマンドでできるフォルダーの構成
                ~/worktree
                ├── __Project__
                │     └── .git/
                └── __FolderB__
                       └── .git     #// ファイル
            .git ファイルの内容: |
                gitdir: __MainWorking__/.git/worktrees/__BranchB__
            コマンド: |
                cd  ~/worktree
                git clone  https://github.com/____/__Project__  -b __BranchA__
                cd  __Project__
                git worktree add  ../__FolderB__  __BranchB__
                cd ../__FolderB__
                git branch
                    + __BranchA__
                    * __BranchB__
            #// ~/worktree 直下では、git コマンドが使えません。
    マージ:  #search: git merge
    タグ:  #// 特定のコミットに対して付けることができる別名  #keyword: git tag
        概要:
            .git/ref にある「参照」の１つであるが、コミットしても移動しない。
            一部の機能がテスト済みのコミットにタグをつけるのも良いでしょう
        実践例 >> 新機能を入れる前のリビジョンにタグを追加します:  #keyword: git tag stable version
            最終的なブランチの形:
                0.1.x --> new 0.1.x --> new 0.2.x [develop ブランチ]
                        --> 0.2.0 --> ↑             [0.2.x ブランチ]
            （新機能のコーディングが始まっていたら）:
                新機能(new)をコミットします:
            前のリビジョンからブランチ(0.2.x)を作ります:
                git checkout  -b "0.2.x"  "__CommitID__"
            作ったブランチで、ソースの中のバージョン番号を更新してコミットします:
            タグ(0.2.0)をつけます:
                - git tag -a  "0.2.0"  -m "__Comment__"
                - git push origin  "0.2.0"  #// git push だけではサーバーに反映されません
            新機能のブランチへ戻すマージをします:
        タグを一覧します: #keyword: list git tag
            ローカル: git tag
            リモート: git ls-remote --tags  #// 出力の各行の末尾に ^{} があるものは、追跡参照（dereference）です
            ローカルだけ: #keyword: list local only git tag  #// リモートに無い
                comm -23 <(git tag | sort) <(git ls-remote --tags origin | sed 's/.*refs\/tags\///' | sort)
            バージョン 2 に絞り込んで一覧します: git tag | grep v2
        タグの詳細を表示します:  #keyword: git show tag, read git tag
            git show __TagName__
        タグを検索します:
            最も近いタグ: git describe --tag
            条件付き検索: git describe HEAD --tags --long --match "v*" --exclude "-rc.*"
        タグを追加します:  #keyword: git tag add, create git tag  #snippet-depth: 2
            コマンド テンプレート:
                NewTagName="__TagName__";  CommitID="__CommitID__"
                git tag -a  "${NewTagName}"  -m "${NewTagName}"  "${CommitID}"
                git push origin  "${NewTagName}"
                unset  NewTagName;  unset  CommitID
            WIP 開始タグ の場合:  #search: wip-start
            （必要なら）ワーク フォルダーを作り直します:
                - rm -rf  "project"  #// 【注意】フォルダーを削除します
                - git clone  "https://github.com/user/project.git"
                - cd  "project"
            コマンド:
                - git tag -a  "__TagName__"  -m "__Comment__"  "__CommitID__"  #// __CommitID__ は省略できます
                - git push origin  "__TagName__"  #// git push だけ（パラメーターなし）ではサーバーに反映されません
            補足:
                - -m オプションを省略すると、vi エディターが開いてしまいます
                - __CommitID__ は省略できます。現在のコミットにタグが付きます
                - 既存のブランチ名と同じタグ名を付けることはできません。git push するときに失敗します
            関連 >> リリース:  #search: GitHub release tag
        タグを追加した日時:
            コマンド: git tag -l --format="%(creatordate:iso8601) %(refname:short)" | sort | tail
            出力:
                2022-01-01 17:57:19 +0900 v1.0.0
                2022-02-02 13:40:33 +0900 v1.2.0
                2022-03-03 10:56:12 +0900 v1.0.1
            参考: #ref: https://stackoverflow.com/questions/6900328/git-command-to-show-all-lightweight-tags-creation-dates
        タグを移動します:  #keyword: update git tag,  move git tag
            _: 移動するコマンドはありません。コメントを退避した後、削除して追加してください。
            __: | #snip:  #search: delete git tag  #search: git tag add
                git checkout  __TargetBranch__
                git tag -d  "__TagName__"
                git push origin :refs/tags/__TagName__
                git tag -a  "__TagName__"  -m "__TagName__"   #// コメントはタグ名と同じ内容にしています
                git push origin  "__TagName__"
        タグを削除します:  #keyword: delete git tag  #snippet-depth: 2
            注意: マージ ベース（枝分かれしたコミット）からタグがあるコミットまでの、１つ以上のコミットも削除されます
            コマンド:
                DeletingTagName="__DeletingTagName__"
                git tag -d  "${DeletingTagName}"
                git push origin :refs/tags/${DeletingTagName}
                unset DeletingTagName
            ローカルだけにあるタグ:  #search: list local only git tag
        アーカイブ:  #search: Git branch archive
    スタッシュ: #keyword: Git stash  #// コミット前の編集内容を一時退避するスタック
        #ref: https://git-scm.com/docs/git-stash
        プッシュ:  #// 編集内容をスタッシュに入れ、編集前（クリーン状態）に戻します
            名前あり: git stash save __Name__
            名前なし: git stash
        ポップ:
            基本:
                - git stash pop  #// 最近プッシュした編集内容が ワーキング フォルダー に復活します
                - git stash pop stash@{1}  #// 2番目をポップ
            コンフリクトしたとき:  #// 注意：スタッシュ リスト から削除されません
                - git stash pop
                #// コンフリクトしたら、git stash pop しても スタッシュ リスト から削除されません
                #// 編集が完了したら
                - git stash drop  #// 最近プッシュしたスタッシュを削除します
        一覧: git stash list  #// スタッシュに入っている編集内容（エントリー）の名前を一覧します
        内容:
            差分: git stash show -p 0  #// 0 は git stash list で表示される stash@{0} の 0
            差分があるファイル名の一覧: git stash show 0
        削除:  #// 編集内容（エントリー）をスタッシュから削除します
            1つ:
                git stash list
                git stash drop stash@{__Number__}
            全部:
                git stash list
                git stash clear
    サブモジュール: #keyword: Git submodules, Git サブモジュール, Git sub project
        参考: https://qiita.com/sotarok/items/0d525e568a6088f6f6bb
        注意:
            数個のファイルからなるサブモジュールが大量になるプロジェクトを管理することは難しいでしょう:
                なぜなら GitHub のリポジトリが膨大になり管理が難しくなるからです。
            他の人の意見:
                （monorepo の宣伝）
                最終的には、Git サブモジュールは複数のリポジトリを維持する際の問題を解決できません。
                開発プロセスとコードレビュープロセスをスピードアップするために、モノリシックリポジトリを使用することにしました。
                https://www.shopsys.com/how-to-maintain-multiple-git-repositories-with-ease-61a5e17152e0/ >>
                    2. Git サブモジュール
        概要:
            概要: サブモジュールは、クローンしたプロジェクトのフォルダーの中にできる別のプロジェクトです
            フォルダー構成:
                - __Project__/.git
                - __Project__/__SubModule__/.git
                - __Project__/.gitmodules  #search: .gitmodules
            動作概要:
                - git clone や git status は、サブモジュールも同時に行います。
                - 更新（pull, pull, checkout）は、サブモジュールの外と中で別々に行います。
            サブモジュールも同時に更新する場合: #keyword: Git submodules zip
                サブモジュールの外を更新（pull, pull, checkout）したときに、サブモジュールの中のファイルも更新する場合、
                普段は、サブモジュールの中の .git フォルダーを圧縮しておき、
                サブモジュールを更新（pull, pull, checkout）するときは、一時的に .git フォルダーを復帰させます。
            モノレポ: #keyword:  Monorepo,  モノレポ
                概要: アプリケーションやマイクロサービスの全コードを単一のモノリシックなリポジトリ (普通は Git) に保存するパターン
                    #ref: https://zenn.dev/anneau/articles/4c9beff9645af7
        clone: #// サブモジュールを含むリポジトリをクローンします  #search: git clone submodule
        追加: #// git submodule add  #// サブモジュールとしてクローンします
            git submodule add:  #keyword:
                - cd  "__ParentOfNewSubModule__"
                - git submodule add __URL__  #または
                - git submodule add __URL__  __NewLocalFolderPath__
        一覧: #// プロジェクトに含まれるサブモジュールを一覧します
            __RootProject__/.gitmodules のサンプル: |  #keyword: .gitmodules
                [submodule "bootstrap"]
                    path = bootstrap
                    url = https://github.com/twbs/bootstrap.git
        更新: #// git submodule update  #// サブモジュールも当時のコミットに合わせます  #keyword: git submodule update
            外をコミットしたときのサブモジュールのコミットへ更新:
                参考: git checkout への影響  #search: submodule git checkout
            最新への更新(?): https://stackoverflow.com/questions/1030169/easy-way-to-pull-latest-of-all-git-submodules
        影響: #// サブモジュールの外で Git の操作をするときの影響  #glossary: submodule
            git clone:
                サブモジュールの外（上記 __Project__）をクローンすると、サブモジュール（上記 __SubModule__）もクローンします
            git status:
                概要: サブモジュールの外は、サブモジュールの中のファイルの変更を管理しません。
                    サブモジュールの外は、サブモジュールのコミットのハッシュ値だけ持っています。つまり参照関係にあります。
                modified:__submodule__ (new commits) と表示された:
                    サブモジュールの外をコミットしたときのサブモジュールのコミットが
                    現在のサブモジュールのコミットと異なるとき（ワークで更新したとき？）に表示されます。
                    #search: git submodule update
                modified:__submodule__ (modified content) と表示された:
                    サブモジュール内で git status すると差分が表示される状態であるときに表示されます。
                modified:__submodule__ (untracked content) と表示された:
                    サブモジュール内で git status すると差分が表示される状態であるときに表示されます。
            git checkout:
                チェックアウトしたとき、サブモジュールのコミットは、サブモジュールの外をコミットしたときのものではありません。
                ただし、記録としては当時のコミットであるので、git status するとコミットの差分が表示されます。
                サブモジュールも当時のコミットに合わせるときは、git submodule update をサブモジュールの外で実行します。
            git commit:  #// git push を参照
            git push:
                概要:
                    サブモジュールの中にあるファイルはサブモジュールの外が行うコミットやプッシュの対象外です。
                    また、コミット時のサブモジュールのコミットが .gitmodules ファイルに記録されます。
                手順:
                    先に、cd で カレント フォルダーをサブモジュールに移動してコミットやプッシュします:
                    その後で、サブモジュールの外に移動してコミットやプッシュします:
                新規ブランチをアップロードします:
                    git push --set-upstream origin  __Branch__
                ブランチをアップロードします:
                    git push origin __Branch__
                オプション:  #glossary: git push
                    --force:  #// 強制プッシュ。非推奨
                    --force-with-lease:  #// リース付き強制プッシュ
                        概要:
                            - 他の人が commit を追加していなければ通常のプッシュで拒否されるときでもプッシュします
                            - GitHub で強制プッシュを禁止していてもリース付き強制プッシュならできることが多いです
                        余談 >> lease の意味:
                            - 一般的な lease の意味は、不動産などを借りることです
                            - --force-with-lease の lease の意味は、リモートの最後の状態を「リース（予約）」し、その状態が変更されていないことを確認することです
                トラブルシューティング(git push): #search: git push trouble
    LFS: #keyword: Git LFS  #// 大きいファイルの代わりの ポインターファイル（メタ情報のファイル）。LFS = Large File Storage
        手順:
            新規作成, チュートリアル: #keyword: Git LFS tutorial  #// Git LFS に対応したリポジトリを新規作成して、一部ダウンロード、一部更新します
                インストール状況を確認します: #keyword: Git LFS version  #// Git LFS がインストールされているか確認します
                    git lfs version
                    #// バージョンが表示されればインストールされています
                Git LFS をインストールします: #keyword: install Git LFS
                    Windows GitHub 公式:
                        - https://git-lfs.github.com/ >> Download
                        - ダウンロードしたファイル（例：git-lfs-windows-v3.5.1.exe）を開く
                    CentOS7: sudo yum install -y  git-lfs
                    mac: brew install git-lfs
                    Git LFS をインストールできない場合:
                        .gitattribute を削除します（あれば）
                    参考:
                        GitLab 公式: https://gitlab-docs.creationline.com/ee/topics/git/lfs/
                        Git LFSについて調べてみた: https://medium.com/nttlabs/enabling-git-lfs-c907ca393ccb
                リポジトリを新規作成します:
                    #search: Git new repository
                git clone >> 初回:  #// 設定ファイル .gitattributes ファイルを追加します
                    注意: createrepo コマンドを使うときは、ポインターファイルは使えません
                    コマンド: |
                        cd  __ParentOfProejct__
                        rm -rf  my-vm
                        GIT_LFS_SKIP_SMUDGE=1  git clone https://github.com/svc-my/my-vm    #// ポインター ファイル だけできます
                        cd  my-vm
                        git checkout -b download_test

                        tee .gitattributes > /dev/null  #// 左記コマンド実行後、貼り付け, Ctrl + D で完了  #search: Git LFS .gitattributes
                            * filter=lfs diff=lfs merge=lfs -text
                            .gitattributes -filter=lfs -diff=lfs -merge=lfs text
                            git-config/** -filter=lfs -diff=lfs -merge=lfs text

                            *.md -filter=lfs -diff=lfs -merge=lfs text
                        git add "."
                        git commit -m "Add .gitattributes file."
                        git push
                git clone >> 2回目:  #// 最初の LFS 適用ファイルを追加します。同時に git-config も追加するように要求されます
                    git clone する場合:
                        cd  __ParentOfProejct__
                        rm -rf  my-vm
                        GIT_LFS_SKIP_SMUDGE=1  git clone https://github.com/svc-my/my-vm  -b download_test
                        #// 以下に続きます
                    共通: |
                        cd  __Proejct__
                        touch  "__FilePath__"  #// LFS が適用されるファイルを配置します。まだ、１つもアップロードしないときは dummy ファイルを配置します
                        git add "."
                            #// git add を実行すると自動的に  __Project__/git-config/hooks にファイルが生成されます
                        rm  "__FilePath__"  #// dummy ファイルを配置したときは、ここで dummy ファイルを削除します
                        git add "."
                            #// git-config/ を追加します
                        git lfs ls-files
                            #// git-config が含まれていないことを確認します
                        git commit -m "Add first LFS file and git-config (automatically)."  または  git commit -m "Add git-config (automatically)."
                        git push  #// 時間計測する場合は time git push
                一部ダウンロードします: #keyword: download in Git LFS,  download Git LFS pointer and large files
                    #// 一部だけ大きいファイルをダウンロードします
                    WebUI の場合:
                        ファイルをクリックするとダウンロードできます
                        git clone は不要です
                    CLI >> git clone の場合: |
                        cd  __ParentOfProejct__
                        rm -rf  my-vm
                        GIT_LFS_SKIP_SMUDGE=1  git clone https://github.com/svc-my/my-vm  -b download_test
                        git lfs pull  --include "__LargeFilePath__"
                        ls -l  "__LargeFilePath__"
                    CLI >> curl の場合:  #// 認証ありの場合、未確認
                        OK: |
                            curl --header "PRIVATE-TOKEN: $(cat ~/.secret/gitlab-pat-LFS-downloader)"  "https://gitlab.com/api/v4/projects/9907/repository/files/.vagrant.7z/raw?ref=download_test"  --output "./lfs_pointer"
                                version https://git-lfs.github.com/spec/v1
                                oid sha256:1111d75328adab4f7ac40d24ba092fac3543557bcab831605bcb58c33bd14847
                                size 7151
                            以降、未確認
                            ファイル本体のダウンロードはできない
                        NG: |
                            "${glabCommand}" api /projects/9907/gitlab-lfs/objects/sha256:1111d75328adab4f7ac40d24ba092fac3543557bcab831605bcb58c33bd14847
                            curl --header "PRIVATE-TOKEN: $( cat ~/.secret/gitlab-pat-LFS-downloader )" https://gitlab.com/user/proj/-/raw/download_test/.vagrant.7z
                            curl --header "PRIVATE-TOKEN: $(cat ~/.secret/gitlab-pat-LFS-downloader)"  "https://gitlab.com/user/proj/gitlab-lfs/objects/1111d75328adab4f7ac40d24ba092fac3543557bcab831605bcb58c33bd14847"  --output "./a.7z"
                一部アップロードします: #keyword: upload in Git LFS
                    #// 一部だけ大きいファイルを更新して git push します
                    CLI の場合:  #search: update one Git LFS file
                        cd  "__Project__"
                        （LFS が適用されるファイルを配置します。ポインターファイルから置き換えます）
                        git add "."
                        git commit -m "____"
                        git push  #// 時間計測する場合は time git push
                    WebUI の場合:
                        大きいファイルは、時間がかかりすぎるか失敗したことしかありません
                （ポインターファイルに戻す場合）:
                    - できません。git clone からやり直します  #search: download Git LFS pointer files
            一部だけ大きいファイルをダウンロードします: #search: download in Git LFS
            一部だけ大きいファイルを更新して git push します: #keyword: upload one Git LFS file,  update git push one Git LFS file
                注意: createrepo コマンドを使うときは、ポインターファイルは使えません
                （準備）:  #search: Git LFS tutorial
                    GIT_LFS_SKIP_SMUDGE=1  git clone https://github.com/svc-my/my-vm    #// ポインター ファイル だけできます
                ポインターファイルを、更新する内容のファイルに置き換えます:
                    code  __PointerFilePath__
                        または
                    cp  __SourceFilePath__  __PointerFilePath__
                        など
                git push します:  #// 自動的にポインターファイルではないと判定します
                    cd  "__GitWork__"
                    git add "."
                    git commit -m "____"
                    git push
            すべて大きいファイルをダウンロードします: #keyword: download Git LFS large files
                CLI の場合:
                    ダウンロードします:
                        git-lfs がインストールされているか確認します:
                            #search: Git LFS version
                            Git LFS をインストールする場合:
                                #search: install Git LFS
                        git clone します:
                            普段の git clone コマンドと同じです
                    ポインターファイルがダウンロードされてしまう場合:
                        Git LFS をインストールします:  #search: install Git LFS
                    git clone の動き:
                        Git LFS がインストールされていないとき:  #search: Git LFS version
                            _: ポインターファイルがダウンロードされます
                        Git LFS がインストールされているとき:
                            _: 大きいファイルがダウンロードされます
                            一部だけ大きいファイルをダウンロードする場合:  #search: download in Git LFS
                ブラウザーの場合:
                    1つのファイル:  ブラウザーからダウンロードできます
            すべてポインターファイルでダウンロードします: #keyword: download Git LFS pointer files
                Git LFS がインストールされていない場合:
                    普通に git clone します
                Git LFS がインストールされている場合:
                    GIT_LFS_SKIP_SMUDGE 環境変数を設定します:  #keyword: GIT_LFS_SKIP_SMUDGE
                        GIT_LFS_SKIP_SMUDGE=1  git clone ____
                        #// 参考: https://stackoverflow.com/questions/42019529/how-to-clone-pull-a-git-repository-ignoring-lfs
                    #// git clone したあとで大きいファイルを追加して git add することはできます。
                    #// add したファイルの ポインターファイルをダウンロードすることもできます。
            ポインターファイルに戻します:
                できません。git clone からやり直します
                #search: Git LFS tutorial  >> ポインターファイル
            LFS の状態を表示します:  #search: git lfs ls-files
            リポジトリに大きいファイルがある警告に対処します:
                Encountered 1 file that should have been a pointer, but wasn't:  #// 大きいファイルなのに、Git LFS の ポインター ファイル がリポジトリに入っていません。
                    手順:
                        git checkout などを実行したら、編集ありの状態になり、clean できない
                    ログ: |
                        $ git status
                            modified:   pyzabbix-0.7.5.tar.gz
                        $ git checkout .
                            Updated 1 path from the index
                            Encountered 1 file that should have been a pointer, but wasn't:
                                pyzabbix-0.7.5.tar.gz
                    対処: |  #// リポジトリにあるファイルを Git LFS の ポインター ファイル に置き換えます。大きいファイルがリポジトリから無くなるわけではありません
                        $ git lfs status  #// 問題のファイルを一覧します
                            Objects not staged for commit:
                                pyzabbix-0.7.5.tar.gz (Git: 23ce8c7 -> File: 23ce8c7)
                        $ git lfs migrate import --no-rewrite
                            migrate: override changes in your working copy?  All uncommitted changes will be lost! [y/N] y
                            migrate: changes in your working copy will be
                        $ git add . / commit / push
                    状況:
                        大きいファイルなのに、Git LFS の ポインター ファイル がリポジトリに入っていません。
        コマンド:  #glossary: Git LFS
            スコープ:
                - git lfs コマンドは localhost 内グローバル（~/.gitconfig）に影響します。
                - --local オプションを付けると Git ワーキング内だけに影響します。
            git lfs install:  #// git lfs コマンドを使えるようにします  #search: download in Git LFS
                デフォルトで大きいファイルをダウンロードする場合:  #// git clone で LFS トラックされたファイルを自動的にダウンロードします
                    git lfs install
                ポインターファイルをダウンロードする場合:
                    git lfs install  --skip-smudge
                グローバル設定を変える場合:  #// 自動的にダウンロードするかどうかの設定を localhost 内のグローバルに対して変える場合
                    git lfs install  [--skip-smudge] を再実行します
                ローカル設定を変える場合:  #// 特定の Git ワーキング フォルダー の中だけ自動的にダウンロードするかどうかの設定を変える場合
                    git lfs install --local [--skip-smudge]
            git lfs pull:  #// ダウンロードします
                git lfs pull  --include "__LargeFilePath__"  #search: download in Git LFS
            git lfs ls-files:  #// 状態を表示します
                書式: __Hash__  __AsteriskOrHyphen__ __Path__
                __AsteriskOrHyphen__:
                    "*": 実際の内容が入っています
                    "-": ポインターファイルになっています
            git lfs track __Path__:
                __Project__/.gitattributes ファイルに行を追加します
            git lfs untrack __Path__:
                __Project__/.gitattributes ファイルから該当行を削除します
        ファイル:
            ポインターファイル:  #keyword: Git LFS pointer file,  Git LFS ポインターファイル
                #// LFS フィルター を適用したファイルには、ポインターファイルもできます
                サンプル:
                    version https://git-lfs.github.com/spec/v1
                    oid sha256:00001111ad9d8850e5e50e7ecbeb869f5dee086248e3769e407bf50f1705dc74
                    size 123456
                ダウンロード:  #search: download in Git LFS
                その他手順:  #search: install Git LFS
            LFS が適用されているかどうか: #keyword: Git LFS LFS-tracked files
                WebUI でファイル一覧を表示し、ファイル名の右に (LFS) が付いているかどうか
            .gitattributes ファイル:  #search: Git LFS .gitattributes
            ファイルやフォルダーに対する設定:  #// LFS トラックします
                フォルダーに LFS を使う設定をします:  #// フォルダーを LFS トラックします
                    __TargetFolder__/.gitattributes ファイル: #keyword: Git LFS .gitattributes
                        設定:
                            基本: |  #// 拡張子が .rpm のファイルに対して LFS フィルター を適用します
                                *.rpm filter=lfs diff=lfs merge=lfs -text
                            一部除外: |  #// 拡張子が .rpm のファイル「以外」に対して LFS フィルター を適用します
                                * filter=lfs diff=lfs merge=lfs -text
                                .gitattributes -filter=lfs -diff=lfs -merge=lfs text
                                git-config/** -filter=lfs -diff=lfs -merge=lfs text

                                *.md -filter=lfs -diff=lfs -merge=lfs text
                        参照:
                            filter, diff, merge に接頭辞 - が付いていなければ LFS が適用されます
                フォルダーに LFS を使わない設定をします:  #// LFS をインストールしていない環境でもファイルをダウンロードします。ポインターファイルにしません
                    git lfs uninstall
                    touch **/*
                    git commit -a
                    #// 参考: https://stackoverflow.com/questions/48699293/how-to-i-disable-git-lfs
            ローカル キャッシュ:  #keyword: Git LFS local cache
                デフォルト: __Project__/.git/lfs/objects
                LFS_OBJECT_DIR 環境変数:
        概念:
            smudge: #keyword: Git LFS smudge  #// スマッジ（汚す）。 ポインターファイルを大きいファイルに変換すること
            clean: #keyword: Git LFS clean  #// 大きいファイルをポインターファイルに変換すること
    フック:  #keyword: Git hooks,  git-config  #ref: https://git-scm.com/docs/githooks
        #ref: ${COMMAND_PREFIX}{programming}/方法論/CVS/Git.svg#Git_hook
        ❗注意: ローカルでのみ実行されます。GitHub ではフックは実行されません。たとえばプルリクエストしても post-merge フックは動きません。
        フックの目的:
            ブランチごとの要求事項のチェック:
            Gitの管理対象外の内容のチェック: .gitignore されるファイルの存在や内容のチェックや自動調整をフックを使って自動実施できます
            パーミッションの復元: chmod +x 以外のパーミッションは Git は管理対象外ですが、フックを使って管理できます
        フックを .git の外に作る場合:
            準備: #keyword: git hookspath
                PC ごとに１度だけ下記の設定コマンドを実行する必要があります。
                git config --local  core.hookspath  "git-config/hooks"
            コミットを禁止します:  #keyword: disabled git commit
                __Project__/git-config/hooks/pre-commit: |  #keyword:
                    #!/bin/bash
                    pwd  #// カレント フォルダー に関わらず __Project__ になります
                    echo  "To commit this work folder is disabled by __Project__/git-config/hooks/pre-commit"
                    exit  1
                実行可能モードを追加します:
                    chmod +x __Project__/git-config/hooks/pre-commit
                サンプル (Git bash):
                    コミットを禁止します: #keyword: disable git commit
                        （１回目）Git hooks を使えるようにします:  #search: Git hooks
                        (git bash): |  #focus: git-config/hooks
                            cd  __Project__
                            git config --local  core.hookspath  "git-config/hooks"
                            edit="$(pwd)/git-config/hooks/pre-commit"
                            mkdir -p  "${edit}"
                            rmdir     "${edit}"
                            echo  '#!/bin/sh' > "${edit}"
                            echo  "pwd" >> "${edit}"
                            echo  "echo  \"\"  >&2" >> "${edit}"
                            echo  "echo  \"__Project__/git-config/hooks/pre-commit: [ERROR] To commit in this work is disabled\"  >&2" >> "${edit}"
                            echo  "exit  1" >> "${edit}"
                            chmod +x  "${edit}"
                            ls -l  "git-config/hooks/pre-commit"
                            git status
                    （必要なら）コミットを禁止を試します:
                        注意: .git フォルダーのバックアップがあること
                        (git bash):
                            git add .
                            git commit -m "____"
                    （デバッグする場合）:
                        git-config/hooks/pre-commit;  echo $?
                コミット禁止を終了します:
                    #// 右記の続きです  #search: disable git commit
                    rm  "git-config/hooks/pre-commit"
                    git commit -m "____"
            設定ファイルをチェックします:  #keyword: check file contents Git hooks  #// たとえば、.env ファイルに storage=local が無ければコミットできないエラーにします
                #ref: ${GitHub}/MyPrivateCode/bash/git-hooks/pre-commit#function  CheckPatternExists
        フックを .git の中に作る場合:
            注意:
                リポジトリに保存されません
            コミットを禁止します:
                __Project__/.git/hooks/pre-commit: |
                    #!/bin/bash
                    echo  "To commit this work folder is disabled by __Project__/git-config/hooks/pre-commit"
                    exit  1
                実行属性を追加します:
                    chmod +x __Project__/.git/hooks/pre-commit
                サンプル (Git bash):
                    コミットを禁止します:
                        （１回目）Git hooks を使えるようにします:  #search: Git hooks
                        (git bash):  #focus: .git/hooks
                            cd  __Project__
                            edit="$(pwd)/.git/hooks/pre-commit"
                            mkdir -p  "${edit}"
                            rmdir     "${edit}"
                            echo  '#!/bin/sh' > "${edit}"
                            echo  "echo  \"\"" >> "${edit}"
                            echo  "echo  \"[ERROR] To commit in this work is disabled by __Project__/.git/hooks/pre-commit\"" >> "${edit}"
                            echo  "exit  1" >> "${edit}"
                            chmod +x  "${edit}"
                            ls -l  .git/hooks/pre-commit
                            git status
                    （必要なら）コミットを禁止を試します:
                        注意: .git フォルダーのバックアップがあること
                        (git bash):
                            git add .
                            git commit -m "____"
        シークレットを git サーバーにアップロードしないようにする場合: #keyword: git secret hooks
            git-secrets: #keyword: aws git-secrets  #// AWS のシークレットが git に公開されないかチェックします
                公式: #ref: https://github.com/awslabs/git-secrets
                概要:
                    AWS のシークレット（API キーなどの秘密の鍵）を git のコミットに追加しようとすると拒否されるようにします。
                    対象は、コミット、コミットメッセージ、--no-ff マージ。
                    設定された禁止された正規表現パターンの1つと一致する場合、コミットは拒否されます。
                インストール:
                    本体:
                        mac:
                            brew install git-secrets
                            git secrets  #// git secrets の使い方が表示されます
                    フック:  #// プロジェクトに git-secrets のフックを追加して、コミットにシークレットが追加されないようにします
                        git secrets --install
                        git secrets --register-aws
                    テンプレート:  #// git init や git clone したときに git-secrets フックをプロジェクトに追加するように設定します  #search: git init template
                        git secrets --register-aws --global
                        git secrets --install ~/.git-templates/git-secrets
                        git config --global init.templateDir ~/.git-templates/git-secrets
                参考: #ref: https://dev.classmethod.jp/articles/startup-git-secrets/
            手動:
                gitフックによりAWSアクセスキー混入を防止する: #ref: https://qiita.com/aosho235/items/bf84a59caeb7c51abb60
                    判定方法: AKI から始まるパターンを検索すること
        フックの種類: #glossary: Git Hooks  #// イベントの種類
            pre-commit:  #ref: https://git-scm.com/docs/githooks#_pre_commit
            post-checkout:  #ref: https://git-scm.com/docs/githooks#_post_checkout  #// git clone でも実行されます
            ...:
    init のテンプレート: #keyword: git init template
        概要:
            init のテンプレートを設定しておくと、git clone や git init したときにテンプレートの内容が .git フォルダーの中にコピーされます
            #ref: https://stackoverflow.com/questions/16363460/set-up-a-default-directory-structure-on-git-init
            #ref: https://git-scm.com/docs/git-init#_template_directory  #keyword: official Git template_directory
        手順: #// テンプレートを設定して、テンプレートを使います
            テンプレートの内容を作ります:  #// 適切な場所にフォルダーを作り、その中にファイルやフォルダーを作ります
                ~/.git-files/init-template/hooks/pre-commit ファイル : | #// 例
                    #!/bin/bash
                    echo "Error in pre-commit"
                    exit 1
                （Linuxの場合）実行属性を追加します:
                    chmod +x ~/.git-files/init-template/hooks/pre-commit
                #// ドットから始まるファイルやフォルダーはテンプレートとして扱われません（未確認）
            テンプレートのフォルダーの場所を .gitconfig に設定します:
                参照: git config init.templateDir
                設定: git config --global  init.templateDir  "~/.git-files/init-template"
                #// templateDir の設定方法は他にもあります  #search: official Git template_directory
            git clone コマンドを実行します:
                cd  __ParentOfProject__
                git clone https://github.com/Takakiriy/first
                cd first  #// __Project__ に移動
            コピーされたファイルを確認します:
                cd __Project__
                cat .git/hooks/pre-commit
    認証: #keyword: git authentication
        Web 認証:
            #search: GitHub steps
            #search: GitLab steps
        git clone:
            #search: git clone authentication
Git: #keyword: git
    公式: #keyword: Git 公式  #ref: https://git-scm.com/  #ref: https://git-scm.com/docs/
    手順, インストール:  #// クローン、マージ、プルリクエスト
        インストール, ログイン:  #keyword: install Git, install Git bash
            本体:
                Windows >> Git for Windows をインストールする場合:
                    - https://git-scm.com/ >> Downloads >> Windows
                    - ダウンロードしたファイル（例：Git-2.33.0.2-64-bit.exe）を開く
                    - Next を9回押す
                    - Configuring the line ending conversions: Checkout as-is, commit as-is
                    - 他のインストール オプションはデフォルトを使用
                Windows >> Install Git for Windows:  #// 上記の英訳
                    - https://git-scm.com/ >> Downloads >> Windows
                    - Open the downloaded file (e.g. Git-2.33.0.2-64-bit.exe)
                    - Press Next button 9 times
                    - Configuring the line ending conversions: Checkout as-is, commit as-is
                    - Other installation options are defaults
                Linux Ubuntu: #keyword: Linux Ubuntu Git
                    最新:  #search: update Ubuntu git
                    Ubuntu 20.04 標準: 2.25.1
                    Ubuntu 18.04 標準: 2.17.1
                Linux Rocky9: #keyword: Linux Rocky9 Git
                    sudo dnf update -y
                    sudo dnf install -y  git
                Linux CentOS7: #keyword: Linux CentOS7 Git
                    git version 2.x:  #// 2022-09-16 現在 version 2.36.1 (本家 https://git-scm.com/ は 2.37.3)
                        IUS Community 版: #keyword: Git IUS Community
                            Ansible の場合:  #ref: ${GitHub}/MyPrivateCode/ansible_vagrant/single_vm_ansible/GoCD/playbooks/git.yml
                            手動の場合:  #// 公式にあるが動作せず
                                リポジトリをインストールします:
                                    - sudo yum install -y \
                                        https://repo.ius.io/ius-release-el7.rpm \
                                        https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
                                git をインストールします:  #// リポジトリに IUS を指定します。ただし、一度エラーになります
                                    - sudo yum install -y  git  --enablerepo=ius --disablerepo=base,epel,extras,updates
                                        # 2022-09-16  #focus: emacs-filesystem,  perl(Term::ReadKey),  perl(Error),  libpcre2-8.so.0
                                        # Error: Package: git236-2.36.1-2.el7.ius.x86_64 (ius)
                                        #         Requires: emacs-filesystem >= 24.3
                                        # Error: Package: git236-2.36.1-2.el7.ius.x86_64 (ius)
                                        #         Requires: perl(Term::ReadKey)
                                        # Error: Package: git236-perl-Git-2.36.1-2.el7.ius.noarch (ius)
                                        #         Requires: perl(Error)
                                        # Error: Package: git236-core-2.36.1-2.el7.ius.x86_64 (ius)
                                        #         Requires: libpcre2-8.so.0()(64bit)
                                エラー解析:
                                    CentOS7 のリポジトリに入っている yum に指定するパッケージ名を調べます:
                                        調べ方:
                                            #search: pkgs.org
                                        調べた結果:
                                            emacs-filesystem: emacs-filesystem  #// pkgs.org で調べる必要はありません
                                            perl(Term::ReadKey): perl-TermReadKey
                                            perl(Error): perl-Error
                                            libpcre2-8.so.0: pcre2
                                不足しているパッケージをインストールします:
                                    - sudo yum install -y  emacs-filesystem  perl-TermReadKey  perl-Error  pcre2
                                再度 git をインストールします:
                                    - sudo yum install -y  git  --enablerepo=ius --disablerepo=base,epel,extras,updates
                                git のバージョンを確認します:
                                    - git --version  #// 2.36.1,  2022-09-16 現在
                                参考:
                                    CentOS7でYumを使って最新版gitを導入する: #ref: https://qiita.com/Crow314/items/5e99c9933546d6577e34
                                    URL: #ref: https://ius.io/setup
                                    メニューの場合: https://git-scm.com/ >> Downloads（左下）>> Linux/Unix（中）>> CentOS（をページ内検索）>>
                                        the IUS Community Project >> Get Started
                        Endpoint Community 版:  #// 非公式版
                            - sudo yum -y install https://packages.endpointdev.com/rhel/7/os/x86_64/endpoint-repo.x86_64.rpm
                            - sudo yum install -y  git
                            - git --version  #// 2.37.1 (2022-09-16)
                            #ref: https://computingforgeeks.com/install-git-2-on-centos-7/
                    git version 1.x:  #// 2021-10-14 現在 version 1.8.3.1
                        - sudo yum install git 
                        - git --version
                mac の git: #search: Xcode Git  #// 2022-05-22 git 2.32.1
            Git のユーザー名を設定する場合:  #keyword: Git username example, git config user.email, git config user.name
                個別設定: #search: git name
                プロジェクト固有の設定: #keyword: set-local-git-user
                    - cd  __Project__
                    - git config --local user.email "yourname@example.com"
                    - git config --local user.name  "Your Name"
                デフォルトの設定:
                    #// デフォルト（global）に設定しなくても local に設定すれば動作します  #search: delete git config
                    - git config --global user.email "yourname@example.com"
                    - git config --global user.name  "Your Name"
                設定を表示します:
                    - cd  __Project__
                    - git config  user.email
                    - git config  user.name
                user.email:
                    user.email の値は、git push などをするときのアカウント名として使われます。
                    初めて git push すると、認証を求められます。
                コミットの編集者を修正します:  #search: git amend author
                参考: #ref: ${programming}/方法論/CVS/Git.svg#git_config
            各種コマンド:  #// git 本体にない各種関連コマンド:  #search: git commands
            proxy:  #keyword: git proxy
                環境変数による設定:
                    ~/.bashrc :
                        #search: Linux HTTP_PROXY
                git config による設定:
                    proxy 環境の PC の Git からリポジトリにアクセスできるようにします:
                        参考: https://qiita.com/ryotaro76/items/0e40ffb6173b1580e671
                        コマンド: git config --global http.__URL__.proxy http://__ProxyDomain__:__ProxyPortNum__
                        GitHub にアクセスする例: git config --global http.https://github.com/.proxy http://10.100.100.100:8080  #keyword: GitHub proxy
                    現在の設定: git config --global -l
                    上記 proxy の設定を解除します:  #// proxy のない LAN に変わったとき
                        コマンド: git config --global --unset  http.__URL__.proxy
                        GitHub にアクセスする例: git config --global --unset  http.https://github.com/.proxy
            認証関連:
                ログイン トークン:
                    #search: GitHub login token
                credential.helper:  #// パスワードを保存します
                    #search: git clone authentication automatic input
                （必要なら）パスワード入力を不要にします: #// git push するたびにパスワードを入力することを不要にします
                    #search: git push SSH key
        リポジトリを作ります:  #search: Git new repository
        前回のコミットのメッセージを変更します:  #search: git commit amend
        クリーン, リセット:
            コミット状態に戻します:  #keyword: git clean,  git clean -fd
                git reset
                git checkout  "."
                git clean -fd
                git status
                #// 戻したことをキャンセルする場合  #search: git checkout undo
            クリーンします:  #// .gitignore によってリポジトリに登録されないファイルをワークでも削除します  #keyword: git deep clean
                注意: ローカルに保存しているパスワードなどが入ったファイルはバックアップしてください
            .gitignore されるファイルも削除する場合:  #// .git リポジトリがないプロジェクトの場合
                コマンド: git clean -Xdf  #keyword: git clean -Xdf   #// ❗注意 .gitignore が指すファイルも削除します
                #// ❗注意 .gitignore が指すファイルも削除します
                bash:
                    cd  __Project__
                    git init
                    git clean -Xdf
                    rm -rf .git
                サブ フォルダー の中にある対象フォルダーが再帰的に削除されない場合:
                    git add . して認識させてから git clean します
            関連:
                追加したファイルを削除してコミット状態に戻します:  #search: git checkout
                クリーン状態かとうかを判定します:  #search: git status clean or dirty
                リモート追跡ブランチを整理します:  #search: git fetch -p
        マージ:  #keyword: git merge
            git merge:
                コマンド: （双方のブランチを git pull してから） git merge  __OtherInputBranch__  --no-edit
                コミット メッセージ: | #keyword: git merge message  #// マージしたとき
                    Merge branch '__SourceBranch__' into __DestinationBranch__: merge
                一覧 >> マージしたブランチ: #keyword: git merged branches,  Git merge list  #// マージ（したコミット）だけを一覧します
                    #focus: __Branch1__, __Branch2__, __Tag1__, develop
                    git log --merges --oneline  develop-wip
                        1111111 Merge branch '__Branch1__' into develop-wip
                        2222222 Merge branch '__Branch2__' into develop-wip
                        4444444 Merge tag '__Tag1__' into develop-wip
                        3333333 (develop) Merge pull request
                実施:  #// 実施, キャンセル
                    基本的なマージの手順:
                        設定: #settings:
                            __RepositoryName__: typrm
                            __SourceBranchName__: develop
                            __DestinationBranchName__: master
                            __MergeCommitMessage__: merge
                        バックアップを作成します:
                            #Git bash
                            - cd  "__MergingFolder__"
                            - rm -f "../_bk-typrm.tar.gz"  #// 前のバックアップの削除  #template: "../_bk-__RepositoryName__.tar.gz"
                            - Node.js のプロジェクトの場合:
                                tar cvzf "../_bk-typrm.tar.gz"  --exclude "node_modules"  --exclude "Lib"  --exclude "__pycache__"  "."  #template: "../_bk-__RepositoryName__.tar.gz"
                            - Django のプロジェクトの場合:
                                tar cvzf "../_bk-typrm.tar.gz"  --exclude "Lib"  --exclude "__pycache__"  "."  #template: "../_bk-__RepositoryName__.tar.gz"
                        両方のブランチをコミット＆pushする（されていること）:
                            git status
                        サーバーと同期して、マージ先のブランチに切り替えます:
                            - git pull  #// SSH のパスフレーズの入力要求があったときは eval `ssh-agent` && ssh-add コマンドを実行すると以後の入力要求がなくなります
                            - （下記は一度に実行できます）: |  #// パスフレーズの入力要求が発生しない場合のみ
                                git checkout -b  "develop"  "origin/develop"  ||  git checkout  "develop"
                                    #template: git checkout -b  "__SourceBranchName__"  "origin/__SourceBranchName__"  ||  git checkout  "__SourceBranchName__"
                                git pull
                                git checkout -b  "master"  "origin/master"  ||  git checkout  "master"
                                    #template: git checkout -b  "__DestinationBranchName__"  "origin/__DestinationBranchName__"  ||  git checkout  "__DestinationBranchName__"
                                git pull
                                    #// ちなみに git pull  "origin"  "origin/fix-chiho-xml" は、git fetch ＋ git merge と同じらしい
                            - コンフリクトがないことをチェックします:
                                git diff --name-only --diff-filter=U  #// または  git diff --check
                            - git log: |
                                git log --oneline --decorate --graph --branches --tags --remotes --pretty=format:"%C(auto)%h %d %s %C(cyan)%an %C(green)%ad" --date=iso-local
                        マージします:
                            コマンド: |
                                git merge  "origin/develop"  --no-edit
                                    #template: "origin/__SourceBranchName__"
                                #// または
                                    git merge  "origin/develop" -m "Merge branch 'develop' into master: merge"
                                            #template: git merge  "origin/__SourceBranchName__" -m "Merge branch '__SourceBranchName__' into __DestinationBranchName__: __MergeCommitMessage__"
                            コンフリクトした場合: #search: Git conflict
                            リモート リポジトリ がない場合: #search:
                        マージした結果を確認します:  #keyword: git merge result
                            master の差分＝マージした内容:  #template: __DestinationBranchName__ の差分＝マージした内容
                                git diff origin/master  #  --name-only
                                    #template: git diff origin/__DestinationBranchName__  #  --name-only
                            master の内容をマージする前に戻すとき:  #template: __DestinationBranchName__ の内容をマージする前に戻すとき
                                git checkout "__CommitID__" -- "__FilePath__"
                            git log:
                                git log --oneline --decorate --graph --branches --tags --remotes --pretty=format:"%C(auto)%h %d %s %C(cyan)%an %C(green)%ad" --date=iso-local
                            上記 merge でコンフリクトが発生したとき:
                                git commit -a -m "Merge branch '__SourceBranchName__' into __DestinationBranchName__:__MergeCommitMessage__"
                            上記 merge でコンフリクトが発生せずに、自動マージした内容から変更したとき:
                                git commit -a -m "自動マージに対する修正"
                            上記 merge でコンフリクトが発生せずに、自動マージした内容から更新がなかったとき:
                                nothing to commit, working tree clean と表示され、コミットは不要です。
                            状態を確認する:
                                git status
                        ここでマージやコミットするときに必要なことをする（テストなど）修正が必要ならコミットを追加する:
                        マージが完了したのでサーバーへプッシュします:
                            - git log --oneline --decorate --graph --branches --tags --remotes --pretty=format:"%C(auto)%h %d %s %C(cyan)%an %C(green)%ad" --date=iso-local
                            - git push
                            - git log --oneline --decorate --graph --branches --tags --remotes --pretty=format:"%C(auto)%h %d %s %C(cyan)%an %C(green)%ad" --date=iso-local
                        （必要なら）元のブランチに戻ります:
                            - git checkout  develop  #template: __SourceBranchName__
                            - （必要なら）master から develop へマージします:  #template: __DestinationBranchName__ から __SourceBranchName__ へ
                                git merge  "origin/master" -m "Merge branch 'master' into develop"
                                    #template: git merge  "origin/__DestinationBranchName__" -m "Merge branch '__DestinationBranchName__' into __SourceBranchName__"
                        その他:
                            バックアップの削除: rm  "../_bk-typrm.tar.gz"  #template: rm  "../_bk-__RepositoryName__.tar.gz"
                            タグの一覧: git tag
                            タグを付ける: git tag -a  "__TagName__"  -m "__MergeCommitMessage__"
                            タグをサーバーへ反映: git push origin  "__TagName__"  #// git push だけでは反映されない
                            リストアする:
                                - mkdir "../_bk-typrm" && cd "../_bk-typrm" &&  tar xvf "../_bk-typrm.tar.gz"
                                    #template: mkdir "../_bk-__RepositoryName__" && cd "../_bk-__RepositoryName__" &&  tar xvf "../_bk-__RepositoryName__.tar.gz"
                                - cd ..  &&  rm -rf "typrm"  &&  mv  "_bk-typrm"  "typrm"  &&  cd  "typrm"
                                    #template:  rm -rf "__RepositoryName__"  &&  mv  "_bk-__RepositoryName__"  "__RepositoryName__"  &&  cd  "__RepositoryName__"
                    コンフリクトした場合:  #search: Git conflict
                    違うブランチでファイルを編集した場合:  #search: Git incorrect branch edit
                    git push, git pull できないときのマージ:  #// ローカルで一時的なブランチを作ってマージします
                        状況: |  #focus: rebasing
                            git branch
                                (no branch, rebasing __BranchName__)
                                __BranchName__
                            git status
                                You are currently editing a commit while rebasing branch 'master' on '2222222'.
                            gitlog
                                * 2222222  (origin/__BranchName__, origin/HEAD)
                                | * 3333333  (__BranchName__)
                                |/  
                                * 1111111
                        ローカルで一時的なブランチ _rebasing と _local を作ります: |  #focus: _rebasing, _local
                            git checkout -b _rebasing 2222222
                            git checkout -b _local 3333333
                            gitlog
                                * 2222222  (origin/__BranchName__, origin/HEAD, _rebasing)
                                | * 3333333  (HEAD -> _local, __BranchName__)
                                |/  
                                * 1111111
                        ローカルでマージします: |
                            git merge "_rebasing"  -m "Merge branch '_rebasing' into _local: merge"
                            コンフリクトがあった場合
                                #// コンフリクトを解消
                                git add "."
                                git commit -m "local merge"
                            gitlog
                                * 4444444  (HEAD -> _local) local merge
                                |\  
                                * | 3333333  (__BranchName__)
                                | * 2222222  (origin/__BranchName__, origin/HEAD, _rebasing)
                                |/  
                                * 1111111
                        ブランチを張り直します: |
                            #// スキップできる？
                                git branch -D   "__BranchName__"
                                git checkout -b "__BranchName__"  "4444444"
                                git branch -D  "_local"
                                git branch -D  "_rebasing"
                                gitlog
                                    * 4444444  (HEAD -> __BranchName__) local merge
                                    |\  
                                    * | 3333333
                                    | * 2222222  (origin/__BranchName__, origin/HEAD)
                                    |/  
                                    * 1111111
                                git status
                                    You are currently editing a commit while rebasing branch '__BranchName__' on '3333333'.
                                        (use "git commit --amend" to amend the current commit)
                                        (use "git rebase --continue" once you are satisfied with your changes)
                                git commit --amend
                                gitlog
                                    * 4444444  (HEAD -> __BranchName__) local merge
                                    |\  
                                    | | * 5555555  (origin/master, origin/HEAD) Merge branch '_rebasing' into _local: merge 
                                    | |/| 
                                    |/|/  
                                    * | 3333333
                                    | * 2222222  (origin/__BranchName__, origin/HEAD)
                                    |/  
                                    * 1111111
                                git diff 4444444 5555555
                                    (no difference)
                                git rebase --continue
                                    error: update_ref failed for ref 'refs/heads/master': cannot lock ref 'refs/heads/master': is at 4cda3895902b216e1eff6e47c6bd46dd4834d0b8 but expected 898b4a457cf7ab4fb05ea6d7b9b08327770e85ce
                                    error: could not update refs/heads/master
                                git rebase --abort
                                    （__Branch__ は最初の位置 3333333 に戻ってしまう。git rebase --skip は未確認）
                            #// ここからすればいい？
                            git checkout -b _tmp 3333333
                            git branch -D __Branch__
                            git checkout -b __Branch__ 4444444
                            git branch -D _tmp
                            git status
                                On branch master
                                nothing to commit, working tree clean
                            git push --set-upstream origin master
                            git status
                                On branch master
                                Your branch is up to date with 'origin/master'.

                                nothing to commit, working tree clean
                    リポジトリの外のフォルダーを 3way merge します(git_merge):
                        設定: #settings:
                            __OldFolder__: ${HOME}/Desktop/CRUD_patch/site/back_up  #// commit 1
                            __SourceFolder__: ${HOME}/Desktop/CRUD_patch/site/patch  #// commit 2-A
                            __DestinationFolder__: ${HOME}/Desktop/django1/django1
                            __WorkFolder__:        ${HOME}/Desktop/_merge/work    #// ★削除されます
                        バックアップを作成します:
                            バックアップを作成します:
                                （下記は一度に実行できます）: |
                                    #新しい Git bash
                                    cd  "${HOME}/Desktop/django1/django1"  #template: "__DestinationFolder__"
                                    rm -f "${HOME}/Desktop/_bk-destination.tar.gz"  #// 前のバックアップの削除
                                    tar cvzf "${HOME}/Desktop/_bk-destination.tar.gz"  --exclude "node_modules"  "."
                            （バックアップから復元するとき）:
                                #新しい Git bash
                                - cd  "__ParentOfDecompressed__"
                                - mkdir  "_decompressed"  #// ここに復元されます
                                - tar xvf   "_bk-destination.tar.gz"  --directory  "_decompressed"
                                #// Git bash を閉じます
                                #// 必要に応じて復元したフォルダーを改名してください
                        old, src, dst ブランチを作成します:
                            （下記は一度に実行できます）: |
                                #新しい Git bash
                                rm -rf    "${HOME}/Desktop/_merge/work"  #template: "__WorkFolder__"
                                mkdir -p  "${HOME}/Desktop/_merge/work"  #template: "__WorkFolder__"
                                cd        "${HOME}/Desktop/_merge/work"  #template: "__WorkFolder__"

                                #// commit old branch
                                git init
                                git config user.email "you@example.com"
                                git config user.name "Your Name"
                                git checkout -b "old"  #// make and switch to a new branch
                                cp -rapT  "${HOME}/Desktop/CRUD_patch/site/back_up/"  "${HOME}/Desktop/_merge/work/"
                                    #template: "__OldFolder__/"  "__WorkFolder__/"
                                git add .
                                git commit -m "old"
                                ls | grep -v -E '^\.git$' | xargs rm -r  #// remove all except .git

                                #// commit src(source) branch
                                git checkout -b "src"  #// make and switch to a new branch
                                cp -rapT  "${HOME}/Desktop/CRUD_patch/site/patch/"  "${HOME}/Desktop/_merge/work/"
                                    #template: "__SourceFolder__/"  "__WorkFolder__/"
                                git add .
                                git commit -m "src"
                                ls | grep -v -E '^\.git$' | xargs rm -r  #// remove all except .git

                                #// commit dst(destination) branch
                                git checkout "old"  #// switch to a new branch
                                rm -rf  "${HOME}/Desktop/django1/django1/.git"  #template: "__DestinationFolder__/.git"
                                mv  ".git"  "${HOME}/Desktop/django1/django1"  #template: "__DestinationFolder__"
                                cd  "${HOME}/Desktop/django1/django1"          #template: "__DestinationFolder__"
                                rm -rf "${HOME}/Desktop/_merge/work"          #template: "__WorkFolder__"
                                git checkout -b "dst"  #// make and switch to a new branch
                                git add .
                                git commit -m "dst"
                        マージします:
                            - cd  "${HOME}/Desktop/django1/django1"  #template: "__DestinationFolder__"
                            - git merge  "src" -m "Merge branch 'src' into featured：local merge"
                            - rm -rf .git
                    develop => release マージ:  #keyword: Git merge develop release
                        状況を見る:
                            git checkout develop
                            git pull
                            gitlog1
                        release を develop の最新と同じにする場合:
                            develop => release のマージをすることで release ブランチを進めます:  #search: git merge
                            git push:
                        release を develop の途中と同じにする場合:
                            途中にブランチ(_tmp)を新規作成します:
                            _tmp => release のマージをすることで release ブランチを進めます:  #search: git merge
                            git push:
                        途中のマージを除く場合:
                            GitHub でリバートします:  #search: GitHub revert
                            git push:
                    merge, --no-ff: 必ず枝分かれさせます
                    fast-forward, Rebase and merge:  #keyword: fast-forward,  Git fast forwarding
                        rebase してからマージします。枝分かれせず直線的な git log になります。
                    Squash merge:  #keyword: Squash and merge
                        概要: 枝分かれしていたコミットの列を１つのコミットにまとめて、枝分かれせず直線的な git log にします。
                        イメージ: #ref: ${my_images}/2022/git_merges.png
                            #ref: ${typrm_files}/ref/Git-AI.yaml#label: git merge squash from AI
                        GitHub:
                            squash merging を禁止する:
                                GitHub プロジェクト >> Settings タグ >> Allow squash merging（をブラウザーの機能で検索）
                            参考: #ref: https://docs.github.com/ja/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges#squash-and-merge-your-pull-request-commits
                    マージをキャンセルします:  #keyword: git merge cancel,  git merge --abort
                        編集完了前の場合: git merge --abort  #// コンフリクトの解消作業をキャンセルします
                        編集後の場合:
                            ブランチの HEAD を移動する場合:  #search: git branch move
                            git reset コマンドを使う場合:  #search: git reset --hard
                        コミット後の場合:
                            マージ前のツリーに戻します:  #// ファイルの内容は戻しません
                                git reset --soft HEAD^  #search: git commit cancel
                            リバートします:  #// リバートを行ったコミットを追加します
                                git revert -m 1  __MergedCommitID__
                        参考: #ref: https://qiita.com/chihiro/items/5dd671aa6f1c332986a7
                    git diff で作ったパッチを適用します: #keyword: git apply,  git diff patch  #// ブランチの途中のコミット間の差分をマージ（適用：apply）します
                        ❗非推奨？: 同じ Git ワーキング フォルダー の中の 2つのブランチ間であれば、推奨→ #search: git soft reset commit
                        関連:  #// squash, cherry-pick
                            - コミットをまとめます  #search: Git commit squash
                            - 違うブランチでファイルを編集した場合   #search: Git incorrect branch edit
                            - 1つのコミットを適用します  #search: git cherry-pick
                        WIP ブランチをまとめる場合:  #focus: __FeatureBranch__,  __WIPBranch__
                            （推奨）:  #search: Git commit squash
                            すべての WIP コミット をまとめる場合:
                                （バイナリを含む場合, git rebase を使う場合）:  #search: git rebase commit
                                （git apply を使う場合）: #keyword: git apply diff command example
                                    文書の設定: #settings:
                                        __FeatureBranch__: feature1  #// 同じ内容に編集するブランチ。コピー先相当
                                        __WIPBranch__: feature1-wip  #// コピー元相当
                                    (Git bash): |
                                        cd  __Project__
                                        （前のコミット feature1 との差分に問題がないことをレビューする）  #template: __FeatureBranch__
                                        git checkout  "feature1"                                          #template: __FeatureBranch__
                                        （やり直した場合、クリーン状態に戻します）
                                            git reset
                                            git checkout  "."
                                            git clean -df
                                            git status
                                        git diff  "HEAD"  "feature1-wip"  >  ~/_git_patch.diff    #template: __WIPBranch__
                                        git apply  ~/_git_patch.diff  #// (or)  cd __Project__;  patch -p1 < ~/_git_patch.diff  (or)  patch -p2 < ~/_git_patch.diff
                                            #// まれに、後の git diff で差分が出る場合や期待する差分が出ない場合は、git apply ではなく patch を使ってください
                                            #// バイナリ ファイル がある場合は git rebase を使います  #search: git rebase commit
                                        git add  "."
                                        git diff  "feature1-wip"    #template: __WIPBranch__
                                        git commit -m "_____"
                                        gitlog
                                        git push
                                        git branch -D "feature1-wip"                      #template: __WIPBranch__
                                        git push  --delete origin "feature1-wip"          #template: __WIPBranch__
                                        git checkout -b  "feature1-wip"                   #template: __WIPBranch__
                                        git push  --set-upstream origin "feature1-wip"    #template: __WIPBranch__
                            ブランチの途中のコミット列をまとめる場合: #keyword: git apply along the way  #// 未確認
                                #// 自分のブランチをリベースする前に、WIP コミット をまとめないと何度もコンフリクトが発生する可能性があります
                                #// WIP コミット をまとめて WIP ではないコミットを作ります
                                #// 最新コミットが WIP なら、その付近の WIP コミット列 を 1つの WIP コミット にまとめます
                                #// 複数の範囲についてそれぞれまとめるときは、古いコミットからまとめます
                                まとめる範囲に一時的にブランチを作ります:
                                    開始場所（古いほう）のブランチを作ります:
                                        #$ git checkout -b _tmp_feature  ae70d5ef1
                                        - git checkout -b _tmp_feature  __CurrentNotWipCommitID__  #// __CurrentNotWipCommitID__ を チェック アウト したときの ワーキング フォルダー の内容から開始
                                            #// 差分が含まれるコミットの１つ前（ __OldestWipCommitID__^）で指定することはできません
                                    終了場所（新しいほう）のブランチを作ります:
                                        #$ git checkout -b _tmp_wip  af8e435a2
                                        git checkout -b _tmp_wip  __NewNotWipCommitID__
                                コミットをまとめます: |  #search: git diff patch
                                    git checkout  "_tmp_feature"
                                    git diff  "HEAD"  "_tmp_wip"  >  ~/_git_patch.diff
                                    git apply  ~/_git_patch.diff  #// (or)  cd __Project__;  patch -p1 < ~/_git_patch.diff  (or)  patch -p2 < ~/_git_patch.diff
                                    git add  "."
                                    git diff  "_tmp_wip"
                                    git commit -m "________"
                                    gitlog
                                続きのコミット列をコピー（チェリー ピック）します:
                                    #// git diff & git apply はベースとなるファイルの内容が違うと使えないためです
                                    まとめる範囲のブランチを更新します:
                                        git branch -D _tmp_wip
                                        git checkout -b _tmp_wip
                                    チェリー ピック します:
                                        （下記）
                                        #$ git cherry-pick  af8e435a2..31bb37bc9  #// チェック アウト したときの ワーキング フォルダー の内容から
                                一時的に作ったブランチを削除します:
                                    #$ git checkout  t325_mail_noreply_wip
                                        git checkout  __OtherBranch__
                                    git branch -D _tmp_feature
                                    git branch -D _tmp_wip
                                他にもまとめる範囲があれば繰り返します:
                                    上記の中の差分:
                                        #$ git checkout -b _tmp_feature  af8e435a2
                                        #$ git checkout -b _tmp_wip  31bb37bc9
                        その他の場合:
                            パッチを作ります: #keyword: make git diff
                                コミット間の場合:
                                    git diff __OldCommitID__ __NewCommitID__ > ~/_git_patch.diff
                                まだコミットしていない最新との場合:
                                    git diff  > ~/_git_patch.diff
                            パッチを適用します: #keyword: apply git diff
                                git が使える環境の場合:
                                    git apply ~/_git_patch.diff
                                        #// エラーが発生すると何も編集されません
                                        #// --check オプションを付けると、エラーが発生しなくても何も編集されません
                                        #// 続きます
                                patch が使える環境の場合:
                                    cd _____
                                    patch -p1 < ~/_git_patch.diff
                                    #// 続きます
                            パッチが正しく適用されたことを確認します:
                                git add "."
                                git diff __NewCommitID__
                        コマンド オプション:
                            git apply:
                                --exclude, --exclude-from: #keyword: git apply --exclude,  git apply --exclude-from  #// 処理対象から外すファイル
                                    --exclude=__Pattern__
                                        または
                                    --exclude-from=__ListFilePath__
                        トラブルシューティング(git apply):
                            - #// patch does not apply
                                手順: git apply  ~/_git_patch.diff
                                エラー: |
                                    error: patch failed: __Path__:__LineNum__
                                    error: __Path__: patch does not apply
                                対処:
                                    cd __Project__;  patch -p1 < ~/_git_patch.diff  (or)  patch -p2 < ~/_git_patch.diff
                                    #// まれに、後の git diff で差分が出る場合や期待する差分が出ない場合は、git apply ではなく patch を使ってください
                            - #// binary
                                手順: git apply  ~/_git_patch.diff
                                エラー: |
                                    error: cannot apply binary patch to '__BinaryFilePath__' without full index line
                                対処:
                                    バイナリ ファイル 以外にパッチをあてます:
                                        cd __Project__;  patch -p1 < ~/_git_patch.diff  (or)  patch -p2 < ~/_git_patch.diff
                                        #// git apply ではエラーが発生したときにパッチがあたりません
                                    バイナリ ファイル をコピーします:
                                        Windows: エクスプローラーを使います
                            - #// すでに変更後の内容だった場合:
                                エラーになります。
                                ~/_git_patch.diff ファイルの diff --git ... の行から次の diff --git ... の前まで削除してください。
                    双方向マージします（差分があるブランチ）: #keyword: git mutual merge,  git diff merge  #// Git のグラフに双方向のマージ __Feature__ → develop → __Feature__ を追加します
                        #// 以下は、自動マージを行い、一部を __Feature__ ブランチ固有のコードに戻す手順です
                        文書の設定: #settings:
                            __Feature__: feature1
                            __Develop__: develop
                        develop → feature1:    #template: __Develop__ → __Feature__  #// __Develop__ ブランチの更新を __Feature__ ブランチに反映します
                            develop-sync ブランチ（下記）がある場合:    #template: __Develop__-sync
                                以下は __Develop__ ブランチと __Feature__ ブランチ を双方向マージする手順が書かれていますが、
                                その場合は __Develop__-sync (develop-sync) ブランチ と __Feature__ ブランチ を双方向マージします。__Develop__-sync を更新します
                            現在の feature1 ブランチをロックします:  #// ロックとは開始位置を固定すること、リベースしても失わないようにすることです  #template: __Feature__
                                -   git checkout  feature1      #template: checkout  __Feature__
                            マージまたはリベースします:
                                （リベースする場合）:  #// __Develop__ の更新内容を __Feature__ に取り込みます  #search: git rebase remote branch
                                    #// 注意）Git グラフ は一直線になります。マージベースが develop になります
                                    -   git checkout -b feature1-sync
                                    -   git rebase origin/develop  #// または origin/develop-sync
                                    -   gitlog
                                                #template-at(-3): -b __Feature__-sync
                                                #template-at(-3): rebase origin/__Develop__
                                                #template-at(-4): // または origin/__Develop__-sync
                                （マージする場合）:  #// __Develop__ の更新内容を __Feature__ に取り込みます
                                    -   git checkout -b feature1-sync
                                    -   git merge  --no-edit --no-ff  origin/develop  #// または origin/develop-sync    #search: --no-diff
                                    -   gitlog
                                                #template-at(-3): -b __Feature__-sync
                                                #template-at(-3): --no-ff  origin/__Develop__
                                                #template-at(-4): // または origin/__Develop__-sync
                                （参考）develop の更新内容を見てマージする場合:  #// __Develop__ の更新内容を自動的に取り込まない場合    #template: ）__Develop__
                                    #search: VSCode git diff branch new
                                    #search: VSCode git diff branch commit merge
                                    #// 次の戻す編集の手順はスキップします
                            develop で更新された部分のうち、feature1 ブランチでは変えたい（戻したい）部分を、今までの内容がまだ入っている feature1 ブランチを参考に編集します:
                                    #template-at(-1): __Develop__ で更新
                                    #template-at(-2): 、__Feature__ ブランチ
                                    #template-at(-3): __Feature__ ブランチを参考
                                コマンド: |  #focus: feature1    #template: __Feature__
                                    git diff  feature1  #// develop（または develop-sync）で更新されていない部分については差分は表示されません。次へ進んでください
                                                #template-at(-1): diff  __Feature__
                                                #template-at(-2): __Develop__（または __Develop__-sync）で更新
                                        #// または、VSCode で、feature1 ブランチと ワーキング フォルダー を比較します  #search: Compare with Working Tree+    #template: __Feature__
                                        #//     左が feature1 ブランチ（古い feature1 ブランチ）    #template: 左が __Feature__ ブランチ（古い __Feature__
                                        #//     右が feature1 ブランチ、カレント ブランチ、マージ後、適用していいかチェックする部分  #template: __Feature__
                                        #// 大量に差分として残したい部分を戻したときは、改めて git diff を表示すると差分が少なく表示されます
                                        #// develop と feature1 の両方を共通のコードに更新したいときは、一旦戻す編集をして、双方向マージを行った後で両方のブランチを更新してください    #template: __Develop__ と __Feature__
                                    code ____    #// マージしたくない部分を戻します（左から右へ）
                                    git add "."
                                    git status
                                編集した場合:  #// git status が clean ではない場合
                                    （リベースした場合）:
                                        git commit -m "Restore correct difference after rebase"
                                    （マージした場合）:
                                        git commit -m "Restore correct difference after merge"
                                    続き:
                                        git push --force-with-lease
                                編集しなかった場合:
                                    git push
                                プルリクエストする場合:  #search: GitHub pull requests
                                    feature1 ← feature1-sync
                                        #template: __Feature__ ← __Feature__-sync
                                マージします:  #// テストが通ったら
                                    -   マージしないで feature1-sync ブランチを残しておくケースもあります    #template: __Feature__-sync
                                    -   feature1-sync ブランチがある場合、feature1-sync を feature1-wip ブランチにマージしたものをデプロイします  #search: develop-wip
                                                #template: __Feature__-sync ブランチがある場合、__Feature__-sync を __Feature__-wip ブランチに
                        feature1 → develop:    #template: __Feature__ → __Develop__  #// __Feature__ ブランチの更新を __Develop__ ブランチに反映します
                            現在の develop ブランチをロックします: |  #// または __Develop__-sync    #template: 現在の __Develop__
                                    git checkout  develop  #// または develop-sync
                                    git pull
                                            #template-at(-2): checkout  __Develop__
                                            #template-at(-3): // または __Develop__-sync
                            feature1 → develop-sync マージを行います:  #// __Feature__ ブランチ の更新内容を __Develop__ に取り込みます    #template: __Feature__ → __Develop__-sync
                                コマンド: |
                                    git checkout -b develop-sync    #// develop-sync ブランチがすでにあるときは -b を削除して実行します
                                    git merge  feature1  --no-edit --no-ff    #search: --no-diff  #template: __Feature__
                                    gitlog
                                #// git merge  feature1-sync  --no-edit --no-ff でなくても構いません  #template: __Feature__-sync
                                #template-at(-4): checkout -b __Develop__-sync    #// __Develop__-sync
                            feature1 で更新された部分のうち、差分として残したい部分を、戻します in develop:  #search: git merge commit message
                                        #template-at(-1): __Feature__ で更新
                                        #template-at(-2): in __Develop__
                                コマンド: |  #focus: develop    #template: __Develop__
                                    git diff  develop  #// __Feature__ で更新されていない部分については差分は表示されません。次へ進んでください  #template: __Develop__
                                        #// または、VSCode で、develop ブランチと ワーキング フォルダー を比較します  #search: Compare with Working Tree    #template: __Develop__
                                        #//     左が develop ブランチ（古い develop ブランチ）                                        #template: 左が __Develop__ ブランチ（古い __Develop__
                                        #//     右が develop ブランチ、カレント ブランチ、マージ後、適用していいかチェックする部分    #template: 右が __Develop__
                                        #// 大量に差分として残したい部分を戻したときは、改めて git diff を表示すると差分が少なく表示されます
                                        #// develop と feature1 の両方を共通のコードに更新したいときは、一旦戻す編集をして、双方向マージを行った後で両方のブランチを更新してください    #template: __Develop__ と __Feature__
                                    code ____  #// マージしたくない部分を戻します（左から右へ）。feature1 にも修正が必要な内容はメモして後で修正してください  #template: __Feature__
                                    git add "."
                                    git commit -m "Merge branch 'feature1' into develop: Restore over-merged content"  #template: '__Feature__' into __Develop__
                                    gitlog
                                    git push
                                プルリクエストする場合:  #search: GitHub pull requests
                                    develop ← develop-sync
                                        #template: __Develop__ ← __Develop__-sync
                                マージします:  #// テストが通ったら、マージ develop ← develop-sync         #template: __Develop__ ← __Develop__-sync
                                    -   マージしないで develop-sync ブランチを残しておくケースもあります    #template: __Develop__-sync
                                    -   develop-sync ブランチがある場合、develop-sync を develop-wip ブランチにマージしたものをデプロイします  #search: develop-wip
                                                #template: __Develop__-sync ブランチがある場合、__Develop__-sync を __Develop__-wip ブランチに
                                    #// feature1-sync → feature1 のマージは後で マージ ベース を新しくするまで行いません    #template: __Feature__-sync → __Feature__
                        マージ ベース を新しくします:  #// feature1-sync ブランチを新しい develop（develop-sync）→ new-feature1 の位置に移動します    #template: // __Feature__-sync ブランチを新しい __Develop__（__Develop__-sync）→ new-__Feature__
                                #// マージ ベース が新しい develop ブランチ（暫定的には develop-sync ブランチ）の最新コミットになります    #template: __Develop__ ブランチ（暫定的には __Develop__-sync ブランチ）
                                #// これをしないと、次の双方向マージをするときの マージ ベース も、今回と同じく古い マージ ベース になってしまいます
                                #// これは双方のテストが終わるまで遅らせても構いません
                            （まだなら）feature1-sync を develop-sync にマージします:    #template: __Feature__-sync を __Develop__-sync に
                                #// すでに develop ← develop-sync のマージが済んでいたら、以降は develop-sync を develop に読み替えてください
                                        #template-at(-1): __Develop__ ← __Develop__-sync
                                        #template-at(-2): 以降は __Develop__-sync を __Develop__ に
                                feature1-sync でテストを通します:                       #template: __Feature__-sync
                                feature1-sync の修正が無かった場合:                     #template: __Feature__-sync
                                    マージします:  #// マージしても内容の更新はありません。Git グラフのみ更新します
                                        #// develop-sync ← feature1-sync                #template: __Develop__-sync ← __Feature__-sync
                                        -   git checkout develop-sync                  #template: __Develop__-sync
                                        -   git merge feature1-sync --no-edit           #template: __Feature__-sync
                                        -   git diff  origin/develop-sync              #template: __Develop__-sync
                                                #// 差分なし
                                        -   gitlog
                                        -   git push
                                                #// 差分が無いのでプルリクのチェックは動きません
                                feature1-sync の修正があった場合:                       #template: __Feature__-sync
                                    feature1 → develop のマージ（上記）をやり直します   #template: __Feature__ → __Develop__
                                        #//（実績なし）
                            new-feature1 ブランチを作ります:  #// develop-sync から枝分かれさせます    #template: __Develop__-sync から
                                                                #template-at(-1): new-__Feature__
                                ブランチを作ります:  #// このブランチは、枝分かれしている場所に余計な（グラフの）エッジを付けないために、git apply するためだけのブランチです
                                    git checkout -b new-feature1    #template: new-__Feature__
                                内容を feature1-sync に合わせます: |    #template: __Feature__-sync
                                    手順は WIP ブランチを git apply でまとめる手順とほぼ同じです。
                                    #search: git apply diff command example
                                    ただし、
                                        -   __FeatureBranch__ = new-feature1        #template: new-__Feature__
                                        -   __WIPBranch__ = feature1-sync           #template: = __Feature__-sync 
                                        #// git rebase は使わないでください。
                                                バイナリファイルの apply（同期）は ~/_git_patch.diff を作る前に Git の管理外でコピーし、
                                                git apply の --exclude オプションなどを使ってください
                                        -   git commit -m "Restore correct difference and get feedback from develop."    #template: from __Develop__.
                                                #// このコミットは、feature1 の内容です
                                        -   git commit より後のコマンドは実行しません
                            new-feature1 ブランチと同じ位置に feature1-sync ブランチを移動します:  #// new-feature1 ブランチ は削除します    #template: new-__Feature__
                                        #template-at(-1): new-__Feature__
                                        #template-at(-2): に __Feature__-sync
                                -   git checkout  feature1-sync          #template: __Feature__-sync
                                -   git merge new-feature1  --no-edit    #template: new-__Feature__
                                -   gitlog
                                -   git push
                                #// new-feature1 ブランチ は削除します        #template: new-__Feature__
                                -   git branch -D  new-feature1               #template: new-__Feature__
                        最後に、__Branch__-sync を __Branch__ へマージしていいなら、マージして、__Branch__-sync を削除します:
                            #// __Branch__ は、develop または feature1 です    #template: __Develop__ または __Feature__
                            #// __Branch__-sync ブランチは、develop-wip ブランチに含まれる feature ブランチに相当するので、
                            #// feature ブランチを develop-wip ブランチから develop ブランチに移動できる条件を満たしたのなら、以下を実行できます。
                            #search: develop-wip branch
                                -   git checkout  __Branch__
                                -   git merge __Branch__-sync  --no-edit
                                -   gitlog
                                -   git push
                                #// __Branch__-sync ブランチを削除します
                                -   git branch -D  __Branch__-sync
                                -   git push --delete origin  __Branch__-sync
                        参考 >> ターゲット別ブランチ:  #search: specific target branch
                    common ブランチ:  #// develop ブランチ にマージする前に他のブランチにマージする場合
                        #search: update common branch
                    関連 >> コミットを分けます:  #search: split Git commit
                マージ戦略: #keyword: git merge strategy  #ref: ${typrm_files}/ref/Git-AI.yaml#label: git merge strategy from AI
                    （比較の図）:  #ref: ${my_images}/2025/merge_strategies.html
                        マージ戦略は、マージ ボタン のプルダウンから選べます。
                        ブランチを削除はボタンを押す必要があります。
                    （手順）>> 現在の設定を表示します:
                        git config --show-origin --get pull.rebase
                        git config --show-origin --get merge.ff
                    merge:  #// fast forward できるケースでも、枝分かれと結合をします
                        git merge __SourceBranch__ --no-edit --no-ff  #keyword: --no-edit --no-ff,  git merge --no-ff --no-edit
                        #// GitHub では --no-ff 付きのマージになります  #ref: https://docs.github.com/ja/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/about-merge-methods-on-github
                    rebase:  #search: Git merge develop release
                    squash:  #search: Squash and merge
                    ours, theirs:
            git cherry-pick:  #keyword: git cherry-pick  #// 1つのコミットだけマージします
                #ref: ${typrm_files}/ref/Git-AI.yaml#label: git cherry-pick
                #ref: https://qiita.com/okmtz/items/62aa5a25f75b1754a861
                基本:
                    git cherry-pick コマンドを実行します: |
                            gitlog  #// コミット ID (__NewCommit__) をメモします。複数可能
                            git checkout __DestinationBranch__
                            git cherry-pick  "__NewCommit__"   #// 1つのコミットずつしかできない？
                        #// 以下に続きます
                    できたコミットを確認します:
                        #search: VSCode diff commit
                    コミットメッセージの修正:  #// cherry-pick されたコミットが適用されたことがすぐにわかるようにします
                        git commit --amend -m "__DefaultCommitMessage__ - cherry-pick from __Branch__ commit __CommitID__ 2024-01-01."
                        git log --grep="cherry-pick from __Branch__ commit __CommitID__"
                    プッシュします:
                        git push
                コミット列をコピーする場合: #keyword: git cherry-pick range  #// 別のブランチに 1つ以上のコミットをコピー（チェリー ピック）します
                    #// コミットのファイル差分が同じになるようなコミットを作ります。ここではそれをコピーと呼んでいます
                    #// 並列したブランチに同じ内容を作ることもできそうです（未確認）
                    #// auther は変更されず、commiter は自分になります
                    #// 複数の範囲に分けてコピーするとき（コミット列の途中にマージしてできたコミットがあるとき）は、古いコミット列からコピーします
                    1つのコミットを チェリー ピック します:
                        git cherry-pick  __CommitID__
                    コミット列を チェリー ピック します:
                        - git cherry-pick  __BaseCommitID__..__LastCommitID__  #// __BaseCommitID__ を チェック アウト したときの ワーキング フォルダー の内容から
                            #// または
                        - git cherry-pick  __FirstCommitID__^..__LastCommitID__  #// __FirstCommitID__ に含まれる差分から。^（1つ前）を付けます
                    コミット列の途中にマージしてできたコミットがあるとき: #keyword: Git cherry-pick merged commit  #// 親コミットが複数あるとき
                        前提:
                            git diff patch の場合: git diff patch の手順のときは以下の親の番号は不要です。なぜなら Git 的には新しい内容のコミットが作られるからです  #search: git diff patch
                            リベースしたい場合: #keyword: git rebase contains merged commit  #// リベースのコンフリクトが複雑なので、コミット列をコピーしてリベース相当をしたい場合
                                マージした（された）それぞれのブランチの片方に マージ ベース がある場合:
                                    普通に git rebase できます。マージ ベース があるブランチがリベースする前のベースになります  #search: git rebase
                                マージ ベース から最新コミットの間に分岐とマージがある場合:
                                    未確認
                        親の番号を調べます:  #// 自分のブランチの途中にあるマージしてできたコミットについて、その親の番号（直前のコミットの番号）を調べます
                            コマンド: |
                                git log --pretty=%P -n 1 __MyMergedCommitID__
                            出力の解析:
                                出力: __ParentCommitID_1__ __ParentCommitID_2__
                                判定:
                                    - __ParentCommitID_1__ からの差分を取り込む場合、git cherry-pick に -m 1 を指定します
                                    - __ParentCommitID_2__ からの差分を取り込む場合、git cherry-pick に -m 2 を指定します
                        マージしてできたコミットまで チェリー ピック します:
                            #// リベースするブランチの古い マージ ベース からマージしてできたコミットまでチェリーピックします
                            #$ git cherry-pick -m 1  ae70d5ef1..af8e435a2
                            git cherry-pick -m ___ParentNum__  __NewBaseCommitID__..__MyMergedCommitID__
                            #$ git cherry-pick  af8e435a2..31bb37bc9
                        コンフリクトしたら:
                            手順:
                                - コードを編集
                                - git add ____
                                - git cherry-pick --continue
                            マージした結果が変更なしだったら:
                                git commit --allow-empty を実行するように表示されるので、よければ
                                    git commit --allow-empty
                                と
                                    git cherry-pick --continue
                        エラー:
                            ログ: |
                                error: commit __SourceBranchFirstCommitID__ is a merge but no -m option was given.
                            対処:
                                親のコミットID と親の番号の対応関係を表示します:
                                    git log --pretty=%P -n 1 __MergedCommitID__
                                親の番号を git cherry-pick に指定します:
                                    （上記）git cherry-pick -m
                マージやリベースしたとき:  #search: Git rebase cherry-pick  #snip: cherry-pick したコミットは、リベース先のブランチにあるコミットに統合されます。コミットが減ります
            コンフリクトした場合: #keyword: Git conflict
                コンフリクトの一覧:
                    git diff --name-only --diff-filter=U  #// または  git diff --check
                コンフリクトした部分に現在のブランチの内容を採用する場合: #keyword: Git checkout --ours
                    - git checkout --ours  "__FilePath__"     #// current を採用します
                        #// または
                    - git checkout --ours  "."                #// すべてのコンフリクトに current を採用します
                    #// git add _____ も必要です
                コンフリクトした部分にマージ元のブランチの内容を採用する場合: #keyword: Git checkout --theirs  #// 受け入れる場合
                    - git checkout --theirs  "__FilePath__"   #// Incoming を採用します
                        #// または
                    - git checkout --theirs  "."              #// すべてのコンフリクトに Incoming を採用します
                    #// git add _____ も必要です
                編集する場合: #keyword: Git conflict basic
                    エラー メッセージ: |
                        $ git merge develop --no-edit
                        Auto-merging __ConflictedFilePath__
                        CONFLICT (content): Merge conflict in __ConflictedFilePath__
                        Auto-merging __MergedFilePath__
                        Automatic merge failed; fix conflicts and then commit the result.
                    コンフリクトしたファイルに追加される内容のサンプル: |
                        ...
                        <<<<<<< HEAD
                            my edit
                        =======
                            others edit
                        >>>>>>> __Others__
                        ...
                    ステータス: マージ中のステータスになります
                    どのように編集したらいいか分からない場合:  #search: Git conflict technique
                    編集が完了したら: |
                        git add "."
                        git commit -m "Merge branch 'develop' into master: merge"
                            #template: git commit -m "Merge branch '__SourceBranchName__' into __DestinationBranchName__: merge"
                        #// 必要なら git push も
                    マージした結果を確認します:  #search: git merge result
                #↓ 関連
                2回目以降のマージの場合:  #search: Git resolve conflict again
                git rebase のコンフリクト:  #search: git rebase conflict
                git revert のコンフリクト:  #search: git revert conflict
                develop-wip のコンフリクト:  #search: Git conflict develop-wip
                過去に解消したコンフリクトを再び行う場合:  #search: Git resolve conflict again
                Git 以外のコンフリクト:
                    #search: 設定ファイルの監視
            コンフリクト解消テクニック: #keyword: Git conflict technique
                基本:  #search: Git conflict
                編集後に定義が無くなるシンボルがある場合:
                    そのシンボルで全文検索して、他で使われていたら、その定義を残します
                編集後に参照が無くなるシンボルがある場合:
                    そのシンボルで全文検索して、定義だけになったら、その参照を残します
                コンフリクトが iPhone で発生した場合: #keyword: conflict in iPhone  #// Working Copy アプリ によるマージがうまくいかず、広い範囲でコンフリクトした場合
                    最新:
                        WorkingCopy の Resolveが異常（予期せぬ大量の追加など）なら、Textastic などでコンフリクトのタグを直接編集します。(<)を7つ並べて検索できます。
                    新:
                        iPhone で両方を含むように保存します:  #// このファイルに含む内容を A, B とし、A をコンフリクトしたときに受け入れた部分とします
                            #// iPhone で正しくマージするのは諦めて、PC でマージします
                        A.PC_current と B.PC_old を作ります:
                            PC で git pull する前かつ clean 状態なら:
                                現在のファイルの内容を B.PC_old へコピーします:
                                    ____-B.PC_old.yaml ファイルを作っても、エディターの新しいタブを作るだけでもよいです
                                PC で git pull します:
                                    コンフリクトしたら theirs を採用します
                                #// 現在のファイルは A.PC_current です。
                            PC で git pull した後なら:
                                #// 現在のファイルは A.PC_current です。
                                PC の git pull する前の最新コミットを B.PC_old へコピーします:
                                    そのコミットにブランチを作ります
                                    そのブランチにスイッチします
                                    B.PC_old へコピーします
                                    元のブランチに戻ります
                                    作ったブランチを削除します
                        C.PC_merging の初期状態を作ります:
                            B.PC_old を C.PC_merging にコピーします
                                #// 以後、基本的に B.PC_old は使いませんが、作業中に必要になったら参照します
                        C.PC_merging を更新します:
                            PC で更新があった部分のうち、大きく追加された部分「以外」を C.PC_merging とマージします:
                                - A.PC_current → C.PC_merging の差分を表示して、対象部分を手動でマージします。
                                    #// A.PC_current と C.PC_merging の両方を編集できるように、A.PC_current はクリップボードにコピーして比較するのではなく A.PC_current のファイルと比較します
                                - 最終的に大きく追加された１つの部分だけになるようにします
                        D.big_accept を作ります:
                            大きい差分を D.big_accept に移動します:  #// A.PC_current は、D.big_accept の内容の部分が削除されます
                                A.PC_current → C.PC_merging の差分を表示します:
                                一旦、差分の下端にジャンプします:
                                    ↑↓（Previous Change, Next Change：右上）を押します  #// 差分の上端にはジャンプできません
                                差分の上端にジャンプします:
                                    右半分（C.PC_merging）をクリックして、キーボードの ↑ キーを押します
                                移動する範囲の最初の行の行頭をクリックします:
                                    左半分（A.PC_current）をクリックします
                                差分の下端にジャンプします:
                                    ↓（Next Change：右上）を押します
                                移動する範囲の次の行の行頭をクリックします:
                                    Shift キーを押しながら、左半分（A.PC_current）をクリックします
                                カットします:
                                    Ctrl + X キー
                                D.big_accept に貼り付けます:
                                    Ctrl + V キー
                                    #// クリップボードが変わっていたら、左半分（A.PC_current）をアンドゥして再度カットします
                        C.PC_merging を削除します:
                            #// A.PC_current と C.PC_merging が同じ内容になっているはずです
                        A.PC_current と D.big_accept の差分を表示して、手動でマージします:
                            #// 通常、差分はほとんどありません
                    旧:
                        iPhone で両方を含むように保存します:  #// このファイルに含む内容を A, B とし、A をコンフリクトしたときに受け入れた部分とします
                            #// iPhone で正しくマージするのは諦めて、PC でマージします
                        （参考）以下で作るファイル:
                            A: ____-A-base.yaml    #// iPhone でコンフリクトしたときに受け入れた部分（それ以外は含めなくて良い）
                            B: ____-B-iPhone.yaml  #// base を除いた iPhone の最新
                            C: ____-C-PC.yaml      #// PC のマージ前。 またはマージ後の base を除いた部分
                            D: ____.yaml           #// マージした結果を作るファイル
                        PC の git pull する前の内容を C へコピーします:  #// このファイルに含む内容を C とします
                            ____-C-PC.yaml
                        PC で git pull します:
                            コンフリクトしたら theirs を採用します
                        マージした結果から、A の部分を新しいファイルへ移動します:  #// 移動した内容は最新ファイルから削除します
                            ____-A-base.yaml
                        最新ファイルを B へコピーします:  #// 最新ファイルを D とします
                            ____-B-iPhone.yaml
                        A, B, C を 3 way merge して D を更新します:
                            - A→B 差分を D へ
                            - A→C 差分を D へ
                コンフリクトした部分が広い場合:
                    - コンフリクトした部分を別の一時ファイルに移動させます
                    - コンフリクトした部分の一部が、コンフリクトしていない部分にあれば、どちらかを削除します
                    - 前のコミットからの差分を確認しながら編集します
            参照:
                プルリクエストによるマージを一覧します: #search: GitHub list pull request merge
                マージした内容を確認します:
                    GitHub の場合: GitHub のプルリクエストの Files タブ
        バックアップ: #keyword: Git back up
            GitHub など:
                自動的にバックアップしています。 リポジトリを削除しない限り無くなることはありません。
                ファイルを消してコミットしても復元できます。
            全ブランチのバックアップ:  #// 未確認
                #ref: ${typrm_files}/ref/Git-AI.yaml#label: git clone --mirror
            .git のコピー:  #search: git backup example
            back-up-files スクリプト: #search: back-up-file
            シークレット: #search: bash .env back up  #// リポジトリに含めないシークレットをバックアップします
            diff のコピー:  #search: git diff back up
        関連 >> プルリクエスト: #search: GitHub pull request
    コマンド, オプション: #keyword: git commands  #glossary:  #ref: https://git-scm.com/docs/
        git コマンド:  #glossary:
            git add:  #// ファイルをステージに入れます。ファイルの内容を git のインデックスに反映します
            git archive:  #// コミットの全体または更新差分が入った .zip ファイルを作ります
                基本: git archive __CommitOrBranch__  [__RelativePath__]  -o __OutputZipPath__  [__Options__]
                    #// __RelativePath__ は zip ファイルの中にも格納されます。
                    #// 格納したくないときは、cd で移動してから "__RelativePath__" = "." にして実行してください。
                すべて取り出す: #// .git フォルダー以外のすべてを圧縮します。.gitignore に指定されたファイルも圧縮されません
                    .zip ファイルを作る場合:
                        - cd  "__FolderHavindDotGitFolder__"  #// .git フォルダーがあるフォルダー
                        - git archive HEAD -o archive.zip
                        -   .gitignore に指定されたファイルも圧縮されません。
                            この zip ファイルをカレント フォルダーに展開すると、カレント フォルダーの直下に
                            いくつかのファイルやフォルダーが作られます。
                    .gitignore に無いファイルだけコピーする場合: #search: Git .commit
                追加・変更分を取り出す: #// 古いコミットから最新コミットまでに追加・変更したファイルを圧縮・展開します:
                    #// 削除したファイルは含みません。
                    圧縮します:
                        - cd  "__FolderHavindDotGitFolder__"  #// .git フォルダーがあるフォルダー
                        - git archive HEAD `git diff --name-only --diff-filter=ACMRTUXB  __OldCommitID__  HEAD` -o  ../diff_.zip
                            #// --diff-filter  #search: git diff filter
                            #// タイムスタンプはコミットした日時になります
                            #// __OldCommitID__ は git log で確認できます
                    展開します:
                        - cd  "__FolderHavindDotGitFolder__"  #// .git フォルダーがあるフォルダー
                        - unzip -o  ../diff_.zip  #// -o オプションは確認しないで上書きします
                削除の一覧:  #// 古いコミットから最新コミットまでに削除したファイルの相対パスを一覧して削除します:
                    一覧します:
                        - cd  "__FolderHavindDotGitFolder__"  #// .git フォルダーがあるフォルダー
                        - git diff --name-only --diff-filter=D  __OldCommitID__  HEAD  |  tee ../diff_del_.txt
                            #// --diff-filter  #search: git diff filter
                    削除します:
                        - cd  "__FolderHavindDotGitFolder__"  #// .git フォルダーがあるフォルダー
                        - cat ../diff_del_.txt | xargs rm -v  #// cat に指定したファイルに書かれたパスのファイルを削除します
                参考:  #ref: ${programming}/方法論/CVS/Git.svg#git_archive
                関連:  #search: git clone --separate-git-dir
            git blame: #keyword: git blame,  Git history editor 編集者  #// コードの「行」の編集者を調べます  git brame ではない
                #ref: https://git-scm.com/docs/git-blame
                GitHub: #search: GitHub blame
                前のバージョン: #search: git log --follow
            git branch: #search: Git branch
                git branch -m:  #// ブランチ名の変更
                    #ref: https://qiita.com/obonno3/items/f44bb730facc29a3b7d5
            git checkout: #keyword: git checkout
                コミット状態に戻します:  #search: git clean
                ブランチを切り替えます:  #search: switch Git branch
                    基本: git checkout  ___TargetBranch__  #search: switch Git branch
                    git checkout -t: リモートブランチから新しいブランチをローカルに生成し、さらにそのブランチへ移動します
                    内容を変えずに、現在のブランチを変更します:  #// ワーキング フォルダー の内容は変更しません
                        #search: git symbolic-ref
                戻したことをキャンセルします:  #keyword: git checkout undo
                    git checkout にパラメーターを指定しなかった場合:  #// パラメーターの例: "."
                        ファイルはコミットまで戻されていません
                    IDE で開いていた場合:
                        アンドゥで戻ります
                    参考: #ref: https://stackoverflow.com/questions/2961240/get-back-the-changes-after-accidental-checkout
                サブモジュールの外での操作:  #search: submodule git checkout
                別のブランチにあるファイルをコピーします: #keyword: git checkout file from other branch
                    git checkout  __BranchName__ -- __FilePath__
            git checkout-index:
                .gitignore で無視されないファイルだけコピーします: #search: .gitignore copy
                    git checkout-index -fau --prefix="working/"
                    カレント フォルダー とその子フォルダーの中にあるファイルがコピー元になります。
                    コピー先を指定する --prefix オプションが相対パスの場合、Git ワーキング フォルダー のルートが基準になります。
                -a オプション:  #// 追加されたファイルもコピーします。ただし、git add しないとコピーされません
                -u オプション:  #// 更新された後の内容がコピーされます。ただし、git add しないとコピーされません。付けないとリポジトリの内容がコピーされます
            git cherry-pick: #search:
            git clone:  #// ダウンロードします  #keyword:  #ref: ${programming}/方法論/CVS/Git.svg#git_clone
                基本: git clone __URL__
                入力オプション:
                    ブランチ, タグ:  #// ブランチまたはタグをダウンロードする場合
                        - rm -rf  "__ProjectName__"  #// 【注意】フォルダーを削除します
                        - git clone  "__RepositoryURL__"  -b "__BranchOrTag__"
                    一部のフォルダー:  #search: sparse checkout
                出力オプション:
                    作るフォルダー名: #keyword: git clone output  #// 作るフォルダー名も指定する場合
                        git clone __URL__  __NewLocalFolderPath__
                        #// __NewLocalFolderPath__ を省略したときと __NewLocalFolderPath__ にリポジトリ名を指定したときが、同じ動作になります
                        #// __NewLocalFolderPath__ の直下にリポジトリの内容が入ります
                        #// __NewLocalFolderPath__ に "."（ピリオド）を指定した場合、git clone した後の cd コマンドが不要になります
                    ${GitClone} にダウンロードする場合: #keyword: ${GitClone} download,  gitcache
                        ${GitClone} フォルダーを開きます:
                            #ref: ${GitClone}/GitHub
                            cd  __GitClone__/GitHub/__RepositoryUser__
                            git clone __URL__
                        関連 >> 自分の GitHub: #ref: ${GitHub}  #keyword: ${GitHub}  #ref: https://github.com/Takakiriy/
                    WSL2 にダウンロードする場合:  #search: git clone Windows to WSL2
                認証オプション: #keyword: git clone authentication
                    SSH 接続する場合:
                        以後のパスワード入力を不要にする:  #// ssh-add  #// git clone に指定するリポジトリが private であり、SSH キー にパスワードが設定されている場合
                            eval `ssh-agent -s`  &&  ssh-add
                            git clone  git@github.com:__Account__/__Repository__   #//❗ https ではないことに注意
                            #// SSH 接続をするリポジトリになります。HTTP 接続に切り替える場合  #search: gitssh
                    トークンや基本認証パスワードを使う場合:
                        username と password に指定するもの: #keyword: git authentication username password  #// 各種方式で異なります
                            PAT の場合:
                                username: oauth2
                                password: PAT
                        ~/.netrc を使う場合:  #search: ~/.netrc Git
                        ~/.git-credentials を使う場合: #keyword: ~/.git-credentials  #// 非推奨
                            #// 平文で保存するため非推奨
                            基本認証:
                                ~/.git-credentials ファイル:
                                    https://__User__:__Password__@__RepositoryServer__
                            #// git clone コマンドに指定する URL を書きます
                            #// 複数書くことができるようです（未確認）
                            場所:
                                - ~/.my-credentials
                                    #// credential.helper = store であること  #search: git clone authentication automatic input
                                #// または
                                - credential.helper の設定  #search: git credential.helper store
                                #// git clone に .my-credentials の場所を指定するオプションはありません。一時変更してください  #search: temporary git credential.helper store
                                #// 平文を指定する方法はあります  #search: git clone authentication
                        コマンドに指定する場合: #// 非推奨
                            ❗リスク: git remote get-url origin コマンドで表示されてしまいます  #keyword: git clone token in URL risk
                            トークン, PAT: #keyword: git clone https://oauth2:
                                git clone  https://oauth2:$(cat ~/.secret/gitlab-pat)@__GitRepositoryURL__
                                #search: git clone PAT
                            パスワード:  #// HTTPS であれば、通信上は暗号化されています。パスワードの平文は HTTPS の中で流れるため
                                git clone  https://__GitLabUser__:__GitLabApiToken__@__GitRepositoryURL__
                                #// __GitRepositoryURL__ は https:// を含みません
                        実行中入力: |  #// HTTPS であれば、通信上は暗号化されています。パスワードの平文は HTTPS の中で流れるため
                            #// 後日 git pull するときは、毎回入力が必要です
                            $ git clone  https://__GitRepositoryURL__
                            Cloning into 'reposiroty'...
                            Username for 'https://__GitRepositoryURL__': 
                            Password for 'https://__GitLabUser__@__GitRepositoryURL__': 
                        credential.helper: #keyword: Git credential.helper,  git clone authentication automatic input  #// Git リポジトリのパスワードを毎回入力することを不要にします
                            #// Git クライアント内の認証情報の保存場所。保存場所はヘルパーによっていろいろあります
                            #ref: https://git-scm.com/book/ja/v2/Git-のさまざまなツール-認証情報の保存
                            参照: #// 現在の設定を表示します。クライアント側
                                - git config credential.helper
                                - cat ~/.git-credentials  #// store 設定の場合
                            設定: #// 設定します。クライアント側。 Git リポジトリにアクセスしようとすると自動的にユーザー名とパスワード（やトークン）を入力します
                                # ↓保存場所
                                cache, メモリー:  #// 一定時間だけ入力不要にします。デフォルト 15分
                                    - git config --global credential.helper cache
                                    - git config --global credential.helper 'cache --timeout=60'
                                ファイル, store: #keyword: git config credential.helper  #// ❗平文
                                    設定を表示します:  #// 有効無効と、ファイルのパス
                                        入力コマンド:
                                            -   git config  --get credential.helper
                                            #// または
                                            -   git config --global  --get credential.helper  #search: git config --global
                                        出力の意味:
                                            - |
                                                $ git config  --get credential.helper
                                                store                           #// git fetch などを実行するときに、~/.git-credentials から認証情報を読み込みます
                                            - |
                                                $ git config  --get credential.helper
                                                store --file ~/.my-credentials  #// git fetch などを実行するときに、~/.my-credentials から認証情報を読み込みます
                                            - |
                                                $ git config  --get credential.helper
                                                                                #// 何も表示されないとき、git fetch などを実行するときに、認証情報を読み込みません
                                    保存します: #// 未確認
                                        次回入力した認証情報をファイルに保存するように設定します:
                                            標準的な ~/.git-credentials に保存する場合:
                                                git config --global credential.helper store
                                            指定した場所に保存する場合:
                                                git config --global credential.helper store  --file ~/.my-credentials
                                        認証情報を保存します:
                                            git fetch を実行する場合: |  #// git fetch を実行して認証情報を保存する場合
                                                $ git config --global credential.helper store
                                                $ git fetch
                                                Username for 'https://github.com': myusername
                                                Password for 'https://myusername@github.com': ********
                                                # ↑ここで入力した認証情報が自動的にファイルに保存される
                                    （古い情報）:
                                        パスワードを設定します:  #// 以下のいずれか
                                            ~/.git-credentials:  #search: ~/.git-credentials
                                            Git リポジトリにアクセス >> ユーザー名とパスワードを入力します:
                                        ファイルに保存する設定をします: #keyword: git credential.helper store  #// 以下のいずれか
                                            基本:
                                                - git config --global credential.helper store  #// ~/.git-credentials に保存されます
                                                - git config --global credential.helper store  --file ~/.my-credentials  #// ~/.my-credentials に保存されます
                                                #// 認証情報は平文で保存されます
                                            一時的にファイルの場所を指定する場合:  #keyword: temporary git credential.helper store
                                                - su --login __User__  #// 必要なら、ユーザーを正しくします
                                                - git config credential.helper
                                                #// 以下は何も表示されなかった場合
                                                - git config --global credential.helper store  --file __CredentialsFilePath__
                                                - git clone  __URL__
                                                - git config --global --unset credential.helper
                                        参考 >> 他の保存場所:  #search: save password
                                なし:  #// （デフォルト）保存されません。接続のたびにパスワードを入力します
                                    - git config --global --unset credential.helper
                                OS のパスワード管理:
                                    - git config --global credential.helper manager
                                    - Git リポジトリにアクセス >> ユーザー名とパスワードを入力します
                            保存, git credential approve: #keyword: git credential approve  #// credential.helper に「この認証情報を保存してください」と指示します
                                サンプル: |  #// シークレットを変数に保存しません  #search: git authentication username password
                                    printf "protocol=https\nhost=%s\nusername=%s\npassword=%s\n\n" \
                                        "${GitLabHost}"  "$( cat  "${GitLabAccountPath}" )"  "$( cat  "${GitLabPATPath}" )" \
                                    | docker exec -i ${containerName} sh -lc 'git credential approve'  ||  Error
                                Vault と連携する場合:  #search: Vault + GitLab PAT + CI + Container
                        #↓ リポジトリ側、クラウド側
                        GitHub:  #search: GitHub account
                        GitLab:  #search: GitLab access token
                        いろいろなトークン >> GitLab:  #search: GitLab members
                性能のオプション:
                    --depth オプション: #keyword: git clone --depth  #// シャロークローン (shallow clone)
                        --depth 1 とすると、最新のコミットだけダウンロードします。早くダウンロードできます
                    一部のフォルダー: #keyword: sparse checkout,  git clone part  #// 一部のフォルダーだけ git clone する場合
                        設定: #settings:
                            __RepositoryUser__: vercel
                            __Project__: next.js
                            __Branch__: canary
                            __RelativePath__: examples/with-react-bootstrap
                            __GitClone__: ~/GitClone/GitHub  #ref: ${GitClone}/GitHub
                        URL:
                            https://github.com/vercel/next.js/tree/canary/examples/with-react-bootstrap
                            #template: https://github.com/__RepositoryUser__/__Project__/tree/__Branch__/__RelativePath__
                            #to__: vercel, next.js, canary, examples/with-react-bootstrap
                        sparse-checkout を使う場合:
                            初回の場合:  #focus: next.js,  examples
                                準備:
                                    - mkdir -p  ~/GitClone/GitHub/vercel  #template: __GitClone__/__RepositoryUser__
                                    - cd        ~/GitClone/GitHub/vercel  #template: __GitClone__/__RepositoryUser__
                                ルート フォルダー の直下のファイルをダウンロードします:
                                    - git clone --filter=blob:none --sparse https://github.com/vercel/next.js.git
                                        #template: __RepositoryUser__/__Project__.git
                                        #// Git 2.26.0 以降が必要  #ref: https://stackoverflow.com/questions/72223738/failed-to-initialize-sparse-checkout
                                        #// Git 2.25.0 (2020-01-13)
                                        #// Git 2.25.1 では失敗するらしい
                                    - cd  next.js
                                一部のフォルダーをダウンロードします:
                                    - git sparse-checkout set examples/with-react-bootstrap  #template: __RelativePath__
                                        #// examples/with-react-bootstrap フォルダーをダウンロードします
                                        #// set サブコマンドは今まで設定していたフォルダー（ここでは ルート フォルダー）を
                                        #// sparse-checkout の対象外にして、そのフォルダーにあるファイルを削除します。
                            追加する場合:  #// ~/GitClone/GitHub/vercel フォルダーがある場合
                                    #template: __GitClone__/__RepositoryUser__ フォルダーがある場合
                                - git sparse-checkout add examples/amp-story
                                    #// examples/amp-story フォルダーを追加ダウンロードします
                                    #// add サブコマンドの代わりに set サブコマンドを指定すると、
                                    #// 今まで設定していたフォルダー（ここでは examples/with-react-bootstrap）を
                                    #// sparse-checkout の対象外にして、そのフォルダーにあるファイルを削除します。
                            #ref: https://github.com/isaacs/github/issues/1888
                        古い方法:
                            sparsecheckout を使う場合:
                                #// .git フォルダーは全体をダウンロードします
                                mkdir -p ~/GitClone/GitHub/vercel/next.js
                                cd ~/GitClone/GitHub/vercel/next.js
                                git init
                                git config core.sparsecheckout true
                                git remote add origin https://github.com/vercel/next.js.git
                                echo examples/with-react-bootstrap > .git/info/sparse-checkout
                                git pull origin canary
                            --no-checkout オプションを使う場合:
                                #// .git フォルダーは全体をダウンロードします
                                git clone --no-checkout https://github.com/vercel/next.js.git
                        使えない方法:
                            git clone --no-checkout:
                                - mkdir -p  ~/GitClone/GitHub/vercel
                                - cd        ~/GitClone/GitHub/vercel
                                - git clone --filter=blob:none --no-checkout https://github.com/vercel/next.js.git
                                - cd  next.js
                                - git sparse-checkout init
                                - git sparse-checkout add examples/amp-story
                                #ref: https://qiita.com/3w36zj6/items/b005c46a150100d66d78
                内容のオプション:
                    シンボリック リンク:  #keyword: Git symbolic link repository  #// シンボリック リンク を含むリポジトリの場合
                        Linux の場合:
                            通常通り git clone します
                        Windows の場合:
                            管理者として Git Bash を開きます:
                                Windows 10 21H1 スタート >> Git Bash（と入力）>> Git Bash（を右クリック）>> 管理者として実行
                            リポジトリの内容をダウンロード(git clone)します:
                                - cd  __ParentOfProject__
                                - git clone -c core.symlinks=true __RepositoryURL__
                            管理者権限をもつシェルを終了します:
                                Git Bash を閉じます
                        リンクすることの問題点:
                            import/include ができない問題が発生しやすい:
                                ユースケース:
                                    - project-B/code.py  ->  ../project-A/copy.py という シンボリック リンク があるとき
                                    - 後から project-A/code.py に import target-B を追加したら
                                    - project-B/code.py にも import target-B が追加され
                                    - project-B/target-B.py が存在しないのでエラーになります
                                構成: |
                                    project-A/
                                        code.py
                                            import target-A
                                            import target-B   #// 後から追加
                                        target-A.py
                                        target-B.py
                                    project-B/
                                        code.py  ->  ../project-A/copy.py
                                            import target-A
                                            import target-B    #// エラー
                                        target-A.py
                    サブフォルダー .git:  #// サブフォルダーにも .git フォルダーがある場合  #search: Git submodule
                    .git を分けて git clone する場合: |  #keyword: git clone --separate-git-dir  #ref: https://stackoverflow.com/questions/11497457/git-clone-without-git-directory
                        #!/bin/bash
                        rm -rf _working
                        git clone --separate-git-dir="_git" --depth=1 file://${PWD}  "_working"
                        rm -rf _git
                        rm -f _working/.git
                    .git フォルダーだけ:  #keyword: git clone .git  #// .git フォルダーだけダウンロードする場合
                        git clone:
                            - git clone --no-checkout  __URL__
                            #// または
                            - git clone --no-checkout  __URL__  "."  #// ./.git フォルダーができます
                                #// 実行前に、カレント フォルダー が空でないとエラーになります
                            #// または
                            - git clone --no-checkout  --depth 1  __URL__
                            #// 以下に続きます
                        ❗注意:
                            ダウンロード後に git status を実行すると、ファイルが削除されたステージング状態になっています
                        別の方法でファイルを用意した後:
                            git reset  #// ステージング前の状態に戻します。This returns Git status to not staging
                                #// これを実行しないと、git status は、削除がステージング状態にあり、追加がステージング前の状態にあると表示されます
                トラブルシューティング（Git clone）:  #keyword: git clone trouble
                    - #// 関連: #search: git push trouble
                    - #// git clone したら小さいファイルしかできない (Git LFS)
                        手順: git clone ____
                        エラー: なし
                        症状:
                            以下のような内容のファイルができる: |
                                version https://git-lfs.github.com/spec/v1
                                oid sha256:00001111ad9d8850e5e50e7ecbeb869f5dee086248e3769e407bf50f1705dc74
                                size 123456
                            __Project__/.gitattributes ファイルがある: |
                                *.__Extension__ filter=lfs diff=lfs merge=lfs -text
                        対処:
                            Git LFS をインストールします:  #search: install Git LFS
                        メモ:
                            #search: Git LFS
                            LFS を使うように新しく設定します:
                                cd __Project__
                                git-lfs install
                                git-lfs track "*.rpm"  #// .rpm を LFS の対象にする場合
                    #↓ エラー メッセージ
                    - #// git clone しようとしたら Permission denied (publickey).  #keyword: git clone SSH
                        手順: git clone git@__Server__  #// この形式は SSH で接続しようとしています
                        エラー: Permission denied (publickey).
                        対処A:
                            接続先のサーバーまたはサービスに公開鍵を設定します:  #search: Git SSH key
                        対処B:
                            SSH キー を指定します:  #// git 2.3 以降。 Git bash でも使えます
                                GIT_SSH_COMMAND="ssh -i ~/.ssh/special_id_rsa"  git clone git@__Server__
                            GIT_SSH_COMMAND: #keyword:
                                GIT_SSH_COMMAND に指定した秘密鍵は、git コマンドを実行するホストに存在する必要があります。
                                    #label: git clone SSH password
                            別途手動で git clone する場合: #keyword: manual git clone secrets
                                スクリプトでは git clone してできるファイルが存在するまで待ちます。
                                #search: WaitForFileExists
                        対処C:
                            SSH キーが合っているか確認します:  #// 下記の場合、鍵は ~/.ssh/github_id_rsa で合っています
                                $ ssh git@github.com -i ~/.ssh/github_id_rsa
                                PTY allocation request failed on channel 0
                                Hi __Name__! You've successfully authenticated, but GitHub does not provide shell access.
                                Connection to github.com closed.
                        対処D:
                            HTTPS 接続に変えます  #search: git remote set-url
                    - #// Username for 'https://github.com'
                        手順: git clone
                        ログ: |
                            Cloning into '__Repository__'...
                            Username for 'https://gitlab.com':
                        対処:
                            トークンを設定します  #search: ~/.netrc  #search: GitLab PAT
                    - #// Encountered ____ files that should have been pointers, but weren't
                        手順: git clone
                        エラー: |
                            Encountered 2 files that should have been pointers, but weren't:
                        対処:
                            Git LFS をインストールして、git add, commit, push し直します
                        原因:
                            リポジトリにあるファイルが大きいにもかかわらず LFS 属性が付いていません。
                    - #// fatal: could not read Username for 'https://git....': No such device or address
                        手順: SSH で接続した接続先から起動したスクリプトから git clone
                        エラー: |
                            fatal: could not read Username for 'https://git....': No such device or address
                        対処A:
                            アクセス権があるユーザーを使います
                        対処B:
                            アクセス トークン を使います  #search: GitLab PAT
                        対処C:
                            #ref: ${typrm_files}/ref/Git-AI.yaml#label: git clone SSH password
                関連:
                    .zip ファイルをダウンロードします: #search: GitHub .zip download
                    .zip ファイルにまとめます: #search: git archive
                #search: Git repository
            git commit: #keyword: git commit command  #search: Git コミット  #ref: https://git-scm.com/docs/git-commit
                基本: git commit -m "__CommitMessage"
                #search: Git コミット
            git config: #keyword:
                ユーザー名:  #search: Git username
                コマンド: #keyword: git config command
                    参照: #keyword: get git config
                        カレント フォルダー での値: git config  __VariableName__
                            #// __Working__/.git/config ファイルがあるとローカルの設定が使われ、無ければグローバルの設定が使われます
                        ローカル: git config --local  __VariableName__  #// プロジェクト内のみ
                        グローバル: git config --global  __VariableName__   #// ユーザーごと
                    一覧:
                        --list オプション
                    設定: #keyword: set git config
                        ローカル: git config --local  __VariableName__  "__NewValue__"  #// プロジェクト内のみ
                        グローバル: git config --global  __VariableName__  "__NewValue__"  #// ユーザーごと
                    削除: #keyword: delete git config  #focus: --unset
                        ローカル:
                            - git config --local  __VariableName__  #// 設定を確認します
                            - git config --local --unset  __VariableName__  #// 削除します
                        グローバル:
                            - git config --global  __VariableName__  #// 設定を確認します
                            - git config --global --unset  __VariableName__  #// 削除します
                ファイル: #keyword: .gitconfig file,  .git/config
                    ローカル: #keyword: git config --local,  __Working__/.git/config
                        場所: __Working__/.git/config
                        CLI: git config --local   #search: get git config  #search: set git config
                        #// git clone すると初期化されます。git push/pull などをしても、それぞれの（別の人の）ワーキング フォルダー との間で同期しません
                    グローバル: #keyword: git config --global,  ~/.gitconfig
                        場所: ~/.gitconfig  #// ユーザーごと
                        CLI: git config --global  #search: get git config  #search: set git config
                        #// git config --global --edit を実行すると vi で編集します
                    システム: #keyword: /etc/gitconfig
                        場所: /etc/gitconfig
                        CLI:  #search: get git config  #search: set git config
                    内容:  #// ファイルの内容の書式とコマンドでの指定方法
                        コマンド:  #focus: user, name
                            git --local config  user.name Takakiriy
                        ファイル: |
                            [user]
                                name = Takakiriy
                    #ref: https://note.nkmk.me/git-config-setting/
                設定内容: #glossary: git config reference  #// [user] の email の値は git config user.email で表示できます
                    user.email: = takakiriy@gmail.com
                    user.name: = Takakiriy
                    core.repositoryformatversion: = 0
                    core.filemode: = true
                    core.bare: = false
                    core.logallrefupdates: = true
                    rebase.autoStash:  #// git rebase (git pull の内部などで) するときに自動的に git stash と git stash pop を行います
                    pull.rebase:  #// git pull するときに自動的にリベースを行います
            git diff: #keyword:
                比較対象別:
                    別のブランチと比較:
                        一覧します:  #// 差分があるファイルを一覧します
                            - git diff  __OtherBranch__  --name-only  #// 現在のファイルの内容（コミット前）と別のブランチを比較します
                        ファイルの内容の差分を表示します:
                            - git diff  __OtherBranch__  __FilePath__  #// 現在のファイルの内容（コミット前）と別のブランチを比較します
                            - git diff  __OtherBranch__  __FilePath__  ":(exclude)__Path__"  #// __Path__ を比較の対象外にします
                                #// __FilePath__ を省略すると "." を指定したときと同じ動作になります
                                #search: Git pathspec
                                #//  赤い表示(- 削除)は __OtherBranch__ にある内容、緑の表示(+ 追加)は現在のブランチにある内容
                        VSCode を使う場合:  #search: VSCode git diff branch
                    別のホストとの比較:  #// git diff ではできません  #search: Linux file list with CRC
                    別のコミットと比較:
                        内容の差分を表示します:
                            git diff  "__OldCommitID__"  "__NewCommitID__"
                        差分があるファイルを一覧します:
                            git diff  --name-only  "__OldCommitID__"  "__NewCommitID__"
                        VSCode で比較します: #keyword: git diff VSCode
                            Source Control ビューから見る場合: #search: VSCode source control old commit
                            フォルダーを作って比較する場合:  #// new フォルダーと old フォルダーを作り、VSCode の拡張機能 Compare Folder を使って比較を表示します
                                #search: VSCode diff compare folders
                                準備:
                                    -   #// 2回目以降の場合
                                        find "${HOME}/_git_diff"  |  xargs -i  echo chmod +w "{}"
                                    -   #// 上記 echo chmod を chmod に置き換えて実行します。
                                    -   rm -rf  "${HOME}/_git_diff"
                                        mkdir   "${HOME}/_git_diff"
                                    -   git status   #// clean 状態であること
                                    -   _new_branch=__NewBranch__
                                        _old_branch=__OldBranch__
                                        git checkout  $_new_branch
                                    -   git diff  --name-only $_old_branch > "${HOME}/_git_diff/file_names.txt"
                                        cat  "${HOME}/_git_diff/file_names.txt"
                                差分があるファイルについて、_new_branch の内容をコピーします:
                                    -   cd  __ParentOfDotGitFolder__
                                    -   git checkout  $_new_branch
                                    -   cat  "${HOME}/_git_diff/file_names.txt"  |  xargs -i  dirname {}  |  xargs -i  echo mkdir -p "${HOME}/_git_diff/new/{}"
                                    -   #// 上記 echo mkdir を mkdir に置き換えて実行します。
                                    -   cat  "${HOME}/_git_diff/file_names.txt"  |  xargs -i  echo cp "{}" "${HOME}/_git_diff/new/{}"
                                    -   #// 上記 echo cp を cp に置き換えて実行します。
                                差分があるファイルについて、_old_branch の内容をコピーします:
                                    -   cd  __ParentOfDotGitFolder__
                                    -   git checkout  $_old_branch
                                    -   cat  "${HOME}/_git_diff/file_names.txt"  |  xargs -i  dirname {}  |  xargs -i  echo mkdir -p "${HOME}/_git_diff/old/{}"
                                    -   #// 上記 echo mkdir を mkdir に置き換えて実行します。
                                    -   cat  "${HOME}/_git_diff/file_names.txt"  |  xargs -i  echo cp "{}" "${HOME}/_git_diff/old/{}"
                                    -   #// 上記 echo cp を cp に置き換えて実行します。
                                    -   git checkout  $_new_branch  #// 必要なら
                                リードオンリーにします:  #// 新しくできたファイルをリードオンリーにすることで、new old の内容ではなくなることを防ぎます
                                    -   find "${HOME}/_git_diff"  |  xargs -i  echo chmod -w "{}"
                                    -   #// 上記 echo chmod を chmod に置き換えて実行します。
                                実行します:
                                    -   code  "${HOME}/_git_diff/new"
                                        #// VSCode の拡張機能 Compare Folders を使って、"${HOME}/_git_diff/old" と比較します
                                        #search: VSCode diff compare folders
                    1つのファイルだけ過去と比較する場合:  #search: VSCode git diff 1-file
                表示のカスタマイズ:
                    左右(+-)の意味:  #// - は古いほうにある。つまり新しいほうで削除。
                        -   git diff __MinusRedOld__ __PlusGreenNew__
                        -   git diff __MinusRedOld__  #// + = working
                        -   git diff  #// - = index (commit), + = working
                    VSCode で表示:  #search: codediff
                    GitHub などで比較:  #search: GitHub diff
                    ファイル名一覧: #keyword: git diff --name-only  #// ブランチでこれまでに編集したファイルの一覧
                        基本:  #// 直前のコミットと比較します
                            git diff --name-only
                        コミット指定:
                            git diff --name-only  __OldCommitID__  __NewCommitID__
                        分岐してから最新までの差分:
                            マージ ベース（枝分かれ元）のブランチのコミットIDをメモします:
                                __BaseCommitID__  #search: gitlog1
                            マージ ベースとブランチの最新コミットの間で違いがあるファイルを一覧します:
                                git diff --name-only  __BaseCommitID__  __Branch__
                        特定のフォルダーのみ:
                            ファイル名のみ:
                                git diff --name-only  __OldCommitID__  [__NewCommitID__]  --  "__FolderPath__"
                            変更内容:
                                git log -p --  "__FolderPath__"
                    less のように表示モードにしない:
                        git --no-pager diff
                    前後の行を表示しない:
                        git diff  --unified=0    #// --unified 0 ではエラーになります
                パッチとバックアップ:
                    パッチ, git diff で作ったパッチを適用します: #search: git apply
                    バックアップ:  #// Untracked file も含めて差分ファイルを保存します
                        #// ワーキング フォルダー で修正した内容をコミットする前にバックアップします
                        コマンド: #keyword: git diff back up
                            Untracked なファイルを git diff の対象に追加します:
                                git status
                                git add -N  __UntrackedFilePath1__ __UntrackedFilePath2__ ...
                            バックアップします:
                                git diff  > __BackUpFilePath__
                        注意:
                            すでに git add (-N なし) を実行した後で、git add -N しても効果ありません。
                        #ref: https://stackoverflow.com/questions/855767/can-i-use-git-diff-on-untracked-files
                行やファイルや mode の編集:
                    特定の行の変更履歴:
                        前のコミット: #keyword: git lens previous commit
                            VSCode の GitLens 拡張機能による Open Change with Previous Revision ボタン（右上）
                        過去全て:  #search: git log -L
                            git log -L __StartLineNum__,__EndLineNum__:__FilePath__
                    行を削除したコミットを検索:  #// 行の内容が分かっているとき、その行が削除されたタイミングのコミットを特定します
                        git log -S "__DeletedLineContents__" --patch __FilePath__
                        git log -S "__DeletedLineContents__" --patch
                    操作別, --diff-filter オプション: #keyword: git diff filter
                        よくある指定:
                            --diff-filter=ACMRTUXB: 削除したファイル（D）以外
                            --diff-filter=DCMRTUXB: 追加したファイル（A）以外
                        指定内容:
                            Added (A)
                            Copied (C)
                            Deleted (D)
                            Modified (M)
                            Renamed (R)
                            have their type (i.e. regular file, symlink, submodule, ...) changed (T)
                            Unmerged (U)
                            Unknown (X)
                            have had their pairing Broken (B)
                    mode のみの diff: #keyword: git diff mode,  git chmod diff old new mode 100755 100644 777 444
                        ❗注意: 実行モードのみ対象です。書き込み属性の変更は git では扱いません。git diff で表示されませんし git commit や push しても記録されません
                        状況のサンプル: |
                            $ git diff
                            diff --git a/.gitignore b/.gitignore
                            old mode 100644    #// 実行可能モードがオフ
                            new mode 100755    #// 実行可能モードがオン
                                #// 実行モードのみ対象です
                        core.fileMode 設定:
                            Windows の場合:  #// 次のようにすると上記のような不要な diff が出ないようになります:
                                設定変更: git config --local  core.fileMode  false
                                WSL2 へ git clone: #keyword: git clone Windows to WSL2  #// PowerShell で WSL の共有フォルダーに git clone すると、実行可能モードを扱えるようになります
                                    (PowerShell):  #// Rocky8Test ディストリビューション の場合
                                        cd  \\wsl.localhost\Rocky8Test\home\user1
                                        git clone  https://github.com/Takakiriy/typrm.git
                                        code --remote wsl+Rocky8Test  "home/user1"
                                    (bash):
                                        cd  ~/typrm
                                        git config --local  core.fileMode  true
                                        chmod +x README.md
                                        git diff
                                            diff --git a/README.md b/README.md
                                            old mode 100644
                                            new mode 100755
                            Linux の場合: #keyword: core.fileMode  #// デフォルトまたは次の設定をしないと、実行可能モードは変更できません
                                git config --local  core.fileMode  true
                                chmod +x __File__
                                git diff
                                #// git clone したときの Git hooks で上記の設定を変えるのが良さそう  #search: Git Hooks post-checkout
                                #// Windows との共有フォルダーの中の Git ワーキング フォルダー では、git config --local の設定を変更できません。Text file busy エラーになります。
                        Git のファイルのモード: #keyword: git chmod +x  #// Git が認識している chmod +x
                            表示:  #// Git が認識している chmod +x を表示します
                                - git ls-files -s  __FilePath__   #// __FilePath__ を省略すると、サブフォルダーの中のファイルも含めて一覧します
                                - git ls-files -s  __FolderPath__   #// サブフォルダーの中のファイルも含めて一覧します
                            編集:
                                Windows Git bash で Git が認識する chmod +x を編集します: | #keyword: Windows Git chmod +x
                                    git config --local  core.fileMode true

                                    git update-index --chmod=+x  __FilePath__   #// または --chmod=-x
                                    git add --chmod=+x  __FilePath__  #// update-index と add の両方が必要です
                                        #// 他のファイルも同様に update-index と add をします。
                                        #// ここの状態で git status すると、__FilePath__ が staged と not staged の両方に表示されます

                                    git config --local  core.fileMode false
                                        #// ここの状態で git status すると、__FilePath__ が staged だけに表示されます
                                    git status  #// または  git ls-files -s  __Path__
                                    git commit ____
                                    git push
                互換性, 類似ツール:
                    .git フォルダーがない場合:  #search: git .commit
                    diff との互換性:  #search: Linux diff git compatible
                    CRC によるフォルダーの比較:  #search: Linux file list with CRC
                前のバージョン: #search: git log --follow
                検索 >> 変更内容:  #search: git log search
                参考: snote >> git diff  #ref: ${programming}/方法論/CVS/Git.svg#git_diff
            git fetch:
                リモートのブランチを最新に更新します:
                    git fetch -p
                #ref: https://stackoverflow.com/questions/292357/what-is-the-difference-between-git-pull-and-git-fetch?rq=1
                -p オプション: #keyword: git fetch -p  #// リモート追跡ブランチを整理します
                    リモートに存在しなくなったリモート追跡ブランチをすべて削除します。
                        git fetch -p
                    git remote prune origin と同じ？
                    gitlog に赤く表示される origin/__Branch__ がリポジトリ（リモート）になければ、origin/__Branch__ を削除します。
                    origin/__Branch__ は、リモート追跡ブランチと言います。
                    #ref: https://qiita.com/uasi/items/69368c17c79e99aaddbf
                    #ref: https://stackoverflow.com/questions/17832850/what-does-git-fetch-p-or-prune-mean
            git gc:  #// ガベージ コレクション。削除したコミットなどを完全に削除します
                コマンド: git gc --auto
                関連コマンド:  #// 他のコマンドを実行したときでも閾値を超えていたら自動的に ガベージ コレクション を実行します
                    git pull, git merge など
                閾値:  #// 閾値を超えないと自動的には実行されません
                    2週間, 6700 オブジェクト
                #ref: ${typrm_files}/ref/Git-AI.yaml#label: git gc auto
            git grep:
                過去のコミットから検索します:
                    git rev-list:
                        コマンド:
                            基本:
                                git rev-list __HEAD_Or_Branch__ | xargs git grep --heading --line-number '__Keyword__'
                            正規表現:
                                git rev-list __HEAD_Or_Branch__ | xargs git grep --heading --line-number -e '__Keyword__'
                            and 条件:
                                git rev-list __HEAD_Or_Branch__ | xargs git grep --heading --line-number -e '__Keyword1__' --and -e '__Keyword2__'
                        __HEAD_Or_Branch__:
                            HEAD: 現在のブランチ
                            （ブランチ名）: 指定のブランチ
                            --all: 全てのブランチ
                        --and オプション:  #keyword: git grep --and
                            _: --and, --or, --not
                            参考: grep（git grep ではない）には --and オプションは ありません。
                            #rer: https://www.thegeekstuff.com/2011/10/grep-or-and-not-operators/
                        続きと終了:
                            検索結果が 1画面以上になると一時停止します。less コマンドと同じ
                        参考:
                            #ref: https://future-architect.github.io/articles/20200611/#特定のファイルだけ検索
                    _commit_ID_list.txt:  #keyword: git grep _commit_ID_list.txt  #// コミット ID のリストから検索します
                        ~/_commit_ID_list.txt ファイルを作り
                        cat ~/_commit_ID_list.txt | xargs git grep --heading --line-number '__Keyword__'
                    関連:  #search: git log search
            git log: #keyword:
                １行ずつ表示:  #// 現在のブランチのみします
                    git pull
                    git log --oneline --decorate --pretty=format:"%C(auto)%h %d %s %C(cyan)%an %C(green)%ad" --date=iso-local
                ツリー表示:
                    基本:  #search: gitlog
                    安定表示:  #search: git log --topo-order
                情報:  #// 1つのコミットの情報を表示します  #search: git show
                署名:  #// コミットにつけられた署名  #search: git log --show-signature
                前のバージョン >> 1つのファイル: #keyword: git log --follow
                    git log --follow __FilePath__
                検索 >> 変更内容:  #// 指定した変更内容を含むコミットを探します  #keyword: git log search,  git log branch grep
                    基本:  #// 追加または削除または変更前後の行の内容で検索します
                        git log -S '__Keyword__'
                    ファイル名で絞り込みます:
                        git log -S '__Keyword__' -- __RelativePathFromCurrentFolder__  #// Ascii 文字以外は検索できない (git 2.36.1)
                    ユーザーや日付で絞り込みます:
                        git log -S '__Keyword__' | grep -1 __UserName__  #// -1 は #search: grep before after lines
                    コミット ID のリストから検索します:  #search: git grep _commit_ID_list.txt
                        ~/_commit_ID_list.txt ファイルを作り
                        cat ~/_commit_ID_list.txt | xargs git grep --heading --line-number '__Keyword__'
                    全てのブランチを全文検索します:
                        git log -p --all | grep "Math.round(bandWidthIn"
                        git log -G"Math.round(bandWidthIn" --all
                    #ref: https://www.web-dev-qa-db-ja.com/ja/git/gitの履歴でコミット済みのコードをgrep（検索）するにはどうすればいいですか？/969680228/
                分岐した後のコミット一覧:
                    #search: gitlog1 2022-08
                    #search: git show-branch
                テスト用 安定表示:  #search: git log --topo-order
                オプション: #keyword: git log options
                    --branches: 他のブランチも表示します
                    --date=iso-local: 日時が ISO8601 形式になります。時刻を日本時間にするには TZ='Asia/Tokyo'  git log --date=iso-local
                    --date-order: コミット単位で日付順のソートを行います。つまり、並行して表示します。コミッター日時でソートします  #search: Git コミッター日時
                    --author-date-order: 作成日付順のソートを行います  #search: Git オーサー日時
                    --topo-order: トポロジカル順のソートを行います。より安定しています。トポロジカル制約（親が子より先）を守ります。
                        まだ安定しない場合は、--branches オプションを指定しないで、ブランチ名を git log コマンドのパラメーターに指定します。
                        左に書いたブランチが上に表示されます。（それだけではなさそう）
                        ブランチの途中にあるブランチは指定しなくても表示できます。
                    --date-order も --topo-order もない場合: --date-order でも --topo-order でもない混合の表示順です
                    --follow: 前のバージョン >> 1つのファイル  #search: git log --follow
                    --reverse: 上下逆順で表示します。ただし --graph と同時に設定はできません
                    --graph: グラフでブランチの関係を表示します
                    --oneline: 1コミットあたり1行でコンパクトに表示します
                    --pretty=format: #keyword:
                        (%ad): 日時。--date=iso-local も指定すると ISO8601 形式になります
                        (%C(__Color__)): 色を付けます。指定できる値は、auto, normal, black, red, green, yellow, blue, magenta, cyan, white
                            #ref: https://git-scm.com/docs/git-config#Documentation/git-config.txt-color
                            #ref: https://git-scm.com/docs/pretty-formats#Documentation/pretty-formats.txt-emC82308203em
                        (%d): ブランチやヘッダーの位置
                        (%h): コミットID
                        (%s): コミット メッセージ
                    未確認:
                        作成者: #keyword: Git auther
                            ブランチ一覧:  #search: git-branches-from-author
                        作成日: #keyword: Git オーサー日時,  Git 作成日時, Git 作成者日付 オーサー日付
                            git log --format="%h %an %ad" --date=local
                        コミッター: #keyword: Git commiter
                        更新日:  #keyword: Git コミッター日時,  Git 更新日時, Git コミッター日付 コミット日付
                            #search: Git file time stamp
                            コマンド:
                                git log --format="%h %cn %cd" --date=local
                            更新コマンド:  #// 更新日時を更新するコマンド
                                git commit --amend, フォース プッシュ, リベース
                        作成日と更新日: #keyword: Git 作成日 更新日
                            グラフを表示するとき:  #// 作成日か更新日かどちらを表示すべきか
                                ベスト: 両方
                                ベター: 作成日
                                混乱する: 更新日  #// ← デメリット
                            #↓ メリットと反論。ChatGPT より
                            1. 責任の明確化:
                                オーサー日付は、コードの変更を最初に作成した人を示します。これにより、その変更の元々の作成者が誰であるかが明確になります。
                                コミッター日付は、そのコミットをリポジトリに適用した人を示します。これは特に、コードレビューやメンテナンスを行った他の開発者がコミットを扱った場合に重要です。
                                ただし、同じ人なら分ける必要はありません
                            2. 歴史の正確な追跡:
                                プロジェクトにおいて、特定の変更がいつどのように導入されたかを正確に追跡することができます。例えば、コードの修正や機能追加がいつ元のリポジトリに統合されたかが分かります。
                                しかし、リベースした後のブランチの分岐点のコミットの作成日から分かります
                            3. プロジェクトの透明性:
                                複数の開発者が関与する大規模なプロジェクトでは、誰が実際にコードをレビューしてマージしたかを記録することで、プロジェクトの透明性が向上します。
                                ただし、同じ人なら分ける必要はありません
                            4. リベースやチェリーピックの管理:
                                リベースやチェリーピックなどのGit操作を行う際に、オーサー日付が保持されることで、元のコミットの意図を保ちつつ、新たなブランチのコンテキストに適切に統合することができます。これにより、変更がいつ、なぜ導入されたかのオリジナルのコンテキストが失われることなく、新しいブランチに適用されます。
                                しかし、リベースした後のブランチの分岐点のコミットの作成日から分かります
                            5. 監査とコンプライアンス:
                                組織やプロジェクトが監査やコンプライアンス要件に従う場合、誰が変更を承認してリポジトリにマージしたかを明確にすることが重要です。オーサーとコミッターの日付を分けることで、これらのプロセスがより明確になり、必要に応じて適切な行動を追跡できます。
                                ただし、同じ人なら分ける必要はありませんし、リベースした後のブランチの分岐点のコミットの作成日から分かります
                                ファイルのタイムスタンプなら更新ビルドが正しく動くために必要だが、そうではない
                        コミット日時を証明します:  #search: Git commit date
                        #ref: https://docs.github.com/ja/account-and-profile/setting-up-and-managing-your-github-profile/managing-contribution-settings-on-your-profile/troubleshooting-commits-on-your-timeline#
                    -L, 特定の行の変更履歴:  #keyword: git log -L
                        git log -L __StartLineNum__,__EndLineNum__:__FilePath__
            git ls-remote:
                リモートのブランチ・タグのある位置のコミットIDを一覧します:
                    git ls-remote
                リモートのブランチ（のヘッド）を一覧します:
                    git ls-remote --heads
                リモートのタグを一覧します:
                    git ls-remote --tags  #search: list git tag
                リポジトリを指定します:
                    git ls-remote --heads -- https://github.com/Takakiriy/first
                        #template__: -- __ReposirotyURL__
                コミットID を取得します:  #// 指定したリポジトリの指定したブランチのヘッドの コミットID を取得します
                    git ls-remote -- https://github.com/Takakiriy/first  refs/heads/main
                        #template__: -- __ReposirotyURL__  refs/heads/__BranchName__
            git merge:
                公式: #ref: https://git-scm.com/docs/git-merge
                #search: git merge
            git merge-base:  #// マージ ベース。共通の祖先
                git merge-base __BranchA__ __BranchB__
                #search: VSCode git merge-base
            git pull: #keyword:
                git stash をしなくて済むようにします:  #// ワーキング フォルダー が clean ではないときに git pull すると git stash する必要がありますが、それを自動で行います
                    cd  __Project__
                    git config pull.rebase true
                    git config rebase.autoStash true  #// --autostash は rebase モード でのみ機能します
                別のブランチを同期（git pull）します:
                        #// 1つのコマンドではできません
                    -   git stash   #// git status が clean ではないときだけ
                    -   git checkout  __OtherBranch__
                    -   git pull
                    -   git checkout  __FeatureBranch__
                    -   git stash pop  #// git stash を実行したときだけ
                認証オプション: #keyword: git pull authentication
                    ~/.netrc を使う場合: |  #search: ~/.netrc Git  #//❗必要なら作業後に ~/.netrc ファイルを削除すること
                        vi ~/.netrc
                            #// 動作確認済み: GitLab deploy token 
                        git pull
                            #// git pull https://${DEPLOY_USERNAME}:${DEPLOY_TOKEN} ... ではうまくいきません。ブランチが指定できてなさそう
                        rm ~/.netrc  #// 元々ファイルが無い場合
                        less ~/.netrc  #// 無いことを確認
                詳細:
                    構成: git pull = git fetch + git merge origin/branch
                    git pull で自動的に GC が始まることがあります:
                        ログ: |
                            remote: Enumerating objects: 12, done.
                            remote: Counting objects: 100% (12/12), done.
                            remote: Compressing objects: 100% (8/8), done.
                            remote: Total 8 (delta 6), reused 2 (delta 0), pack-reused 0
                            Unpacking objects: 100% (8/8), 1.33 KiB | 24.00 KiB/s, done.
                            From https://github.com/Takakiriy/steps
                            5186878..6dbd7e8  master     -> origin/master
                            Auto packing the repository in background for optimum performance.
                            See "git help gc" for manual housekeeping.
                            Enumerating objects: 5266, done.
                            Counting objects: 100% (5198/5198), done.
                            Delta compression using up to 8 threads
                            Compressing objects: 100% (5197/5197), done.
                            Writing objects: 100% (5198/5198), done.
                            Total 5198 (delta 4280), reused 0 (delta 0), pack-reused 0
                            Removing duplicate objects: 100% (256/256), done.
                            Updating 5186878..6dbd7e8
                            Fast-forward
                            0_memo.yaml    | 17 +++++++++++------
                            Economics.yaml |  4 ++++
                            Life.yaml      |  1 +
                            3 files changed, 16 insertions(+), 6 deletions(-)
            git push:
                基本:
                    -   git push  #// 現在のブランチのコミットをサーバーに同期します
                    -   git push origin __Branch__
                SSH のパスフレーズ省略: #keyword: Git SSH,  git push SSH key  #// SSH のパスフレーズの入力を求められないようにします
                    リモート（サーバー）に接続するプロトコルを SSH に設定します:
                        確認: #keyword: git remote get-url
                            リモートに接続するプロトコルを確認します:
                                git remote -v の場合: #keyword: Git SSH URL
                                    コマンド: git remote -v
                                    SSH 接続のときの出力例: |  #// git@ から始まります
                                        origin  git@github.com:Takakiriy/typrm.git (fetch)  #template: git@__Domain__:__Account__/__Repository__.git
                                        origin  git@github.com:Takakiriy/typrm.git (push)   #template: git@__Domain__:__Account__/__Repository__.git
                                    HTTP 接続や ローカル フォルダー のときの出力例: |  #// https: や file: から始まります
                                        origin  https://github.com/Takakiriy/typrm.git (fetch)  #template: https://__Domain__/__Account__/__Repository__.git
                                        origin  https://github.com/Takakiriy/typrm.git (push)   #template: https://__Domain__/__Account__/__Repository__.git
                                git remote get-url の場合:
                                    コマンド: git remote get-url origin
                                    HTTP 接続のときの出力例: |
                                        https://github.com/Takakiriy/typrm.git
                                    終了コード: 0=正常, 2=設定なし
                        設定: #keyword: git remote set-url,  git HTTPS SSH
                            SSH:  #// リモートに接続するプロトコルを SSH に設定します:  #copy-template: git remote ssh, {__Domain__: github.com, __User__: Takakiriy, __Repository__: typrm, __SshKey__: id_rsa}
                                - gitssh
                                #// または
                                - git remote set-url origin git@github.com:Takakiriy/typrm.git  #template: git@__Domain__:__User__/__Repository__.git
                                - git remote -v
                                - eval `ssh-agent -s`  &&  ssh-add ~/.ssh/id_rsa    #template: ~/.ssh/__SshKey__
                            HTTPS, file:  #// HTTPS や file に戻すとき:  #copy-template: git remote https, {__Domain__: github.com, __User__: Takakiriy, __Repository__: typrm}
                                - git remote set-url origin https://github.com/Takakiriy/typrm.git  #template: https://__Domain__/__User__/__Repository__.git
                                - git remote -v
                            gitssh コマンド: #keyword: gitssh  #// SSH と HTTPS を切り替える独自コマンド  #ref: ${GitHub}/MyPrivateCode/bash/gitssh/gitssh
                                gitssh スクリプト本体:  #ref: ${GitHub}/MyPrivateCode/bash/gitssh/gitssh
                                gitssh スクリプトを使う場合: |  #focus: set-url
                                    cd  ~/_tmp
                                    git clone https://github.com/Takakiriy/first
                                    cd first
                                    git remote get-url origin
                                        #// https://github.com/Takakiriy/first

                                    gitssh  #// set-url
                                        #// git@github.com:Takakiriy/first.git
                                        #// If you enter password 1 time, input command "eval `ssh-agent` && ssh-add".
                                    gitssh  #// set-url
                                        #// https://github.com/Takakiriy/first
                                スクリプトを使わない場合: |  #focus: set-url
                                    cd  ~/_tmp
                                    git clone https://github.com/Takakiriy/first
                                    cd first
                                    git remote get-url origin
                                        #// https://github.com/Takakiriy/first

                                    git remote set-url origin git@github.com:Takakiriy/first.git
                                    git remote get-url origin
                                        #// git@github.com:Takakiriy/first.git
                                    git remote set-url origin https://github.com/Takakiriy/first
                                    git remote get-url origin
                                        #// https://github.com/Takakiriy/first
                        （設定）: #settings:
                            __Domain__: github.com
                            __User__: Takakiriy
                            __Accout__: Takakiriy
                            __Repository__: typrm
                    対象のサーバーに接続するときに使う SSH キーを設定します:
                        SSH キーを作っていなければ作ります:  #search: ssh-keygen
                        SSH キーをリポジトリに登録していなければ登録します:
                            GitHub:  #search: GitHub SSH key
                            GitLab:  #search: GitLab publickey
                        （パスワードの入力を不要にする場合） ~/.ssh/config ファイルに下記を追加します:
                            サンプル: |
                                Host github.com
                                    User my-name
                                    IdentityFile ~/.ssh/id_rsa
                            書式: |
                                Host __URL_DomainPart__
                                    User __AccountName__
                                    IdentityFile __SSH_SecretKeyFilePath__
                    git push を試します:
                        上記 ~/.ssh/config ファイルの設定をしていない場合:  #// 未確認
                            git コマンドで秘密鍵を使うように設定します >> 現在のプロセスが終わるまで有効:
                                #search: ssh-agent
                        ダミーのタグを作ります:  #search: git tag
                        ダミーのタグを削除します:
                    参考: #ref: https://yoshiyoshifujii.hatenablog.com/entry/2014/08/12/230144
                SSH 秘密鍵を指定する場合:
                    GIT_SSH_COMMAND="ssh -i __PrivateKeyPath__"  git push
                    #search: git clone trouble
                アクセス トークン を使う場合:
                    git push https://__AccessToken__@__RepositoryURL__.git
                自分だけが編集したブランチを強制プッシュする場合:  #// --force-with-lease
                    git push --force-with-lease
                        #search: git rebase remote branch
                rebase するか警告されたとき: #keyword: git pull rebase warning
                    // git config pull.rebase true  #// 警告されないようにします。git pull で rebase するように設定します
            git rebase: #keyword:  #// リベースした後で push するときは git push --force-with-lease
                ブランチのベースを移動します:  #keyword: git rebase branch
                    コミットを１つでも git push した後の場合: #keyword: git rebase remote branch  #// リベース前がリポジトリにある場合
                        新しい方法:  #// --force-with-lease を使います。develop ブランチから feature ブランチが枝分かれしている場合
                            編集するブランチに移動します:
                                -   git checkout  feature  #template: git checkout  __FeatureBranch__
                            （不安なら）編集前をロックします:
                                -   git branch  feature-lock  #template: git branch  __FeatureBranch__-lock
                            リベースします:
                                -   git rebase origin/develop  #template: origin/__BaseBranch__
                                    #// コンフリクトしたファイルは VSCode の Source Control ビュー >> Merge Changes に一覧されます
                                    #// --committer-date-is-author-date オプションを指定すれば、更新日時（コミッター日時）を作成日時（作成者日時）にしますが、gitlog を使うのであれば不要です
                                    #search: Git 作成日 更新日
                            （コンフリクトが発生して解決した場合のみ）:
                                -   git rebase --continue
                                #// 複数回実行する場合もあります
                                #// 戻すときは git rebase --abort
                                #// コンフリクトが多いときは、コミットをまとめます
                            結果を確認します:
                                -   gitlog
                                -   git diff  feature-lock  --name-only  #// feature-lock を作ったときのみ
                                #// など
                            プッシュします:
                                -   git push --force-with-lease
                            （問題なければ）編集前のロックを解除:
                                -   git branch -D  feature-lock  #template: git branch -D  __FeatureBranch__-lock
                        古い方法:
                            注意:
                                以下の操作は feature ブランチを自分だけが編集するときだけに限定してください。
                                それ以外の場合、マージしましょう。 （追記）新しい方法があります  #search: git rebase remote branch
                            実験:  #// 実際に入力するコマンドは、下記（コマンド）の部分です
                                ローカルにリポジトリ（サーバー）を作ります:
                                    #search: Git local repository
                                前提条件を作ります: |
                                    #// ベースのコミットを作ります
                                    -   echo 1 > 1.txt
                                        git add "."
                                        git commit -m commit_1
                                        git push
                                    #// develop ブランチを作ります
                                    -   git checkout -b develop
                                        git push --set-upstream origin develop
                                    #// feature ブランチを作ります
                                    -   git checkout -b feature
                                        echo 2 > 2.txt
                                        git add "."
                                        git commit -m "feature)) commit_2"
                                    -   echo 3 > 3.txt
                                        git add "."
                                        git commit -m "feature)) commit_3"
                                        git push --set-upstream origin feature
                                    #// develop ブランチにコミットを追加します
                                    -   git checkout develop
                                    -   echo D2 > D2.txt
                                        git add "."
                                        git commit -m "develop)) commit_D2"
                                    -   echo D3 > D3.txt
                                        git add "."
                                        git commit -m "develop)) commit_D3"
                                        git push
                                    #// feature ブランチに戻ります
                                    -   git checkout feature
                                gitlog (0): |  #focus: feature, develop
                                    * 5555555  (origin/develop, develop) develop)) commit_D3 user1 2022-02-22 11:27:51 +0900
                                    * 4444444  develop)) commit_D2 user1 2022-02-22 11:27:47 +0900
                                    | * 3333333  (HEAD -> feature, origin/feature) feature)) commit_3 user1 2022-02-22 11:26:51 +0900
                                    | * 2222222  feature)) commit_2 user1 2022-02-22 11:26:39 +0900
                                    |/
                                    * 1111111  (origin/master, master) commit_1 user1 2022-02-22 11:26:20 +0900
                                （メモ）: ここで git pull develop すると、マージしてしまいます
                                rebase します:  #//（コマンド） #search: git rebase local branch
                                    -   git checkout feature  #// feature ブランチが、
                                    -   git rebase develop    #// develop から枝分かれした地点を移動します
                                        #template-at(-2): __FeatureBranch__
                                        #template-at(-2): __BaseBranch__
                                gitlog (1): |  #focus: feature, develop
                                    * 3333999  (HEAD -> feature) feature)) feature)) commit_3 user1 2022-02-22 11:26:51 +0900
                                    * 2222999  feature)) commit_2 user1 2022-02-22 11:26:39 +0900
                                    * 5555555  (origin/develop, develop) develop)) commit_D3 user1 2022-02-22 11:27:51 +0900
                                    * 4444444  develop)) commit_D2 user1 2022-02-22 11:27:47 +0900
                                    | * 3333333  (origin/feature) feature)) commit_3 user1 2022-02-22 11:26:51 +0900
                                    | * 2222222  feature)) commit_2 user1 2022-02-22 11:26:39 +0900
                                    |/
                                    * 1111111  (origin/master, master) commit_1 user1 2022-02-22 11:26:20 +0900
                                push します:  #//（コマンド）既存のブランチを改名して、新しいブランチを同じ名前で作ります
                                    #// 以下の操作は feature ブランチを自分だけが編集するときだけに限定してください
                                    -   git status   #// clean 状態であること
                                    -   git checkout -b  old_feature  origin/feature
                                        git push --set-upstream origin  old_feature
                                        git checkout  feature
                                    -   git push origin --delete  feature
                                        git push
                                        #template-at(-5): old___FeatureBranch__  origin/__FeatureBranch__
                                        #template-at(-5): old___FeatureBranch__
                                        #template-at(-5): __FeatureBranch__
                                        #template-at(-5): __FeatureBranch__
                                gitlog (2): |  #focus: old_feature,  feature,  develop  #// コミットID が変わります。 2222222⇒2222999, 3333333⇒3333999
                                    * 3333999  (HEAD -> feature, origin/feature) feature)) commit_3 user1 2022-02-22 11:26:51 +0900
                                    * 2222999  feature)) commit_2 user1 2022-02-22 11:26:39 +0900
                                    * 5555555  (origin/develop, develop) develop)) commit_D3 user1 2022-02-22 11:27:51 +0900
                                    * 4444444  develop)) commit_D2 user1 2022-02-22 11:27:47 +0900
                                    | * 3333333  (origin/old_feature, old_feature) feature)) commit_3 user1 2022-02-22 11:26:51 +0900
                                    | * 2222222  feature)) commit_2 user1 2022-02-22 11:26:39 +0900
                                    |/
                                    * 1111111  (origin/master, master) commit_1 user1 2022-02-22 11:26:20 +0900
                                古いブランチを削除します:  #//（コマンド）  #focus: old_feature
                                    -   git branch -D  old_feature
                                        git push origin --delete  old_feature
                                        #template-at(-2): old___FeatureBranch__
                                        #template-at(-2): old___FeatureBranch__
                                gitlog (3): |  #focus: feature, develop
                                    * 3333999  (HEAD -> feature, origin/feature) feature)) commit_3 user1 2022-02-22 11:26:51 +0900
                                    * 2222999  feature)) commit_2 user1 2022-02-22 11:26:39 +0900
                                    * 5555555  (origin/develop, develop) develop)) commit_D3 user1 2022-02-22 11:27:51 +0900
                                    * 4444444  develop)) commit_D2 user1 2022-02-22 11:27:47 +0900
                                    * 1111111  (origin/master, master) commit_1 user1 2022-02-22 11:26:20 +0900
                        設定:  #settings:
                            __FeatureBranch__: feature
                            __BaseBranch__: develop
                    コミットを１つも git push していない場合: #keyword: git rebase local branch
                        概要:
                            - git pull すると自動的に git rebase の処理が行われます。なので git rebase コマンドを意識するケースは少ないでしょう。
                            - 自分のブランチの根本にあったブランチにコミットが追加されたとき、そのコミットをマージして（取り込んで）
                                自分のブランチの根本を更新します
                            - （近い⇒）自分がコミットする前に、他の人による新しいコミットがあるときに、先に git pull で取り込んでからコミットします
                            - （間違い⇒）指定したコミットを、ブランチを変えて作り直したり、ひとまとめにしたりして、ログを綺麗にするコマンド
                                https://www.sejuku.net/blog/71919
                        公式: #ref: https://git-scm.com/book/ja/v2/Git-のブランチ機能-リベース
                            #// 矢印の向きが逆なことに注意
                        概念図: #ref: ${my_images}/2021/git-rebase4.png
                        サンプル:  #// 実際に入力するコマンドは、下記（コマンド）の部分です
                            作業フォルダーを作り、移動します:
                                cd  try_git_rebase
                            自分がブランチを作って編集したとします:
                                編集した結果: |  #focus: feature, master
                                    * 3333333  (HEAD -> feature) ours3
                                    * 2222222  ours2
                                    * 1111111  (master) theirs1
                                編集するコマンド:
                                    ベースのコミット:
                                        -   git init
                                        -   echo ours1 > file.txt
                                            echo ours2 >> file.txt
                                            echo ours3 >> file.txt
                                            echo theirs1 >> file.txt
                                            echo theirs2 >> file.txt
                                            echo theirs3 >> file.txt
                                            git add .
                                        -   git commit -m "theirs1"
                                    feature ブランチを作る:
                                        -   git checkout -b feature
                                    feature / 2つ目と 3つ目のコミット:
                                        -   _c="$(sed "s/ours2/ours2_changed/g"  file.txt)";  echo "$_c" > file.txt
                                            git add .
                                            git commit -m "ours2"
                                            _c="$(sed "s/ours3/ours3_changed/g"  file.txt)";  echo "$_c" > file.txt
                                            git add .
                                            git commit -m "ours3"
                            結果 gitlog (1): |  #focus: feature, master
                                    * 3333333  (HEAD -> feature) ours3
                                    * 2222222  ours2
                                    * 1111111  (master) theirs1
                            ベースとしたブランチに更新がありました:
                                git checkout master
                                _c="$(sed "s/theirs2/theirs2_changed/g"  file.txt)";  echo "$_c" > file.txt
                                git add .
                                git commit -m "theirs2"
                            結果 gitlog (2): |  #focus: master
                                    * 4444444  (HEAD -> master) theirs2
                                    | * 3333333  (feature) ours3
                                    | * 2222222  ours2
                                    |/
                                    * 1111111  theirs1
                            rebase（マージ）する前のファイルの内容 file.txt:
                                file.txt >> 3333333 ours3:  #// git checkout feature
                                    ours1
                                    ours2_changed
                                    ours3_changed
                                    theirs1
                                    theirs2
                                    theirs3
                                file.txt >> 4444444 theirs2:  #// git checkout master
                                    ours1
                                    ours2
                                    ours3
                                    theirs1
                                    theirs2_changed
                                    theirs3
                            rebase します:  #//（コマンド）
                                - git checkout feature  #// 自分のブランチに
                                - git rebase master     #// ベースのブランチを取り込みます
                            結果 gitlog (3):
                                イメージ: |  #focus: feature, 4444444
                                    | * 333BBBB  (HEAD -> feature) ours3
                                    | * 222BBBB  ours2
                                    |/
                                    * 4444444  (master) theirs2
                                    * 1111111  theirs1
                                実際の表示: |
                                    * 333BBBB  (HEAD -> feature) ours3
                                    * 222BBBB  ours2
                                    * 4444444  (master) theirs2
                                    * 1111111  theirs1
                            rebase（マージ）した後のファイルの内容:  #// ファイルの内容が変わりました
                                file.txt >> 333BBBB ours3:  #focus: theirs2_changed  #// theirs2_changed が変わりました
                                    ours1
                                    ours2_changed
                                    ours3_changed
                                    theirs1
                                    theirs2_changed
                                    theirs3
                                file.txt >> 4444444 theirs2:  #// 変化なし
                                    ours1
                                    ours2
                                    ours3
                                    theirs1
                                    theirs2_changed
                                    theirs3
                            git status は変わりません:  #// git pull と同じです
                                git status  #// working tree clean
                                #// なぜなら自分の前回のコミットが 3333333 ⇒ 333BBBB に変わったからです
                            今後編集すると再びブランチごとに分かれます:  #focus: 5555555
                                feature / ours4 のコミット:
                                    git checkout feature
                                    _c="$(sed "s/ours1/ours1_changed/g"  file.txt)";  echo "$_c" > file.txt
                                    git add .
                                    git commit -m "ours4"
                                master / theirs3 のコミット:
                                    git checkout master
                                    _c="$(sed "s/theirs3/theirs3_changed/g"  file.txt)";  echo "$_c" > file.txt
                                    git add .
                                    git commit -m "theirs3"
                            結果 gitlog (4): |
                                * 5555555  (HEAD -> master) theirs3
                                | * 444BBBB  (feature) ours4
                                | * 333BBBB  ours3
                                | * 222BBBB  ours2
                                |/
                                * 4444444  theirs2
                                * 1111111  theirs1
                            注意:
                                rebase は git pull すると自動的に行われます。
                                なので git rebase コマンドを意識するケースは少ないでしょう。
                        キャンセル:  #// git rebase する前に戻します
                            #search: git reset --hard
                    コンフリクトが発生した場合: #keyword: git rebase conflict  #// git rebase __BranchName__ を実行したらコンフリクトが発生した場合
                        手順:  #ref: https://docs.github.com/en/get-started/using-git/resolving-merge-conflicts-after-a-git-rebase
                            コンフリクトを解消する場合:  #keyword: git rebase --continue
                                基本:  #// コンフリクトが発生したファイルについてコンフリクトを解消する編集をします
                                    git add/rm _____
                                    git rebase --continue
                                エディターを開かないようにする: |  #// --no-edit 相当  #keyword: git rebase --no-edit  #ref: https://stackoverflow.com/questions/43489971/how-to-suppress-the-editor-for-git-rebase-continue
                                    git add/rm _____
                                    GIT_EDITOR=:  git rebase --continue
                            リベース前の状態に戻す場合:  #keyword: git rebase --abort
                                git rebase --abort
                            コンフリクトを解消した後でリベース前の状態に戻す場合:  #keyword: git rebase cancel
                                git reflog コマンドと git reset --hard "HEAD@{____}" コマンドでキャンセルできます
                                    git reflog
                                    git reset --hard "HEAD@{3}"   #// rebase (start) の１つ下
                                #search: git cancel
                            代わりに cherry-pick を使う場合:  #search: git cherry-pick range
                        サンプル: |  #focus: feature-1,  2222222,  __CurrentBranch__,  --continue
                            $ git rebase "feature-1"
                                Auto-merging 0.txt
                                CONFLICT (content): Merge conflict in 0.txt
                                error: could not apply d05667c... B1
                                    hint: Resolve all conflicts manually, mark them as resolved with
                                    hint: "git add/rm <conflicted_files>", then run "git rebase --continue".
                                    hint: You can instead skip this commit: run "git rebase --skip".
                                    hint: To abort and get back to the state before "git rebase", run "git rebase --abort".
                                Could not apply d05667c... B1
                            $ git status
                                rebase in progress; onto 2222222
                                You are currently rebasing branch '__CurrentBranch__' on '2222222'.
                                (fix conflicts and then run "git rebase --continue")
                                (use "git rebase --skip" to skip this patch)
                                (use "git rebase --abort" to check out the original branch)

                                Unmerged paths:
                                (use "git restore --staged <file>..." to unstage)
                                (use "git add <file>..." to mark resolution)
                                        both modified:   a

                                no changes added to commit (use "git add" and/or "git commit -a")
                            $ gitlog
                                * 2222222  (HEAD, feature-1)
                                | * 3333333  (__CurrentBranch__)
                                |/  
                                * 1111111
                            $ vi a
                            $ git add a
                            $ git rebase --continue
                                [detached HEAD b0c3bee] B1
                                2 files changed, 2 insertions(+), 1 deletion(-)
                                create mode 100644 _err_out.log
                                Successfully rebased and updated refs/heads/feature-1-local-B.
                        関連:  #search: git conflict
                    git cherry-pick と git rebase: #keyword: Git rebase cherry-pick
                        git cherry-pick コマンドを使ってリベースする場合: #search: git cherry-pick range
                            - git rebase を使うときよりも、コンフリクトが少ない傾向があります
                            - 最終的に同じ内容ならいい場合、最後に git diff で違いが無ければ、個別のコンフリクトの解消は適当でいいです
                        途中に cherry-pick したコミットがある場合:
                            _: cherry-pick したコミットは、リベース先のブランチにあるコミットに統合されます。コミットが減ります
                            実行時のメッセージ: |
                                $ git rebase __TargetBranch__
                                    warning: skipped previously applied commit __CommitHashA__
                                    warning: skipped previously applied commit __CommitHashB__
                                    warning: skipped previously applied commit __CommitHashC__
                                    hint: use --reapply-cherry-picks to include skipped commits
                                    hint: Disable this message with "git config advice.skippedCherryPicks false"
                                    Successfully rebased and updated refs/heads/__CurrentBranch__.
                    no-ff マージを含むブランチをリベースする場合: #keyword: Git rebase no-ff
                        状況:  #// develop ブランチを release ブランチに対してリベースする場合
                            リベース前: |  #focus: develop, release
                                *   4444444  (release) fix
                                | * 3333333  (develop) Merge branch 'feature' into develop
                                |/| 
                                | * 2222222  feature branch commit
                                |/  
                                *   1111111  old release
                            リベース後: |
                                *   3330000  (develop) Merge branch 'feature' into develop
                                |\ 
                                | * 2220000  feature branch commit
                                |/  
                                *   4444444  (release) fix
                                *   1111111  old release
                        手順:
                            リベースします: |
                                git checkout develop
                                git rebase -i --rebase-merges  release    #// エディターが開きます  #// Git 2.18以降
                                    label onto             #// リベース前のリベース対象(release)のコミットを、以降では onto で表す、という定義

                                    # Branch feature
                                    reset onto             #// HEAD を onto(release) の位置に移動します
                                    pick 2222222 feature branch commit    #// 2222222 を cherry-pick します
                                    label feature          #// 現在位置（cherry-pick後の位置）のコミットを、以降では feature で表す、という定義

                                    # Branch develop  
                                    reset onto             #// HEAD を onto(release) の位置に移動します
                                    merge -C 3333333 feature # Merge branch 'feature' into develop    #// feature → develop へマージします
                                #// 基本的には編集しなくて OK。 保存・終了します
                            リベース前にあったブランチやタグを更新します: |
                                git branch -D  __Branch__  #// delete branch
                                git checkout -b  __Branch__  __CommitID__  #// new branch
                    古いブランチほうにあるブランチの直後にリベースする場合: #keyword: Git rebase --onto
                        git rebase --onto __NextBaseBranch__  __CurrentBaseBranch__  __FeatureBranch__
                        #// __FeatureBranch__ のベースを __CurrentBaseBranch__ から __NextBaseBranch__ に移動します
                    関連:
                        コミット列をコピーする場合:
                            途中にマージしてできたコミットがあるとき:  #// 自分のブランチ（リベースするブランチ）の途中にあるとき
                                #search: git rebase contains merged commit
                コミットをまとめます:  #keyword: git rebase commit,  git rebase -i
                    概要:
                        - 自分のブランチの最新コミットからいくつかのコミットをまとめます
                    関連 >> コミットをまとめる他の方法:  #search: Git commit squash
                    注意:
                        途中にマージがあるとうまくいかないようです
                    コマンド:
                        開始します:
                            git checkout __WIP_Branch__
                            git rebase -i __PreviousTag__
                                #// __WIP_Branch__ は、まとめるコミットを含む WIP ブランチ
                                #// __PreviousTag__ は編集対象の範囲の１つ前のコミットまたはそれに付けたタグ。__PreviousTag__ のコミットは変わりません
                                #// できるコミットのタイムスタンプはまとめた中で最も古いコミット日時です（良くない）
                                #search: git rebase commit example
                        全部まとめる場合:  #// 最も古いコミット以外のすべてのコミットの pick を squash に書き換えます
                            エディターが開くので、処理内容を編集します:  #focus: squash
                                編集前:  #// 上が古い❗
                                    pick 2222222 WIP 2
                                    pick 3333333 WIP 3
                                    pick 4444444 WIP 4
                                編集後:  #// まとめる範囲の最も古い（上の）コミット以外のコミットをすべて squash に変えます
                                    pick 2222222 WIP 2
                                    squash 3333333 WIP 3
                                    squash 4444444 WIP 4
                                #// squash のスペルは、開いたファイルのコメントに書いてあります
                            再びエディターが開くので、コミット メッセージ を編集します:
                                編集前: |
                                    WIP 2
                                    WIP 3
                                    WIP 4
                                編集後: |  #// WIP 2, WIP 3, WIP 4 をまとめた新しい コミット メッセージ は commit_2
                                    commit_2
                            実行した結果の gitlog : |  #focus: __Branch__  #// ローカルの __Branch__ ブランチのコミットはまとめられます
                                * (HEAD -> __Branch__) commit_2
                                | * (origin/__Branch__) WIP 4
                                | * WIP 3
                                | * WIP 2
                                |/
                                * (tag: __PreviousTag__) commit_1
                                * (origin/master, master) master_1
                            git push します: #keyword: git rebase commit push
                                git diff "origin/__Branch__"
                                git push  --delete origin  "__Branch__"
                                git push  --set-upstream origin "__Branch__"
                        WIP 2, WIP 3 をまとめる場合:  #focus: squash  #// コミット メッセージ は自動的にエディターが開いたファイルに書きます
                            編集前:
                                pick 2222222 WIP 2
                                pick 3333333 WIP 3
                                pick 4444444 WIP 4
                            編集後:
                                pick 2222222 WIP 2
                                squash 3333333 WIP 3
                                pick 4444444 WIP 4
                            再びエディターが開くので、コミット メッセージ を編集します:
                                編集前: |
                                    WIP 2
                                    WIP 3
                                編集後: |  #// WIP 2, WIP 3 をまとめた新しい コミット メッセージ は commit_2。 WIP 4 の コミット メッセージ は変えられません
                                    commit_2
                            実行した結果の gitlog : |
                                * (HEAD -> __Branch__) WIP 4
                                * commit_2
                                | * (origin/__Branch__) WIP 4
                                | * WIP 3
                                | * WIP 2
                                |/
                                * (tag: __PreviousTag__) commit_1
                                * (origin/master, master) master_1
                        WIP 3, WIP 4 をまとめる場合:  #focus: squash
                            編集前:
                                pick 2222222 WIP 2
                                pick 3333333 WIP 3
                                pick 4444444 WIP 4
                            編集後:
                                pick 2222222 WIP 2
                                pick 3333333 WIP 3
                                squash 4444444 WIP 4
                            再びエディターが開くので、コミット メッセージ を編集します:
                                編集前: |
                                    WIP 3
                                    WIP 4
                                編集後: |  #// WIP 3, WIP 4 をまとめた新しい コミット メッセージ は commit_3。 WIP 2 の コミット メッセージ は変えられません
                                    commit_3
                            実行した結果の gitlog : |
                                * (HEAD -> __Branch__) commit_2
                                | * (origin/__Branch__) WIP 4
                                | * WIP 3
                                |/
                                * WIP 2
                                * (tag: __PreviousTag__) commit_1
                                * (origin/master, master) master_1
                    サンプル:
                        準備:
                            （mac の場合）# をコメントにします:
                                setopt interactivecomments
                            リポジトリのフォルダーを作ります:
                                (Git bash): |
                                    cd        $HOME
                                    rm -rf    $HOME/try_git_rebase_commit/repository/try_git_rebase_commit.git
                                    mkdir -p  $HOME/try_git_rebase_commit/repository/try_git_rebase_commit.git    #template: __RepositoryName__/repository/__RepositoryName__.git
                                    cd        $HOME/try_git_rebase_commit/repository/try_git_rebase_commit.git    #template: __RepositoryName__/repository/__RepositoryName__.git
                                    git init --bare --shared=true
                            自分がブランチを作ったとします:
                                編集した結果: |  #focus: feature, main, commit_1
                                    * (HEAD -> feature, origin/feature) WIP 4
                                    * WIP 3
                                    * WIP 2
                                    * (tag: commit_1) commit_1
                                    * (origin/main, main) main_1
                                編集するコマンド: |  #// Git bash
                                    #// ベースのコミット:
                                        mkdir -p  $HOME/try_git_rebase_commit/work    #template: __RepositoryName__/work
                                        cd        $HOME/try_git_rebase_commit/work    #template: __RepositoryName__/work
                                        rm -rf  try_git_rebase_commit                         #template: __RepositoryName__
                                        git clone file://$HOME/try_git_rebase_commit/repository/try_git_rebase_commit.git   #template: __RepositoryName__/repository/__RepositoryName__.git
                                        cd  $HOME/try_git_rebase_commit/work/try_git_rebase_commit   #template: __RepositoryName__/work/__RepositoryName__
                                        git checkout -b  main
                                        echo "
                                            Line1
                                            commit_1
                                            Line2
                                            WIP 2
                                            Line3
                                            WIP 3
                                            Line4
                                            WIP 4
                                            Line5
                                            "  |  sed 's/^ *//' > file.txt
                                        git add "."
                                        git config --local user.email "yourname@example.com"    #search: Git username example
                                        git config --local user.name  "Your Name"
                                        git commit -m "main_1"
                                        git push --set-upstream origin "main"
                                    #// feature ブランチを作ります
                                        git checkout -b "feature"
                                    #// 1つ目～ 4つ目のコミット
                                        sed -i -E "s/commit_1/commit_1_changed/g"  file.txt
                                        git add .
                                        git commit -m "commit_1"
                                        git tag -a  "commit_1"  -m ""
                                        sed -i -E "s/WIP 2/WIP 2_changed/g"  file.txt
                                        git add .
                                        git commit -m "WIP 2"
                                        sed -i -E "s/WIP 3/WIP 3_changed/g"  file.txt
                                        git add .
                                        git commit -m "WIP 3"
                                        sed -i -E "s/WIP 4/WIP 4_changed/g"  file.txt
                                        git add .
                                        git commit -m "WIP 4"
                                        git push --set-upstream origin "feature"
                            バックアップとリストア:
                                リポジトリ:
                                    .git フォルダーをバックアップします: |  #search: git backup example
                                        cd  $HOME/try_git_rebase_commit/repository
                                        tar cvzf  "try_git_rebase_commit.git.tar.gz"  "try_git_rebase_commit.git"
                                    .git フォルダーをリストアします: |
                                        cd  $HOME/try_git_rebase_commit/repository
                                        rm -rf  try_git_rebase_commit.git
                                        tar xvf "try_git_rebase_commit.git.tar.gz"
                                ワーク:
                                    .git フォルダーをバックアップします: |  #search: git backup example
                                        #// 圧縮します:
                                            cd  $HOME/try_git_rebase_commit/work/try_git_rebase_commit
                                            tar cvzf  "try_git_rebase_commit.git.tar.gz"  ".git"
                                        #// .git.tar.gz をバックアップの置き場所に移動します:
                                            mv  "try_git_rebase_commit.git.tar.gz" ".."
                                    .git フォルダーをリストアします: |
                                        #// バックアップのファイルをコピーします:
                                            cd  $HOME/try_git_rebase_commit/work/try_git_rebase_commit
                                            cp  "../try_git_rebase_commit.git.tar.gz" "./.git.tar.gz"
                                        #// リストアします: #copy: restore .git commands
                                            mv ".git" ".git_bk"
                                            tar xvf ".git.tar.gz"
                                            git checkout "."
                                            rm -rf ".git_bk"
                                            rm ".git.tar.gz"
                                            git status
                                            gitlog
                        コミットをまとめます:  #keyword: git rebase commit example  #// WIP 2 ～ WIP 4 を commit_2 にまとめます
                            （commit_1 タグが無い場合）commit_1 タグを作ります:  #// commit_1 は、まとめた後にできるコミットの1つ前のコミット。WIP の前のコミット
                                - git tag  #// タグを一覧します
                                - git tag -a  "commit_1"  -m "__Comment__"  "__Commit_1_ID__"  #// __Commit_1_ID__ は置き換えてください
                            コマンド:
                                git rebase -i  "commit_1"
                                    #// -i オプションがあると、処理内容の編集ができるようになります
                            エディターが開くので、処理内容を編集します:
                                最も古いコミット以外のすべてのコミットの pick を squash に書き換えます:
                                    #focus: pick, squash  #// # から始まる行はコメントです。処理に影響しません
                                    編集前:
                                        pick 2222222 WIP 2
                                        pick 3333333 WIP 3
                                        pick 4444444 WIP 4
                                    編集後:
                                        pick 2222222 WIP 2
                                        squash 3333333 WIP 3
                                        squash 4444444 WIP 4
                                    （補足）:
                                        以下のような fixup（コメントを採用しない）は最も古いコミットに指定できません:
                                            fixup 2222222 WIP 2     エラー
                                            fixup 3333333 WIP 3
                                            pick  4444444 WIP 4
                                エディターを閉じます:
                                    Esc, Esc, Z, Z
                            再びエディターが開くので、コミット メッセージ を編集します:
                                新しく作られるコミットのメッセージに編集します:
                                    #// 複数のコミットができるときは、複数回開きます。１つずつ保存と終了をしてください
                                    #focus: commit_2
                                    #// コミット メッセージ の 1行目は gitlog（1行1コミットの一覧）にも表示されます
                                    編集前: |  #// # から始まる行はコメントです。処理に影響しません
                                        # This is a combination of 3 commits.
                                        # This is the 1st commit message:

                                        WIP 2

                                        # This is the commit message #2:

                                        WIP 3

                                        # This is the commit message #3:

                                        WIP 4
                                    編集後: |  #// コミット メッセージ は commit_2
                                        # This is a combination of 3 commits.
                                        commit_2
                                エディターを閉じます:
                            実行した結果の gitlog : |  #focus: feature  #// ローカルの feature ブランチのコミットはまとめられます
                                * (HEAD -> feature) commit_2
                                | * (origin/feature) WIP 4
                                | * WIP 3
                                | * WIP 2
                                |/
                                * (tag: commit_1) commit_1
                                * (origin/main, main) main_1
                            （キャンセルする場合）: |  #// reflog はキャンセルされず追加になりますが、reflog はローカルにのみ存在し、リポジトリには記録されません
                                $ git reflog    #search: git reflog
                                    4444000 (HEAD -> feature) HEAD@{0}: rebase (finish): returning to refs/heads/feature
                                    4444000 (HEAD -> feature) HEAD@{1}: rebase (squash): commit_2
                                    3333333 HEAD@{2}: rebase (squash): # This is a combination of 2 commits.
                                    2222222 HEAD@{3}: rebase (start): checkout commit_1
                                    4444444 (origin/feature) HEAD@{4}: commit: WIP 4
                                $ git reset --hard "HEAD@{4}"
                                    HEAD is now at 4444444 WIP 4
                                $ gitlog
                                    * (HEAD -> feature, origin/feature) WIP 4
                                    * WIP 3
                                    * WIP 2
                                    * (tag: commit_1) commit_1
                                    * (origin/main, main) main_1
                            （commit_1 タグが不要な場合）タグを削除します:
                                git tag -d  "commit_1"
                        git push します: #keyword: git rebase commit push
                            サーバーと内容が変わっていないことを確認します:
                                git diff "origin/feature"  #// feature ブランチの場合
                            サーバーのブランチを削除します:
                                git push  --delete origin  "feature"  #// feature ブランチの場合
                            アップロードします:
                                git push  --set-upstream origin "feature"  #// feature ブランチの場合
                        コミットをまとめた結果の gitlog : |  #focus: feature
                            * (HEAD -> feature, origin/feature) commit_2
                            * commit_1
                            * (origin/main, main) main_1
                過去の コミット メッセージ を変えます: #keyword: git rebase reword  #search: git rebase -i
                    git rebase -i __PreviousCommitID__
                    pick を reword または r に置き換えます。編集するものすべて。
                    メッセージを編集します。
                    保存終了したら次のコミットのメッセージを編集します
                rerere, 同様のコンフリクトの解消を自動化します:  #keyword: git rerere  #// REuse REcorded REsolution
                    自動的に解消します:
                        有効化します:  #// デフォルトは無効です。一度有効化したら false に戻さないらしい
                            -   git config --local  rerere.enabled  true  #search: git config
                            -   git config --local  rerere.autoupdate  true  # 自動的にaddまで実行。オフにしても diff 表示されない（編集したファイル名だけ分かる）
                        git rebase します:
                            同様のコンフリクトを解消する編集を自動的に行います
                            正しい編集結果について  #search: git rebase reference merge
                    編集内容の削除:  #// 自動的に解消するときに参考にする同様の編集内容の記録があります
                        特定の記録を削除:
                            git rerere forget __FileName__  #// ファイルパス？
                        すべての記録を削除:
                            rm -rf .git/rr-cache/
                    （参考）同様のコンフリクトが発生する原因:  #ref: ${typrm_files}/ref/Git-AI.yaml#label: git rebase rerere
                設定: #settings:
                    __RepositoryName__: try_git_rebase_commit
            git remote: #keyword: git remote
                git remote -v:  #// リポジトリのアドレスを表示します
                git remote add:  #// リポジトリとの関係を新規に作ります
                git remote set-url:  #// 別のリポジトリに関係を変えます
                git remote get-url:  #search:
                関連: #search: リモート追跡ブランチ
            git rev-parse:  #// コミットIDを表示します  #search: Git rev-parse commit ID
                注意: リモートを見るときは git fetch してから git rev-parse origin/__Branch__ してください 
            git reflog:  #keyword: git 操作履歴,  git reflog #// ローカルにのみ存在  #ref: https://stackoverflow.com/questions/16842529/is-there-a-way-in-git-to-push-the-reflog
                #search: git cancel
                git reflog コマンド:
                    git reflog --date=default
                出力例: |  #// 注意: git push の記録は残りません
                    commit ID (branch)    HEAD@{__Date__}: command
                    -------------------------------------------------------------------------------------------------------
                    7c738a5d1 (HEAD -> feature) HEAD@{Fri Jan 1 11:22:33 2022 +0900}: checkout: moving from feature to feature
                    7c738a5d1 (HEAD -> feature) HEAD@{Fri Jan 1 11:22:33 2022 +0900}: rebase (finish): returning to refs/heads/feature
                    7c738a5d1 (HEAD -> feature) HEAD@{Fri Jan 1 11:22:33 2022 +0900}: rebase (pick): Changed commit message
                    5eb484411 (develop) HEAD@{Fri Jan 1 11:22:33 2022 +0900}: rebase (start): checkout develop
                    10942daa1 (origin/feature) HEAD@{Fri Jan 1 11:22:33 2022 +0900}: checkout: moving from feature_2 to feature
                関連:
                    キャンセルします:  #search: git reset --hard
            git reset:
                パラメーターなし:
                    リポジトリ全体の git add をキャンセルします。ファイルの内容は変わりません
                パラメーターあり:
                    パラメーターの意味は git add と同じ
                soft: #keyword: git reset --soft  #// 現在のブランチの位置を変更します。インデックス、ワーキング フォルダー の内容は変えません
                    前回のコミットをキャンセルします:  #search: git commit cancel
                        プッシュする前: git reset --soft HEAD^
                            #// 具体的な手順は --hard を参照  #search: git reset --hard
                            #// コミットは無くなります。リモートのコミットは残ります
                            #// 2つキャンセルするには、HEAD~2 を指定します。HEAD^2 ではありません
                    内容を変えずに、現在のブランチを変更します:  #// ワーキング フォルダー の内容は変えません
                        #search: git symbolic-ref
                hard: #keyword: git reset --hard,  git cancel,  git undo  #// 現在のブランチの位置、インデックス、ワーキング フォルダー を変更します
                    手順:
                        キャンセルする内容を確認します:
                            git reflog --date=iso  #// --date オプションを付けると日時が表示されます
                        出力例 >>> --date=iso あり: |  #search: rebase (start)
                            commit ID (branch)    HEAD@{__Num__}: command
                            -------------------------------------------------------------------------------------------------------
                            7c738a5d1 (HEAD -> feature) HEAD@{2023-01-01 00:00:00 +0000}: checkout: moving from feature to feature
                            7c738a5d1 (HEAD -> feature) HEAD@{2023-01-01 00:00:00 +0000}: rebase (finish): returning to refs/heads/feature
                            7c738a5d1 (HEAD -> feature) HEAD@{2023-01-01 00:00:00 +0000}: rebase (pick): Changed commit message
                            5eb484411 (develop) HEAD@{2023-01-01 00:00:00 +0000}: rebase (start): checkout develop
                            10942daa1 (origin/feature) HEAD@{2023-01-01 00:00:00 +0000}: checkout: moving from feature_2 to feature
                        出力例 >>> --date=iso なし: |
                            commit ID (branch)    HEAD@{__Num__}: command
                            -------------------------------------------------------------------------------------------------------
                            7c738a5d1 (HEAD -> feature) HEAD@{0}: checkout: moving from feature to feature
                            7c738a5d1 (HEAD -> feature) HEAD@{1}: rebase (finish): returning to refs/heads/feature
                            7c738a5d1 (HEAD -> feature) HEAD@{2}: rebase (pick): Changed commit message
                            5eb484411 (develop) HEAD@{3}: rebase (start): checkout develop
                            10942daa1 (origin/feature) HEAD@{4}: checkout: moving from feature_2 to feature
                        git reset コマンドを実行します:  #// HEAD@{____} に書かれたコマンドを実行した直後の状態に戻します
                            git reset --hard "HEAD@{4}"   #// 上から 4行分をキャンセルする場合
                                #// ワーキング フォルダー を維持する場合は --hard の代わりに --soft に置き換えます
                        git reset --hard を実行した後の reflog: |  #// ソース ファイル の内容は 4行分キャンセルしますが reglog は追加されます
                            commit ID (branch)    HEAD@{__Num__}: command
                            -------------------------------------------------------------------------------------------------------
                            10942daa1 (HEAD -> feature) HEAD@{0}: reset: moving to HEAD@{4}  #// {4} は reset 実行前の値。reset した対象はこの出力では {5}
                            7c738a5d1 HEAD@{1}: checkout: moving from feature to feature
                            7c738a5d1 HEAD@{2}: rebase (finish): returning to refs/heads/feature
                            7c738a5d1 HEAD@{3}: rebase (pick): Changed commit message
                            5eb484411 (develop) HEAD@{4}: rebase (start): checkout develop
                            10942daa1 (origin/feature) HEAD@{5}: checkout: moving from feature_2 to feature
                    関連:  #search: git reset --soft
                mixed: #keyword: git reset --mixed  #// 現在のブランチの位置、インデックス を変更します。ワーキング フォルダー の内容は変えません （--mixed はデフォルトです）
                    #search: git symbolic-ref
                関連:  #search: git reflog
            git revert:
                （関連）>> GitHub プルリクエストのリバート: #search: GitHub revert
                公式: #ref: https://git-scm.com/docs/git-revert
                概要:
                    マージを取り消した内容のコミットを新しく追加します。
                    過去にマージしたという記録(gitlog)は変わりません。
                コマンド:  #search: git revert example_1
                    書式: | #// 以下のいずれか
                        git revert __MergedCommitIdOrTag__  --mainline 1  --no-edit
                        git revert __MergedCommitIdOrTag__  --mainline 1  -m "Revert \"Merge branch '__SubBranch__' into __MainBranch__: merge\""
                    __MergedCommitID__: revert するマージをしたコミット。探すときは #search: GitHub list pull request merge
                手順, サンプル:
                    注意: リリース ブランチ を revert した後はデプロイも行うこと  #search: release branch
                    GitHub と連携する場合: #search: GitHub local revert
                    基本サンプル:  #// コミットとその前のコミットの差分を取り消します
                        状況を作ります:
                            作業フォルダーを作り、移動します:
                                cd  try_git_revert
                            develop ブランチにマージ1, マージ2 , マージ3 を作ります:
                                作った後の状態（目標）: |  #copy: try_git_revert_git_log_1
                                    *   0003333  (HEAD -> develop) Merge branch 'merge3' into develop: merge
                                    |\
                                    | * 3333333  (merge3) merge3
                                    |/
                                    *   0002222  Merge branch 'merge2' into develop: merge
                                    |\
                                    | * 2222222  (merge2) merge2
                                    |/
                                    *   0001111  Merge branch 'merge1' into develop: merge
                                    |\
                                    | * 1111111  (merge1) merge1
                                    |/
                                    * 0000000  (master) base
                                編集するコマンド: |
                                    #// develop
                                        rm -rf .git;  rm *
                                        git init
                                        echo Line1   >  file.txt
                                        echo merge1 before >> file.txt
                                        echo Line2   >> file.txt  #// これらの行が必要な理由はコンフリクトしないためです
                                        echo merge2 before >> file.txt
                                        echo Line3   >> file.txt
                                        echo merge3 before >> file.txt
                                        echo Line4   >> file.txt
                                        git add .
                                        git commit -m "base"
                                        git checkout -b "develop"
                                    #// merge1
                                        git checkout -b "merge1"
                                        _c="$(sed "s/merge1 before/merge1 after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                        git add .
                                        git commit -m "merge1"
                                        git checkout "develop"
                                        git merge  "merge1" --no-ff  --no-edit
                                    #// merge2
                                        git checkout -b "merge2"
                                        _c="$(sed "s/merge2 before/merge2 after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                        git add .
                                        git commit -m "merge2"
                                        git checkout "develop"
                                        git merge  "merge2" --no-ff --no-edit
                                        git tag -a  "merge2_tag"  -m ""
                                    #// merge3
                                        git checkout -b "merge3"
                                        _c="$(sed "s/merge3 before/merge3 after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                        git add .
                                        git commit -m "merge3"
                                        git checkout "develop"
                                        git merge  "merge3" --no-ff --no-edit
                            結果 gitlog (1):  #// revert する前の状態
                                gitlog: |  #copy: try_git_revert_git_log_1
                                    *   0003333  (HEAD -> develop) Merge branch 'merge3' into develop: merge
                                    |\
                                    | * 3333333  (merge3) merge3
                                    |/
                                    *   0002222  Merge branch 'merge2' into develop: merge
                                    |\
                                    | * 2222222  (merge2) merge2
                                    |/
                                    *   0001111  Merge branch 'merge1' into develop: merge
                                    |\
                                    | * 1111111  (merge1) merge1
                                    |/
                                    * 0000000  (master) base
                                ファイルの内容:  #focus: after  #// 後の revert で after2 が置き換わります
                                    コマンド: cat file.txt
                                    出力:
                                        Line1
                                        merge1 after
                                        Line2
                                        merge2 after
                                        Line3
                                        merge3 after
                                        Line4
                        マージ2 を revert します:  #keyword: git revert example_1
                            （参考）merge2_tag に予想される コミット メッセージ: #focus: Merge
                                git merge コマンドによる場合: |
                                    Merge branch 'merge2' into develop: merge
                                プルリクエスト(GitHub)による場合: |
                                    Merge pull request #__PullRequestID__ from __Owner__/__BranchName__
                            --mainline オプションに指定する親番号を調べます:  #// mainline = マージを受け入れた側
                                上記マージを行った場合、親番号は 1 になります:
                                （親番号を確認する場合）:
                                    コマンド: git show "merge2_tag"
                                    出力: |  #// 左から親番号 1, 2 のコミットID
                                        Merge: __Commit_0001111__  __Commit_2222222__
                            revert します:  #focus: merge2, develop  #// このサンプル以外では、下記の merge2, develop を変更して下さい
                                コマンド >> git merge コマンドだった場合:
                                    git revert merge2_tag  --mainline 1  --no-edit  #// merge2_tag の部分はマージのコミットIDでも可能
                                追加されるコミットのメッセージ: #focus: Revert
                                    書式:
                                        Revert "__MergeCommitMessage__"
                                    git merge コマンドでマージしたマージをリバートした場合: |
                                        Revert "Merge branch 'merge2' into develop: merge”
                                    プルリクエストからマージしたマージをリバートした場合: |
                                        Revert "Merge pull request #__PullRequestID__ from __Owner__/__BranchName__"
                        結果 gitlog (2):
                            gitlog: | #focus: Revert  #// revert された内容のコミットが新しく追加されます
                                *   1113333  (HEAD -> develop) Revert "Merge branch 'merge2' into develop: merge"
                                *   0003333  Merge branch 'merge3' into develop: merge
                                |\
                                | * 3333333  (merge3) merge3
                                |/
                                *   0002222  Merge branch 'merge2' into develop: merge
                                |\
                                | * 2222222  (merge2) merge2
                                |/
                                *   0001111  Merge branch 'merge1' into develop: merge
                                |\
                                | * 1111111  (merge1) merge1
                                |/
                                * 0000000  (master) base
                            ファイルの内容:  #focus: before  #// merge2 で変更された内容が元に戻ります
                                コマンド: cat file.txt
                                出力:
                                    Line1
                                    merge1 after
                                    Line2
                                    merge2 before
                                    Line3
                                    merge3 after
                                    Line4
                    コンフリクトした場合:
                        状況を作ります:
                            develop ブランチにマージ1, マージ2 , マージ3 を作ります:
                                編集するコマンド: |
                                    #// develop
                                        rm -rf .git;  rm *
                                        git init
                                        echo merge1 before >> file.txt
                                        echo merge2 before >> file.txt
                                        echo merge3 before >> file.txt
                                        git add .
                                        git commit -m "base"
                                        git checkout -b "develop"
                                    #// merge1
                                        git checkout -b "merge1"
                                        _c="$(sed "s/merge1 before/merge1 after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                        git add .
                                        git commit -m "merge1"
                                        git checkout "develop"
                                        git merge  "merge1" --no-ff  --no-edit
                                        git tag -a  "merged1_tag"  -m ""
                                    #// merge2
                                        git checkout -b "merge2"
                                        _c="$(sed "s/merge2 before/merge2 after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                        git add .
                                        git commit -m "merge2"
                                        git tag -a  "merge2_tag"  -m ""
                                        git checkout "develop"
                                        git merge  "merge2" --no-ff --no-edit
                                        git tag -a  "merged2_tag"  -m ""
                                    #// merge3
                                        git checkout -b "merge3"
                                        _c="$(sed "s/merge3 before/merge3 after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                        git add .
                                        git commit -m "merge3"
                                        git checkout "develop"
                                        git merge  "merge3" --no-ff --no-edit
                                ファイルの内容:
                                    コマンド: cat file.txt
                                    出力:
                                        merge1 after
                                        merge2 after
                                        merge3 after
                            結果:
                                gitlog: |
                                    *   0003333  (HEAD -> develop) Merge branch 'merge3' into develop
                                    |\
                                    | * 3333333  (merge3) merge3
                                    |/
                                    *   0002222  (tag: merged2_tag) Merge branch 'merge2' into develop
                                    |\
                                    | * 2222222  (tag: merge2_tag, merge2) merge2
                                    |/
                                    *   0001111  (tag: merged1_tag) Merge branch 'merge1' into develop
                                    |\
                                    | * 1111111  (merge1) merge1
                                    |/
                                    * 0000000  (master) base
                        マージ2 を revert します:  #search: git revert example_1
                            コマンド: |  #focus: merge2, develop  #// このサンプル以外では、下記の merge2, develop を変更して下さい
                                git revert "merged2_tag"  --mainline 1  --no-edit
                            エラーメッセージ: |  #keyword: git revert conflict
                                Auto-merging file.txt
                                CONFLICT (content): Merge conflict in file.txt
                                error: could not revert d2a8d02... Merge branch 'merge2' into develop
                                hint: after resolving the conflicts, mark the corrected paths
                                hint: with 'git add <paths>' or 'git rm <paths>'
                                hint: and commit the result with 'git commit'                        
                        コンフリクトした内容を確認します:
                            コマンド: cat file.txt
                            出力: |
                                merge1 after
                                <<<<<<< HEAD
                                merge2 after
                                merge3 after
                                =======
                                merge2 before
                                merge3 before
                                >>>>>>> parent of 0002222 (Merge branch 'merge2' into develop)
                            出力内容:
                                HEAD: 最新コミット 0003333
                                parent of 0002222: 0001111。git revert の --mainline に指定したコミット
                        マージ2 のブランチで変更した内容を表示します:
                            コマンド: git diff "merged1_tag" "merge2_tag"  file.txt
                            出力: |  #focus: merge2
                                @@ -1,3 +1,3 @@
                                    merge1 after
                                -   merge2 before
                                +   merge2 after
                                    merge3 before
                        以上の情報を元に、revert のコンフリクトを解消します:
                            merge2 ブランチで変更する前の内容（parent of 0002222, diff の before）に戻します:
                            merge2 より後でマージしたすべてのブランチの内容（HEAD, merge3, ...）に変更します:
                            結果 >> このサンプルの場合: |  #focus: merge2, merge3
                                echo merge1 after   >  file.txt
                                echo merge2 before  >> file.txt
                                echo merge3 after   >> file.txt
                        変更内容を確認します:
                            コマンド: git diff file.txt
                            出力: |  #focus: merge2, merge3
                                @@@ -1,3 -1,3 +1,3 @@@
                                    merge1 after
                                -   merge2 after
                                +   merge2 before
                                -   merge3 before
                                +   merge3 after
                            出力内容:
                                diff で表示される変更前の内容:
                                    merge2_tag
                                diff で表示される変更後の内容:
                                    HEAD から merge2_tag を revert した内容
                                    merge2 ブランチで変更する前の内容と、merge2 より後でマージした後の内容
                        コミットします: |
                            git add "."
                            git commit --no-edit
                        結果 gitlog (2): | #focus: Revert  #// revert された内容のコミットが新しく追加されます
                                *   1113333  (HEAD -> develop) Revert "Merge branch 'merge2' into develop"
                                *   0003333  Merge branch 'merge3' into develop
                                |\
                                | * 3333333  (merge3) merge3
                                |/
                                *   0002222  (tag: merged2_tag) Merge branch 'merge2' into develop
                                |\
                                | * 2222222  (tag: merge2_tag, merge2) merge2
                                |/
                                *   0001111  (tag: merged1_tag) Merge branch 'merge1' into develop
                                |\
                                | * 1111111  (merge1) merge1
                                |/
                                * 0000000  (master) base
                        追加されたコミットのメッセージ: Revert "__MergeCommitMessage__"  #focus: Revert
                    GitHub のプルリクエストのマージを取り消す（revert する）場合: #search: GitHub revert
                    revert してから再度マージする場合: #keyword: Git revert re-merge
                        サンプル:
                            状況を作ります:  #keyword: try_git_remerge_1
                                作った後の状態（目標）:
                                    グラフ: |
                                        | ---o---M---x---R---x
                                        |       /
                                        | --A--B---------------C
                                    gitlog: |
                                        * 4c500b4  (HEAD -> feature) feature C
                                        | * cca6ecd  (develop) develop xRx
                                        | * 7bcbe93  Revert "Merge branch 'feature' into develop: merge"
                                        | * 70c83d4  develop x
                                        | *   2e3eb62  (tag: merged_tag) Merge branch 'feature' into develop: merge
                                        | |\
                                        | |/
                                        |/|
                                        * | f7ee61c  feature B
                                        * | 0775cab  feature A
                                        | * 173aa8e  develop o
                                        |/
                                        * 1dabd6d  base
                                作業フォルダーを作り、移動します:
                                    cd  try_git_revert
                                develop ブランチと feature ブランチを作り、マージします: |
                                    #// develop
                                        rm -rf .git;  rm *
                                        git init
                                        git checkout -b "develop"
                                        echo Line1   >  file.txt
                                        echo develop o before >> file.txt
                                        echo Line2   >> file.txt  #// この行が必要な理由はコンフリクトしないためです
                                        echo feature A before >> file.txt
                                        echo Line3   >> file.txt
                                        echo feature B before >> file.txt
                                        echo Line4   >> file.txt
                                        echo develop x before >> file.txt
                                        echo Line5   >> file.txt
                                        echo develop xRx before >> file.txt
                                        echo Line6   >> file.txt
                                        echo feature C before >> file.txt
                                        echo Line7   >> file.txt
                                        git add .
                                        git commit -m "base"
                                    #// feature
                                        git checkout -b "feature"
                                        _c="$(sed "s/feature A before/feature A after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                        git add .
                                        git commit -m "feature A"
                                        _c="$(sed "s/feature B before/feature B after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                        git add .
                                        git commit -m "feature B"
                                    #// develop
                                        git checkout "develop"
                                        _c="$(sed "s/develop o before/develop o after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                        git add .
                                        git commit -m "develop o"
                                    #// merge develop <= feature
                                        git merge  "feature" --no-edit
                                        git tag -a  "merged_tag"  -m ""
                                結果 >> file.txt : |  #focus: after
                                    Line1
                                    develop o after
                                    Line2
                                    feature A after
                                    Line3
                                    feature B after
                                    Line4
                                    develop x before
                                    Line5
                                    develop xRx before
                                    Line6
                                    feature C before
                                    Line7
                                コミットをいくつか追加していき、途中でリバートします: |
                                    #// develop にコミットを追加します
                                        git checkout "develop"
                                        _c="$(sed "s/develop x before/develop x after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                        git add .
                                        git commit -m "develop x"
                                    #// マージをリバートします  #search: git revert example_1
                                        git checkout "develop"
                                        git revert merged_tag  --mainline 1  --no-edit
                                        git tag -a  "revert_tag"  -m ""
                                    #// develop にコミットを追加します
                                        git checkout "develop"
                                        _c="$(sed "s/develop xRx before/develop xRx after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                        git add .
                                        git commit -m "develop xRx"
                                    #// feature にコミットを追加します
                                        git checkout "feature"
                                        _c="$(sed "s/feature C before/feature C after/g"  file.txt)";  echo "$_c" > file.txt;  unset _c
                                        git add .
                                        git commit -m "feature C"
                                結果:
                                    feature file.txt : |  #focus: after
                                        Line1
                                        develop o before
                                        Line2
                                        feature A after
                                        Line3
                                        feature B after
                                        Line4
                                        develop x before
                                        Line5
                                        develop xRx before
                                        Line6
                                        feature C after
                                        Line7
                                    develop file.txt : |  #focus: after
                                        Line1
                                        develop o after
                                        Line2
                                        feature A before
                                        Line3
                                        feature B before
                                        Line4
                                        develop x after
                                        Line5
                                        develop xRx after
                                        Line6
                                        feature C before
                                        Line7
                                .git フォルダーをバックアップします: | #keyword: git backup example,  .git back up
                                    #// 圧縮します:
                                        tar cvzf  "try_git_revert.git.tar.gz"  ".git"
                                    #// .git.tar.gz をバックアップの置き場所に移動します:
                                        mv  "try_git_revert.git.tar.gz" ".."
                            （参考）失敗するケース:  #// リバートしたコミットが再マージされない
                                #// 右記の続きです  #search: try_git_remerge_1
                                マージします: |  #// merge develop <= feature
                                    git checkout "develop"
                                    git merge  "feature" --no-edit
                                結果:
                                    グラフ: |
                                        | ---o---M---x---R---x---M2(Bad)
                                        |       /               /
                                        | --A--B---------------C
                                    file.txt : |  #focus: before  #// A, B が再マージされない
                                        Line1
                                        develop o after
                                        Line2
                                        feature A before
                                        Line3
                                        feature B before
                                        Line4
                                        develop x after
                                        Line5
                                        develop xRx after
                                        Line6
                                        feature C after
                                        Line7
                            成功するケース:
                                .git フォルダーをリストアします: |
                                    #// バックアップのファイルをコピーします:
                                        cd  try_git_revert
                                        cp "../try_git_revert.git.tar.gz" "./.git.tar.gz"
                                    #// リストアします: #copy: restore .git commands
                                        mv ".git" ".git_bk"
                                        tar xvf ".git.tar.gz"
                                        git checkout "."
                                        rm -rf ".git_bk"
                                        rm ".git.tar.gz"
                                        git status
                                        gitlog
                                #// 右記の続きです  #search: try_git_remerge_1
                                リバートをリバートします: |
                                    git checkout "develop"
                                    git revert "revert_tag" --no-edit
                                結果 of リバートのリバート:
                                    グラフ: |
                                        | ---o---M---x---R---x---r
                                        |       /
                                        | --A--B---------------C
                                    develop file.txt : |  #focus: feature  #// revert_tag でリバートした内容を再マージしたことになります
                                        Line1
                                        develop o after
                                        Line2
                                        feature A after
                                        Line3
                                        feature B after
                                        Line4
                                        develop x after
                                        Line5
                                        develop xRx after
                                        Line6
                                        feature C before
                                        Line7
                                    gitlog: |  #focus: Revert
                                        * dc88e09  (HEAD -> develop) Revert "Revert "Merge branch 'feature' into develop""
                                        * fa8ff55  develop xRx
                                        * 9b59e7c  (tag: revert_tag) Revert "Merge branch 'feature' into develop"
                                        * 766aa01  develop x
                                        *   3156404  (tag: merged_tag) Merge branch 'feature' into develop
                                        |\
                                        * | ba1d86e  develop o
                                        | | * 2984d79  (feature) feature C
                                        | |/
                                        | * cd1a6b7  feature B
                                        | * c602136  feature A
                                        |/
                                        * 9ad75f8  base
                                マージします: |  #// merge develop <= feature
                                    git checkout "develop"
                                    git merge  "feature" --no-edit
                                結果 of マージ:
                                    グラフ: |
                                        | ---o---M---x---R---x---r---M2(good)
                                        |       /                   /
                                        | --A--B-------------------C
                                    develop file.txt : |  #focus: after  #// マージ後に追加したコミットをマージします
                                        Line1
                                        develop o after
                                        Line2
                                        feature A after
                                        Line3
                                        feature B after
                                        Line4
                                        develop x after
                                        Line5
                                        develop xRx after
                                        Line6
                                        feature C after
                                        Line7
                                    gitlog: |  #focus: Merge
                                        *   d47ed1a  (HEAD -> develop) Merge branch 'feature' into develop
                                        |\
                                        | * 2984d79  (feature) feature C
                                        * | dc88e09  Revert "Revert "Merge branch 'feature' into develop""
                                        * | fa8ff55  develop xRx
                                        * | 9b59e7c  (tag: revert_tag) Revert "Merge branch 'feature' into develop"
                                        * | 766aa01  develop x
                                        * | 3156404  (tag: merged_tag) Merge branch 'feature' into develop
                                        |\| 
                                        | * cd1a6b7  feature B
                                        | * c602136  feature A
                                        * | ba1d86e  develop o
                                        |/
                                        * 9ad75f8  base
                        参考:
                            Stack overflow: #ref: https://stackoverflow.com/questions/1078146/re-doing-a-reverted-merge-in-git
                            公式 >> 解説: #ref: https://mirrors.edge.kernel.org/pub/software/scm/git/docs/howto/revert-a-faulty-merge.txt
                                状況: |
                                    How to revert a faulty merge
                                    誤ったマージを元に戻す方法
                                    ============================

                                    Alan <alan@clueserver.org> said:

                                        I have a master branch.  We have a branch off of that that some
                                        developers are doing work on.  They claim it is ready. We merge it
                                        into the master branch.  It breaks something so we revert the merge.
                                        They make changes to the code.  they get it to a point where they say
                                        it is ok and we merge again.
                                        マスターブランチがあります。 一部の開発者が取り組んでいるブランチがあります。 
                                        彼らはそれが準備ができていると主張します。 それをマスターブランチにマージします。 
                                        何かが壊れるので、マージをリバートします。 彼らはコードに変更を加えます。 
                                        彼らはそれが大丈夫だと彼らが言うところまでそれを手に入れ、そして我々は再びマージしたい。

                                        When examined, we find that code changes made before the revert are
                                        not in the master branch, but code changes after are in the master
                                        branch.
                                        調べてみると、リバート前に行われたコード変更はマスターブランチにはありませんが、
                                        後のコード変更はマスターブランチにあります。
                                        
                                    and asked for help recovering from this situation.
                                    この状況から回復する方法を教えてください。

                                    The history immediately after the "revert of the merge" would look like this:
                                    「マージのリバート」直後の履歴は次のようになります：

                                        | ---o---o---o---M---x---x---W
                                        |               /
                                        |       ---A---B

                                    where A and B are on the side development that was not so good, M is the
                                    merge that brings these premature changes into the mainline, x are changes
                                    unrelated to what the side branch did and already made on the mainline,
                                    and W is the "revert of the merge M" (doesn't W look M upside down?).
                                    IOW, `"diff W^..W"` is similar to `"diff -R M^..M"`.
                                    ここで、AとBはあまり良くなかったサイド開発であり、
                                    Mはこれらの時期尚早な変更をメインラインにもたらすマージであり、
                                    xはサイドブランチが行ったものとは無関係の変更であり、すでにメインラインで行われています。 
                                    マージMを元に戻します」（WはMを逆さまに見えませんか？）。
                                    言い換えれば "diff W^..W" は "diff -R M^..M" に似ています。

                                    Such a "revert" of a merge can be made with:
                                        $ git revert -m 1 M

                                    After the developers of the side branch fix their mistakes, the history
                                    may look like this:
                                    サイドブランチの開発者が間違いを修正した後、履歴は次のようになります。

                                        | ---o---o---o---M---x---x---W---x
                                        |               /
                                        |       ---A---B-------------------C---D

                                    where C and D are to fix what was broken in A and B, and you may already
                                    have some other changes on the mainline after W.
                                    ここで、CとDは、AとBで壊れていたものを修正するためのものであり、
                                    Wの後にメインラインで他の変更がすでに行われている可能性があります。

                                    If you merge the updated side branch (with D at its tip), none of the
                                    changes made in A or B will be in the result, because they were reverted
                                    by W.  That is what Alan saw.
                                    更新されたサイドブランチ（先端にDが付いている）をマージすると、
                                    Wによってリバートされたため、AまたはBで行われた変更は結果に反映されません。
                                    これがAlanが見たものです。
                                リバートのリバート: |
                                    Linus explains the situation:

                                        Reverting a regular commit just effectively undoes what that commit
                                        did, and is fairly straightforward. But reverting a merge commit also
                                        undoes the _data_ that the commit changed, but it does absolutely
                                        nothing to the effects on _history_ that the merge had.
                                        通常のコミットを元に戻すと、そのコミットが行ったことを効果的に元に戻すことができ、
                                        かなり簡単です。 ただし、マージコミットを元に戻すと、
                                        コミットが変更された_data_も元に戻されますが、
                                        マージが_history_に与えた影響にはまったく影響しません。

                                        So the merge will still exist, and it will still be seen as joining
                                        the two branches together, and future merges will see that merge as
                                        the last shared state - and the revert that reverted the merge brought
                                        in will not affect that at all.
                                        したがって、マージは引き続き存在し、2つのブランチを結合していると見なされ、
                                        将来のマージでは、そのマージが最後の共有状態と見なされます。
                                        また、マージをリバートした復帰は、それにまったく影響しません。

                                        So a "revert" undoes the data changes, but it's very much _not_ an
                                        "undo" in the sense that it doesn't undo the effects of a commit on
                                        the repository history.
                                        したがって、「リバート」はデータの変更を元に戻しますが、
                                        リポジトリ履歴に対するコミットの影響を元に戻さないという意味では、
                                        「アンドゥ」ではありません。

                                        So if you think of "revert" as "undo", then you're going to always
                                        miss this part of reverts. Yes, it undoes the data, but no, it doesn't
                                        undo history.
                                        したがって、「リバート」を「アンドゥ」と考えると、リバートの部分を常に見逃してしまいます。
                                        データを元に戻しますが、履歴を元に戻しません。

                                    In such a situation, you would want to first revert the previous revert,
                                    which would make the history look like this:
                                    このような状況では、最初のリバートを前のリバートにすることをお勧めします。
                                    これにより、履歴は次のようになります。

                                        | ---o---o---o---M---x---x---W---x---Y
                                        |               /
                                        |       ---A---B-------------------C---D

                                    where Y is the revert of W.  Such a "revert of the revert" can be done with:
                                    ここで、Y は W をリバートした結果です。このような「リバートのリバート」は次のようにすればできます。

                                        $ git revert W

                                    This history would (ignoring possible conflicts between what W and W..Y
                                    changed) be equivalent to not having W or Y at all in the history:
                                    この履歴は（WとW..Yが変更したものの間で発生する可能性のある競合に関しては無視して）、
                                    履歴にWまたはYがまったくないことと同等です。

                                        | ---o---o---o---M---x---x-------x----
                                        |               /
                                        |       ---A---B-------------------C---D

                                    and merging the side branch again will not have conflict arising from an
                                    earlier revert and revert of the revert.
                                    サイドブランチを再度マージしても、以前のリバートと、リバートのリバートから生じる競合は発生しません。

                                        | ---o---o---o---M---x---x-------x-------*
                                        |               /                       /
                                        |       ---A---B-------------------C---D

                                    Of course the changes made in C and D still can conflict with what was
                                    done by any of the x, but that is just a normal merge conflict.
                                    もちろん、CとDで行われた変更は、xのいずれかによって行われた変更と競合する可能性がありますが、
                                    これは通常のマージの競合です。
                                破棄して変更した場合: |
                                    On the other hand, if the developers of the side branch discarded their
                                    faulty A and B, and redone the changes on top of the updated mainline
                                    after the revert, the history would have looked like this:
                                    一方、サイドブランチの開発者が障害のあるAとBを破棄し、
                                    元に戻した後に更新されたメインラインに加えて変更をやり直した場合、
                                    履歴は次のようになります。

                                        | ---o---o---o---M---x---x---W---x---x
                                        |               /                 \
                                        |       ---A---B                   A'--B'--C'

                                    If you reverted the revert in such a case as in the previous example:
                                    前の例のような場合にリバートした場合：

                                        | ---o---o---o---M---x---x---W---x---x---Y---*
                                        |               /                 \         /
                                        |       ---A---B                   A'--B'--C'

                                    where Y is the revert of W, A' and B' are rerolled A and B, and there may
                                    also be a further fix-up C' on the side branch.  `"diff Y^..Y"` is similar
                                    to `"diff -R W^..W"` (which in turn means it is similar to `"diff M^..M"`),
                                    and `"diff A'^..C'"` by definition would be similar but different from that,
                                    because it is a rerolled series of the earlier change.  There will be a
                                    lot of overlapping changes that result in conflicts.  So do not do "revert
                                    of revert" blindly without thinking..
                                    ここで、Y は W のリバートであり、A' と B' は A と B にリロールされたものであり、
                                    サイドブランチにさらに修正 C 'がある場合もあります。 "diff Y^..Y" は
                                    "diff -R W^..W" に似ており（つまり、 "diff M^..M" に似ています）、
                                    "diff A'^..C'"` は、以前の変更のリロールされたシリーズであるため、定義上は似ていますが、
                                    それとは異なります。 多くの重複した変更が競合を発生させるでしょう。 ですから、
                                    考えずに盲目的に「リバートのリバート」をしないでください。

                                        | ---o---o---o---M---x---x---W---x---x
                                        |               /                 \
                                        |       ---A---B                   A'--B'--C'

                                    In the history with rebased side branch, W (and M) are behind the merge
                                    base of the updated branch and the tip of the mainline, and they should
                                    merge without the past faulty merge and its revert getting in the way.
                                    リベースされたサイドブランチの履歴では、W（およびM）は、
                                    更新されたブランチのマージベースとメインラインの先端の背後にあり、
                                    過去の誤ったマージとその復帰が邪魔になることなくマージする必要があります。

                                    To recap, these are two very different scenarios, and they want two very
                                    different resolution strategies:
                                    要約すると、これらは2つの非常に異なるシナリオであり、2つの非常に異なる解決戦略が必要です。

                                    -   If the faulty side branch was fixed by adding corrections on top, then
                                        doing a revert of the previous revert would be the right thing to do.
                                        障害のあるサイドブランチが上部に修正を追加することによって修正された場合、
                                        前のリバードをリバートすることは正しいことです。

                                    -   If the faulty side branch whose effects were discarded by an earlier
                                        revert of a merge was rebuilt from scratch (i.e. rebasing and fixing,
                                        as you seem to have interpreted), then re-merging the result without
                                        doing anything else fancy would be the right thing to do.
                                        (See the ADDENDUM below for how to rebuild a branch from scratch
                                        without changing its original branching-off point.)
                                        以前のマージの復帰によって影響が破棄された障害のあるサイドブランチが
                                        最初から再構築された場合（つまり、あなたが解釈したような、リベースと修正の場合）、
                                        他に何もせずに結果を再マージするのは正しいことです。
                                        （元の分岐点を変更せずに最初から分岐を再構築する方法については、
                                        以下の補遺を参照してください。）
                                多くのことをする単一のコミットのデメリット: |
                                    However, there are things to keep in mind when reverting a merge (and
                                    reverting such a revert).
                                    ただし、マージをリバートする（およびそのようなリバートをリバートする）場合は、
                                    注意が必要なことがあります。

                                    For example, think about what reverting a merge (and then reverting the
                                    revert) does to bisectability. Ignore the fact that the revert of a revert
                                    is undoing it - just think of it as a "single commit that does a lot".
                                    Because that is what it does.
                                    たとえば、マージをリバートする（およびそのようなリバートをリバートする）と
                                    二つの可能性があることを考えてみてください。リバートのリバートがアンドゥである
                                    という事実を無視してください。- それを「多くのことをする単一のコミット」と考えてください。
                                    それがそれをすることだからです。

                                    When you have a problem you are chasing down, and you hit a "revert this
                                    merge", what you're hitting is essentially a single commit that contains
                                    all the changes (but obviously in reverse) of all the commits that got
                                    merged. So it's debugging hell, because now you don't have lots of small
                                    changes that you can try to pinpoint which _part_ of it changes.
                                    追いかけている問題があり、「このマージをリバートする」にヒットした場合、
                                    ヒットしているのは基本的に、マージされたすべてのコミットのすべての変更（ただし明らかに戻すこと）
                                    を含む単一のコミットです。 つまり、デバッグの地獄です。これは、変更の_部分_
                                    を特定するための小さな変更があまりないためです。

                                    But does it all work? Sure it does. You can revert a merge, and from a
                                    purely technical angle, Git did it very naturally and had no real
                                    troubles. It just considered it a change from "state before merge" to
                                    "state after merge", and that was it. Nothing complicated, nothing odd,
                                    nothing really dangerous. Git will do it without even thinking about it.
                                    しかし、それはすべて機能しますか？ 確かにそうです。 マージを元に戻すことができます。
                                    純粋に技術的な観点から、Gitは非常に自然にマージを実行し、実際の問題は発生しませんでした。 
                                    「マージ前の状態」から「マージ後の状態」への変更と考えただけで、それだけでした。 
                                    複雑なことも、奇妙なことも、本当に危険なこともありません。 
                                    Gitはそれについて考えることさえせずにそれを行います。

                                    So from a technical angle, there's nothing wrong with reverting a merge,
                                    but from a workflow angle it's something that you generally should try to
                                    avoid.
                                    したがって、技術的な観点からは、マージを元に戻すことには何の問題もありませんが、
                                    ワークフローの観点からは、一般的に回避する必要があります。

                                    If at all possible, for example, if you find a problem that got merged
                                    into the main tree, rather than revert the merge, try _really_ hard to
                                    bisect the problem down into the branch you merged, and just fix it, or
                                    try to revert the individual commit that caused it.
                                    可能であれば、たとえば、メインツリーにマージされた問題を見つけた場合は、
                                    マージをリバートするのではなく、問題をマージしたブランチに二分して修正するか、
                                    それを引き起こした個々のコミットを元に戻してみてください。 

                                    Yes, it's more complex, and no, it's not always going to work (sometimes
                                    the answer is: "oops, I really shouldn't have merged it, because it wasn't
                                    ready yet, and I really need to undo _all_ of the merge"). So then you
                                    really should revert the merge, but when you want to re-do the merge, you
                                    now need to do it by reverting the revert.
                                    はい、それはもっと複雑です、そして、それは常にうまくいくとは限りません
                                    （その答えは時々次のようなものです：「おっと、それはまだ準備ができていなかったので、
                                    私は本当にそれをマージするべきではありませんでした、
                                    そして私は本当にすべてのマージを元に戻す必要があります）。
                                    したがって、実際にはマージを元に戻す必要がありますが、マージを再実行する場合は、
                                    元に戻すことによってマージを実行する必要があります。
                                ブランチ全体を再作成する: |
                                    ADDENDUM
                                    付録

                                    Sometimes you have to rewrite one of a topic branch's commits *and* you can't
                                    change the topic's branching-off point.  Consider the following situation:
                                    トピックブランチのコミットの1つを書き直さなければならない場合があります。*そして*
                                    トピックブランチをオフにするポイントを変更することはできません。 次の状況を考慮してください。

                                        | P---o---o---M---x---x---W---x
                                        |  \         /
                                        |   A---B---C

                                    where commit W reverted commit M because it turned out that commit B was wrong
                                    and needs to be rewritten, but you need the rewritten topic to still branch
                                    from commit P (perhaps P is a branching-off point for yet another branch, and
                                    you want be able to merge the topic into both branches).
                                    ここで、コミット W はコミット M を元に戻しました。これは、コミットBが間違っていて、
                                    書き直す必要があることが判明したためですが、コミット P から分岐するには、
                                    書き直されたトピックが必要です（おそらく、P はさらに別の分岐の分岐点であり、
                                    トピックを両方のブランチにマージできます）。

                                    The natural thing to do in this case is to checkout the A-B-C branch and use
                                    "rebase -i P" to change commit B.  However this does not rewrite commit A,
                                    because "rebase -i" by default fast-forwards over any initial commits selected
                                    with the "pick" command.  So you end up with this:
                                    この場合の自然な方法は、A-B-C ブランチをチェックアウトし、
                                    "rebase -i P" を使用してコミット B を変更することです。
                                    ただし、これはコミットAを書き換えません。なぜなら "rebase -i" はデフォルトで
                                    pick コマンドで選択した初期コミットを超えてファストフォワーディングされるためです。
                                    だからあなたは次のようにします：

                                        | P---o---o---M---x---x---W---x
                                        |  \         /
                                        |   A---B---C   <-- old branch
                                        |    \
                                        |     B'---C'   <-- naively rewritten branch

                                    To merge A-B'-C' into the mainline branch you would still have to first revert
                                    commit W in order to pick up the changes in A, but then it's likely that the
                                    changes in B' will conflict with the original B changes re-introduced by the
                                    reversion of W.
                                    A-B'-C' をメインラインブランチにマージするには、最初にコミットWをリバートして
                                    Aの変更を pick する必要がありますが、B'の変更が、Wのリバージョンによって再導入された
                                    B の変更と競合する可能性があります。

                                    However, you can avoid these problems if you recreate the entire branch,
                                    including commit A:
                                    ただし、コミットAを含むブランチ全体を再作成すると、これらの問題を回避できます。                                

                                        |   A'---B'---C'  <-- completely rewritten branch
                                        |  /
                                        | P---o---o---M---x---x---W---x
                                        |  \         /
                                        |   A---B---C

                                    You can merge A'-B'-C' into the mainline branch without worrying about first
                                    reverting W.  Mainline's history would look like this:
                                    最初に W をリバートすることを心配せずに、A'-B'-C' をメインラインブランチにマージできます。
                                    メインラインの履歴は次のようになります。

                                        |   A'---B'---C'------------------
                                        |  /                              \
                                        | P---o---o---M---x---x---W---x---M2
                                        |  \         /
                                        |   A---B---C

                                    But if you don't actually need to change commit A, then you need some way to
                                    recreate it as a new commit with the same changes in it.  The rebase command's
                                    --no-ff option provides a way to do this:
                                    ただし、実際にコミットAを変更する必要がない場合は、同じ変更を加えた新しいコミットとして
                                    再作成する方法が必要です。 rebase コマンドの --no-ff オプションは、これを行う方法を提供します。

                                        $ git rebase [-i] --no-ff P

                                    The --no-ff option creates a new branch A'-B'-C' with all-new commits (all the
                                    SHA IDs will be different) even if in the interactive case you only actually
                                    modify commit B.  You can then merge this new branch directly into the mainline
                                    branch and be sure you'll get all of the branch's changes.
                                    --no-ffオプションは、インタラクティブなケースで実際にコミット B を変更するだけの場合でも、
                                    まったく新しいコミットで新しいブランチ A'-B'-C' を作成します（すべてのSHA IDは異なります）。
                                    その後、マージできます。 この新しいブランチをメインラインブランチに直接接続し、
                                    ブランチのすべての変更を確実に取得できるようにします。

                                    You can also use --no-ff in cases where you just add extra commits to the topic
                                    to fix it up.  Let's revisit the situation discussed at the start of this howto:
                                    トピックにコミットを追加して修正する場合は、--no-ff を使用することもできます。
                                    このハウツーの冒頭で説明した状況をもう一度見てみましょう。

                                        | P---o---o---M---x---x---W---x
                                        |  \         /
                                        |   A---B---C----------------D---E   <-- fixed-up topic branch

                                    At this point, you can use --no-ff to recreate the topic branch:
                                    この時点で、--no-ff を使用してトピックブランチを再作成できます。

                                        $ git checkout E
                                        $ git rebase --no-ff P

                                    yielding

                                        |   A'---B'---C'------------D'---E'  <-- recreated topic branch
                                        |  /
                                        | P---o---o---M---x---x---W---x
                                        |  \         /
                                        |   A---B---C----------------D---E

                                    You can merge the recreated branch into the mainline without reverting commit W,
                                    and mainline's history will look like this:
                                    コミット W を元に戻さずに、再作成されたブランチをメインラインにマージできます。
                                    メインラインの履歴は次のようになります。

                                        |   A'---B'---C'------------D'---E'
                                        |  /                              \
                                        | P---o---o---M---x---x---W---x---M2
                                        |  \         /
                                        |   A---B---C
                -m, --mainline: #keyword: Git mainline
                    コマンド: git revert __CommitID__ --mainline __ParentNumber__
                    __ParentNumber__:
                        parent number, 親番号: １つ前のコミットを指す 1から始まる番号
                        main line: マージを受け入れた側
                    参考:
                        #ref: https://stackoverflow.com/questions/43395504/git-revert-a-merge-determine-which-parent-is-which-m-1-vs-m-2
                        #ref: https://git-scm.com/docs/git-revert#Documentation/git-revert.txt--mparent-number
                        #ref: https://blog.toshimaru.net/git-revert-mainline/
            git rm:
                git rm __File__: ワーキング フォルダー にあるファイルを削除し、リポジトリにあるファイルを削除するようにステージングします
                git rm --cache __File__: ワーキング フォルダー にあるファイルは削除せずに、リポジトリにあるファイルを削除するようにステージングします
            git show: #keyword:  #// 現在のコミットの情報と diff を表示します。git log -1 と git diff に相当します
                コマンド: git show __CommitID__
                出力内容: |  #// git log では diff の部分は表示されません  #keyword: git log output
                    $ git show __CommitID__
                    Author: __Author__ <__EMail__>
                    Date:   __Date__

                        __CommitMessage__

                    diff --git a/__RelativePath__ b/__RelativePath__
                    deleted file mode 100644
                    index 8d67a2d..0000000
                    --- a/__RelativePath__
                    +++ /dev/null
                    @@ -1,8 +0,0 @@
                    __Diff__
            git show-branch:  #// 分岐した後のコミット一覧
                関連 >> 相手のブランチに含まれないコミットの一覧:
                    #search: gitlog1 2022-08
                最近の受け入れマージから今までの両ブランチのコミット一覧:
                    書式: git show-branch  __BranchA__  __BranchB__
                    出力サンプル: |
                        $ git show-branch  bui-test  master
                        * [bui-test] bui: ported paintTest
                        ! [master] bui: paint save button
                        --
                        +  [master] bui: paint save button
                        +  [master^] bui: port paintTest
                        +  [master~2] bui: copied paintTest from mui
                        *   [bui-test] bui: ported paintTest
                        --  Merge branch 'master' of ssh://hoge.org/git/idst
                    記号の意味:
                        上の -- の上: ブランチの一覧
                        上の -- の下: コミットの一覧
                        最も下の --: 分岐が始まったコミット。
                            「分岐が始まったコミット」から「現在のブランチの最新コミット」の間のコミット（複数）は表示されません
                        (*): 現在のブランチ、現在のブランチのコミット
                        (!): 他のブランチ
                        (+): コミット
                        (-): マージ（最新のみ表示？）
            git status: #keyword: git status
                -s, --short オプション: #keyword: git status --short  #ref: https://git-scm.com/docs/git-status#_short_format
                    編集した場合:
                        $ git status --short
                        M example.txt
                    ファイル名の左の2文字:
                        "??": Unstaged   #// "??" は ?? と表示されることを表します
                        A_: Unstaged を add した状態   #// A_ は A と空白を表します
                        AM: Unstaged を add して再び編集した状態
                        _M: 編集した状態   #// _M は空白と M を表します
                        M_: 編集して git add した状態   #// M_ は M と空白を表します
                        MM: 編集して git add して再び編集した状態
                        _D: 削除した状態   #// _D は空白と D を表します
                        MD: 編集して git add して削除した状態
                        UU: unmerged both modified
                クリーン状態かどうかを判定する場合: #keyword: git status clean or dirty
                    基本:
                        local  clean="false"
                        if [ "$(git status --short)" == "" ]; then
                            clean="true"
                        fi
                        #ref: https://remarkablemark.org/blog/2017/10/12/check-git-dirty/
                        #注意: git diff の stdout では untracked (add する前の新規) の有無を判定できません
                    親フォルダーの状態を表示しない場合:
                        test-locommit#function  GitStatusCurrentFolder
                １つも git add していないか、すべて git add したか:
                    #search: AllFilesAreGitAdd
                    #search: CheckIfGitResetState
                modified のファイルをコピーする場合:  #search: CopyGitModifiedFiles
                大文字小文字を区別する場合:  #// Windows と mac の場合
                    手順:
                        - 大文字小文字を変えたファイルやフォルダーを ワーキング フォルダー の外へ移動
                        - git commit & push  #// 削除します
                        - 大文字小文字を変えたファイルやフォルダーを ワーキング フォルダー の中へ移動
                        - git commit & push  #// 大文字小文字を変えて復活させます
                    非推奨:
                        - git config --local  core.ignorecase  false
                        - これを設定したとき、rename ではなく new file になってしまいます
                        - それでも git commit & push しても、GitHub のリポジトリ内のファイル名の大文字小文字は変わりません
                まとめてチェックする場合:  #// 複数のフォルダーで git status を実行するスクリプト
                    #search: gitstatus
            git symbolic-ref:
                内容を変えずに、現在のブランチを変更します: |  #// ワーキング フォルダー の内容は変更しません
                    git symbolic-ref HEAD  refs/heads/__TargetBranch__  #// 現在のブランチを変えます。現在のブランチの位置や ワーキング フォルダー の内容は変えません
                    git reset --mixed  origin/__TargetBranch__  #// 現在のブランチの位置を変えます。ワーキング フォルダー の内容は変えません
                    git branch
                    git status
                    git add  "."
                    git commit  -m "____."
                    git push --set-upstream  origin  __TargetBranch__  #// --set-upstream が必要です
                #// 実行後に git push すると __TargetBranch__ に push します
            git --version:  #// バージョンを表示します
                関連:
                    リリース日: #ref: https://mirrors.edge.kernel.org/pub/software/scm/git/
        git-sim: #ref: https://gigazine.net/news/20230204-git-sim/
            情報量としては gitlog とほぼ同じ。少し少ない
        #↓独自コマンド
        gitlog コマンド（独自）:  #keyword: gitlog
            関連:  #// GitHub, VSCode, git log コマンド
                GitHub >> Network graph:  #search: GitHub Network graph
                VSCode:  #search: VSCode commit graph
                git log コマンド:  #search: git log
            内容: ツリー表示（ネットワーク グラフ表示）とリモート表示ができる git log です
            コード:
                bash:
                    インストール スクリプト:
                        最新 Git の場合: |
                            mkdir -p ~/bin
                            echo '#!/bin/bash' > ~/bin/gitlog
                            echo 'git fetch -p  ||  read  -p "Press Enter key to continue ..."  dummyVariable' >> ~/bin/gitlog
                            echo 'git fetch --tags --force' >> ~/bin/gitlog
                            echo '' >> ~/bin/gitlog
                            echo 'TZ="Asia/Tokyo"  git log --oneline --decorate --graph --branches --tags --remotes --pretty=format:"%C(auto)%h %d %s %C(cyan)%an %C(green)%ad" --date=iso-local  "$@"' >> ~/bin/gitlog
                            echo '    #// --date-order: コミット単位で日付順のソートを行います' >> ~/bin/gitlog
                            chmod +x ~/bin/gitlog
                            gitlog
                        Git 1.8.3.1 の場合:
                            mkdir -p ~/bin
                            echo "git fetch -p" > ~/bin/gitlog
                            echo "git log --oneline --decorate --graph --branches --tags --remotes --pretty=format:\"%C(auto)%h %d %s %C(cyan)%an %C(green)%ad\"" >> ~/bin/gitlog
                            chmod +x ~/bin/gitlog
                            gitlog
                    参考 >> git log のオプション:  #search: git log options
                PowerShell:
                    インストール スクリプト:
                        ${script} = "${HOME}\AppData\Local\Microsoft\WindowsApps\gitlog.ps1"
                        echo "git fetch" > ${script}
                        echo "git log --oneline --decorate --graph --branches --tags --remotes --pretty=format:`"%C(auto)%h %d %s %C(cyan)%an %C(green)%ad`" --date=iso-local" >> ${script}
                    （Windows 全体の設定）スクリプトを実行できるようにします:
                        Set-ExecutionPolicy  RemoteSigned  -Scope CurrentUser
                PATH を通します:  #keyword: home/bin PATH
                    bash の場合:
                        すでに通っています
                    zsh の場合:  #// mac の場合
                        - cat ~/.zshrc | grep $HOME/bin
                        - 上記コマンドを実行して何も表示されなかったら:
                            - echo 'export PATH="$HOME/bin:$PATH"' >> ~/.zshrc
                            - source ~/.zshrc
        gitlogc コマンド（独自）:  #keyword: gitlogc
            内容: gitlog コマンドに、コミッターとコミット日時を追加して表示します
            インストール スクリプト: |
                mkdir -p ~/bin
                echo '#!/bin/bash' > ~/bin/gitlogc
                echo 'git fetch -p  ||  read  -p "Press Enter key to continue ..."  dummyVariable' >> ~/bin/gitlogc
                echo '' > ~/bin/gitlogc
                echo 'TZ="Asia/Tokyo"  git log --oneline --decorate --graph --branches --tags --remotes --pretty=format:"%C(auto)%h %d %s %C(cyan)%an %C(green)%ad %C(red)commiter:%C(blue)%cn %C(blue)%cd)" --date=iso-local  "$@"' >> ~/bin/gitlogc
                echo '    #// --date-order: コミット単位で日付順のソートを行います' >> ~/bin/gitlogc
                chmod +x ~/bin/gitlogc
        gitlog1 コマンド（独自）:  #keyword: gitlog1
            概要: 現在のブランチに分岐してからのログをコンパクトに表示する git log です
            関連:
                VSCode でも同様の内容を見ることができます  #search: VSCode source control ahead
            出力例: |
                develop branch
                2022-08-01 11:22:33 +0900 1111111  (origin/develop, origin/HEAD, develop) Merge pull request
                2022-08-01 11:22:33 +0900 2222222  Merge pull request
                branched from commit: 4444444444
                HEAD -> feature branch
                2022-08-01 11:22:33 +0900 5555555  (HEAD -> feature, origin/feature) Added
                2022-08-01 11:22:33 +0900 6666666  Updated
            code ~/bin/gitlog1: |  #keyword: gitlog1 2022-08  #// chmod +x ~/bin/gitlog1 すること
                #// gitlog1:
                #//     gitlog1
                #//     gitlog1 all  #// all commits
                baseBranch=develop
                currentBranch=$( git rev-parse --abbrev-ref HEAD )

                git fetch -p
                if [ "${currentBranch}" != "${baseBranch}"  -a  "$1" != "all" ]; then
                    commonCommitID=$( diff -u <(git rev-list --first-parent ${currentBranch})  <(git rev-list --first-parent ${baseBranch}) | sed -ne 's/^ //p' | head -1 )
                        #// https://stackoverflow.com/questions/1527234/finding-a-branch-point-with-git

                    echo "${baseBranch} branch"
                    git log --first-parent --oneline --pretty=format:"%ad %C(blue)%h%C(auto) %d %s %C(cyan)%an" --date=iso-local  ${currentBranch}..${baseBranch}
                    echo "branched from commit: ${commonCommitID}"
                    echo "HEAD -> ${currentBranch} branch"
                    git log --first-parent --oneline --pretty=format:"%ad %C(blue)%h%C(auto) %d %s %C(cyan)%an" --date=iso-local  ${baseBranch}..
                        #// マージした瞬間のコミットも含みます
                else
                    git log --oneline --pretty=format:"%ad %C(blue)%h%C(auto) %d %s %C(cyan)%an" --date=iso-local
                fi
            参考:
                diff -u <(git rev-list --first-parent HEAD)  <(git rev-list --first-parent develop) | sed -ne 's/^ //p' | head -1 :
                    #ref: https://stackoverflow.com/questions/1527234/finding-a-branch-point-with-git
                git rev-parse --abbrev-ref HEAD :
                    現在のブランチを表示します:  #keyword: show Git current branch
                        bashlib:
                            #search: GetCurrentGitBranch
                            #search: ChangeGitBranch
                    #ref: https://stackoverflow.com/questions/6245570/how-do-i-get-the-current-branch-name-in-git
            PATH を通します:
                #search: home/bin PATH
            （注意）以下は、他のブランチのコミットも含みます:  #keyword: gitlog1 old
                bash:
                    インストール スクリプト:
                        mkdir -p ~/bin
                        echo "git fetch" > ~/bin/gitlog1_bad
                        echo 'git log --oneline --pretty=format:"%ad %C(blue)%h%C(auto) %d %s %C(cyan)%an" --date=iso-local' >> ~/bin/gitlog1_bad
                        chmod +x ~/bin/gitlog1_bad
                PowerSnell:
                    インストール スクリプト:
                        ${script} = "${HOME}\AppData\Local\Microsoft\WindowsApps\gitlog1_bad.ps1"
                        echo "git fetch" > ${script}
                        echo "git log --oneline --pretty=format:`"%ad %C(blue)%h%C(auto) %d %s %C(cyan)%an`" --date=iso-local" >> ${script}
                    （Windows 全体の設定）スクリプトを実行できるようにします:
                        Set-ExecutionPolicy  RemoteSigned  -Scope CurrentUser
        gitdiff1 コマンド（独自）:  #keyword: gitdiff1 
            概要: 現在のブランチに分岐してからの diff を表示する git diff です
            ~/bin/gitdiff1: |  #// chmod +x ~/bin/gitdiff1 すること
                baseBranch=develop
                currentBranch=$( git rev-parse --abbrev-ref HEAD )

                git fetch
                commonCommitID=$( diff -u <(git rev-list --first-parent ${currentBranch})  <(git rev-list --first-parent ${baseBranch}) | sed -ne 's/^ //p' | head -1 )
                    #// https://stackoverflow.com/questions/1527234/finding-a-branch-point-with-git

                git diff  "${commonCommitID}"  HEAD  "$@"
            参考:
                -first-parent:
                    #ref: https://qiita.com/kure/items/c096b352d8babfd585f6
                    #erf: https://stackoverflow.com/questions/4649356/how-do-i-run-git-log-to-see-changes-only-for-a-specific-branch
            ボツ:
                #// git log --no-merges -p --pretty=format:"%ad %C(blue)%h%C(auto) %d %s %C(cyan)%an" --date=iso-local  ${baseBranch}.. | grep ^\+\+\+ | cut -c 7- 
                    #// マージした部分は含みません
                    #// コミットごとに分かれてしまう
                #// git log --name-only -m --no-merges --pretty=format:"%ad %C(blue)%h%C(auto) %d %s %C(cyan)%an" --date=iso-local  ${baseBranch}..
                    #// コミットごとに分かれてしまう
        gitlog2 コマンド（独自）:  #keyword: gitlog2
            内容: 現在のブランチともう１つのブランチのログをツリー表示する git log です
            （注意）以下は、他のブランチのコミットも含みます:
                スクリプトの実行:
                    gitlog2  __Branch1__  __Branch2__
                bash:
                    インストール スクリプト:
                        mkdir -p ~/bin
                        echo "git fetch" > ~/bin/gitlog2
                        echo "git log --oneline --decorate --graph --tags --remotes --pretty=format:\"%C(auto)%h %d %s %C(cyan)%an %C(green)%ad\" --date=iso-local  \$*" >> ~/bin/gitlog2
                        chmod +x ~/bin/gitlog2
                    直接実行:
                        git log --oneline --decorate --graph --tags --remotes --pretty=format:"%C(auto)%h %d %s %C(cyan)%an %C(green)%ad" --date=iso-local  __Branch1__  __Branch2__
                PowerSnell:
                    インストール スクリプト:
                        ${script} = "${HOME}\AppData\Local\Microsoft\WindowsApps\gitlog2.ps1"
                        echo "git fetch" > ${script}
                        echo "git log --oneline --decorate --graph --tags --remotes --pretty=format:`"%C(auto)%h %d %s %C(cyan)%an %C(green)%ad`" --date=iso-local  `$Args" >> ${script}
                    （Windows 全体の設定）スクリプトを実行できるようにします:
                        Set-ExecutionPolicy  RemoteSigned  -Scope CurrentUser
                PATH を通します:
                    #search: home/bin PATH
        gitstatus コマンド（独自）:  #keyword: gitstatus  #// 事前に設定した複数のフォルダーに対して git status を実行します
            概要:
                - ローカルにある全リポジトリに git status を実行します
                - ローカルにある設定をリポジトリにコピーします（git status を実行する前に）
                - 一定期間以上バックアップされていないファイルを一覧します（git status を実行する前に、-mtime オプション）
                - リポジトリに入れてはいけない NG ワード をチェックします  #search: CheckNGWord
            関連するファイル: #keyword: gitstatus related files  #ref: ~/bin/gitstatus
                gitstatus.ps1: |  #ref: ~/bin/gitstatus.ps1
                    & "C:\Program Files\Git\bin\bash" $HOME/bin/gitstatus
                gitpull:  #ref: ~/bin/gitpull
                gitpull.ps1: |  #ref: ~/bin/gitpull.ps1
                    & "C:\Program Files\Git\bin\bash" $HOME/bin/gitpull
            ~/bin/gitstatus のサンプル: |
                #!/bin/bash

                function  Main() {
                    BackUp
                    GitStatusAndNGWord
                }

                function  BackUp() {
                    cp  "${HOME}/bin/typrm"  "${GitHub}/MyPrivateCode/settings/M1-mac"
                    find  "${GitHub}/MyPrivateCode/settings/company/desktop"  -type f  -mtime +30  |  xargs -r ls -l --time-style=full-iso
                }

                function  GitStatusAndNGWord() {
                    #// git status and check NG word.
                    local  checkingPath="${GitHub}/typrm"
                    cd  "${checkingPath}"
                    git status --short  |  sed -E "s|^|$( GetCurrentFolder ): |"
                    CheckNGWord

                    local  checkingPath="${GitHub}/locommit"
                    cd  "${checkingPath}"
                    git status --short  |  sed -E "s|^|$( GetCurrentFolder ): |"
                    CheckNGWord

                    ...
                }

                function  GetCurrentFolder() {  #// for compatible to PowerShell
                    echo  "${PWD}"  |  sed -E "s|${HOME}|\${HOME}|"
                }

                Main
            CheckNGWord: |  #keyword:
                function  CheckNGWord() {

                    local  patternOfNGWord='__Product__|__Company__'

                    #// 差分だけ調べる場合
                    git diff  |  grep -iE  "${patternOfNGWord}"  |  sed -E "s|^|${PWD}:🟥NG_word: |"

                    #// 全部調べる場合
                    # grep -rniEI \
                    #     --exclude-dir "node_modules"  --exclude-dir "build"  --exclude-dir ".git"  --exclude-dir ".vagrant" \
                    #     --exclude=\*.{svg,pdf}  --exclude "package-lock.json"  --exclude "yarn.lock" \
                    #     "${patternOfNGWord}"  "C:${PWD:2}"
                }
            設定のバックアップを作成します: #keyword: back up by gitstatus  #ref: ${GitHub}/MyPrivateCode/settings/
                gitstatus コマンドを実行すると各種端末の設定ファイルをバックアップします。
                MyPrivateCode をコミットできるように、コミット前に実行するであろう gitstatus でバックアップしています。
        gitpull コマンド（独自）:  #keyword: gitpull  #// 事前に設定した複数のフォルダーに対して git pull を実行します
            ~/bin/gitpull のサンプル: |
                #!/bin/bash
                errorCount=0

                cd  "${GitHub}/typrm"
                pwd
                git pull  ||  errorCount=$(( ${errorCount} + 1 ))

                cd  "${GitHub}/locommit"
                pwd
                git pull  ||  errorCount=$(( ${errorCount} + 1 ))

                ...

                echo  ""
                echo  "errorCount = ${errorCount}"
            場所:
                実行する本体: ~/bin/gitpull
                バックアップ:  #search: back up by gitstatus
            関連するファイル:  #search: gitstatus related files
        locommit コマンド:  #keyword: locommit,  旧 new-commit  #ref: ${GitHub}/locommit/bin/locommit  #ref: https://github.com/Takakiriy/locommit/
            概要:
                Git の ワーキング ディレクトリ（.git フォルダーがあるフォルダー）の外でも
                Git の ワーキング ディレクトリ のサブフォルダーでも使える
                git status や git diff に相当するコマンドです。
                特定のフォルダーの中だけで、差分管理ができるようになります。
                #ref: https://github.com/Takakiriy/locommit/blob/stable/README-jp.md
                #ref: ${GitHub}/locommit/README-jp.md
            手順:
                開始時:
                    ローカルでコミットします:  #// .commit フォルダーを作ります  #ref: ${GitHub}/locommit/README-jp.md### locommit コマンド
                        locommit
                        #search: Git .commit
                    新しいリポジトリを作ります:  #ref: ${GitHub}/locommit/README-jp.md## init-bare-push コマンド
                        locommit init-bare-push
                locommit を使わない場合:
                    差分を出力する場合:
                        git diff  > ~/_git_patch.diff  #search: git apply
                    .gitignore されるファイル以外をコピーする場合:
                        #search: git checkout-index
                        #search: .gitignore copy
                WinMerge の locommit 対応: #keyword: WinMerge locommit
                    概要: フォルダーの比較は .gitignore を除いた __Project__/.commit と __Project__/.commit_new で行い、
                        ファイルを編集するときは __Project__/.commit と __Project__ を比較して行います
                    手順:
                        （まだ作ってないとき）比較対象を __Project__/.commit に作ります:
                            cd  "__OtherProject__"
                            locommit  #// パラメーターなし
                        __Project__/.commit_new を更新します:
                            cd  "__Project__"
                            locommit  #// パラメーターなし
                        フォルダー比較します:
                            WinMerge で __Project__/.commit と __Project__/.commit_new を比較します
                        ファイルを編集するとき:
                            （ファイルを右クリック）>> 左側シェルメニュー >> WinMerge >>
                            （1番目のパスをコピー）>>
                            （2番目に張り付けて、.commit/ を削除）>>
                            比較 ボタン
                        すべて編集が完了したら:
                            locommit push __OutputPath__
                                または
                            locommit push  /dev/null
                関連 >> _base:  #search: project with base
            コマンド:  #glossary:
                locommit:  #ref: https://github.com/Takakiriy/locommit/blob/stable/README-jp.md#locommit-コマンド
                    .commit フォルダーが無い場合:
                    .commit フォルダーがすでに有る場合:
                    --no-git オプション:
                locommit clone:  #ref: https://github.com/Takakiriy/locommit/blob/stable/README-jp.md#clone-コマンド
                locommit pull:   #ref: https://github.com/Takakiriy/locommit/blob/stable/README-jp.md#pull-コマンド
                locommit push:   #ref: https://github.com/Takakiriy/locommit/blob/stable/README-jp.md#push-コマンド
            ファイル:
                .commit フォルダー:  #// コミットしたフォルダーと同じ内容のフォルダー。読み取り専用ファイルに設定されます
                .commit_new フォルダー:  #// 最新と同じ内容をコピーしたフォルダー。読み取り専用ファイルに設定されます
                .gitignore:  #ref: ${GitHub}/locommit/.gitignore  #// locommit で使うフォルダーを除外する推奨設定
                    最低限:
                        .commit
                        .commit_*
                    サンプル:
                        .commit
                        .commit_*
                        _base
                        _base.yaml
                        .DS_Store
            コード:
                ローカル:  #ref: ${GitHub}/locommit/bin/locommit
                公開:  #ref: ${GitHub}/locommit  #ref: https://github.com/Takakiriy/locommit
                開発:
                    #ref: ${GitHub}/locommit    #// develop ブランチ
                    #ref: ${steps}/working/locommit    #// 追加機能
        codediff コマンド（独自）:  #keyword: codediff  #ref: ${GitHub}/codediff/codediff
            #ref: https://github.com/Takakiriy/codediff
            内容: 2つのフォルダーの差分を git diff として見えるようにフォルダーを新しく作り、Visual Studio Code で開きます
                Git のリポジトリから git clone して git diff として見えるフォルダーを作ることもできます。
            インストール:
                本体:  #ref: https://github.com/Takakiriy/codediff/blob/main/codediff
                    #ref: ${GitHub}/codediff/codediff
                サンプル:
                    git clone  https://github.com/Takakiriy/codediff  ~/GitHub/codediff/codediff
                    ln -sf  ~/GitHub/codediff/codediff  ~/bin/codediff
            コマンド:
                - codediff  path/to/old/folder  path/to/new/folder
                - codediff  https://URL1#branch1  https://URL2#branch2
                - codediff  /c/Users/____/_base.yaml
                - wsl codediff  /c/Users/____/_base.yaml
            ファイル:
                codediff タグ: #keyword: codediff tag  #// #codediff:  #ref: https://github.com/Takakiriy/codediff/blob/main/README-jp.md
                    言語ごとのテンプレート:  #search: diff _base example
                    codediff タグ を含むファイル:
                        目的: codediff の設定を含んだ 1つのファイルを指定するだけで、差分が表示できるようになります。
                        書き方: |
                            codediff タグ（#codediff:）を書きます。
                            そのタグの次の行のインデントより浅くなる行の前までが codediff の設定になります。
                        サンプル: |  #search: _base.yaml
                            This is a YAML file:

                            diff: |  #codediff:
                                [Old]
                                LocalPath = _base
                                [New]
                                LocalPath = .
                                ExcludeRelativePath = _base
                            This is out of codediff settings:
                        ExcludeRelativePath: #keyword:
                            プロジェクトの種類によって、ExcludeRelativePath の設定がほぼ決まります  #search: diff _base example
                    プロジェクト差分:  #search: diff _base
            開発:  #search: codediff tickets
            関連:
                Git:  #search: VSCode source control old commit
                code --diff:  #search: 
            トラブルシューティング:
                - #// 起動すると node_modules などのコピーに時間がかかる
                    手順: codediff _base.yaml
                    対処: ExcludeRelativePath を書きます  #search: ExcludeRelativePath
                        #search: diff _base example
        brebase コマンド（独自）:  #keyword: brebase  #ref: ${GitHub}/brebase
            #ref: https://github.com/Takakiriy/brebase
        proj コマンド（独自）:  #keyword: proj
            内容: プロジェクトを一覧します
            インストール スクリプト: |
                script=~/bin/proj
                echo "find . > ~/_find.out" > $script
                echo "cat ~/_find.out | grep /pyproject\.toml$  #// Python" >> $script
                echo "cat ~/_find.out | grep /go\.mod$  #// Go language" >> $script
                echo 'cat ~/_find.out | grep "/package\.json$" | grep -v "/node_modules/" | grep -v "/\.venv/"  #// JavaScript' >> $script
                echo "rm  ~/_find.out" >> $script
                chmod +x $script
    概念, 構造:  #search: Git concept
    ファイル:
        .gitignore: #keyword:
            書式サンプル: |
                # comment
                *.obj  #// サブフォルダーもリポジトリーに入れません
                .env   #// サブフォルダーもリポジトリーに入れません
                /.env  #// .gitignore ファイルがあるフォルダーだけ入れません
                **/node_modules/  #// サブフォルダーも含めて node_modules フォルダーをリポジトリーに入れません
                bin/   #// サブフォルダーも含めて bin フォルダーをリポジトリーに入れません
                package/**/*.ts  #// package フォルダーの中のサブフォルダーもリポジトリーに入れません
                !/a.obj  #// リポジトリーに入れます。たとえ *.obj が設定されていても
            設定サンプル:  #keyword: .gitignore examples
                逆に無視しないファイルを指定する場合:  #focus: !
                    .gitignore: |
                        *
                        !README.md
                サブフォルダーをすべて無視する設定: #keyword: .gitignore sub folders
                    .gitignore: |
                        # ignore all sub folders
                        */
                    説明:
                        (*/): 全てのサブフォルダーを無視
                        (!.gitignore): ルートフォルダーの .gitignore ファイルを無視しない
                        (!*/): ルートフォルダーの直下のファイルを無視しない
            #ref: https://qiita.com/anqooqie/items/110957797b3d5280c44f
            サブフォルダーにも入れることができます:
                __Project__/.gitignore
                __Project__/__SubProject__/.gitignore
            ❗注意:  #// リポジトリにすでにあるファイルが .gitignore に指定されると、VSCode で淡色表示にならず、リポジトリに残り続けます  #keyword: .gitignore already in repository
                関連: #search: .gitignore copy
            リポジトリから削除します:  #search: .gitignore delete  #// リポジトリにあるファイルが .gitignore にマッチしたときに、リポジトリから削除します  
                -   git rm --cached  "__FilePath__"
                -   git rm --cached -r  "__FolderPath__"
                #// ファイルの実体は削除されません
            .gitignore を使ってファイルをコピーします: #search: .gitignore copy  #// .gitignore にマッチしないファイルだけコピーします
            トラブルシューティング:
                設定が反映されない場合:
                    git add したすべてのファイルを add する前に戻します:
                        git reset
                    .gitignore で無視されるファイルを一覧します:  #// おそらく、存在するファイルのうち無視されるファイルは、後半の Ignored files: 以降に表示されます
                        git status --ignored
                        #ref: https://qiita.com/blue0513/items/1525a7f06d708e901690#ignoreされてるか確認
                    #ref: https://www-creators.com/archives/6144
        .gitattributes:  #keyword:
            サンプル: |
                *           text=auto    #// 改行の自動調整。Git がテキストと判定するファイルのみ(?)
                *.txt       text
                *.vcproj    text eol=crlf  #// チェックアウトするときでもコミットするときでも、改行コードをCRLFに自動調整
                *.sh        text eol=lf
                *.jpg       -text         #// 改行の自動調整をしない。text 属性をオフにする
                *.rpm       filter=lfs diff=lfs merge=lfs -text  #// LFS を使います  #search: Git LFS
                                    #// git-lfs がインストールされていないでこの設定があると小さいファイルになる？
            Git-LFS 関連:  #search: Git LFS .gitattributes
            ファイルの説明:
                行の順番: 下が優先です
            Checking-out and checking-in: https://git-scm.com/docs/gitattributes#_checking_out_and_checking_in
        .gitkeep:  空のフォルダーをリポジトリに入れます（未確認）。削除されてもリポジトリに残します（未確認）  #keyword:
        .commit: #keyword: Git .commit  #// 独自。ベースとなるコミット
            手順:
                更新確認: #keyword:  #// フォルダーの中に更新があるかどうかを調べます
                    locommit コマンドを使う場合:
                        準備:
                            更新前の内容を .commit に作ります:
                                locommit  #search: locommit
                        更新確認:
                            フォルダーの中に更新があるかどうかを調べます:
                                locommit  #search: locommit
                    手動でする場合:  #// locommit が安定したため、非推奨
                        準備:
                            .gitignore で無視されないファイルだけコピーします: #keyword: .gitignore copy
                                新しい手順:
                                    #// コピー先は、 ../_new フォルダーです
                                    - cd  __ParentOfDotGit__
                                    - git reset                 #// 注意：一部が git add 状態のときは、その情報が失われてしまいます
                                    - cp  ".gitignore"  ".gitignore_original"
                                    - code  ".gitignore"        #search: .gitignore examples
                                    - git rm -r --cached  "."   #// .gitignore の対象は deleted でステージングされ、.gitignore の対象外は untracked になります
                                    - git add "."               #// untracked ではなくします
                                    - rm -rf  "../_new/"
                                    - git checkout-index -fau --prefix="../_new/"  #// deleted でステージングされたファイルは、このコマンドでコピーされません
                                    - ls -a  "../_new"
                                    #// ↓ 元に戻します
                                    - git reset
                                    - cp  ".gitignore_original"  ".gitignore"
                                    - rm  ".gitignore_original"
                                古い手順:  #// この手順は、すでにリポジトリにあるファイルもコピーされてしまいます
                                    #// コピー先は、 .commit フォルダーです
                                    bash:
                                        -   rm -rf .commit
                                            git init
                                            git add .
                                            git commit -m temporary    #// git commit は不要かも
                                        -   mkdir .commit
                                            git checkout-index -a -f --prefix=.commit/
                                            rm -rf .git
                                    #// --prefix オプションの末尾のスラッシュは省略できません
                        編集: #// __Project__ フォルダーの中を編集または使用します
                        更新の有無を確認します:
                            差分が少ない場合:
                                __Project__/ と __Project__/.commit/ を WinMerge などで比較します
                            差分が多い場合:  #keyword: .commit_new
                                #// コピー先は、 .commit_new フォルダーです
                                bash:
                                    -   rm -rf .commit_new
                                        git init
                                        git add .
                                        git commit -m temporary
                                    -   mkdir .commit_new
                                        git checkout-index -a -f --prefix=.commit_new/
                                        rm -rf .git
                                比較:
                                    __Project__/.commit_new と __Project__/.commit/ を WinMerge などで比較します
                        完了時:
                            .commit フォルダーを更新します:
                                上記と同じ手順で .commit フォルダーを作ります
                                .commit フォルダーの内容は git clone してできるフォルダーの内容と同じです
                        補足:
                            Do a "git export" (like "svn export")?:
                                #ref: https://stackoverflow.com/questions/160608/do-a-git-export-like-svn-export
                            git archive コマンドは遅いです:
                                - git archive HEAD | tar -x -C .new_commit  #// 遅い
        _base/, _base.yaml:  #// 独自。ベースとなるコミット
            ベースとの差分表示: #keyword: diff _base  #// 教材となるプロジェクトにおいて、機能追加に必要なコードを差分で表示します
                手順:
                    一般的な CLI 環境の場合:  #search: locommit
                        設定ファイルを表示してからコピーしたパスを codediff コマンド に貼り付けるだけで、差分を表示できます。
                        codediff コマンドに、codediffタグ（#codediff:）を含むファイルのパス（主に __Project__/_base.yaml）を指定することで、
                        差分を表示できます
                    typrm を使う環境の場合: #keyword: codediff typrm
                        構造化ドキュメンテーションから ref タグ（#ref:）を typrm に貼り付けるだけで、差分を表示できます。
                        typrm に、codediffタグ（#codediff:）を含むファイルのパス（主に __Project__/_base.yaml）を示す ref タグ（#ref:）貼り付けて、
                        メニューから 3.codediff を選ぶことで、差分を表示できます。
                    インストール:
                        codediff をインストールします:
                        （typrm を使う場合）typrm の TYPRM_VERB 環境変数の一部に以下を追加します: |  #ref: ${GitHub}/MyPrivateCode/settings/M1-mac/typrm#codediff
                            - #
                                label: 3.codediff
                                number: 3
                                regularExpression: ^.*\.(yaml)(#.*)?$
                                command: 'codediff  "${file}"'
                サンプル: #keyword: diff _base example  #// _base.yaml ファイル。codediff タグ（#codediff:）を含むファイル
                    Next.js プロジェクト:  #ref: ${GitHub}/MyPrivateCode/Next_js/next_js_zip_file_reader/_base.yaml
                    Swift プロジェクト:  #ref: ${GitHub}/MyPrivateCode/Swift/1st/UITextViewAttribute-14-1/_base.yaml
                    （codediff タグを含むファイルを作る）:  #search: project with base
            ベースの更新を反映します: #keyword: locommit update base project  #// ある機能などを追加したプロジェクトに、ベースとしたプロジェクトの更新を反映します
                準備: #keyword: project with base,  _base  #// プロジェクトを作ったときのベースをプロジェクトに含めます
                    ベース:
                        __Project__/_base:  #// ベースとなるプロジェクトのコピーをこのフォルダーに入れておきます。差分がすぐ分かるようたするためです
                            - __Project__/_base/_base は含めない。リポジトリを参照する
                            - __Project__/_base/_base.yaml は含めない。リポジトリを参照する
                        __Project__/_base.yaml: #keyword: _base.yaml  #// _base の リポジトリ名と コミット ID
                            基本サンプル: |  #search: GitHub diff
                                Test pass:  #// __Project__ のテストが Pass した日。_base のテストではない
                                    2023-01-01
                                _base:
                                    CommitID: da02394  #// 2020-01-01  #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMock_1
                                diff: |  #codediff:
                                    [Old]
                                    LocalPath = _base
                                    [New]
                                    LocalPath = .
                                    ExcludeRelativePath = _base
                            codediff タグのブロックを修正します:  #// codediff タグ のブロックの構成は、言語の種類によってパターンがあります
                                #search: diff _base example
                                #search: codediff tag
                            ダウンロードした場合: |  #// ベースとなるプロジェクトをダウンロードしたときの _base.yaml の書き方
                                _base:
                                    #ref: __URL__
                                    #search: __Keyword__
                            ベースとパスが違う場合:  #keyword: moved _base
                                基本: |
                                    _base/moved/file: Copy of _base/file
                                移動先(in __Project__)が .gitignore される場合:
                                    #// 上記基本と書き方は同じですが、更新するときに工夫が必要です
                                    #search: update moved base .gitignore
                            _base.yaml や _base が非公開の場合:  #search: private _base.yaml
                                .gitignore: |
                                    _base*
                                _base.yaml: |
                                    _base.yaml:
                                        #search: __Project__ _base.yaml  #// ベースというよりバックアップ
                    メイン:
                        __Project__: 最終状態、または、応用する前の再利用しやすい状態。再利用しやすい状態が 2つあるときはプロジェクトを分ける。
                    差分表示: #search: diff _base  #// ベースとメインの差分を表示します
                    応用: #keyword: _plus  #// （必要な場合のみ）応用手順で使うファイル
                        __Project__/_plus/__Step__: 応用の手順で必要となるファイルを入れておきます。
                            ダウンロードしたファイルも含める。他のリポジトリに置いてもよい。
                            手順が複雑になる場合は別のプロジェクトに分ける
                更新:  #keyword: update project base,  update _base.yaml
                    ベースの更新を手動でする場合:
                        （必要なら）_base の内容を調整します:  #// 次の手順で比較しやすいようにします
                            たとえば、ベースの一部のファイルをコピーします  #search: moved _base
                        更新しようとする内容を確認します:
                            __Project__/_base と __Project__ を比較します
                        ベースのプロジェクトを更新してテストしてコミットします:
                            __BaseProject__
                    ベースの更新をマージする場合:  #// 他のプロジェクトによってベースが更新された内容を受け入れるようなマージをします
                        手動:  #// v1.1.0 以前の locommit のバージョンの場合
                            （必要なら）.gitignore される部分を更新する場合:  #keyword: update moved base .gitignore
                                #// 必要かどうかは _base.yaml に書いてあります。
                                #// 更新する前に __Project__ のバックアップを取っておくとよいでしょう。
                                一時的に .gitignore_merging フォルダーを作ります。__Project__, 古い _base, 最新の _base すべてに作ります。
                                #search: moved _base
                                #// 以下に続きます
                            .commit の内容を _base の内容に置き換えます:
                                cd  __Project__
                                mv  ".commit"  ".commit_this"
                                mv  "_base"    ".commit"
                                # 不要？→ locommit  #// ".commit_new" を作ります
                            マージします:
                                - #// __NewBaseProject__/_base や __NewBaseProject__/_base.yaml が存在しないことを確認します
                                - locommit pull  "__NewBaseProject__"  #// __NewBaseProject__ は __Project__/_base の最新版
                                #// ここでコンフリクトが発生したら処置します
                            .commit の内容を元に戻し、_base の内容を更新します:
                                rm -rf  "_base"
                                cp -ap  "__NewBaseProject__"  "_base"
                                mv  ".commit_this"  ".commit"
                            .gitignore される部分を更新した場合:
                                .gitignore_merging フォルダーの内容を元（.gitignore される部分）に戻し、.gitignore_merging フォルダーを削除します。
                                _base の .gitignore_merging はそのままで構いません。
                                #search: moved _base
                                #// 以下に続きます
                            _base.yaml に書かれたコミットID を更新します:
                                code  _base.yaml
                        新機能: #keyword: locommit pull-base  #// locommit の新機能
                            - locommit pull-base  _base  __NewBaseProject__  #// _base.yaml をリードして、.commit_new のうち _base などを対象外にする
                            #// 以下は pull (pull-base ではない) でもテストする
                            #// テストケース：ベースにあってプロジェクトにないファイル
                            #// テストケース：,gitignore が増えて対象外になったファイルが増えたケース
        ワーキング ツリー:  #search: Git working tree
        ファイル: #keyword: Git tracked file  #// Git の管理下にあるファイル。ソース ファイル など
            変更内容:  #search: git diff
            更新日: #keyword: Git file time stamp  #// 変更内容がコミットされた日時
                表示:
                    git コマンドの場合: |
                            $ git log -1 --format="%ai" -- __FilePath__  #// Current folder must be in Git working folder.
                            2023-08-08 09:15:33 +0000
                        #// 現在のタイムゾーンで表示されます
                        #// カレント フォルダー が対象の Git ワーキング フォルダー の中にいないとエラーになります
                        #search: bash compare date time
                ファイルのタイムスタンプをコミット日時に設定します:  #keyword: set-git-commit-date.sh
                    find  "hostconf/iptables"  -type f  | \
                        set-git-commit-date.sh
                    #ref: ${GitHub}/MyPrivateCode/bash/set-git-commit-date/set-git-commit-date.sh#function  SetGitCommitDate
                    #search: find grep
                    #search: Linux time stamp
                オーサー日時:  #search: Git オーサー日時
            削除日: #keyword: Git deleted file  #// 指定した名前のファイルが削除されたコミット（コミット ID, 削除日）を探します
                相対パスを調べます:  #// ファイル名またはその一部から相対パスの全体を調べます
                    git log --diff-filter=D --summary | grep "delete mode" -A 1 | grep "__PartOfFileName__"
                コミット情報を調べます:  #search: git log output
                    git log --diff-filter=D --name-only -- "__RelativePath__"
        .git:
            減らす: #keyword: reduce .git  #// .git フォルダーのサイズを減らします
                方法A:
                    git clone しなおす
                方法B:
                    git gc --prune=now
    設定 >> ワーキング フォルダー の設定:
        一覧: cat .git/config  #// 設定の一覧
        リモートに接続するプロトコル: #search: git remote
    Git bash: #search:
    その他 仕様:
        pathspec: #keyword: Git pathspec  #// Git におけるパスの仕様
            公式: #ref: https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefpathspecapathspec
            ワイルドカード(*):
                doc/*.jpg にヒットするパス:
                    サンプル: doc/image.jpg, doc/sub/image.jpg 
            magic signature (:から始まるパス):
                top, /:  #// .git フォルダーがあるフォルダー
                    サンプル:
                        - git diff :/sub/main.ts
                        - git diff ":(top)src/main.ts"
                    公式: #ref: https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-top
                exclude, !:  #// 対象外にするパス
                    サンプル:
                        - git diff develop  ':!build'
                        - git diff develop  ":(exclude)build"
                    公式: #ref: https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-exclude
                範囲の終了を明示する場合: |  #// 未確認
                    : を書きます 例) :magic signature:
    トラブルシューティング:
        git clone:  #search: git clone trouble
        git merge:
            not_merged_to_main:  #// まだマージしていないという印  #keyword:
                サンプル: #ref: ${GitHub}/MyPrivateCode/ansible_vagrant/multi_vm_ansible/dependency.yaml
                sub branch を更新したとき:
                    下記を付けてからコミットします
                        #keyword: __Sub___is_not_merged_to_main
                __Sub___is_not_merged_to_main があるとき:
                    main branch を更新して動作確認してコミットします
            コンフリクトが発生したとき:
                コンフリクトした部分はすべて自分の内容を適用する場合:
                    git checkout --ours  "__FileOrFolderPath__"
                コンフリクトした部分はすべて相手の内容を適用する場合:
                    git checkout --theirs  "__FileOrFolderPath__"
        git pull:
            - #// git pull に stash が必須になってしまっている
                手順: git pull
                ログ: |
                    error: cannot pull with rebase: You have unstaged changes.
                    error: please commit or stash them.
                対処:
                    git config --global rebase.autoStash true
                関連:
                    rebase.autoStash: git rebase (git pull の内部などで) するときに自動的に git stash と git stash pop を行います
                    pull.rebase: git pull するときに自動的にリベースを行います
            - #// git pull >> Pulling without specifying how to reconcile divergent branches is discouraged. #keyword: git Pulling without reconcile
                手順: 初めて git pull したとき
                エラー: |
                    Pulling without specifying how to reconcile divergent branches is
                    discouraged. You can squelch this message by running one of the following
                    commands sometime before your next pull:

                    git config pull.rebase false  # merge (the default strategy)
                    git config pull.rebase true   # rebase
                    git config pull.ff only       # fast-forward only

                    You can replace "git config" with "git config --global" to set a default
                    preference for all repositories. You can also pass --rebase, --no-rebase,
                    or --ff-only on the command line to override the configured default per
                    invocation.
                対処:
                    現在の設定を表示します:
                        - git config pull.rebase
                        - git config pull.ff
                    選択候補一覧:
                        merge: git log がブランチになるようです（未確認）
                        rebase: （未確認） #search: git rebase
                        fast-forward: （未確認）
                解説: よりよくマージする方法を選んでいない可能性があります。
                    今までの git の仕様では、他のユーザーが新しくコミットしたリポジトリに対して、
                    競合がなければ fast forward、
                    競合があって git pull すると merge、
                    競合があって git stash してから git pull すると rebase していましたが、
                    merge か rebase か fast forward のいずれかに統一していくことが良い方法と考えられたと思われます。
            - #// 同期されない
                手順: git pull
                問題: 2つデバイスで内容が異なる
                対処: カレント フォルダーが違っていたら直してください
            - #// no such ref was fetched.
                手順: git pull
                エラー: |
                    Your configuration specifies to merge with the ref 'refs/heads/__Branch__'
                    from the remote, but no such ref was fetched.
                原因: ローカルにあるブランチがリモートで削除されたため
                対処:
                    git checkout __ExistingBranch__
                    git pull
        git push: #keyword: git push trouble
            - #// 関連: #search: git clone trouble
            - #// 古い git push --force で push.default を matching にするか simple にするか聞かれる
                手順: git push --force
                ログ: |
                    warning: push.default is unset; its implicit value is changing in
                    Git 2.0 from 'matching' to 'simple'. To squelch this message
                    and maintain the current behavior after the default changes, use:

                        git config --global push.default matching

                    To squelch this message and adopt the new behavior now, use:

                        git config --global push.default simple

                    See 'git help config' and search for 'push.default' for further information.
                    (the 'simple' mode was introduced in Git 1.7.11. Use the similar mode
                    'current' instead of 'simple' if you sometimes use older versions of Git)
                対処:
                    git config --global push.default simple
                    git push --force
                解説:
                    matching: ローカルとリモートで同名のすべてのブランチをプッシュ
                    simple: 現在のブランチのみをプッシュ  #// 推奨されている新しい動作です
            - #// ブランチの最初のコミットの場合
                git push --set-upstream origin __NewBranchName__
            - #// remote: HTTP Basic: Access denied
                手順: git push
                エラー: |
                    remote: HTTP Basic: Access denied
                    fatal: Authentication failed for '__URL__'
                対処:
                    接続方法を調べます:
                        git remote get-url origin
                    HTTPS の場合:
                        VSCode 場合:
                            パスワードを入力するボックスに書いてある URL に注意して、正しいパスワードを入力してください
                    SSH の場合:
                        ~/.ssh/id_rsa ファイルにパスワードが設定してあればそのパスワードを入力します
            - #// remote: You are not allowed to upload code. The requested URL returned error: 403
                手順: git push
                エラー: |
                    remote: You are not allowed to upload code.
                    fatal: unable to access 'https://_______/': The requested URL returned error: 403
                原因:
                    HTTPS でリポジトリにアクセスできません
                対処:
                    たとえば SSH でリポジトリにアクセスします:
                        git remote set-url origin git@github.com:Takakiriy/typrm.git
                        git push
GitHub, サーバー、リポジトリ:  #// GitHub, プロジェクトボード, プルリクエスト
    GitHub: #keyword:  #ref: https://github.com/Takakiriy/  #ref: ${GitHub}
        公式 >> 検索: #keyword: GitHub search
            全体:  #ref: https://github.com/ >> Search GitHub（右上）
            組織単位: org:__Organization__ __Keyword__
            ファイル名を検索: filename:__PartOfName__
            プロジェクト:  #ref: https://github.com/Takakiriy >> Search GitHub（右上）
                コード, コミット メッセージ, Issue などを検索できます
            プライベート プロジェクト:
                ログインするとヒットします
                他のユーザーでログインするとヒットしません
        手順: #keyword: GitHub steps
            コード参照:  #search: GitHub code
            ダウンロード:
                git clone コマンドでローカルにダウンロードする場所:
                    ルート: #ref: ${GitHub}
                    typrm: #ref: ${GitHub}/typrm
                .zip ファイルをダウンロードします: #keyword: GitHub .zip download
                    特定のコミット:
                        書式: https://github.com/__UserName__/__ProjectName__/archive/__CommitID__.zip
                        サンプル: https://github.com/Takakiriy/typrm/archive/2d0385c376f8fbed1050aafada0603db8eaf8eca.zip
                        #// HTML がダウンロードされる場合、その内容が認証に失敗したという内容であれば、PAT などが必要です
            SSH 公開鍵を設定します: #search: GitHub publickey
            アカウント設定: #search: GitHub account
            新規リポジトリ: #keyword: GitHub new repository
                LICENSE ファイル の編集部分:
                    Copyright [yyyy] [name of copyright owner]
            プルリクなど:  #search: GitHub pull requests
            レビューします:
                pull request に:  #search: GitHub review example
                commit に:  #search: GitHub commit comment
            プロジェクト管理関係:
                タスクリスト: #// チェックボックス  #keyword: GitHub task list,  GitHub check box
                    概要: チェックボックスの一覧です。親 Issue の画面にはタスクの消化状況(0 of 3)が表示されます
                    公式: #ref: https://docs.github.com/ja/issues/tracking-your-work-with-issues/about-task-lists
                        #ref: https://docs.github.com/ja/issues/tracking-your-work-with-issues/creating-issues/about-task-lists
                    サンプル: #search: GitHub task list example
                    タスクリストを作ります:
                        Issue や Pull Request の最初のコメント（Write）: | #search: GitHub Issues
                            __OverviewOrURL__

                            ## ToDo
                            - [ ] __Task1__
                            - [ ] __Task2__
                        Preview（タブ）で確認できます:
                    チェックを付けます（タスクを完了にします）:
                        編集前: |
                            - [ ] __Task__
                        編集後: |
                            - [x] __Task__
                    進捗状況, タスクの消化状況を表示します（Issue の親子関係を設定します）:  #keyword: GitHub child issue
                        親 Issue を作ります:
                            最初のコメント: リリースのまとめなど
                        子 Issue の最初のコメント（Write）に 親 Issue を追加します:
                            最初のコメント: __ParentIssueURL__ __ParentIssueTitle__
                        親 Issue を表示して、子 Issue のタスクの消化状況を確認します:
                            #// 子 Issue にタスクリストが無いときは消化状況は表示されません。子 Issue へのリンクだけ表示されます。
                            Issue の履歴に表示される内容:
                                __ChildIssueTitle__      __Status__
                                0 of 1 task complete
                        注意: 一覧最初のコメントにある タスク リスト だけが集計対象です。後から最初のコメントを編集することはできます
                        一覧で表示: https://github.com/ >>（リポジトリ）（左）>> Issues（タブ）>>
                            Issue名の下に n of m tasks と表示されます
                        Issue で表示: https://github.com/ >>（リポジトリ）（左）>> Issues（タブ）>>（Issue名）>>
                            Issue名の下に n of m tasks と表示されます
                    子 Issue の表示をしないようにします:  #// リリース延期など
                        #// 非表示にすることはできません
                        対象外にした子 Issue のリストを書きます
                    関連 >> 汎用 Markdown で作成:  #search: Markdown task list
                マイルストーン:  #// Issue をまとめた進捗度  #keyword: GitHub milestone  #ref: https://docs.github.com/ja/issues/using-labels-and-milestones-to-track-work/managing-labels
                    #// 表のほうがリリース状況など列が揃っていて見やすいです
                    新規作成:
                        空のマイルストーンを新規作成します:
                            メニュー:
                                https://github.com/ >>（リポジトリ）（左）>>
                                Issues（タブ）>> Milestones（右上）>> New milestone（右上）
                            Title: マイルストーンに付ける名前。後から編集できます。例：アルファ版、バージョン1.0リリース
                            Due date (optional): _____
                            Description: ____
                            Create milestone（右下）:
                        マイルストーンを割り当てます:
                            対象の Issue または Pull Request を開きます:  #search: GitHub Issues
                            マイルストーンを選びます:
                                milestone（右 上から 4番目）>>（対象のマイルストーン）
                    表示:
                        進捗状況を調べます:
                            メニュー: https://github.com/ >>（リポジトリ）（左）>> Issues（タブ）>> Milestones（右上）
                            進捗度グラフ（行の右半分）: closed / (open + closed)
                            open（グラフの下）: open の Issue の数
                            closed（グラフの下）: closed の Issue の数
                        関連する Issue, Pull Request を一覧します:
                            メニュー: https://github.com/ >>（リポジトリ）（左）>> Issues（タブ）>> Milestones（右上）>>
                                マイルストーン名（行の左半分）
                    編集:
                        Title など:
                            メニュー: https://github.com/ >>（リポジトリ）（左）>> Issues（タブ）>> Milestones（右上）>>
                                Edit（行の右半分の左下）
                        関連する Issue:
                            メニュー: https://github.com/ >>（リポジトリ）（左）>> Issues（タブ）>> Milestones（右上）>>
                                マイルストーン名（行の左半分）>> Issue名 >>
                                milestone（右 上から 4番目）>>（対象のマイルストーン）
                Projects >> プロジェクトボード: #keyword: GitHub project,  GitHub Projects board  #// タスクカードと To do, In progress, Done レーン
                    公式:
                        - https://docs.github.com/ja/issues/organizing-your-work-with-project-boards
                        - https://docs.github.com/ja/issues/organizing-your-work-with-project-boards/managing-project-boards/about-project-boards#creating-and-viewing-project-boards
                    注意: DEV 環境, STG 環境, PRD 環境 の順に行かないケースがあるときは管理が難しくなります
                        リリース タスク リスト を推奨します  #search: Markdown task list
                    手順:
                        チュートリアル:
                            プロジェクトボードを作ります（Organizationなし）:
                                メニュー: #// 以下のいずれか
                                    - GitHub のプロジェクトのページ >> Projects（タブ）>> New Project
                                    - プロフィール画像（右上）>> Your profile >> Projects（タブ）>> New Project
                                Project board name: Example Project （例）
                                Description: This is a project board trial. （例）
                                Project template: Basic Kanban （例）
                                    テンプレートの内容は https://docs.github.com/ja/issues/organizing-your-work-with-project-boards/managing-project-boards/about-project-boards#templates-for-project-boards
                                Visibility: Private
                                Linked repositories: ____ （先頭数文字を入力すると候補が表示されるのでクリックします）
                                    上へスクロールして Repositories タブを右クリック >> リンクを新しいタブで開く >> __RepositoryName__
                                    https://github.com/Takakiriy/__RepositoryName__ の __RepositoryName__
                                Create project ボタン:
                                Welcome to GitHub Projects のカードに書かれた操作を試してみてください:
                                Issue カードまたは プルリクエスト カード を追加します:
                                    #search: GitHub Issue card
                            自動化を設定します:
                                Issue が追加されたら ToDo 列に自動的に追加します:
                                    メニュー: プロジェクトボード >> …（ToDo 列の右上）>> Manage automation
                                    Preset: To do
                                    Move issues here when... >> Newly added: チェック
                                    Update automation ボタン:
                                Issue がクロードされたら Done 列に自動的に移動します:
                                    メニュー: プロジェクトボード >> …（Done 列の右上）>> Manage automation
                                    Preset: Done
                                    Move issues here when... >> Closed: チェック
                                    Update automation ボタン:
                            プロジェクトをクローズします:
                                メニュー: GitHub のプロジェクトのページ >> Projects（タブ）>> …（対象プロジェクトの右上）>>
                                    Close
                    構成:
                        （構成）:
                            リンクしているプロジェクト:
                            プロジェクトボード:
                                列, カラム:
                                    カードの種類:
                                        カードの構成:
                        プロジェクトボード:
                            プロフィール画像（右上）>> Your profile >> Projects（タブ）>> __ProjectName__
                        リンクしているプロジェクト:
                            調べる:  #// プロジェクトボードにリンクしているリポジトリを調べます:
                                メニュー: プロジェクトボード >> __ProjectName__（にマウスカーソルを合わせます。左上）>>
                                    Linked repositories
                        列, カラム:  #// いくつかのカードを含む列
                        カードの構成:
                            ラベル:
                            アサインされた人:
                            ステータス:
                            オープンした人:
                            その他:
                            カードの操作:
                                - 列から列へのカードの移動などはドラッグアンドドロップでできます
                                - 自動的に移動させることもできます  https://docs.github.com/ja/issues/organizing-your-work-with-project-boards/managing-project-boards/about-project-boards#templates-for-project-boards
                        カードの種類:
                            Issue カード: #keyword: GitHub Issue card  #// カードの左上に○に・または！のアイコン（リポジトリの Issues タブにもあるアイコン）が表示されます
                                追加: #// 既存の Issue を新しくカードにして、カラムの中にそのカードを追加します:
                                    （必要なら）Issue を追加します: #search: GitHub Issue
                                    メニュー: プロジェクトボード >> Add cards（右上）>> 表示された Issue をドラッグ＆ドロップします
                                Issue の詳細表示:
                                    Issue カードのタイトル（を右クリック。カードの上）>> リンクを新しいウィンドウで開く
                            プルリクエスト カード:  #// カードの左上に合流する矢印のアイコン（リポジトリの Pull requests タブにもあるアイコン）が表示されます
                                Issue カードの操作方法と同じ
                            ノート:  #// （選択した列内でカードとして分類される）ノート
                                    ノートでは要求を満たせない場合、ノートを Issue に変換することができます
            Web ブラウザーでファイルを追加します:  #search: GitHub new file
            ドキュメント公開:  #search: GitHub Pages
        画面, タブ:  #// Issue, プルリクエスト などのタブ
            Code タブ:
                コード参照: #keyword: GitHub code  #// コードを読みます。または、コードを見せます
                    URL を取得する場合: #keyword: GitHub URL,  Git URL  #// コミットの URL なので内容が変化しません
                        GitHub の Code タブを選びます:
                            https://github.com/__Account__/__Repository__
                            #// __Account__ は個人または組織のアカウント名です
                        行番号をクリックします:
                            複数行を指す場合: さらに Shift を押しながら範囲の最後の行をクリックします
                        パーマリンクに変換します:  #// 特定のコミットに固定された URL になります
                            y キー
                        アドレス バー からコピーします:
                    ファイルを表示する場合: #keyword: GitHub code file  #// 指定したコミットのファイルの内容を GitHub で表示します
                        ブラウザーで表示する場合:
                            表示する コミット ID をコピー（この ID は GitHub の右上で検索してもヒットしない可能性があります） >>
                            GitHub の 任意のファイルかフォルダーをクリック >>
                            URL のブランチ名を コミット ID に置き換えて Enter キー >>
                            URL の後半をファイルの相対パスに置き換えて Enter キー
                        GitLens でワーキングと比較する場合:  #// バグあり
                            （比較する コミット ID をコピー）>> VSCode >> F1 キー >> gitlens show >>（貼り付け）>>（コミットをクリック）>>（下へスクロール）>> Compare with Working Tree
                                -- Changed（バグ？）
                    検索する場合:  #// ドキュメントが GitHub にあれば、ドキュメントに書かれたシンボルからコードを検索することができるようになります
                        上にある検索ボックス「Search or jump to...」にキーワードを入力 >> In this repository
                    コードの編集者を調べる場合:
                        GitLens: #search:
                        git blame: #keyword: GitHub blame
                            #ref: https://thinkit.co.jp/article/8436#blame-
                    GitHub ファイル一覧に大文字小文字区別しない:  #// できません
                        GitHub の自分のリポジトリをブラウザーで表示するときにファイル名の一覧を大文字小文字区別しないで一覧するにはどうしたらいいでしょうか
                        GitHub 本体に対する要望はどこに投稿すればいいでしょうか
                        org:github case sensitive web
                            https://github.com/orgs/community/discussions/
                        想定される設定の場所
                            https://github.com/settings/appearance
                        日付ソートは却下
                            https://github.com/orgs/community/discussions/52932
                diff: #keyword: GitHub diff
                    １つのコミットの編集内容:  #search: GitHub commit contents
                    複数のコミットをまたがる差分:
                        サンプル:
                            https://github.com/__Owner__/__Project__/compare/__OldCommit__..__NewCommit__
                            https://github.com/__Owner__/__Project__/compare/__OldCommit__..__NewCommit__#diff-__DiffID__  #// 対象ファイルにスクロールします
                                #// 1つのファイルだけ表示することはできません。重たくなるときは編集した１つのコミットを特定してください
                            #ref: https://github.com/github-linguist/linguist/compare/f75c570..3391dcc
                    注意: 同じリポジトリの中の同じパスの位置でのみ使えます
                    異なるパスで表示する:
                        特別なブランチを使う場合:
                            比較対象が同じパスになる場所にコピーして特別なブランチにコミットします
                Markdown:  #// 書式  #keyword: GitHub Markdown
                    書式:
                        改行: コードに改行があると、表示にも改行が入ります
                        コード: |  #ref: https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/creating-and-highlighting-code-blocks
                            ```YAML
                            code
                            ```
                        その他: 一般の Markdown と同じです  #search: Markdown
                    タスク リスト:
                        GitHub の機能:  #search: GitHub task list
                        汎用 Markdown で作成:  #search: Markdown task list
                右のビュー:
                    Topics: #keyword: GitHub topics
                        About（右上）の下に表示される青いキーワードのチップの並び
            Issue タブ:  #// チケット  #keyword: GitHub Issues
                参考: https://www.atmarkit.co.jp/ait/articles/1703/29/news021.html
                Issue を追加します:  #keyword: add GitHub Issues
                    メニュー: https://github.com/ >>（リポジトリ）（左）>> Issues（タブ）>> New issue（右上）
                    タイトル: ____
                    Write（タブ）: ____  #// 本文  #search: GitHub Markdown
                        #// Write に Issue URL を書くと、リンク先の Issue に、関連する Pull Request として緑色の Open（初期状態）が表示されるようになります。
                    Write のサンプル:
                        他の issue やプルリクへのハイパーリンク:
                            空白と '#' と数字を書くと、同じリポジトリの中の issue やプルリクへのリンクになります。
                                #1234
                            #// issue とプルリクは重複しないように番号が割り振られています。
                        タスクリスト付き Issue: |  #keyword: GitHub task list example  #search: GitHub task list
                            __OverviewOrURL__

                            ## ToDo
                            - [ ] __Task__
                        リリース用まとめ Issue: |
                            ## リリース日
                            ## 変更履歴
                            ## Issues （チケット）
                            ## ToDo
                            - [ ] __Task__
                        リリース タスク リスト:  #search: Markdown task list
                        リリースの Issue: |
                            __OverviewOrURL__

                            Release 0.0.0 __ReleaseIssueURL__   （これを書くと、リリース用まとめ Issue に、ToDo（タスクリスト）の消化状況が表示されます）

                            ## ToDo
                            - [ ] __Task__
                    Assignees（右上）: ____
                    添付ファイル: Write（本文）の中へファイルをドラッグ＆ドロップします
                    Submit new issue ボタン:
                    （必要なら）プロジェクトボードで優先順位を管理します:  #search: GitHub Project board
                一覧:
                    自分にアサインされているイシュー:
                        メニュー: https://github.com/ >>（リポジトリ）（左）>> Issues（タブ）>> Filters（左上）>> Your issues
                    実施中:  #// 自分が担当するクローズしていないチケット
                        is:issue is:open author:USERNAME created:>=YYYY-MM-DD
                        is:issue is:open author:m-toda
                    完了:  #// 自分がクローズしたチケット
                        author の場合:
                            is:issue is:closed closed:>=YYYY-MM-DD author:USERNAME
                            is:issue is:closed closed:>=2022-04-01 author:m-toda assignee:m-toda
                        assignee の場合:  #// author と同時に表示する方法は未調査
                            is:issue is:closed closed:>=YYYY-MM-DD assignee:USERNAME 
                            is:issue is:closed closed:>=2022-04-01 assignee:m-toda
                返事などコメントを追加します:
                    メニュー: https://github.com/ >>（リポジトリ）（左）>> Issues（タブ）>>（イシュー）
                    Write（タブ）: ____
                    Comment ボタン:
                書式:  #search: markdown  #// 本文の書式
                子 Issue と関連付けます:  #search: GitHub child issue
                コミットから Issue を探します:
                    GitHub の検索ボックス（上）に コミット ID を入力します
                関連するプロジェクト ボードを表示します:
                    Issue の画面 >> Projects（右の列の上から3番目）
                        #// そこからプロジェクトボードの列を変更することもできます
                クローズします: #keyword: GitHub issue close
                    Desktop:
                        メニュー: https://github.com/ >>（リポジトリ）（左）>> Issues（タブ）>>（イシュー）
                        Write（タブ）: ____
                        Close issue ボタン:
                    iPhone:
                        Issue の Top >> …（右上）>> クローズする
                マイルストーン: #search: GitHub milestones
            Pull requests タブ:  #keyword: GitHub pull requests, GitHub プルリクエスト, プルリク,  pull requests
                手順: #keyword: GitHub pull request steps  #// ブランチをマージしてもらうためにプルリクエストしてレビューしてマージします
                    基本:  #// 基本的なレビューの手順
                        お試し環境を構築します:
                            二人で編集するリポジトリを作ります（GitHubお試し用）:
                                #search: GitHub partner contributor repository try
                            (owner@)（必要なら）マージ先となるブランチを保護します:
                                #// 保護しなくても承認プロセスは同じです。最後にマージが拒否される違いだけのようです
                                #search: GitHub protected branch
                            (contributor@) ブランチを作ります:
                                Git bash: |
                                    (contributor@) git checkout  -b  "feature"  #// ローカルにブランチを作成  #template: __CompareBranch__
                                    echo c >> a.txt
                                    echo d >> a.txt
                                    echo e >> a.txt
                                    echo f >> a.txt
                                    git add "."
                                    git config user.name  #// ユーザーを確認します
                                    git commit -m "first commit"
                                    git push --set-upstream origin "feature"  #// ブランチを push  #template: __CompareBranch__
                        (contributor@) プルリクエストを発行します:
                            #search: GitHub new pull request
                        (owner@, contributor@) レビューします:  #keyword: GitHub review example  #// コメントを追加します
                            (owner@) 指摘事項がない場合:
                                (owner@) コメントする場合:
                                    Leave a comment に入力します（Merge pull request ボタンの下）
                            (owner@) 指摘事項がある場合:  #keyword: GitHub conversation
                                自分がレビューすべきプルリクエストを一覧します:  #// レビューする＝他の人が開発したコードを確認する
                                    #// 以下のどちらか
                                    メニュー: Pull requests（タブ）>>
                                        is:open is:pr review-requested:@me
                                        （を検索ボックスに追加）
                                    URL: https://github.com/__Owner__/__Repository__/pulls/review-requested/@me
                                    #// 参考  #ref: https://docs.github.com/en/enterprise-server@3.2/search-github/searching-on-github/searching-issues-and-pull-requests#search-by-pull-request-review-status-and-reviewer
                                (owner@) レビューのコメントを追加します:
                                    対象のプルリクエストを表示します:
                                    レビューのコメントを追加します:
                                        差分を表示します: Files Changed タブ
                                        差分にコメントを追加します: #keyword: add comment in GitHub diff
                                            コメントの対象が１行の場合: ＋をクリックします
                                            コメントの対象が複数行の場合: ＋をドラッグします
                                            コメントを入力します:
                                            Cancel: コメントの入力をやめます
                                            Add single comment: 会話を始めます。相手の画面に表示されます。
                                            Start a review: 下書きを追加します。Pending 表示され、まだ相手の画面に表示されません。メールもまだ送信されません
                                (owner@) Pending 表示:  #keyword: GitHub review Pending 表示  #// (owner@) が Start a review ボタンを押したとき
                                    状態: まだ相手の画面に表示されていない下書きのコメントです
                                    #//  Pending は後でまとめて消えます:  #search: GitHub approve example
                                (owner@) １つのファイルをレビューしたことを記録します:
                                    Viewed（右上）: オン
                                (owner@) レビューを完了します:  #keyword: GitHub approve example  #// 相手の画面にコメントを表示されるようにします
                                    完了のダイアログを表示します:
                                        Review changes ボタン（右上）または Finish your review（右上）を押します
                                    Leave a comment: レビュー全体のコメントを入力します
                                    Comment: 会話を続けるとき
                                    Approve: プルリクエストを許可します（オーナーがプルリクエストできるようにします）
                                    Request changes: コードの変更を要求します
                                        #// Reviewers （プルリクエストのページの右上）にチェックが付きます
                                        #// プルリクエストのメインの画面にも Request changes のコメントが表示されます
                                    Submit Review: レビューを完了します
                                    Cancel Review: 下書きをすべて削除します
                                会話をします: #keyword: GitHub conversation example  #// (owner@) が Add single comment ボタンを押したとき
                                    相手の回答を確認します:
                                        コメントを 1つ選びます:
                                            （プルリクエストのページ）>> File changed タブ >> Conversations（上）>>（コメント）
                                            #// しばらく待つとコメントまでスクロールします
                                            #// 最新のコードではなく、コメントを書いた当時のコミット（マージ ベース からの差分）が表示されます
                                        前回レビューしてからの差分を確認します:  #// 新しいタブまたはウィンドウで
                                            前回のレビューから最新の場合:
                                                （ブラウザーの タブを複製）>>（ファイルの相対パスをコピー）>> 
                                                Changes from all commits▽（上）>> Show changes since your last review >>
                                                （相対パスでファイルを検索）>>（対象の行を探します。コメント当時の編集後の行番号を、最新の編集前の行番号から探します）
                                            指定のコミット間の場合:
                                                ...
                                                Changes from all commits▽（上）>>
                                                シフト キー を押しっぱなしにする >> 開始コミットをクリック >>（必要ならスクロール：ホイールは効きません）>>
                                                終了コミットをクリック >> シフト キー を放す >>
                                                ...
                                        状態を確認します:  #// すでに会話が終了したかどうか
                                            Resolve conversation ボタンが表示されているとき: 会話中です。
                                            折りたたまれているとき: 会話は終了しました
                                            Unresolve conversation ボタンが表示されているとき: 会話は終了しました
                                    自分が回答します:
                                        コメントを追加する場合:
                                            (contributor@) Comment または (owner@) Add single comment ボタン:
                                                #// 複数のコメントに一度に返信することはできません。メールでの通知は大量になります。(by ChatGPT 2023-06-19)
                                            Leave comment: コメントを入力します。返信元へのリンクがあると分かりやすくなります
                                        (owner@) 下書きを追加する場合:
                                            Leave comment: コメントを入力します
                                            Add review comment ボタン:
                                            #// Pending 表示 になります  #search: GitHub review Pending 表示
                                        Resolve（解決）にします:
                                            - 修正の意図を開発者が理解できたら Resolve（解決）にします
                                            - 修正後のコードのレビューは、後で新しいコミットをレビューするときに行います
                                            - Files changed タブは最新のコミットに対するレビューが表示されます
                                    #// 次のコメントを選び、相手の回答を確認します（この文書の上側へ戻る）
                                コミットが追加されたら:
                                    再レビューします:  #// 新しいコミットをレビューします  #search: GitHub conversation
                            返信します: #search: GitHub conversation example
                        （Approved されたら）マージします: Merge pull request ボタン
                        #ref: https://docs.github.com/ja/github/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/reviewing-proposed-changes-in-a-pull-request
                    発行:  #keyword: GitHub new pull request  #// プルリクエストを新規作成します
                        サインイン >> 変更した人の GitHub アカウントで GitHub にサインインします:
                        Pull requests（タブ）を表示します:
                            GitHub の対象プロジェクトを開きます: #ref: https://github.com/Takakiriy/collaborate/
                                #template: https://github.com/__RepositoryGroup__/__RepositoryName__/
                            Pull requests（タブ）:
                        プルリクエストを発行します:
                            以下のいずれか:
                                Compare & pull request（右上）:  #// 古いコミットのブランチは表示されません
                                New pull request（右上）:
                                    base（のブランチ）: master  #template: __BaseBranch__
                                    compare（のブランチ）: feature  #template: __CompareBranch__
                                    Create pull request ボタン:
                            タイトルを入力します:
                            変更内容の説明（コメント）を入力します:
                                - コメントを空欄のままでプルリクエストを作ることはできません
                                - コメントに、GitHub Issue のチケットの URL を入力すると、＃と番号の表示になります
                                - ＃と番号は行頭に書きます。 close などのキーワードに続けて＃と番号があると意図しないクローズが行われる可能性があるためです。
                                - 以上は デフォルト ブランチ の コミット メッセージ でも同じです
                                - 参考: https://docs.github.com/ja/github/managing-your-work-on-github/linking-a-pull-request-to-an-issue
                            コンフリクトが発生しないことを確認します:
                            チェックが失敗しないことを確認します:
                                All checks have failed と赤字で表示された場合: #keyword: GitHub pull requests check failed
                                    ログ:
                                        Details （赤字の子項目の右端）
                                    テスト名:
                                        GoCD の場合:
                                            Jobs（タブ）>>（テスト名）
                                    テスト コード のルートのパス:
                                        pytest の場合: |
                                            rootdir: で検索します
                                参考:
                                    Check API: #keyword: GitHub Check API
                                        概要: 誰かがリポジトリにコードをプッシュすると check_suite webhook イベントを送信します。
                                        公式: #ref: https://docs.github.com/ja/developers/apps/guides/creating-ci-tests-with-the-checks-api
                                            アノテーション: ？
                                            チェックスイート:  チェック実行 (個々の CI テスト) をグループ化したもの
                                            保護されたブランチ: ？
                            Create pull request ボタン(2):
                        （必要なら）イシューとプルリクエストへの関連を設定します:
                            ソフトリンク:
                                GitHub Issue にプルリクエストの URL を含むコメントを追加します
                            ハードリンク:  #// クローズすると連動してクローズするようです
                                GitHub のイシューのページ >> Linked pull requests
                        （必要なら）プルリクエストにコミットを追加します（同じブランチ名で追加できます）:
                    テンプレート: #keyword: GitHub pull request template  #// 最初のコメントを入力し始めるときにすでに入っている内容
                        使われる場所:
                            Create pull request ボタン を押した後で表示される文章を入力する場所
                        設定サンプル:
                            方針:  #search: develop-wip branch
                            PULL_REQUEST_TEMPLATE.md ファイル: |  #ref: デフォルト ブランチ の __Project__/.github/PULL_REQUEST_TEMPLATE.md
                                playbook: __Server__/__Service__.yml

                                #__GitHubIssueID__
                                __Abstract__


                                #### レビューの Approve  条件

                                - [ ] コードの diff (Files changed タグ) を確認する
                                - [ ] リベースしてあること（リベースが git push 済みであること）
                                - [ ] DEV リリースする RPM は、各種 feature ブランチをマージした develop-wip ブランチで作る

                                #### develop ブランチへのマージ

                                - [ ] STG リリースが開始されている

                                #### develop ブランチへマージした後

                                - [ ] マージした feature ブランチは、develop-wip ブランチから除く。具体的には develop-wip ブランチを新しい develop ブランチから作り直す（リバートは複雑になる）
                    レビュー:  #keyword: GitHub review  #ref: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/commenting-on-a-pull-request
                        サンプル: #search: GitHub review example
                        ブランチの変更内容:  #// プルリクエストをマージしたときの変更内容を表示します  #keyword: GitHub pull request diff
                            File chaanged（タブ）:
                                プルリクエストの詳細ページ >> Files changed（タブ）
                            追加・変更・削除されたファイルの一覧:
                                jump to（Files changed タブの左下）
                                #// または #search: git diff --name-only 
                        レビューをします（修正前）: #search: GitHub review example
                            差分表示:
                                Files Changed タブ:  #// プルリクに対してコメントを追加できます
                                    （ファイルへのリンク）:  #search: GitHub URL pull request diff file
                                Commits タブ: #keyword: GitHub commit review  #// コミットに対してコメントを追加できます
                                    メニュー:
                                        https://github.com/__Account__/__Repository__/pull/__PullNum__/commits/__CommitID__
                                            または
                                        GitHub リポジトリ >> Pull Requests タブ >>（名前）>> Commits タブ >>（コミット メッセージ：最新は下です）
                                    レビュー記録の内容:
                                        プルリクエストに関連付けられたコミットに入力した内容はプルリクエストの Conversation タブ にも記録されます
                                view reviewed changes ボタン:  #// 指摘コメントの右上
                                #// ただし、コミットが追加されると差分表示ではなくなるファイルがあります
                            セルフ レビュー: Files Changed タブ で セルフ レビュー（自分のコミットを自分でレビューすること）もできます。
                                ただし、Conversation タブの Reviewers（右上）には自分を追加できません。
                            Conversation タブ: File chaanged タブ やコミットの差分に入力したコメントは、Conversation タブ にも表示されます。
                        会話をします: #search: GitHub conversation example
                        レビューをします（修正後）:
                            Outdated マーク >> なし:  #// Outdated マーク が付いていないコメントの場合
                                差分と相手のコメントを表示します:
                                    差分表示（下記）して、コードを検索します。
                                    ただし、差分の外を編集されたときは、Files Changed タブ に編集内容が表示されます。
                                自分のコメントを書きます:
                                    差分表示のページに返信コメントを書いても
                                    Conversation タブ に返信コメントを書いたことと同じになります。
                            Outdated マーク >> あり:  #// Outdated マークが付いたコメントの場合
                                3箇所を表示してレビューします:
                                    Conversation タブ: 相手のコメントの内容の確認と、自分の新しいコメントの入力
                                    差分表示: 下記
                                    Files Changed タブ: 最終形
                            差分表示:
                                View changes ボタン: #keyword: GitHub View changes  #// 押したらそのボタンは消えるようです
                                    1つコミットが追加されたとき:  #// 追加されたコミットの差分
                                        Conversation タブ のコメントの下にコミットが追加され、
                                        その右側にある View changes ボタンを押すと追加されたコミットの差分が表示されます。
                                        Conversation タブ にある編集前のコードの一部をコピーして、差分のページの中を検索すると修正内容が分かります。
                                    2つ目のコミットが追加されたとき:
                                        View changes ボタンは 1つ目と 2つ目の間に表示されますが、
                                        ボタンを押したときの内容は 2つめのコミットの内容です。
                                        つまり、以前どこのコミットまでレビューしたかが View changes ボタンの位置から分かります。
                                コミット ID:  #// を押すと、コミット（によるコードの差分）が開きます
                            階層化されてない場合の返事:
                                レビューの子要素への返信: #keyword: GitHub review reply
                                    すぐ下にある Reply... に返信内容を書きます
                                子要素ではないコメントへの返信:
                                    コメントを編集する場合:
                                        #### __User__
                                        で既存のコメントを区切り、コメントを追記します。
                                    リンクを使うの場合: |  #// バラバラになるため、適度に使うこと
                                        返信元へのリンクを付けると分かりやすくなります。
                                            [コメント](__URL__) への返信
                                    #// コードに対する指摘であれば Files Changed タブでコメントを追加します。返信元へのリンクも書きます
                        レビュー記録について: #keyword: GitHub review logs
                            レビュー記録を書いたときの影響: File chaanged タブでレビューした記録は、同時に Conversation タブにも書かれます
                            リベースの影響: リベースすると、GitHub の File chaanged タブのレビュー記録が一部正しくなくなりますが、
                                Conversation タブに書かれた記録は残ります。Outdated と表示されます。Outdated は通常のコミットによる変更でも表示されます
                            WIP ブランチは作らない:  #search: WIP start tag
                        リベースなどへの追従: #keyword: GitHub review rebase  #// git push --force されても、プルリクは追従できます
                            - プルリクの対象ブランチが git push --force されても、プルリクは追従できます
                            - リベース＆ git push --force-with-lease してもプルリクは追従できます
                            - ただし、ブランチを削除するとプルリクはクローズされます
                            - 手動クローズしたときにリオープンしても追従できます
                            - レビュー記録への影響については  #search: GitHub review logs
                        関連 >> 承認します: #search: GitHub approve
                        関連 >> 指摘と承認: #search: 指摘と承認の心理
                    自動チェック:
                        保護されたブランチ: #keyword: GitHub protected branch  #// 承認を必要とします  #ref: https://docs.github.com/ja/github/administering-a-repository/defining-the-mergeability-of-pull-requests/managing-a-branch-protection-rule
                            作成 >> 保護ルールを設定します:
                                メニュー: GitHub のプロジェクト >> Settings（タブ）>> Branches（左、上から 4番目）>> Add Rule（右）
                                Branch name pattern: master  #// ブランチ名またはそのパターン
                                Require pull request reviews before merging: オン #// マージする前にレビューが必要。コミットはできる
                                以下は、デフォルト:
                                    Required approving reviews: 1  #// 必要なレビューの数
                                    Dismiss stale pull request approvals when new commits are pushed: オフ  #// マージ元に新しいコミットがプッシュされたら、再レビューが必要？
                                    Require review from Code Owners: オフ  #// マージ先のコードのオーナーの承認が必要
                                    Restrict who can dismiss pull request reviews: オフ  #// リポジトリが Organization の一部である場合
                                    Require status checks to pass before merging: オフ  #// 必須ステータスチェックがあるときは、オン
                                    Require branches to be up to date before merging: オフ  #// マージ先を最新にする？
                                Create ボタン:
                                #ref: https://docs.github.com/ja/github/administering-a-repository/defining-the-mergeability-of-pull-requests/managing-a-branch-protection-rule#creating-a-branch-protection-rule
                            関連:
                                ブランチ保護ルール:  #search: GitHub branch protection rule
                                プルリクエスト: #search: GitHub pull request steps
                        必須ステータスチェック: #// 自動テストをパスする必要があります
                            ステータス チェック をパスしないとマージできない設定:  #ref: https://docs.github.com/ja/github/administering-a-repository/defining-the-mergeability-of-pull-requests/managing-a-branch-protection-rule
                        ステータス チェック:  #keyword: GitHub status check,  GitHub pull requests check  #// 自動テスト
                            公式: #ref: https://docs.github.com/ja/github/collaborating-with-pull-requests/collaborating-on-repositories-with-code-quality-features/about-status-checks
                            概要:
                                - git push したり、プルリクエストを生成したりしたら、Web Hook (HTTPS) により GitHub ランナーや Jenkins などに通知されます
                                - 通知を受けたランナーなどはイベントに応じたワークフローを実行します
                                - ステータス チェック の表示内容は、ワークフローの実行結果です
                            操作:
                                実行:  #// ステータス チェック は GitHub Actions の実行結果を表示します
                                    __Project__/.github/workflows/ci.yml : | #keyword: GitHub status check workflow YAML  #// リポジトリ（プロジェクト）に .github フォルダー を作り、GitHub Actions のワークフローを書きます
                                        name: CI  #// ワークフロー名

                                        on: [push, pull_request]  #// トリガー名。git push したときと、プルリクエストを作成・更新したときに jobs を実行します

                                        jobs:
                                            build:                    #// ジョブのシンボル。ジョブを特定するときに使われます
                                                name: Build Project   #// ジョブ名、概要。表示用（未確認）
                                                runs-on: self-hosted  #// ランナーのラベル  #search: GitHub runner config.sh
                                                steps:
                                                -   uses: actions/checkout@v2
                                                -   name: Run a one-line script
                                                    run: echo Hello, world!
                                                -   name: Run a multi-line script
                                                    run: |
                                                        echo Add other commands here
                                                        echo This runs on a self-hosted runner
                                    git push します:
                                        cd  __Project__
                                        git add "."  &&  git commit -m "WIP"  &&  git push
                                    プルリクエストを作ります:
                                        #search: GitHub new pull request
                                    ステータスが表示されます:  #// 自動的に GitHub Actions のジョブが実行され、状況や結果を表示します（ステータス チェック）
                                        画像:  #ref: ${my_images}/2024/GitHub_status_check.png
                                        表示内容:  #focus: build,  pull_request
                                            - CI / build (pull_request)
                                            - CI / build (push)
                                                #template__: __WorkflowName__ / __JobName__ (__TriggetName__)
                                    終わらないとき:
                                        （）Details（右）
                            メモ:
                                Jenkins のプラグインで登録するようです:
                                    GitHubでPullRequestが出ると、Jenkinsでテストした後でEC2に自動デプロイする設定を行った: #ref: https://techblog.recochoku.jp/5299
                                Web API で登録するようです:
                                    Checks API で CI テストを作成する:  #ref: https://docs.github.com/ja/developers/apps/guides/creating-ci-tests-with-the-checks-api
                                    Checks API: #ref: https://docs.github.com/ja/rest/reference/checks
                                Get the combined status for a specific reference: #// 未確認  #ref: https://docs.github.com/ja/rest/reference/repos#get-the-combined-status-for-a-specific-reference
                        自動チェック完了前のマージ:
                            できます。ただし、確実に成功するところまで自動チェックが進んでいること
                    承認します: #keyword: GitHub approve
                        #search: GitHub approve example
                        承認します:
                            プルリク >> File changed タブ >> Review changes（右上）>> Approve >> Submit review
                            #// セルフ レビュー なら Approve などの項目は淡色表示になります
                            #// マージ済みなら Approve などの項目が表示されません
                        承認されたことの確認:
                            Approved になると、プルリクの Conversation タブのページの右上のレビュアーの右に、緑のチェックが付きます
                            ●にマウスを合わせて Awaiting requested review from __User__ と表示されたら未承認です。
                    変更:
                        マージ先のブランチを変える: #keyword: change GitHub pull requests target
                            プルリクのページを開きます >> Edit（右上）>> base（を変えます）
                            #// マージ先が変わるだけです。必要なら別途リベースしてください  #search: Git rebase
                        マージ元のブランチを変える:
                            できません。プルリクを作り直してください
                    マージ:  #keyword: GitHub merge,  GitHub pull requests approved
                        ❗注意: プルリクでマージする前に git rebase しないと コミット グラフ が汚くなります
                        変更を受け入れる人の GitHub アカウントで GitHub にサインインします:
                        GitHub のホームページから変更を受け入れるブランチをブラウザーで開きます:
                            #ref: https://github.com/Takakiriy/collaborate/tree/master
                                #template: https://github.com/__RepositoryGroup__/__RepositoryName__/tree/__BaseBranch__
                        Approved になっているかチェックします:  #search: GitHub approve example
                        Merge pull request ボタン: #🌟
                        （マージする内容の説明）: ____
                        Confirm merge ボタン:
                        #// 承認された後で同じイシューの追加修正をするときは、新しいプルリクエストを作る？
                        マージしたときの コミット メッセージ:  #keyword: pull requests git merge commit message,  Merge pull request from
                            サンプル: |  #// マージ先の gitlog1 に表示されます。以下はプルリクエストした場合です
                                2011-01-31 12:10:00 +0900 123456789  Merge pull request #1122 from owner/branch user
                            表示します:
                                - git status   #// クリーンであること
                                - git checkout develop  #// マージ先(この場合 develop)に切り替えます
                                - gitlog1    #search: gitlog1
                        参考:
                            GitHub のプルリクでマージした場合、fast forwarding にはなりません（git merge の --no-ff オプションと同じ）。
                            理由はおそらく revert しやすくするためでしょう。
                            #ref: https://docs.github.com/ja/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges
                    Revert:  #keyword: GitHub revert  #// マージする前に戻します。マージを取り消します
                        注意: 複数リバートする場合、新しいマージからリバートします
                        概要: プルリクエストでマージした内容をマージする前に戻します。
                            Revert するまでに他のマージがあったときは、そのマージの内容はそのまま残ります。
                        GitHub 手順: #keyword: GitHub revert steps
                            リバートされたかどうか確認します:
                                プルリクエストのページ:  #// で確認する場合
                                    リバートした後でも Revert ボタンはあります。
                                    同じページにリバートしたブランチについて Merged が表示されているかどうかで判断できます。
                                    Revert のブランチに Merged が表示されていたらリバート済みであることを表します。
                                    #ref: ${my_images}/2022/reverted.png
                                Issue のページ:  #// で確認する場合
                                    確認方法: Revert "__PullRequestTitle__" が Merged ならリバート済みです。
                                    マージした順序の確認方法:
                                        プルリクエストのページに表示される下記 __MergedDate__ で判断してください。
                                            __User__ merged commit __CommitID__ into develop on __MergedDate__  [View details] [Revert]
                                        画面に表示されている Merged の並びは、マージした順序ではなく
                                        プルリクエストと Issue を関連付けした日です。
                                    リバートする前後で変わっていない場合:
                            プルリクエストでマージしたマージをリバートします: #keyword: GitHub revert page
                                概要:
                                    リバートするブランチとプルリクエストが作られ、マージするとリバートが実行されます。
                                リバートを開始します:
                                    Revert ボタン（プルリクエストの画面にあるマージの行の右）
                                    #// 新しいプルリクエストを作る画面になります
                                    #// 「Sorry, this pull request couldn’t be reverted automatically.」の
                                    #// エラーが出る場合、新しいマージからリバートしていない可能性が高いです。 #search: GitHub local revert
                                リバートすることに関するコメントを書きます: |
                                    Revert "__PullRequestTitle__"  #// 自動入力されたものをそのまま使います
                                リバートするプルリクエストを作ります:
                                    Create pull request ボタン
                                （参考）自動的に作られるブランチ:
                                    ブランチ名: revert-1-feature（revert-__Num__-__TargetBranch__）
                                    ファイルの内容: リバートした後のファイルの内容
                                （必要なら）レビューをします:
                                    #search: GitHub review
                                （存在するなら）自動テストの成功を確認します:
                                    #search: GitHub Check API
                                自動的に作られたプルリクエストの最初のコメントを編集します: |  #// マージが成功したら編集します。Issue と関連付けします。
                                    Reverts __User__/__Repository__#__PullRequestID__   #// 自動入力されたものをそのまま使います
                                    Issue __User__/__Repository__#__IssueID__  #// 追加します
                                リバートするマージをします:  #search: GitHub merge
                                    Merge pull request ボタン
                                    #// ファイルの内容は revert-1-feature ブランチと同じになります。
                            ローカルでリバートして GitHub に反映させます:  #keyword: GitHub local revert  #// コンフリクトが発生する場合
                                #// コンフリクトが発生する場合、以下の手順が必要です。
                                注意: 複数のマージをリバートするときにコンフリクトが発生する場合、新しいマージからリバートしていない可能性が高いです。
                                    新しいマージがあるときは、GitHub でリバートしてみてください #search: GitHub revert steps
                                注意2: 以下の手順は未確認です
                                (bash): |
                                    git status  #// clean であること
                                    git checkout develop
                                    git pull    #// 直前に GitHub で別のリバートをしたときは必須
                                リバートするマージのコミットID をメモします:
                                    GitHub の場合:
                                        Revert ボタンがある行に コミットID が表示されています:
                                            #ref: ${my_images}/2022/reverted.png?name=revert&x=300&y=287
                                .git フォルダーをバックアップします: |
                                    #// 圧縮します:
                                        cd  __ParentOfDotGit__
                                        tar cvzf  "_tmp.git.tar.gz"  ".git"
                                    #// .git.tar.gz をバックアップの置き場所に移動します:
                                        mv  "_tmp.git.tar.gz" ".."
                                （必要になったら）.git フォルダーをリストアします: |
                                    #// バックアップのファイルをコピーします:
                                        cd  __ParentOfDotGit_
                                        cp  "../_tmp.git.tar.gz" "./.git.tar.gz"
                                    #// リストアします: #copy: restore .git commands
                                        mv ".git" ".git_bk"
                                        tar xvf ".git.tar.gz"
                                        git checkout "."
                                        rm -rf ".git_bk"
                                        rm ".git.tar.gz"
                                        git status
                                        gitlog
                                Revert ブランチを作ります:
                                    git checkout -b "revert-__PullReqestID__-__MergeBranchName__"
                                リバートします:
                                    # git revert __RevertingCommitID__  --mainline 1  --no-edit
                                    git revert 407f2c5  --mainline 1  --no-edit
                                コンフリクトした場合:  #search: git revert conflict
                                    コンフリクトしたファイルを一覧します:
                                    コンフリクトした内容を確認します:
                                        コマンド: cat file.txt
                                        出力: |
                                            merge1 after
                                            <<<<<<< HEAD
                                            merge2 after
                                            merge3 after
                                            =======
                                            merge2 before
                                            merge3 before
                                            >>>>>>> parent of 0002222 (Merge branch 'merge2' into develop)
                                    変更したファイルの内容を表示します:
                                        対象のプリリクエストのページ >> Files changed タブ
                                    以上の情報を元に、revert のコンフリクトを解消します:
                                        Incomming change を採用する可能性が高いです
                                    #// 以上をコンフリクトしたすべてのファイルに対して行います
                                    コミットします: |
                                        git add "."
                                        git commit --no-edit  #// コミット メッセージ は GitHub で Revert ボタンを押したときのものと同じにします
                                以下未確認:
                                プルリクエストを作ります:
                                    #search: GitHub new pull request
                                    タイトル: Revert "__PullRequestTitle__"  #// GitHub で Revert ボタンを押したときのデフォルトと同じにします
                                参考: #ref: https://stackoverflow.com/questions/43221775/git-revert-a-revert-for-a-merge
                            リバートをリバートします: #keyword: GitHub revert of revert #// 再度マージします
                                リバートのリバートを開始します:
                                    Revert したプルリクのページ >> Revert ボタン（プルリクエストの画面にあるマージの行の右）
                                    順番は、リバートした順番と逆（マージした順番と同じ）。
                                    たとえば、A, B, C とマージして、C, B, A とリバートしたら A, B, C とリバートのリバートを実行します。
                                リバートすることに関するコメントを書きます:
                                    デフォルトは、Revert "Revert "__PullRequestTitle__"" です  #// 自動入力されたものをそのまま使います
                                以下は1回目のリバートと同じです:
                                    #search: GitHub revert page
                                （参考）自動的に作られるブランチ:
                                    ブランチ名: revert-2-revert-1-feature（revert-__Num__-revert-__Num__-__TargetBranch__）
                                    ファイルの内容: リバートした後のファイルの内容
                        git revert コマンド:  #// プリリクエストとは関係なくマージを取り消します
                            注意: GitHub プルリクエストを使ってマージしたときは、GitHub で操作してください
                                #search: GitHub revert steps
                            コマンドで実行する場合:
                                #search: git revert
                        補足:
                            - delete branch されていても revert できます
                    リジェクト:  #search: Git rejected branch
                画面:
                    Conversation タブ:
                        最初の会話のテンプレート:  #search: GitHub pull request template
                    Files changed タブ: #keyword: GitHub Files changed
                        _:
                            - マージ ベース からの差分が表示されます  #search: git merge-base
                            - 最新の枝分かれした元のブランチからマージしたときは、そのマージがあったことがコミット一覧に表示されますが、差分は変わりません。
                        ファイルの差分へのリンク: #keyword: GitHub URL pull request diff file
                            相対パスをクリックすると、アドレス バー にそのファイルの diff への URL が表示されます。
                            この URL をクリックしても、その場所にスクロールするまで時間がかかることがあります。
                            ジャンプしても、1つ上のファイルの diff にジャンプすることがあります。
                            相対パスをクリックして、URL をチェックしてください。
                            https://github.com/__Owner__/___Project__/pull/__PullRequestID__/files#diff-__FileDiffID__
                    右:
                        Assignee: レビューを受ける人。書いた人
                概念:
                    マージ:
                        プルリクエストによるマージを一覧します: #keyword: GitHub list pull request merge
                            （関連：マージしたブランチ一覧）:  #search: git merged branches
                            設定: #settings:
                                __OldBranchOrTagName__: release-3.5.x
                                __NewBranchOrTagName__: release-3.6.x
                                __PR_ID__: __PR_ID__
                            __OldBranchOrTagName__ ～ __NewBranchOrTagName__ の間のプルリクエストを一覧します:
                                - git checkout  release-3.6.x  #template: __NewBranchOrTagName__
                                - git log --oneline --pretty=format:"%ad %h %d %s" --date=iso-local | head -n 300 | grep "\(Merge pull request\)\|\(release-3.5.x\)"  #template: __OldBranchOrTagName__
                                #// コミットID を指定することもできます
                            注意:
                                GitHub でスカッシュ マージ を禁止に設定するか、スカッシュ マージ のメッセージも grep でヒットするようにしてください。
                                #search: Squash merge
                            プルリクエスト __PR_ID__ がリバート状態か、リバート of リバート状態かを判定します: |
                                - git checkout  release-3.6.x  #template: __NewBranchOrTagName__
                                - git log --oneline --pretty=format:"%ad %h %d %s" --date=iso-local | head -n 300 | grep "\(Merge pull request \(#\|.*-\)__PR_ID__\)"
                                    #template: __PR_ID__
                            マージの状況を確認したファイルを作ります:
                                merges_YYYY-MM-DD.yaml :
                                    マージの状況:
                                        リリース対象:  #//🌟 最初に対象の __IssueID__ とその __PR_ID__ のツリーを作ります。
                                            __IssueID__:
                                                __PR_ID__: #// ある | ない | リバート状態（ない） | リバート of リバート状態（ある）
                                            __IssueID1__: #//🌟 マージが「ある」ように GitHub で編集します  #search: GitHub merge, GitHub revert
                                                __PR_ID1__: ____
                                                __PR_ID2__: ____
                                            __IssueID2__:
                                        開発環境: #//🌟 ブランチにあるマージのプルリクエストの一覧から開発環境のツリーをここに書きます。
                                            __IssueID1__: #//🌟 マージが「ある」ように GitHub で編集します  #search: GitHub merge, GitHub revert
                                                __PR_ID1__: ____
                                                __PR_ID2__: ____
                                            __IssueID2__:
                                        対象外: #//🌟 ブランチにあるマージのプルリクエストの一覧から対象外のツリーをここに書きます。
                                            __IssueID1__: #//🌟 マージが「ない」ように編集します GitHub で編集します  #search: GitHub merge, GitHub revert
                                                __PR_ID1__: ____
                                                __PR_ID2__: ____
                                            __IssueID2__:
                                    コマンドのログ: |  #//🌟 コマンドの出力にある __PR_ID__ を検索して、上記「マージの状況」のどこかに分類されていること
                                        $ git checkout __NewBranchOrTagName__
                                        $ git log --oneline --pretty=format:"%ad %h %d %s" --date=iso-local | head -n 300 | grep "\(Merge pull request\)\|\(__OldBranchOrTagName__\)"
                                        2022-01-01 11:11:11 +0900 7777777  Merge pull request #__PR_ID__ from __Branch__
                                リリース対象と開発環境にマージが「ある」こと。対象外にマージが「ない」こと:
                                #// ファイルは release issue にアップロードするなどして記録するとよいでしょう
                            マージする内容を確認します:  #// プルリクエストのページを開きます
                                一覧の行から __PullRequestID__ をメモします: |
                                    __CommitID__ Merge pull request #__PullRequestID__ from __Group__/__BranchName__
                                開きます:
                                    __PullRequestID__ のプルリクエストのページを開きます
                            関連:
                                Revert:  #search: GitHub revert
                                develop => release マージ:  #search: Git merge develop release
                                コミットがブランチに含まれているか調べます:  #search: Git commit branch contains
                    コードやコミットID ⇒ プルリクエスト: #keyword: GitHub Commit ID Pull Request
                        コード ⇒ コミットID:  #search: GitLens
                        コミットID ⇒ プルリクエスト:
                            プルリクエストの検索ボックスにコミットIDを入力して検索するだけで
                            プルリクエストを表示できます。
                            プルリクエストに Issue の URL（入力後は#番号のみの表示になります）があると
                            さらに Issue までたどり着けるようになります。
                        ブランチ → ブルリク:
                            gitlog などでブランチから コミットID を調べ、上記 コミットID ⇒ プルリクエスト を調べます
                文書設定: #settings:
                    __CompareBranch__: feature  #// 変更内容が入ったブランチ
                    __BaseBranch__: master  #// 変更を受け入れるブランチ
                    __RepositoryGroup__: Takakiriy
                    __RepositoryName__: collaborate
            Projects タブ:  #search: GitHub project
            Insights タブ:
                Network graph: #keyword: GitHub Network graph
                    コミット履歴をグラフで表示します
            Settings タブ:
                Branches（左）:
                    Default branch:
                    Branch protection rules:  #keyword: GitHub branch protection rule  #search: GitHub branch protect
                        _: マッチしたブランチは、ブランチを削除できなくなります（デフォルト）  #search: allow deletions
                        メニュー: Add Rule（右）または（ルールの）Edit ボタン
                        手順:
                            ブランチをロックします: #keyword: lock GitHub branch steps   #// git push できなくなります。ブランチの削除も拒否します
                                #ref: https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/managing-a-branch-protection-rule
                                lock_test ブランチを作ります:
                                ロックします:  #// また、ブランチの削除も拒否します
                                    GitHub にサインインします:
                                    ブランチの設定画面を開きます:  #search: GitHub branch protection rule
                                        https://github.com/__Account__/__Repository__  >>  Settings タブ >> Branches（左）
                                            または
                                        https://github.com/__Account__/__Repository__/settings/branches
                                    Add Rule ボタン（右）:
                                    Branch name pattern:
                                        サンプル:
                                            -   __BranchName__
                                            -   *__BrandNamePart__*    #// 正規表現ではなくワイルドカードです
                                            -   release-*[0-9x]        #// 末尾が数字か x になっているものが対象です
                                        説明:
                                            #ref: https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/managing-a-branch-protection-rule#about-branch-protection-rules
                                            #ref: https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch
                                        確認方法:
                                            Save した後、もう一度 Edit すると、マッチしたブランチ名の一覧を確認できます
                                    Lock branch: チェック  #// git push できなくなります
                                    Allow force pushes: チェックしない  #// マッチしたブランチはデフォルトで force push できなくなります
                                    Allow deletions: チェックしない  #// マッチしたブランチはデフォルトでブランチを削除できなくなります
                                    Do not allow bypassing the above settings: チェック  #// administrators にもルールを適用します
                                    Create ボタン または Save changes ボタン:
                                    #search: list of GitHub branch protection rule
                                git push できないことを確認します: |  #// エラーメッセージの様子
                                    $ git push
                                    Enumerating objects: 4, done.
                                    Counting objects: 100% (4/4), done.
                                    Delta compression using up to 6 threads
                                    Compressing objects: 100% (2/2), done.
                                    Writing objects: 100% (3/3), 256 bytes | 256.00 KiB/s, done.
                                    Total 3 (delta 1), reused 0 (delta 0), pack-reused 0
                                    remote: Resolving deltas: 100% (1/1), completed with 1 local object.
                                    remote: error: GH006: Protected branch update failed for refs/heads/lock_test.
                                    remote: error: Cannot change this locked branch
                                    To https://github.com/__Account__/__Repository__
                                    ! [remote rejected] lock_test -> lock_test (protected branch hook declined)
                                    error: failed to push some refs to 'https://github.com/__Account__/__Repository__'
                        権限一覧: #keyword: list of GitHub branch protection rule
                            Lock branch:  #// git push できなくなります
                                #search: lock GitHub branch steps
                            Allow force pushes:  #// マッチしたブランチはデフォルトで force push できなくなります
                                #search: lock GitHub branch steps
                            Allow deletions:  #// マッチしたブランチはデフォルトでブランチを削除できなくなります。ここにチェックを入れると削除ができるようになります
                                #search: lock GitHub branch steps
                            Do not allow bypassing the above settings:  #// バイパス権限がある人も拒否する
                                #// 管理者や、ブランチ保護バイパス権限がある人も、保護の設定を有効にします
                                #// free ブランでは、どのアカウントでもバイパス権限を持っている様子
                            署名要求: Require signed commits
                                #// 署名が必要になっても push の拒否はできません
                                #search: register GitHub GPG
                            push できる人を制限します:
                                有料プランのみ対応
                                #ref: https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#restrict-who-can-push-to-matching-branches
                        Create ボタン または Save changes ボタン:
        API: #keyword: GitHub API
            基本:
                #// 未確認
                PAT が無ければ作ります:  #search: GitHub PAT
                    保存場所の例: (@__CLI_Host__) ~/.github/pat-API
                権限 (GitHub PAT scopes): repo
                コマンド: |
                    curl  -H "Authorization: token $( cat ~/.github/pat-API )" \
                        "https://api.github.com/repos/__Owner__/__Repository__/pulls/__PullNum__/reviews"
        概念, 構成:
            （構成）:
                URL:  #search: GitHub code
                リポジトリ:
                    ブランチ:
                        ファイル:
                    リリース:
                アカウント:
            リポジトリ:
                自分のリポジトリ:
                    GitHub: #keyword: GitHub Takakiriy  #ref: https://github.com/Takakiriy/  #ref: ${GitHub}
                    リポジトリを作ります: #search: Git repository
                    MyPrivateCode: #keyword: MyPrivateCode,  my priv  #ref: ${GitHub}/MyPrivateCode  #ref: https://github.com/Takakiriy/MyPrivateCode
                        画像: #keyword: GitHub image URL,  image URL  #ref: ${GitHub}/MyPrivateCode/typrm_images/2023
                            #ref: https://github.com/Takakiriy/MyPrivateCode/tree/master/typrm_images/2023
                    Trials: #keyword:  #ref: ${GitHub}/Trials
                        #ref: https://github.com/Takakiriy/Trials/
                #↓ 仕様
                プライベート: #keyword: GitHub private repository
                    パブリックとの切り替え:
                        リポジトリの Web ページ >> Settings（上）>>（General）>> Danger Zone >> Change visibility ボタン
                数の制限: なし  #ref: https://github.com/pricing
                グルーピング: free プランでは使えません  #ref: https://stackoverflow.com/questions/11852982/can-i-arrange-repositories-into-folders-on-github
                タイム スタンプ:  #keyword: git time stamp
                    リポジトリ全体: |  #ref: https://stackoverflow.com/questions/15918588/github-api-v3-what-is-the-difference-between-pushed-at-and-updated-at/15922637#15922637
                        GET /repos/:owner/:repo
                            "pushed_at": "2011-01-26T19:06:43Z",
                            "created_at": "2011-01-26T19:01:12Z",
                            "updated_at": "2011-01-26T19:14:43Z",
                    ファイル:  #search: git file time stamp
            アカウント: #keyword: GitHub account
                概要:
                    - 個人がGitHubに無料アカウントを2アカウント以上作成すると厳密には利用規約違反になるようです
                        #ref: https://www.google.com/search?q=github+複数アカウント+規約
                    - 「エンタープライズライセンスは利用できない」エラーは、ライセンス数の上限。待てばいい？
                本人:  #// ログイン, 鍵, 通知
                    ログイン トークン:  #keyword: GitHub login token
                        パスワードのみ:
                            2021-08-13 からパスワードのみのログインができなくなります。
                            https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/
                        二要素認証:
                            TOTP アプリで認証します:  #search: TOTP
                            参考: https://docs.github.com/en/github/authenticating-to-github/securing-your-account-with-two-factor-authentication-2fa/configuring-two-factor-authentication
                            登録: #see-above: 参考
                        SSH 公開鍵を設定します: #keyword: GitHub publickey,  GitHub SSH
                            メニュー: https://github.com/settings/keys または
                                https://github.com/ >> アカウント ボタン（右上）>> Settings >> SSH and GPG keys
                            SSH Keys >> New SSH key ボタン:
                                Title: （マシン名など）
                                Key type: Authentication Key
                                Key: （公開鍵の内容） #search: SSH show public key
                                Add SSH key ボタン:
                            接続できないとき: | #// GitHub サーバーに ssh コマンドで接続します
                                $ ssh git@github.com
                                PTY allocation request failed on channel 0
                                Welcome to GitLab, @__UserName__!
                                Connection to github.com closed.
                            #search: SSH
                        PAT(Personal Access Token):  #keyword: GitHub PAT  #// 有効期限がある CI/CD 用以外は非推奨。パスワードの代わりに入力する文字列
                            参考: https://docs.github.com/en/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token
                            アクセス権: （サンプル） repo フル アクセス
                            一覧:
                                https://github.com/settings/tokens
                                    または
                                GitHub リポジトリ >>（アカウント アイコン：右上）>> Settings >> Developer settings（左下）>>
                                    Personal access tokens >> Generate new token
                            作成: #ref: https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic
                                メニュー: PAT 一覧 >> Generate new token（右上）
                                Note: ____
                                Expiration: _____
                                Select scopes:  #search: GitHub PAT scopes
                                    GitHub self hosted runner: workflow
                                Generate token ボタン（下）:
                                （トークンをコピー）:
                                （ローカルの安全な場所にあるメモに貼り付け）:
                                    シェルで使う場合:
                                        ~/.github/pat-API などに保存します
                                トークンを非表示にします:
                                    ブラウザーをリロード 
                        mac のシェルで実行する git を使えるようにします:
                            git clone するとブラウザーが自動的に開いて認証できます。
                            ブラウザーにパスワードを入力すると自動的に PAT が登録されるようです。
                        Recovery codes:
                            Takakiriy:
                                2618d0fc-5d47-4b84-b59d-3f957e0c7df5.8daece73-9f0c-4b0c-b7c6-180789b42f28.ベルフル1.txt
                                6df1c04d-e6e4-40ac-a955-52dc423f311e.d16204fa-24c0-4842-8a8b-e028473fcb13.ベルフル1.png
                    ログイン状態, セッション:
                        メニュー: ログイン >> アカウント ボタン（右上）>> Settings >>（Access）Sessions
                        Web sessions: ブラウザーでログイン中
                        GitHub Mobile sessions: スマホのアプリでログイン中
                    署名, GPG キー 関連: #keyword: register GitHub GPG  #// アカウントの GPG キー を登録します。
                        概要: 書類やコミットに付いている署名に書かれたメールアドレスが秘密鍵によって保証できるようにします（偽装があったらバレます）。
                            メールアドレスの所有者 ⇒ 秘密鍵の所有者 ⇒ 署名を付けた人
                        手順:
                            署名付きコミットをします, その準備をします: #keyword: Git signed commit,  署名付きコミット  Git signature commit
                                CLI の場合:
                                    概要: 
                                        証明するもの: コミットした人
                                            #// コミットに使った GPG キー → GitHub アカウント に登録した GPG キー → GitHub アカウント → 本人
                                        証明しないもの: コミット日時  #// コミット時に限り、実際の日時から変更できます  #search: Git commit date
                                            #// 後でコミット日時も証明する手順への案内があります
                                    準備:
                                        GitHub 用の自分の GPG キー が作業する PC に無ければ作ります:
                                            新規作成する場合:
                                                #search: install GPG
                                            同じ鍵をコピーする場合:
                                                #search: export GPG
                                            バックアップから復帰する場合:
                                                #search: import GPG
                                                #search: Secret Vault USB memory
                                        GitHub に各種設定をします:
                                            GitHub に GPG キー を登録します:  #// 期限切れになった鍵を更新する時は、GitHub への登録を削除してから同じ手順で再登録してください
                                                URL: #ref: https://github.com/settings/keys  >> New GPG key（右）
                                                （または）メニュー: ログイン >> アカウント ボタン（右上）>> Settings >> SSH and GPG Keys（左）>> New GPG key（右）
                                                Title: My-__KeyID__  #// サンプル  #search: gpg --list-secret-keys
                                                GPG の公開鍵をテキスト形式で表示します:
                                                    gpg --armor --export  __KeyID__ | less  #search: export GPG
                                                Key: |
                                                    -----BEGIN PGP PUBLIC KEY BLOCK-----
                                                    ...
                                                    -----END PGP PUBLIC KEY BLOCK-----
                                                Add GPG Key ボタン:
                                            警戒モードを有効にします: #keyword: GitHub Vigilant mode  #// Verified と Partially verified を区別します
                                                URL: #ref: https://github.com/settings/keys  >> Vigilant mode（下）
                                                （または）メニュー: ログイン >> アカウント ボタン（右上）>> Settings >> SSH and GPG Keys（左）>> Vigilant mode（下）
                                                Flag unsigned commits as unverified: オン
                                            GPG キーに登録されたメールアドレスを git に設定します: #keyword: git config GPG
                                                - cd  __Project__
                                                - git config --local user.email  "__EMail__"  #search: GPG email
                                                - git config --local user.name  "__Name__"
                                                #// user.name は違っていても構いませんが設定したほうがよいでしょう。git log では user.name が表示され、GitHub ではアカウント名が表示されます
                                        ローカルの Git が使う GPG キーを設定します: #keyword: Git config gpg.program
                                            (bash):
                                                -   which gpg  #// __GpgExecutableFilePath__ が表示されます
                                                -   gpg --list-secret-keys  #// __KeyID__ が表示されます  #search: gpg --list-secret-keys
                                                -   git config --global gpg.program  "__GpgExecutableFilePath__"  #// which gpg
                                                -   git config --global user.signingkey "__KeyID__"
                                                -   cd __Project__
                                                    git config --local commit.gpgsign true
                                    コミットに署名を付けます:
                                        commit.gpgsign = true の場合:
                                            手順:
                                                - git add ____
                                                - export GPG_TTY=$(tty)
                                                - git commit -m "Signed commit"  #// 通常のコマンドから変更なし
                                                    #// パスワードの入力が求められます
                                                - git push
                                            しなかったときの エラー メッセージ: |
                                                error: gpg failed to sign the data:
                                                gpg: signing failed: Inappropriate ioctl for device
                                        それ以外の場合:
                                            - git add ____
                                            - git commit -S -m "Signed commit"  #// -S オプションを追加しないと署名は付きません
                                                #// パスワードの入力が求められます
                                            - git push
                                    #ref: https://qiita.com/s6n/items/bb869f740a53a3bf169e
                                WebUI の場合:
                                    証明するもの: コミットした人
                                        #// コミットに使った GitHub アカウント → 本人
                                    ログインします:
                                    準備:
                                        #// 未確認
                                        警戒モードを有効にします:  #// Verified と Partially verified を区別します
                                            #search: GitHub Vigilant mode
                                    ファイルを編集します:
                                    コミットします:
                                    #// 以上でコミットに署名が付きます
                            署名を確認します:
                                git push 前, git log の場合: #keyword: git log --show-signature
                                    コマンド:
                                        git log --show-signature
                                            または
                                        git show  --show-signature
                                    表示: |  #focus: using RSA key,  takakiriy@gmail.com,  19:00:00
                                        commit 7c512ee242146b51a220bc7a653bde4a87976e1f (HEAD -> main, origin/main)
                                        gpg: Signature made Sat Dec 24 00:57:02 2022 JST
                                        gpg:                using RSA key 37FF980CF5F2E902A7BC7840E8099F204C43E3F7
                                        gpg: Good signature from "Takakiri <takakiriy@gmail.com>" [ultimate]
                                        Author: Tak <takakiriy@gmail.com>
                                        Date:   Fri Dec 23 19:00:00 2022 +0900

                                            commit message 1

                                        __NextCommit__
                                        __NextCommit__
                                        ...
                                    表示の解説:
                                        上記は下記のコマンドで日付を詐称していますが署名の日時は詐称されていません。
                                        git commit --amend --no-edit --date="2022-12-23 19:00:00 +0900"
                                        #ref: https://stackoverflow.com/questions/68764231/can-someone-check-i-changed-the-date-of-git-commits
                                git push 後, GitHub の場合: #keyword: show GitHub signed commit
                                    メニュー: GitHub >> ... >>（コミット一覧）  #ref: https://github.com/Takakiriy/signatures/commits/main
                                    サンプル: #ref: https://github.com/Takakiriy/signatures/commits/main
                                    キー ID:  Verified ラベル をクリック
                                    表示されるアイコン: 署名の有無にかかわらず、メールアドレスから表示しています
                                    表示されるラベル:
                                        Verified:  #// 署名付きコミット
                                            - 署名付きコミットである && コミットの署名のメールアドレスが GitHub の GPG キー に登録済み。
                                            - 対応する秘密鍵によって署名されたコミットは、公開鍵が削除されても、引き続き検証済みとして表示されます。
                                                #ref: https://docs.github.com/en/authentication/managing-commit-signature-verification/adding-a-gpg-key-to-your-github-account
                                            - ただし、GitHub に登録されているキーが期限切れの場合、Verified をクリックすると Expired（青）が表示されます。
                                                GitHub に GPG キー を再登録してください  #search: Git signed commit
                                        Partially verified: コミッターではない場合
                                        Unverified: 検証できず
                                    表示される日時: 署名された日時
                            コミット日時を証明します:
                                #search: Git commit date
                            （必要なら）キー サーバー に登録します:  #search: synchronizing key server
                            GPG 署名関連: #search: GPG 署名
                        キー サーバー: #keyword: synchronizing key server,  SKS キー サーバー
                            概要: 公開鍵を登録するサーバー。追加のみで削除はできない。
                                有効な キーID であることを示すだけであれば、GitHub などに登録するだけでよい。 #search: show GitHub signed commit
                            脆弱性:
                                証明書ポイズニング: #ref: https://japan.zdnet.com/article/35139514/
                                    大量の署名や証明書によって攻撃対象の証明書を汚染するというこの攻撃を受けると、
                                    検証処理時の負荷が増大し、暗号学的認証が適切に機能しなくなる。
                                    DoS 攻撃 に近い。
                    アカウント設定 >> 通知設定: #keyword: GitHub notifications
                        GitHub からの通知をブラウザーで表示します:
                            メニュー: https://github.com/settings/notifications
                            Automatic watching >>（各種）: チェック
                            （各種）>> Web : チェック
                            Email notification preferences >> Include your own updates: チェック
                メンバー: #keyword: GitHub member  #// オーナーの一員または編集員
                    アカウント メンバー:
                        一覧: https://github.com/__Account__  >>  People タブ
                        追加:
                            新規 DSアカウント:
                                DS アカウントで GitHub Enterprise に通常ログインしたら GitHub のアカウントが作成されます。
                                作成されたら既存の GitHub アカウントによる手順ができるようになります。
                            既存 DSアカウント:
                                （organization の Web ページ）>>（People の）Add member（右）>>（アカウント名などを入力）>> Add >>
                                Member or Owner #// Member ではブランチの新規作成はできません
                        アクセス権:
                            Owner の場合: フル アクセス
                            Member の場合:
                                表示: https://github.com/__Account__  >>  People タブ >>（メンバー名）>>（リポジトリ名の行の）Manage access
                        コミットした人を一覧します: #keyword: GitHub Insights Pulse
                            #ref: ${my_images}/2022/GitHubInsight.png
                            プロジェクト >> Insights タブ >> Pulse
                            #// 署名されていない名前で一覧されます  #search: git log --show-signature
                    Organizations:
                        操作:
                            Organization を新規作成して admin 権限を与えます: #keyword: GitHub Organization
                                #// Organization を新規作成してプロジェクトをそこへ移動し、コラボレーター（メンバー）に admin 権限を与えます
                                #// GitHub Organization を使っても無料です https://github.co.jp/pricing.html >> Free プラン
                                #// 個人アカウントの所有者では admin 権限を設定できません
                                参考: SELECK >> Organization とアクセス管理
                                    https://seleck.cc/655
                                設定: #settings:
                                    __GitHubOwnerAccount__: Takakiriy  #// リポジトリのオーナーのアカウント名
                                    __GitHubCollaboratorAccount__: Takakiri1  #// リポジトリにアクセスするユーザーのアカウント名
                                    __Organization__: SagePlaisir  #// GitHub の Organization 名
                                    __RepositoryGroup__: SagePlaisir  #// __GitHubOwnerAccount__ または __Organization__
                                    __RepositoryName__ : collaborate2
                                    __RegionID__: ap-northeast-1  #// Amplify Console リソースの AWS のリージョン ID
                                    __OwnerMail__: user@example.com
                                所有者の GitHub アカウントでサインインします:
                                    メニュー: https://github.com/ >> 三（右上） >> Sign in
                                    Sign in ページ:
                                        Username or email address: Takakiriy  #template: __GitHubOwnerAccount__
                                        Password: ____
                                        Sign in ボタン:
                                Organization を新規作成します:
                                    メニュー: https://github.com/ >> ＋（右上の＋、アカウントのアイコンの左）>> New organization >>
                                        Join for free
                                    Organization account name: SagePlaisir  #template: __Organization__
                                    Contact email: user@example.com  #template: __OwnerMail__
                                    This organization belongs to: My personal account
                                    Next ボタン:
                                    Add organization members: Takakiri1  #template: __GitHubCollaboratorAccount__
                                    Complete setup ボタン:
                                    Password: __Password_of_Takakiriy__  #template: ___GitHubOwnerAccount___
                                    アンケートに答えます:
                                コラボレーターが Organization に参加する手続きをします:
                                    （初回のみ）:
                                        GitHub からメールが送られてきます:
                                        Join @SagePlaisir ボタン:  #template: __Organization__
                                        Join SagePlaisir ボタン:  #template: __Organization__
                                （既存の個人アカウントにあるリポジトリを移動（インポート）する場合）:
                                    既存のリポジトリ collaborate2 を SagePlaisir にインポートします:  #template: __RepositoryName__ を __Organization__ に
                                        メニュー:
                                            - https://github.com/SagePlaisir >>  #template: __Organization__
                                            - Create a new repository >> Import a repository
                                        Your old repository’s clone URL: https://github.com/Takakiriy/collaborate2
                                            #template: __GitHubOwnerAccount__/__RepositoryName__
                                        Your new repository details: SagePlaisir/collaborate2
                                            #template: __Organization__/__RepositoryName__
                                        Privacy: Private
                                        Begin import ボタン:
                                        Password: __Password_of_Takakiriy__  #template: ___GitHubOwnerAccount___
                                （新しくリポジトリを作成する場合）:
                                    SagePlaisir にリポジトリを新規作成します:  #template: __Organization__
                                        メニュー: https://github.com/SagePlaisir >> Create a new repository または（Repositories）New （左上）
                                        Repository name: collaborate2  #template: __RepositoryName__
                                        Public or Private: Private
                                        Create repository ボタン:
                                        ブラウザーを閉じます:
                                コラボレーターに admin 権限を与えます（所有者が操作）:
                                    admin 権限を持つコラボレーターを招待します:
                                        メニュー:
                                            - https://github.com/SagePlaisir/collaborate2 >>  #template: https://github.com/__RepositoryGroup__/__RepositoryName__
                                            - Setting (タブ) >> Manage access（左）>> Invite teams or people
                                        username: Takakiri1  #template: __GitHubCollaboratorAccount__
                                        Choose a role: Admin  #// Write ロールは git push ができます。後で Write などに変更できます
                                        Add Takakiri1 to this reposiroty ボタン:  #// __GitHubCollaboratorAccount__
                                    招待を受けた人は招待を受け入れます:
                                        - 届いたメールにあるボタンを押します
                                        - View invitation >> Accept invitation
                                OAuth App として Organization を承認します:
                                    メニュー: https://github.com/ >>（アカウントのアイコン）（右上）>> Settings >>
                                        Applications（左下）>> Authorized OAuth Apps（タブ）>>
                                        AWS Amplify (ap-northeast-1) >> （SagePlaisir の右の）Grant
                                            #template: WS Amplify (__RegionID__) >> （__RepositoryGroup__ の右の）Grant
                                    （AWS Amplify が表示されないとき）:
                                        （コラボレーターが）OAuth App として Organization を承認することを要求します:
                                            参考:
                                                - OAuth App に対する Organization の承認をリクエストする
                                                    https://docs.github.com/ja/free-pro-team@latest/github/setting-up-and-managing-your-github-user-account/requesting-organization-approval-for-oauth-apps
                                                - Organization 用の OAuth アプリケーションの承認
                                                    https://docs.github.com/ja/free-pro-team@latest/github/setting-up-and-managing-organizations-and-teams/approving-oauth-apps-for-your-organization
                                            メニュー: https://github.com/ >>（コラボレーターのアカウントのアイコン）（右上）>> Settings >>
                                                Applications（左下）>> Authorized OAuth Apps（タブ）>>
                                                AWS Amplify (ap-northeast-1) >> （SagePlaisir の右の）Request access
                                                    #template: WS Amplify (__RegionID__) >> （__RepositoryGroup__ の右の）
                                                #// Amplify プロジェクトで hosting カテゴリーを追加したら上記 AWS Amplify の項目が表示されます
                                    （所有者が）OAuth App として Organization を承認します:
                                            メニュー: https://github.com/ >>（コラボレーターのアカウントのアイコン）（右上）>> Settings >>
                                                Applications（左下）>> Authorized OAuth Apps（タブ）>>
                                                AWS Amplify (ap-northeast-1) >> （SagePlaisir の右の）Grant
                                                    #template: WS Amplify (__RegionID__) >> （__RepositoryGroup__ の右の）Grant
                                （admin 権限が不要になったら）コラボレーターを write 権限に変更します:
                                    - https://github.com/SagePlaisir/collaborate2 >>  #template: https://github.com/__RepositoryGroup__/__RepositoryName__
                                    - Setting (タブ) >> Manage access（左）
                                    - （Takakiri1 の） Role: Write  #template: __GitHubCollaboratorAccount__
                                （不要になったら）Organization を削除します:
                                    メニュー: https://github.com/ >> （アカウントのアイコン）（右上）>> Your organizations >>
                                        SagePlaisir >> Settings >> Delete this organization（最も下）
                            コラボレーターを個人リポジトリに招待します:
                                #コラボレーターは Organization の Write 権限になるようです
                                参考: GitHub >> コラボレーターを個人リポジトリに招待する
                                    https://docs.github.com/ja/free-pro-team@latest/github/setting-up-and-managing-your-github-user-account/inviting-collaborators-to-a-personal-repository
                                設定: #settings:
                                    __GitHubOwnerAccount__: Takakiriy  #// リポジトリのオーナーのアカウント名
                                    __RepositoryName__: collaborate
                                    __GitHubCollaboratorAccount__: Takakiri1  #// コラボレーターとして招待する人のユーザ名
                                GitHub にサインインします:
                                    メニュー: https://github.com/ >> 三（右上） >> Sign in
                                    Sign in ページ:
                                        Username or email address: Takakiriy  #template: __GitHubOwnerAccount__
                                        Password: ____
                                        Sign in ボタン:
                                メニュー:
                                    - https://github.com/Takakiriy/collaborate >>  #template: https://github.com/__GitHubOwnerAccount__/__RepositoryName__
                                    - Setting (タブ) >> Manage access（左）>> Invite a collaborator
                                招待する人: Takakiri1  #template: __GitHubCollaboratorAccount__
                                Add NAME to REPOSITORY ボタン:  #// 押すとリポジトリへの招待メールが発送されます
                                招待を受けた人は招待を受け入れます:
                                    - 届いたメールにあるボタンを押します
                                    - View invitation >> Accept invitation
                                所有者の Manage access のページに表示される招待したユーザーが Pending 状態の表示ではなくなります:
                                #// 参考：下記「所有者権限が必要な手続きの例」
                            所有者権限が必要な手続きの例:  #// コラボレーターが Amplify Console に CI/CD環境を構築するときに必要です
                                設定: #settings:
                                    __AWS_AccountID__: 654584571574  #
                                    __AWS_UserName__: user2
                                    __GitHubOwnerAccount__: Takakiriy  #// リポジトリのオーナーのアカウント名
                                    __Organization__: SagePlaisir  #// GitHub の Organization 名（Organization を使う場合のみ必要）
                                    __RepositoryGroup__: SagePlaisir  #// __GitHubOwnerAccount__ または __Organization__
                                    __RepositoryName__: collaborate2
                                    __GitHubCollaboratorAccount__: Takakiri1  #// コラボレーターとして招待する人のユーザ名
                                    __RegionName__: 東京  #// CodePipeline のパイプラインを作成するリージョンの名前
                                    __RegionID__: ap-northeast-1  #// __RegionName__ の ID
                                    __AmplifyUser__: collaborate2-amplify  #// Amplify 用 IAM ユーザー、Amplify CLI で必要な権限を持つ
                                    __AmplifyUserAccessKeyID__: AAAABBBB  #// 手順内でメモする値
                                    __AmplifySecretAccessKey__: CCCCDDDD  #// 手順内でメモする値
                                    __AWS_AdministratorGroup__: AdministratorGroup
                                    __CLI_Profile__: collaborate2-amplify  #// aws 関連の CLI のプロファイル名
                                    __GitCollaboratorName__: Your Name2  #// git log コマンドで表示されるユーザー名
                                    __GitCollaboratorMail__: you2@example.com  #// git log コマンドで表示されるメールアドレス
                                準備:
                                    参考:
                                        - AMPLIFY SNS WORKSHOP
                                            https://amplify-sns.workshop.aws/ja/
                                        - 継続的デプロイを使用した静的ウェブホスティング
                                            https://aws.amazon.com/jp/getting-started/hands-on/build-serverless-web-app-lambda-apigateway-s3-dynamodb-cognito/module-1/
                                    ローカルPCへ各種ソフトウェアをインストールします:
                                        Node.js をインストールします:
                                            - https://nodejs.org/ja/download/ >> Windows Installer (.msi) >> 64-bit
                                            - node-v12.19.0-x64.exe をダブルクリックします
                                            - インストール オプションはデフォルトを使用
                                        Git for Windows をインストールします:
                                            - https://git-scm.com/ >> Downloads >> Windows
                                            - Git-2.29.0-64-bit.exe をダブルクリックします
                                            - Next を8回押す
                                            - Configuring the line ending conversions: Checkout as-is, commit as-is
                                            - 他のインストール オプションはデフォルトを使用
                                            - デスクトップを右クリック >> Git Bash Here
                                            - git clone  "https://github.com/githubtraining/hellogitworld.git"
                                            - 成功したら、デスクトップにある hellogitworld フォルダーを削除します ( rm -rf hellogitworld )
                                            - Git のユーザー名を設定します:
                                                - git config --global user.email "you2@example.com"  #template: "__GitCollaboratorMail__"
                                                - git config --global user.name  "Your Name2"        #template: "__GitCollaboratorName__"
                                            - Git bash を閉じます:
                                （まだリポジトリがないなら）Git リポジトリを作成します（所有者）:
                                    GitHub のアカウントを作成します:
                                    GitHub にサインインします:
                                        メニュー: https://github.com/ >> 三（右上） >> Sign in
                                        Sign in ページ:
                                            Username or email address: Takakiriy  #template: __GitHubOwnerAccount__
                                            Password: ____
                                            Sign in ボタン:
                                        ブラウザーを閉じます:
                                    （個人アカウントに作る場合）GitHub にリポジトリを新規作成します:
                                        リポジトリを作成します:
                                            メニュー: https://github.com/ >>（Repositories）New （左上）
                                            Repository name: collaborate2  #template: __RepositoryName__
                                            Public or Private: Private
                                            Create repository ボタン:
                                            ブラウザーを閉じます:
                                    （Organizationsに作る場合）GitHub にリポジトリを新規作成します:
                                        リポジトリを作成します:
                                            メニュー: https://github.com/ >>（アカウントのアイコン）（右上）>> Your Organizations >>
                                                SagePlaisir >> New（右上）または Create a new repository  #template: __Organization__
                                            Repository name: collaborate2  #template: __RepositoryName__
                                            Public or Private: Private
                                            Create repository ボタン:
                                            ブラウザーを閉じます:
                                （まだ招待していないなら）コラボレーターをプロジェクトに招待します（所有者）:
                                    参考: GitHub >> コラボレーターを個人リポジトリに招待する
                                        https://docs.github.com/ja/free-pro-team@latest/github/setting-up-and-managing-your-github-user-account/inviting-collaborators-to-a-personal-repository
                                    メニュー:
                                        - Takakiriy アカウントでサインインしていること:  #template: __GitHubOwnerAccount__
                                        - https://github.com/SagePlaisir/collaborate2 >>  #template: https://github.com/__RepositoryGroup__/__RepositoryName__
                                        - Setting (タブ) >> Manage access（左）>> Invite a collaborator
                                    招待する人: Takakiri1  #// __GitHubCollaboratorAccount__
                                    （個人アカウントのリポジトリの場合）:
                                        Add NAME to REPOSITORY ボタン:  #// 押すとリポジトリへの招待メールが発送されます
                                        招待を受けた人は招待を受け入れます:
                                            - 届いたメールにあるボタンを押します
                                            - View invitation >> Accept invitation
                                        Manage access のページに書かれた Takakiri1 ユーザーがクリックできるようになります:  #// __GitHubCollaboratorAccount__
                                    （Organizationsのリポジトリの場合）:
                                        Choose a role: Write  #// Write ロールは git push ができます。後で変更できます
                                        Add Takakiri1 to this reposiroty ボタン:  #// __GitHubCollaboratorAccount__
                                        #// メールは送られません
                                React のプロジェクトを作成します（コラボレーター）:
                                    GitHub にサインインします（コラボレーター）:
                                        メニュー: https://github.com/ >> 三（右上） >> Sign in
                                        Sign in ページ:
                                            Username or email address: Takakiri1  #template: __GitHubCollaboratorAccount__
                                            Password: ____
                                            Sign in ボタン:
                                        ブラウザーを閉じます:
                                    Git のプライベート リポジトリに接続してダウンロード（クローン）します:
                                        #Git bash:
                                        - cd  "__ParentOfProject__"
                                        - git clone "https://github.com/SagePlaisir/collaborate2.git"  #template: https://github.com/__RepositoryGroup__/__RepositoryName__.git
                                            #// ここでエラーになるときは Git をアンインストール＆インストールしてください
                                        - Sign in with your browser ボタン:  #// プライベート リポジトリのときだけこのボタンが表示されます
                                            - 表示されたアカウント名を確認: wants to access your Takakiri1 account
                                                #template: wants to access your __GitHubCollaboratorAccount__ account
                                            - Authorize GitCredentialManager ボタン:
                                        - 成功したらブラウザーを閉じます:
                                    React のプロジェクトを新規作成してコミットします（リポジトリの内容がまだないとき）:
                                        #Git bash
                                        - cd  "__ParentOfProject__"
                                        - npx create-react-app  "collaborate2"  #template: "__RepositoryName__"
                                            #// npx create-react-app --template typescript  "collaborate2"  #template: "__RepositoryName__"
                                        - cd  "collaborate2"  #template: "__RepositoryName__"
                                        - git add "."
                                        - git commit -a -m "Create new React application"
                                        - git push
                                        - Git bash を閉じます
                                    React のプロジェクトに Amplify を追加します:
                                        aws のアカウントを作成します:
                                        aws にサインインしてリージョンを選択します:
                                            AWS マネジメント コンソールにサインインします:
                                                URL: https://console.aws.amazon.com/
                                                （ユーザー）: IAM ユーザー
                                                アカウントID: 654584571574  #template: __AWS_AccountID__
                                                次へ ボタン:
                                                ユーザー名: user2  #template: __AWS_UserName__
                                                パスワード: __AWS_UserPassword__
                                                サインイン ボタン:
                                            リージョン: 東京 （右上） #template: __RegionName__
                                            ブラウザーを閉じます:
                                        Amplify CLI をインストールしてセットアップします:
                                            参考:
                                                - Install the Amplify CLI
                                                    https://docs.amplify.aws/cli/start/install#option-1-watch-the-video-guide
                                                - AMPLIFY SNS WORKSHOP >> INSTALL & CONFIGS
                                                    https://amplify-sns.workshop.aws/ja/00_prerequisites/20_install_and_configs.html
                                            Amplify CLI をインストールします:
                                                #Git bash
                                                #//任意のフォルダーで
                                                - npm install -g @aws-amplify/cli
                                                - amplify -v  #// 4.30.0
                                            Amplify CLI をセットアップします:
                                                起動コマンド:
                                                    #Git CMD  (Git bash では設定ができません。Windows キー + Git CMD + クリック)
                                                    - amplify configure
                                                ブラウザーが開くので、サインインできていることを確認したら閉じます:
                                                amplify configure の続きを表示します（Enter キーを押します）:
                                                region: ap-northeast-1  #template: __RegionID__
                                                user name: collaborate2-amplify  #template: __AmplifyUser__
                                                (ブラウザーが開きます):
                                                    メニュー: ユーザー >> ユーザーを追加
                                                    ユーザー名: collaborate2-amplify  #template: __AmplifyUser__
                                                    アクセスの種類:
                                                        チェック:
                                                            プログラムによるアクセス
                                                        チェックしない:
                                                            AWS マネジメントコンソールへのアクセス:
                                                        次のステップ ボタン:
                                                    ユーザーをグループに追加:
                                                        選択するグループ（にチェックを入れます）:
                                                            - AdministratorGroup  #template: __AWS_AdministratorGroup__
                                                        次のステップ ボタン:
                                                    タグの追加:
                                                        次のステップ ボタン:
                                                    確認:
                                                        ユーザーの作成 ボタン:
                                                    アクセスキーをメモします:
                                                        アクセスキー ID: AAAABBBB  #template: __AmplifyUserAccessKeyID__
                                                        シークレットアクセスキー: CCCCDDDD  #template: __AmplifySecretAccessKey__
                                                        閉じる ボタン（右下）:
                                                    ブラウザーを閉じます:
                                                amplify configure の続きを表示します（Enter キーを押します）(2):
                                                accessKeyId: AAAABBBB  #template: __AmplifyUserAccessKeyID__
                                                secretAccessKey: CCCCDDDD  #template: __AmplifySecretAccessKey__
                                                Profile Name: collaborate2-amplify  #template: __CLI_Profile__
                                        React のプロジェクトに Amplify を追加します:
                                            参考: AMPLIFY SNS WORKSHOP >> BOOTSTRAP
                                                https://amplify-sns.workshop.aws/ja/30_mock/00_bootstrap.html
                                            起動コマンド:
                                                #Git CMD  (Git bash では設定ができません。Windows キー + Git CMD + クリック)
                                                - cd  "collaborate2"  #template: "__RepositoryName__"
                                                - amplify init
                                            Enter a name for the project: collaborate2  #// そのまま Enter  #template: __RepositoryName__
                                            Enter a name for the environment: production
                                            Choose your default editor: Visual Studio Code  #// そのまま Enter
                                            Choose the type of app that you're building: javascript  #// そのまま Enter. TypeScript の場合でも
                                            What javascript framework are you using: react  #// そのまま Enter
                                            Source Directory Path: src  #// そのまま Enter
                                            Distribution Directory Path: build  #// そのまま Enter
                                            Build Command: npm.cmd run-script build  #// そのまま Enter
                                            Start Command: npm.cmd run-script start  #// そのまま Enter
                                            Do you want to use an AWS profile?: Y (Yes)  #// そのまま Enter
                                            Please choose the profile you want to use: collaborate2-amplify  #template: __CLI_Profile__
                                コラボレーターが Amplify Console に CI/CD環境を構築します:
                                    Amplify hosting のカテゴリーを追加します:
                                        コマンド:
                                            #Git CMD  (Git bash では設定ができません。Windows キー + Git CMD + クリック)
                                            - cd "collaborate2"  #template: "__RepositoryName__"
                                            - amplify add hosting
                                        Select the plugin module to execute: Hosting with Amplify Console (...)
                                        Choose a type Manual deployment: Continuous deployment
                                        (ブラウザーが開きます):
                                            Connect a frontend web app: GitHub
                                            Continue ボタン:
                                                (aws と GitHub の接続がされていなかったとき):
                                                    表示されたアカウント名を確認: wants to access your Takakiri1 account
                                                        #template: wants to access your __GitHubCollaboratorAccount__ account
                                                    Authorize GitCredentialManager ボタン:
                                            リポジトリブランチの追加:
                                                リポジトリ: SagePlaisir/collaborate2  #template: __RepositoryGroup__/__RepositoryName__
                                エラーメッセージ: |
                                    Amplify Console requires you to have admin access to the repository
                                （Organizations のリポジトリの場合）コラボレーターに admin 権限を与えます（所有者）:
                                    #// 個人アカウントの所有者では admin 権限を設定できません
                                    所有者として GitHub にサインインします:
                                        メニュー: https://github.com/ >> 三（右上） >> Sign in
                                        Sign in ページ:
                                            Username or email address: Takakiriy  #template: __GitHubOwnerAccount__
                                            Password: ____
                                            Sign in ボタン:
                                        ブラウザーを閉じます:
                                    コラボレーターに admin 権限を与えます:
                                        - https://github.com/SagePlaisir/collaborate2 >>  #template: https://github.com/__RepositoryGroup__/__RepositoryName__
                                        - Setting (タブ) >> Manage access（左）
                                        - （Takakiri1 の） Role: Admin  #template: __GitHubCollaboratorAccount__
                                    OAuth App として Organization を承認します:
                                        参考: OAuth App に対する Organization の承認をリクエストする
                                            https://docs.github.com/ja/free-pro-team@latest/github/setting-up-and-managing-your-github-user-account/requesting-organization-approval-for-oauth-apps
                                        メニュー: https://github.com/ >>（アカウントのアイコン）（右上）>> Settings >>
                                            Applications（左下）>> Authorized OAuth Apps（タブ）>>
                                            AWS Amplify (ap-northeast-1) >> （SagePlaisir の右の）Grant
                                                #template: WS Amplify (__RegionID__) >> （__RepositoryGroup__ の右の）Grant
                                クリーンアップ（管理者が操作）:
                                    Organization を削除します:
                                        #// 注意: Organization にあるすべてのリポジトリも削除されます
                                        メニュー: https://github.com/ >> （管理者のプロフィール写真） >>
                                            Your organizations >> SagePlaisir >> Settings >>
                                            Delete this organization
                                    OAuth App として Organization の承認を削除します:
                                        メニュー: https://github.com/ >>（アカウントのアイコン）（右上）>> Settings >> Applications（左下）>>
                                        Authorized OAuth Apps （タブ）:
                                            - AWS Amplify (ap-northeast-1) >> … >> Revoke
                                                #template: WS Amplify (__RegionID__)
                                            - Git Credential Manager >> … >> Revoke >> I understand, revoke access
                                    IAM の削除:
                                        - https://console.aws.amazon.com/iam/ >> ユーザー:
                                            - collaborate2-amplify の左にチェック >> （必要なら）ユーザーの削除
                                                #template: __AmplifyUser__
                        概念:
                            Organization:
                                ロール:  #// 役割, 権限
                                    メニュー: GitHub Web >> アカウント アイコン（右上）>> Your organizations
                                    表示内容: __Organization__  __Role__
                                    値: owner, admin, member
                                ランナー:  #search: GitHub runner within organization
                    Enterprise:
            ブランチ: #keyword: GitHub branch
                追加:  #search: GitHub new file
                ブランチ保護:
                    #search: GitHub branch protection rule
            コミット:
                コミット一覧: #keyword: GitHub commit list
                    GitHub >> Code >>（ブランチの選択：ファイル一覧の左上）>> commits（ファイル一覧の右上）
                コミット:
                    編集内容（diff）: #keyword: GitHub commit contents
                        https://github.com/__Owner__/__Project__/commit/__CommitID__#diff-__DiffID__
                    コメント: #keyword: GitHub commit comment  #// コミットのファイル差分にコメントを付けることができます
                        追加:  #search: add comment in GitHub diff
                        一覧:
                            できません。コミットのページの最も下に、（レビュアー名）で検索してくださいと書くとよいでしょう
                        一般的な コミット メッセージ のサンプル:  #search: git commit message example
                履歴:
                    Network graph: #search: GitHub Network graph
            ファイル:  #// 編集できます
                追加:  #keyword: GitHub new file  #// 新しいファイルを作ります
                    新しいブランチを作ります:  #keyword: GitHub new branch
                        メニュー: （対象のリポジトリの Web ページ）>> _ branches（ファイル一覧の上左）>> New branch（右上）>>
                        New branch name: __NewBranch__
                        Source: __SourceBranchName__
                        Create new branch ボタン（右下）:
                    ブランチを選びます:
                        （対象のリポジトリの Web ページ）>>（ブランチのブルダウンを選ぶ：ファイル一覧の上左）
                    作る場所に移動します:
                        （フォルダーをクリック）
                    新しいファイルを作ります:
                        メニュー: Add file（ファイル一覧の上右）
                        以下のいずれか:
                            Create new file:
                                （ファイル名：上）:
                                （内容を編集します）:
                                Commit changes ボタン（右上）:
                                Commit message: ____
                                Commit directly to the new1 branch: チェック
                                Commit changes ボタン:
                                （ブラウザーのリロード）:
                            Upload files:
                                #// 未確認
            リリース: #keyword: GitHub release tag  #// タグのうち、主なリリースに関するタグについて、一覧と文章を追加します
                タイトルを決めます:  #// バージョン名
                    ____
                数行のリリース文章を決めます:
                    ____
                    ____
                追加: #// リリースを追加します
                    メニュー: （GitHub のプロジェクトのページ）>> Releases（右）>> Draft a new release（右上）
                    タグ: ____  #search: Git tag
                    タイトル: ____
                    リリース文章: ____
                    Publish Release ボタン:
            Dependabot: #// セキュリティ更新プログラムのプルリクを作るボット  #ref: https://docs.github.com/ja/code-security/dependabot/dependabot-security-updates/configuring-dependabot-security-updates
        GitHub Actions: #keyword: GitHub Actions,  GitHub CI/CD  #ref: https://github.blog/2021-11-04-10-github-actions-resources-basics-ci-cd/
            手順:
                追加:  #// GitHub Actions のワークフローを追加します
                    サンプル プロジェクト:  #search: brebase  #ref: https://github.com/Takakiriy/brebase/actions
                    （必要なら）ブランチを新規作成します:  #// 以下で追加する設定ファイルが入ります
                        git checkout -b __NewBranch__
                        git push --set-upstream origin __NewBranch__
                    メニュー: （リポジトリ）>> Actions（タブ）>>（2回目以降では）New workflow >>（Simple workflow の）Configure >>
                        （ブランチの選択：左上）>>（discard には OK）
                        #// ここで指定したブランチ、または新規ブランチに、下記の設定ファイルを追加します（どちらのブランチかは後で指定します）
                        #// 下記の設定ファイルが作られます
                    設定ファイル:  #keyword: GitHub Actions YAML,  GitHub workflow .yml
                        場所の例: __Project__/.github/workflows/blank.yml  #keyword: __Project__/.github/workflows/__WorkflowName__.yml  #// .github/workflows の中
                        サンプル: |
                            name: CI  #// アクション名。複数の設定ファイルのグループ名
                            on:  #// いつ実行するか
                                #↓ 子フィールドを持たない場合
                                [push]
                                    #// または
                                [push, pull_request]
                                #↓ 子フィールドを持つ場合
                                push:
                                    branches: [ "main", "__OtherBranch__" ]  #// main ブランチを git push したとき
                                pull_request:
                                    branches: [ "main", "__OtherBranch__" ]  #// main ブランチに対するプルリクエストを作ったとき
                                workflow_dispatch:  #// 手動起動を許可します。Actions タブから起動します
                            jobs:
                                build:  #// build という名前のジョブ
                                    runs-on: ubuntu-latest  #// ランナーのタイプ。実行するホストのタイプ
                                    steps:  #// 以下は順次実行します（並列実行ではない）

                                        -   uses: actions/checkout@v3  #// チェックアウトします。このアクションのバージョンは v3 です。

                                        -   name: Run a one-line script  #// 説明用のみ？
                                            run: echo Hello, world!  #// 実行するコマンド。シェルのコマンド

                                        -   name: Run a multi-line script
                                            run: |  #// 複数のコマンドを実行します
                                                echo Add other actions to build,
                                                echo test, and deploy your project.
                        Commit Changes ... ボタン（右上）:
                    Purpose changes ダイアログ:
                        Commit message:
                        Extend description:
                        (branch):
                            現在のブランチ:
                            新しいブランチ:
                        Purpose changes ボタン:
                    Create pull request ボタン:
                    #search: GitHub pull requests
                ランナーのインストール:  #search: install GitHub runner
                アクションを手動で起動します:
                    .github/workflows/____.yml に workflow_dispatch を追加します
            概念:
                ワークフロー: #keyword: GitHub ワークフロー  #ref: https://docs.github.com/ja/actions/using-workflows/about-workflows
                    ファイル:  #search: .github/workflows/.yml
                        steps:  #search: GitHub Actions steps
                ランナー: #keyword: GitHub runners
                    セルフホステッド ランナー: #keyword: GitHub self-hosted runner  #ref: https://docs.github.com/ja/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners
                        概要 >> 違い:  #// GitHub ホストランナー vs セルフホステッド ランナー
                            #ref: https://docs.github.com/ja/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#セルフホスト-ランナーと-github-ホステッド-ランナーの違い
                        手順:
                            インストール: #keyword: install GitHub runner  #ref: https://docs.github.com/ja/actions/hosting-your-own-runners/managing-self-hosted-runners/adding-self-hosted-runners
                                Docker 版:  #// Docker コンテナー のランナーを作る場合
                                    Dockerfile: |  #keyword: GitHub runner Dockerfile
                                        FROM rockylinux:8.8.20230518
                                        ARG  http_proxy
                                        ARG  https_proxy
                                        ENV  http_proxy="${http_proxy}"
                                        ENV  https_proxy="${https_proxy}"

                                        ARG  RUNNER_VERSION="2.303.0"
                                        ENV  RunnerBinaryURL=https://github.com/actions/runner/releases/download/v${RUNNER_VERSION}/actions-runner-linux-x64-${RUNNER_VERSION}.tar.gz
                                        RUN  dnf install -y  dotnet-sdk-6.0

                                        RUN  useradd  "github-runner"
                                        RUN  echo  "github-runner:github-runner" | chpasswd
                                        RUN  mkdir -p  "/home/github-runner"
                                        RUN  chown  "github-runner:github-runner"  "/home/github-runner"
                                        RUN  dnf install -y sudo
                                        COPY [ "files/sudoers",  "/etc/sudoers" ]

                                        USER github-runner
                                        WORKDIR  /home/github-runner
                                        RUN  curl -fsSL  -o "actions-runner.tar.gz"  -L ${RunnerBinaryURL}
                                        RUN  tar xf  "actions-runner.tar.gz"
                                        RUN  rm  "actions-runner.tar.gz"

                                        COPY ["files/start.sh", "/home/github-runner/start.sh"]
                                        RUN  sudo chown  github-runner:github-runner  "./start.sh"
                                        RUN  sudo chmod +x  "./start.sh"
                                        CMD ["./start.sh"]
                                    Docker (DooD) 対応版 Dockerfile: | #keyword: GitHub runner DooD Dockerfile
                                        FROM rockylinux:8.8.20230518
                                        ARG  http_proxy
                                        ARG  https_proxy
                                        ENV  http_proxy="${http_proxy}"
                                        ENV  https_proxy="${https_proxy}"

                                        ARG  RUNNER_VERSION="2.303.0"
                                        ENV  RunnerBinaryURL=https://github.com/actions/runner/releases/download/v${RUNNER_VERSION}/actions-runner-linux-x64-${RUNNER_VERSION}.tar.gz
                                        RUN  dnf install -y  dotnet-sdk-6.0

                                        ARG  DOCKER_HOST_UID
                                            #// in Docker host: id -u
                                        ARG  DOCKER_HOST_DOCKER_GROUP_GID
                                            #// in Docker host: getent group docker  |  cut -d: -f3
                                        ENV  DOCKER_HOST_UID="${DOCKER_HOST_UID}"
                                        ENV  DOCKER_HOST_DOCKER_GROUP_GID="${DOCKER_HOST_DOCKER_GROUP_GID}"

                                        RUN  useradd  "github-runner"  --uid ${DOCKER_HOST_UID}
                                        RUN  groupadd  "docker"  --gid ${DOCKER_HOST_DOCKER_GROUP_GID}
                                        RUN  gpasswd --add "github-runner"  "docker"
                                        RUN  echo  "github-runner:github-runner" | chpasswd
                                        RUN  mkdir -p  "/home/github-runner"
                                        RUN  chown  "github-runner:github-runner"  "/home/github-runner"
                                        RUN  dnf install -y sudo
                                        COPY [ "files/sudoers",  "/etc/sudoers" ]

                                        USER github-runner
                                        WORKDIR  /home/github-runner
                                        RUN  curl -fsSL  -o "actions-runner.tar.gz"  -L ${RunnerBinaryURL}
                                        RUN  tar xf  "actions-runner.tar.gz"
                                        RUN  rm  "actions-runner.tar.gz"

                                        ARG  DOCKER_CE_CLI_VERSION=25.0.4
                                        RUN  sudo yum install -y yum-utils  && \
                                            sudo yum-config-manager  --add-repo https://download.docker.com/linux/centos/docker-ce.repo  && \
                                            sudo yum install -y  docker-ce-cli
                                        
                                        ARG  DOCKER_COMPOSE_VERSION=v2.24.7
                                            #// https://github.com/docker/compose/releases
                                        RUN  sudo curl -L "https://github.com/docker/compose/releases/download/${DOCKER_COMPOSE_VERSION}/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose  && \
                                            sudo chmod +x /usr/local/bin/docker-compose

                                        # RUN  sudo docker pull mysql:8.0
                                        #     # This fails in docker build command, because -v /var/run/docker.sock:/var/run/docker.sock option is not specified.

                                        COPY ["files/start.sh", "/home/github-runner/start.sh"]
                                        RUN  sudo chown  github-runner:github-runner  "./start.sh"
                                        RUN  sudo chmod +x  "./start.sh"
                                        CMD ["./start.sh"]
                                    files/sudoers:
                                        #search: Dockerfile sudoers
                                    files/start.sh: |  #// config.sh,  run.sh を実行しています
                                        #!/bin/bash
                                        if [ "$1" != "${--register}" ]; then
                                            shift

                                            if [ "$1" == "${--gitlab-pat}" ]; then
                                                mkdir  -p  ~/.secret
                                                shift  2
                                            fi

                                            ./config.sh  "$@"
                                        fi

                                        ./run.sh
                                    （関連サービスのコンテナ―を起動する場合）:
                                        -   name: Get permission created folder by docker run volume option
                                            run: |
                                                sudo mkdir -p /home/github-runner/ci-test
                                                sudo chown -hR github-runner:github-runner /home/github-runner/ci-test
                                                sudo chown github-runner:docker /var/run/docker.sock

                                        -   uses: actions/checkout@v3

                                        -   name: Docker Compose
                                            run: |
                                                cd docker
                                                docker-compose  -f "docker-compose-ci-test.yml"  down
                                                docker-compose  -f "docker-compose-ci-test.yml"  up --build -d
                                    bash:  #// ランナーを登録します
                                        共通:  #// docker run コマンドは共通ではありません
                                            コマンド: |
                                                http_proxy_ip="http://$( dig +short  "$( echo  "${http_proxy}"  |  sed -E  's|https?://([^:/]+).*|\1|' )"  |  grep -E '([0-9]{1,3}\.){3}' ):${http_proxy##*:}"
                                                https_proxy_ip="http://$( dig +short  "$( echo  "${https_proxy}"  |  sed -E  's|https?://([^:/]+).*|\1|' )"  |  grep -E '([0-9]{1,3}\.){3}' ):${http_proxy##*:}"
                                                DockerHostUID="$( id -u )"
                                                DockerHostDockerGroupGID="$( getent group docker  |  cut -d: -f3 )"
                                                DockerSourceImageName=____
                                                cd  __DockerfileFolder__

                                                docker build  --tag ${DockerSourceImageName}  "."  \
                                                        --build-arg http_proxy=${http_proxy_ip}  \
                                                        --build-arg https_proxy=${https_proxy_ip}  \
                                                        --build-arg DockerHostUID=${DockerHostUID}  \
                                                        --build-arg DockerHostDockerGroupGID=${DockerHostDockerGroupGID}  \
                                                        --progress=plain

                                                pat=ghp___Secrets__  #// PAT のスコープ（権限）は、リポジトリなら workflow。Organization なら workflow, admin:org。
                                                clear
                                                docker run -it --rm  --name github-runner-test-1  __Account__/python-github-runner:1.0.0  \
                                                    ./start.sh --register  --pat $pat  --url https://github.com/__Account__/__Repository___  \
                                                    --name github-runner-test-1  --work  /home/github-runner/test-1
                                                    #// These parameters are config.sh parameters  #search: GitHub runner config.sh
                                        Organization のランナーの場合: #keyword: install GitHub runner within organization
                                            ランナー グループを作ります: #keyword: create GitHub runner group
                                                メニュー: GitHub リポジトリ >>（Organization 名：左上）>> Settings タブ（右上）>> Actions（左）>> Runner groups >>
                                                    New runner group（右上）
                                                Group name: ____
                                                Repository access:  #// グループがアクセスできるリポジトリを設定します
                                                    （ドロップダウン）:
                                                        All repositories:
                                                            - private リポジトリすべて
                                                            - Allow public repositories がオンならすべてのリポジトリ
                                                        Selected repositories:
                                                            - 歯車 ボタン を押してリポジトリを選びます。
                                                            - 選んでも Allow public repositories の影響を受けます
                                                    Allow public repositories:
                                                        Repository access でリポジトリを選んでも、Allow public repositories にチェックが入っていないと、
                                                        public リポジトリ（private ではないリポジトリ）にはアクセスできません。
                                                        #// おそらく public リポジトリに悪意のあるコードが埋め込まれる危険を考えたため
                                                Create group ボタン:
                                            config.sh コマンドのオプション:
                                                --url オプション: https://github.com/__Organization__
                                                --runnergroup オプション: Enterprise が定義するグループ名以外を付けます  #search: GitHub runner within enterprise
                                            #// 以下にも Organization のランナーの場合があります
                                        #ref: https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/adding-self-hosted-runners#adding-a-self-hosted-runner-to-an-organization
                                    成功時のログ: |
                                        ...
                                        √ Connected to GitHub
                                        Current runner version: '2.303.0'
                                        2024-01-01 01:00:00Z: Listening for Jobs
                                    #// Docker ランナー のプロセスは終了せず、ログを表示し続けます
                                    登録を確認します:
                                        Repository のランナーの場合:
                                            https://github.com/__Account__/__Repository__/settings/actions/runners  #search: list GitHub runner
                                            #// Idle になるまでジョブを受け付けません。数分かかります
                                        Organization のランナーの場合: #keyword: install GitHub runner within organization 2
                                            Organization に登録されていることを確認します:
                                                https://github.com/organizations/__Organization__/settings/actions/runners  #search: list GitHub runner
                                            リポジトリが使える Runner に登録されたことを確認します:
                                                URL: https://github.com/__Organization__/__Repository__/settings/actions/runners  #search: list GitHub runner
                                                Shared with this repository の表:  #// 1つも無いときは表すら表示されません
                                                    ランナーが表示されたら、そのリポジトリで使われます
                                    トラブルシューティング: #keyword: GitHub runner config.sh trouble
                                        - #// Bad credentials
                                            手順: config.sh  #search: GitHub runner config.sh
                                            エラー: |  #focus: registration-token
                                                Http response code: Unauthorized from 'POST https://github.com/api/v3/orgs/__Group__/actions/runners/registration-token' (Request Id: 12122121-f191-4f16-b47d-244cdc7abecc)
                                                {"message":"Bad credentials","documentation_url":"https://docs.github.com/enterprise-server@3.12/rest"}
                                                Response status code does not indicate success: 401 (Unauthorized).
                                                An error occurred: Not configured. Run config.(sh/cmd) to configure the runner.
                                                Runner listener exit with terminated error, stop the service, no retry needed.
                                                Exiting runner...
                                            対処:
                                                config.sh の --pat オプションに指定する PAT の有効性をチェックします
                                                    #search: GitHub runner config.sh
                                                    #search: GitHub PAT
                                        - #// Name or service not known
                                            手順: config.sh  #search: GitHub runner config.sh
                                            エラー: |
                                                Name or service not known (__ProxyURL__)
                                                An error occurred: Not configured. Run config.(sh/cmd) to configure the runner.
                                                Runner listener exit with terminated error, stop the service, no retry needed.
                                                Exiting runner...
                                            対処:
                                                __ProxyURL__ にアクセスできることを確認します
                                        - #// Must have admin rights to Repository
                                            手順: config.sh  #search: GitHub runner config.sh
                                            エラー: |
                                                Http response code: Forbidden from 'POST https://github.com/api/v3/orgs/__Organization__/actions/runners/registration-token'
                                                    {"message":"Must have admin rights to Repository.","
                                            対処:
                                                PAT の権限をチェックします
                                                    admin:org, repo
                                        - #// Runner listener exit because of updating, re-launch runner after successful update
                                            手順: run.sh
                                            エラー: |
                                                Current runner version: '2.296.3'
                                                2024-03-01 00:00:00Z: Listening for Jobs
                                                Runner update in progress, do not shutdown runner.
                                                Downloading 2.303.0 runner
                                                Waiting for current job finish running.
                                                Generate and execute update script.
                                                Runner will exit shortly for update, should be back online within 10 seconds.
                                                Runner update process finished.
                                                Runner listener exit because of updating, re-launch runner after successful update
                                            対処:
                                                最新版を再インストールします。
                                                インストール時にダウンロードする runner のバイナリのバージョンを変えます
                                    #ref: https://qiita.com/misohagi/items/077123e4931decbb5ed3
                                参考:
                                    #ref: https://docs.github.com/ja/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners
                                    #ref: https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/adding-self-hosted-runners
                                    #ref: https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/configuring-the-self-hosted-runner-application-as-a-service
                                    #ref: https://qiita.com/misohagi/items/077123e4931decbb5ed3
                            一覧: #search: list GitHub runner
                            ログイン: #keyword: login GitHub self-hosted runner
                                Docker 版:  #search: Docker login
                                    docker exec  -it __RunnerContainerName__  sh  #// bash も使えますが、ワークフローの実行は sh が使われます
                            Docker を使うランナーの設計:  #keyword: Docker runner design
                                ランナー コンテナー の起動スクリプト:  #keyword: runner container start.sh  #// 各自で作るスクリプトです
                                    -   docker run などに指定する Docker image 内にある 1つの シェル スクリプト の実行で、
                                        コンテナーの起動、コンテナー内へのトークンの保存、ランナーとしての登録を行います。
                                    -   Ansible を使えば、トークンが書かれた secrets なフォルダーの中にあるファイルへのパスを書かなくできます。
                                    #// これで、コンテナー（イメージではない）が削除されてもランナーをすぐに復帰できるようにします
                        コマンド:
                            start.sh:  #search: runner container start.sh  #// 各自で作るスクリプトです
                            config.sh : #keyword: GitHub runner config.sh  #// ランナーの設定をします。GitHub が提供するスクリプトです
                                サンプル:
                                    ./config.sh  --unattended  --url ${URL}  --pat ${PAT} \
                                        --name github-runner-local-1  --labels github-runner-labels-1  --work /home/github-runner/work
                                    #search: install GitHub runner
                                --unattended: 実行中に入力が要求されなくなります
                                --url: リポジトリの URL。リポジトリのランナーなら https://github.com/__Organization__/__Repository__ 。Organization のランナーなら https://github.com/__Organization__
                                --pat: workflow スコープを持つ PAT  #keyword: GitHub runner PAT  #search: GitHub PAT  #ref: https://docs.github.com/ja/actions/how-tos/manage-runners/self-hosted-runners/monitor-and-troubleshoot#checking-self-hosted-runner-network-connectivity
                                --name: ランナー名
                                --labels: #keyword: GitHub runner config.sh --labels  #// ランナーを特定するためのラベル  #search: GitHub runner label
                                    サンプル:
                                        - （オプションなし）  #// デフォルトのラベルが付きます
                                        - --labels __Label__
                                        - --labels "__Label__,__Label__"  #// コンマの次に空白を入れないこと
                                            #// NG: --labels "__Label__, __Label__"
                                            #// NG: --labels __Label__  --labels __Label__
                                --work: ジョブを実行するときの作業フォルダー。この中でリポジトリの内容が git clone されます。
                                    __Work__/__RepositoryName__/__RepositoryName__ フォルダーができます。
                                トラブルシューティング:  #search: GitHub runner config.sh trouble
                            run.sh:  #// ランナーを起動します。GitHub が提供するスクリプトです
                        概念:
                            ランナー:  #search: GitHub self-hosted runner 
                                共通:
                                    （一覧）: #keyword: list GitHub runner
                                        Repository が使えるランナーの一覧:  #// Organization や Enterprise のランナーがあれば、その表も下に表示されます
                                            URL: https://github.com/__Account__/__Repository__/settings/actions/runners
                                            メニュー: GitHub リポジトリ >> Settings タブ（右上）>> Actions（左）>> Runners
                                            表示: __RunnerName__ (__RunnerLabel1__) (__RunnerLabel2__) ...  __Status__
                                        Organization のランナーの一覧:  #// 使えるランナーとは限りません
                                            URL: https://github.com/organizations/__Organization__/settings/actions/runners
                                            メニュー: GitHub リポジトリ >>（Organization 名：左上）>> Settings タブ（右上）>> Actions（左）>> Runners
                                            表示: __RunnerName__ (__RunnerLabel1__) (__RunnerLabel2__) ...  __Status__
                                            関連 >> 使えるようにする:  #search: install GitHub runner within organization
                                    URL:  #search: GitHub runner config.sh
                                    名前: #keyword: GitHub runner name  #search: GitHub runner config.sh
                                    hostname:
                                        ビルドログに hostname も記録されます。
                                        コンテナ―の場合、Docker ホストの hostname にコンテナー名（の一部）を書くとよいでしょう
                                    ラベル: #keyword: GitHub runner label  #search: GitHub runner config.sh --labels
                                    作成日: 不明  #// 表示されない？  #search: list GitHub runner
                                Organization のランナー: #keyword: GitHub runner within organization  #// 複数のリポジトリで使われるランナー
                                    #search: install GitHub runner within organization
                                    #search: GitHub Organization
                            ランナー グループ:
                                作成:  #search: create GitHub runner group
                            権限:
                                #search: GitHub runner config.sh trouble
                        ログ:  #search: GitHub Actions log
                        トラブルシューティング:  #search: GitHub runner config.sh trouble
                    GitHub ホストランナー:
                        料金:
                            パブリック リポジトリ: 無料
                            プライベート リポジトリ: 従量課金、無料枠あり
                GitHub 拡張機能(VSCode):
                    Repository Secrets:
            ログ: #keyword: GitHub Actions log
                実行したワークフローの一覧:
                    #ref: https://github.com/__Account__/__Repository__/actions
                    GitHub >>（リポジトリ）>> Actions（タブ）
                    #// ワークフローを実行するたびに 1行増えます
                ジョブの実行結果:  #// 経過と実行結果とログを表示します。成功した設定ファイルやジョブには緑色のチェックが付きます
                    ❗注意: 検索するときは、Search logs（右上）に入力します  #// ブラウザーの検索では、折りたたまれた中や、スクロールアウトした内容にヒットしません
                    Web:
                        GitHub >>（リポジトリ）>> Actions（タブ）>>（アクション名：左上）>>（コミット メッセージ：中央）>>
                        （ジョブ名：中央）
                    VSCode 拡張機能:
                        VSCode >> GitHub Actions ビュー >> CURRENT BRANCH >>（コミット メッセージ と実行番号）>>
                        （ジョブ名）>> 🌎
                    保存場所:
                        GitHub のサーバー上。
                        GitHub セルフホステッド ランナー の中ではありません。(ChatGPT 2024-03-26)
                    削除:  #// 1行を削除します
                        （リポジトリ）>> Actions（タブ）>>（アクション名：左上）>>（…：右端）>> Delete workflow run
                スクショ:  #// スクショ画像をアーティファクトに指定すると、GitHub WebUI で確認できます
                    .github/workflows/playwright.yml: |  #focus: upload-artifact
                        name: Playwright Test

                        on:
                            push:
                                branches:
                                    -   main
                            pull_request:
                                branches:
                                    -   main

                        jobs:
                            test:
                                runs-on: ubuntu-latest
                                steps:
                                    -   uses: actions/checkout@v3
                                    -   name: Set up Node.js
                                        uses: actions/setup-node@v3
                                        with:
                                            node-version: '14'
                                    -   name: Install dependencies
                                        run: npm install
                                    -   name: Run tests and take screenshot
                                        run: node test.js
                                    -   name: Upload screenshot to artifacts
                                        uses: actions/upload-artifact@v3
                                        with:
                                            name: screenshots
                                            path: example.png
            ファイル:  #// .github/workflows/.yml
                .github/workflows/.yml : #keyword: .github/workflows,  GitHub ワークフロー ファイル  #search: GitHub ワークフロー
                    #// .github/workflows/____.yml
                    #ref: https://docs.github.com/ja/actions/using-workflows/workflow-syntax-for-github-actions
                    サンプル:
                        基本:  #search: GitHub Actions YAML
                        ステータス チェック:  #search: GitHub status check workflow YAML
                        テストの継続: #keyword: GitHub Actions test conitnue  #// 1つ目のテストが失敗しても2つ目のテストを実行します。1つでも失敗したら全体的なテスト結果も失敗させます
                            .github/workflows/ci.yaml: |  #focus: continue-on-error,  test1,  outcome
                                #//（前略）
                                jobs:
                                    test:
                                        steps:
                                            -   name: First test
                                                run: |
                                                    echo "Running test 1"
                                                    exit 1  # テスト失敗
                                                    echo  "Pass."            #// 追加  #search: GitHub Actions echo Pass.
                                                continue-on-error: true      #// 追加
                                                id: firstTest                #// 追加

                                            -   name: Second test
                                                run: |
                                                    echo "Running test 2"
                                                    exit 0  # テスト成功
                                                    echo  "Pass."            #// 追加
                                                continue-on-error: true      #// 追加
                                                id: secondTest               #// 追加

                                            -   name: Check test results     #// 追加
                                                run: |
                                                    failed=0
                                                    if [[ ${{ steps.firstTest.outcome }} == 'failure' ]]; then   #// id の outcome から判定
                                                        echo  "❌ First test" >&2         #// name の値に完全一致させるとユーザーは検索できるようになります
                                                        failed=$(( ${failed} + 1 ))
                                                    fi
                                                    if [[ ${{ steps.secondTest.outcome }} == 'failure' ]]; then
                                                        echo  "❌ Second test" >&2
                                                        failed=$(( ${failed} + 1 ))
                                                    fi
                                                    if [[ "${failed}" != 0 ]]; then
                                                        echo  "Failed = ${failed}" >&2
                                                        exit 1
                                                    fi
                            ログの表示の変化:
                                最後の Check test results: 失敗したように表示されます
                                失敗しても継続するテスト(step): 失敗しても Pass したように表示されます
                                Pass. 表示した場合:  #keyword: GitHub Actions echo Pass.
                                    - それぞれの step の最後に echo  "Pass." を書くと
                                        後のテストが実行中でも、ここのテストが成功したことが分かりやすくなります
                                    - （違ったみたい→） また、後のテストが実行中でも、成功したテストのログ表示は、すぐに折りたたまれるようです。
                        ログの表示:
                            すべて折りたたみます: Home キー を押して、▽ をクリックします
                    フィールド:
                        name:  #// ランナー名  #search: GitHub Actions YAML
                        on: #// トリガー  #search: GitHub status check workflow YAML  #ref: https://docs.github.com/ja/actions/using-workflows/workflow-syntax-for-github-actions#on
                            （値のみの場合）:  #search: GitHub status check workflow YAML
                                on: [push, pull_request]  #// プルリクエスト用
                                #// 全ブランチが対象です  #search: .github/workflows branches
                            push: git push されたとき
                            pull_request: プルリクエストを作ったときと、作った後に git push されたとき。push トリガー と両方指定する必要はありません
                            workflow_dispatch: #// 手動でジョブをトリガーします  #search: GitHub Actions inputs
                                __VariableName__: | #keyword: GitHub workflow_dispatch,  GitHub Actions YAML Input ID  #// 手動でジョブをトリガーするときに入力する項目
                                    workflow_dispatch:
                                        tags:  #// ${{ inputs.tags }} で参照できます
                                            description: 'Test scenario tags'
                                            required: true
                                            type: string
                                #ref: https://docs.github.com/ja/enterprise-cloud@latest/actions/using-workflows/workflow-syntax-for-github-actions#onworkflow_dispatchinputs
                            #↓ サブフィールド
                            branches: #keyword: .github/workflows branches  #// 値または配列
                                サンプル:  #search: GitHub Actions YAML
                                    on:
                                        push:
                                            branches: [ "main", "__OtherBranch__" ]  #// main ブランチを git push したとき
                                        pull_request:
                                            branches: [ "main", "__OtherBranch__" ]  #// main ブランチに対するプルリクエストを作ったとき
                        jobs:  #search: GitHub Actions YAML
                            build:  #// build という名前のジョブ。build でなくてもよい
                                runs-on:  #keyword: GitHub Actions runs-on  #// ランナーのタイプ。実行するホストのタイプ  #ref: https://docs.github.com/ja/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idruns-on
                                    -   ubuntu-latest
                                        # または
                                    -   [linux, python]  #// And 条件。ランナーのタグ  #search: GitHub runner config.sh --labels
                                    -   "${{ inputs.tags }}"  #// 変数参照  #search: GitHub Actions inputs
                                services:  #// コンテナーを起動します
                                    ❗注意: 非推奨。GitHub ランナー がコンテナー内で動いているときは services は使えません。
                                        コンテナー内で動いているときは jobs/__Job__/steps/run に
                                            docker-compose  -f "docker-compose-ci-test.yml"  up
                                        などを設定します
                                    サンプル: |
                                        services:
                                            mysql:
                                                image: mysql:5.7
                                                env:
                                                    MYSQL_ROOT_PASSWORD: password
                                                    MYSQL_DATABASE: testdb
                                                ports:
                                                    -   3306:3306
                                                options: >-
                                                    --health-cmd="mysqladmin ping --silent"
                                                    --health-interval=10s
                                                    --health-timeout=5s
                                                    --health-retries=3
                                steps: #keyword: GitHub Actions steps  #// 以下は順次実行します（並列実行ではない）

                                    -   uses: actions/checkout@v3  #// チェックアウトします。このアクションのバージョンは v3 です。

                                    -   name: Run a one-line script  #// 説明用のみ？
                                        run: echo Hello, world!  #// 実行するコマンド。シェルのコマンド

                                    -   name: Run a multi-line script
                                        run: |  #// 複数のコマンドを実行します
                                            echo Add other actions to build,
                                            echo test, and deploy your project.
                                            echo "${DEFINED_IN_RUNER}"
                                            #// セルフホステッド ランナー のプロセスで見える変数がここでも使えます  #search: login GitHub self-hosted runner
                                        env:  #keyword: .github/workflows 環境変数  #// run に設定されているコマンドを実行するときの環境変数
                                            PWD: /home/github-runner/work
                                            MY_SECRET: "${{ secrets.MY_SECRET }}"  #// 未確認  GitHubリポジトリ >> Settings >> Secrets >> New repository secret
                    変数:  #// .github/workflows/.yml の中で参照できる変数
                        .github/workflows/.yml 内定義: |  #focus: MASCOT  #ref: https://docs.github.com/ja/actions/learn-github-actions/contexts#env-context
                            __Job__:
                                runs-on: ubuntu-latest
                                env:
                                    MASCOT: Tux
                                steps:
                                    -   run: echo 'Hi ${{ env.MASCOT }}'  # Hi Tux
                                    -   run: echo 'Hi ${MASCOT}'  # Hi Tux
                        シークレット: #keyword: GitHub Actions secrets  #ref: https://docs.github.com/ja/actions/learn-github-actions/contexts#secrets-context
                            定義: GitHub の WebUI で手動登録します。
                                （GutHub のリポジトリのページ）>> Settings タブ（右上）>> Secrets and Variables（左）>> Actions
                            参照: ${{ secrets.MY_SECRET }}  #search: .github/workflows 環境変数
                        runner:  #// GitHub ランナーに関する情報  #ref: https://docs.github.com/ja/actions/learn-github-actions/contexts#runner-context
                            .name: ランナー名  #keyword: GitHub runner.name  #search: GitHub runner name
                            .temp: #keyword: GitHub runner.temp
                                config.sh の --work オプションを __Work__ としたときの __Work__/_temp を参照できます  #search: GitHub runner config.sh
                            その他:
                                - ランナーの環境変数の値を参照することはできます
                                - ランナーの環境変数の値を echo 表示することはできません。*** になります
                                - シークレットの値を API で設定することはできません（その機能はセキュリティ上の問題があるため）
                        inputs: #keyword: GitHub Actions inputs,  GitHub Workflow Dispatch Inputs
                            定義:
                                型: .github/workflows/.yml >> on/workflow_dispatch/__InputName__  #search: GitHub workflow_dispatch
                                値: GitHub UI または GitHub API で設定します
                            参照: ${{ inputs.tags }}
            参考:
                #ref: https://zenn.dev/snowcait/articles/2b4a903b9fd584
                #ref: https://github.blog/2022-02-02-build-ci-cd-pipeline-github-actions-four-steps/
        GitHub Docs: #keyword:  #// 公式マニュアル。GitHub Docs は GitHub の公式マニュアルであり GitHub Pages とは別物です  #ref: https://docs.github.com/ja
        GitHub Pages: #keyword:  #// GitHub Pages サイト、ドキュメント公開。Markdown で書いたドキュメントを表示します。ソース ファイル まで表示されないので見やすいです
            #ref: https://docs.github.com/ja/pages
            サンプル:
                表示:  #ref: https://takakiriy.github.io/documents/AI-answer/manner.html
                編集:
                    git clone  https://github.com/Takakiriy/documents
                    #ref: ${GitHub}/documents
            開始:  #// 公開を開始します
                リポジトリを作ります:  #// 公開する URL を踏まえた名前で。既存のプログラムのリポジトリでも公開できます
                    デフォルトの公開する URL: https://__Account__.github.io/__Repository__/  #// .com ではないことに注意  #search: GitHub Pages URL
                    プライベート リポジトリ の場合: Pro プラン以上が必要です  #// プライベート リポジトリ の内容を静的サイト（GitHub Pages の形式）で公開する場合
                ページ（本文）を編集します: #keyword: edit GitHub Pages
                    .md ファイルを新規作成して、Markdown で書きます
                公開します:
                    ブランチを選びます: #keyword: GitHub Pages branch  #// 公開するブランチを選びます
                        メニュー: （リポジトリの Web ページ）>> Settings タブ >> Pages（左）
                        branch: main など
                        Save ボタン:
                    更新されるまで待ちます:
                        git push から 33秒ほどかかります
                        更新されたようなら、ブラウザーをリロードしてください
                開きます:
                    設定ページに URL が表示されています  #search: GitHub Pages URL
            URL: #keyword: GitHub Pages URL  #// サイトの URL で見ると、ソース ファイル まで表示されないので見やすいです
                #// .com ではないことに注意
                GitHub Pages サイト:
                    - https://__Account__.github.io/__Repository__/  #// .com ではないことに注意。README.md の内容
                    - https://__Account__.github.io/__Repository__/index.html  #// README.md の内容
                    - https://__Account__.github.io/__Repository__/__FileName__.html
                    - https://__Account__.github.io/__Repository__/__Folder__/__FileName__.html
                    - https://__Account__.github.io/__Repository__/__FileName__.html#__Title__  #// __Title__ の部分は、タイトルと一部一致しないこともあります
                    #// サンプル  https://takakiriy.github.io/documents/AI-answer/manner.html
                ソース表示:  #// ブラウザーでは編集できません。編集は→ #search: edit GitHub Pages
                    - https://__Account__.github.io/__Repository__/README.md  #// ルートの内容
                    - https://__Account__.github.io/__Repository__/__FileName__.md
                    - https://__Account__.github.io/__Repository__/__Folder__/__FileName__.md
                リポジトリ:
                    - https://github.com/__Account__/__Repository__/blob/__Branch__/README.md  #// ルートの内容
                    - https://github.com/__Account__/__Repository__/blob/__Branch__/__FileName__.md
                    - https://github.com/__Account__/__Repository__/blob/__Branch__/__Folder__/__FileName__.md
            文章:  #// 編集内容をアップロードします
                書く内容:  #search: Markdown
                基本手順:
                    ファイルを編集します:
                        - 必要ならブランチを新規作成します
                        - ローカルで編集する場合、git clone してからファイルを編集します
                        - VSCode のプレビュー機能を使って表示内容を確認します
                    コミット＆プッシュします:
                        git add ".";  git commit -m "____";  git push
                    公開ページを開きます:
                        #search: GitHub Pages URL
                    更新されるまで待ちます:
                        git push から 33秒ほどかかります
                        更新されたようなら、ブラウザーをリロードしてください
                デプロイしながら編集する場合:  #// 別のブランチを別のホストには作れないようなので、サブ フォルダー に編集用の内容を作ります
                    準備:
                        develop ブランチを新規作成します:  #// ブランチ名は develop 以外でも構いません
                        コピーを作ります:
                            #// 開発用のフォルダーに、現在のサイトのコピーを作ります
                            __Project__ から
                            __Project__/develop-1234 などへ
                            #// アンダースコアは使えません。使ってもサイトでページが見つかりません
                            #// なるべく非公開にしたい場合は、長いハッシュ値のようなフォルダー名にしますが、
                            #// リポジトリが公開されている場合は、リポジトリから漏洩します
                        develop ブランチの内容をサイトで公開するように設定します:
                            #search: GitHub Pages branch
                    develop ブランチで作業します:
                        コミットやデプロイをして、URL に develop-1234 を追加してサイトを確認できます
                    完成したら:
                        戻すコピーをします:
                            __Project__/develop-1234 などから
                            __Project__ へ
                        コミットをまとめて、main ブランチにマージします: |
                            git checkout develop
                            git add "."
                            git commit -m "____"
                            git rebase -i main  #search: git rebase
                            git checkout main
                            git merge develop
                            git push
            図解:  #// .drawio ファイル
                ファイルの配置:
                    - files/figure1.drawio  #// 編集用ファイル  #search: draw.io
                    - files/figure1.png     #// 編集用ファイルからエクスポートした画像
                    - index.html    #// 中に <img src="files/figure1.png"/> のように書きます
            テーマ:
                一覧: |
                    # Theme
                    [![](https://github.com/pages-themes/architect/raw/master/thumbnail.png)](http://pages-themes.github.io/architect)
                    [![](https://github.com/pages-themes/cayman/raw/master/thumbnail.png)](http://pages-themes.github.io/cayman)
                    [![](https://github.com/pages-themes/dinky/raw/master/thumbnail.png)](http://pages-themes.github.io/dinky)
                    [![](https://github.com/pages-themes/hacker/raw/master/thumbnail.png)](http://pages-themes.github.io/hacker)
                    [![](https://github.com/pages-themes/leap-day/raw/master/thumbnail.png)](http://pages-themes.github.io/leap-day)
                    [![](https://github.com/pages-themes/merlot/raw/master/thumbnail.png)](http://pages-themes.github.io/merlot)
                    [![](https://github.com/pages-themes/midnight/raw/master/thumbnail.png)](http://pages-themes.github.io/midnight)
                    [![](https://github.com/pages-themes/minima/raw/master/thumbnail.png)](http://pages-themes.github.io/minima)
                    [![](https://github.com/pages-themes/minimal/raw/master/thumbnail.png)](http://pages-themes.github.io/minimal)
                    [![](https://github.com/pages-themes/modernist/raw/master/thumbnail.png)](http://pages-themes.github.io/modernist)
                    [![](https://github.com/pages-themes/slate/raw/master/thumbnail.png)](http://pages-themes.github.io/slate)
                    [![](https://github.com/pages-themes/tactile/raw/master/thumbnail.png)](http://pages-themes.github.io/tactile)
                    [![](https://github.com/pages-themes/time-machine/raw/master/thumbnail.png)](http://pages-themes.github.io/time-machine)
                Merlot の幅をウィンドウに合わせます:
                    _config.yml: |
                        theme: jekyll-theme-merlot
                        assets:
                            css:
                                -   /assets/css/style.scss
                    assets/css/style.scss: |  #// 編集するときは、ブラウザーの開発者ツールで該当する class を確認してください
                        ---
                        ---

                        @import "{{ site.theme }}";

                        a#forkme_banner {
                            display: none;
                        }

                        div#no-downloads {
                            width: 90%;
                            background-size: 100% 197px;
                            background-repeat: no-repeat no-repeat;
                        }

                        div#no-downloads  span.inner {
                            width: 100%;
                            max-width: none;
                            background-size: 100% 197px;
                            background-repeat: no-repeat no-repeat;
                        }

                        span.banner-fix {
                            display: none;
                        }

                        header {
                            width: 90%;
                            max-width: none;
                        }

                        div.shell {
                            width: 90%;
                        }

                        footer {
                            width: 90%;
                            max-width: none;
                            background-size: 100%;
                            background-repeat: no-repeat;
                        }
    GitLab: #keyword:  #ref: https://gitlab.com/takakiriy1  #ref: https://docs.gitlab.com/  #ref: https://gitlab-docs.creationline.com/ee/
        手順: #keyword: GitLab steps  #// アカウントを作ります。CI/CD を動かします
            アカウントを作ります: #keyword: create GitLab account
                https://about.gitlab.com/ >> Register（右上）>> Username, e-mail, password >>
                届いたメールで confirm >> 新規プロジェクトを作成 >> 招待はキャンセル
            SSH 公開鍵を設定します: #keyword: GitLab publickey
                メニュー:
                    https://about.gitlab.com/-/profile/keys
                        または GitLab (web) >> アカウントのアイコン（右上）>> Preferences >> SSH keys（左）
                Key: （公開鍵の内容） #search: SSH show public key 
                Title: （マシン名など）
                Add key ボタン:
                #// SSH 形式のアドレス git clone git@github.com:Takakiriy/first.git でアクセスするときに使われます
                SSH でアクセスする場合: |
                    ssh -T git@gitlab.com  #// ユーザー名は git 固定です
                    gitssh で SSH 接続に切り替えた場合、~/.ssh/config や ssh-agent で GitLab に登録した公開鍵に対応する秘密鍵を使うように設定します。
                    #search: ~/.ssh/config  #search: ssh-agent
                HTTPS でアクセスする場合:
                    アカウントの ID とパスワードを入力します
                    #// SSH キー は使いません
            git clone ～ git push: #keyword: GitLab git clone push  #// 既存のアカウントを使うように設定して git push します
                設定: #settings:
                    __GitLabUser__: takakiriy1
                    __ProjectName__: first
                アカウントを作ります:  #// 通常、private リポジトリを作るためです
                    #search: create GitLab account
                    #search: GitLab publickey
                git をインストールします:
                    Linux: #search: Linux CentOS7 Git
                リポジトリを新規作成します:
                    メニュー: https://gitlab.com/takakiriy1 >> New Project（右上）>> Create blank project  #template: https://gitlab.com/__GitLabUser__
                    Project name: first  #template: __ProjectName__
                    Create project ボタン（最も下）:
                git clone します:
                    git clone https://gitlab.com/takakiriy1/first  #template: https://gitlab.com/__GitLabUser__/__ProjectName__
                2FA が設定されている場合、個人用アクセストークンを使う場合:
                    エラー メッセージ の一部: |
                        remote: HTTP Basic: Access denied. The provided password or token is incorrect or your account has 2FA enabled and you must use a personal access token instead of a password.
                    #search: GitLab PAT
                Git のユーザー名とメールアドレスを設定します:
                    #// アカウントに合わせる必要はありませんが、コミットしたときに記録されます
                    git config --global --edit : |
                        [user]
                        name = Takakiriy
                        email = takakiriy@gmail.com
                    #// GitLab では global の設定が使われ、local の設定は使われません
                コミットを追加します:
                    -   cd  first  #template: __ProjectName__
                    -   vi _____
                    -   git add "."
                        git commit -m "__Update__"
                        git push
            2要素認証を有効にします: #ref: https://docs.gitlab.com/ee/user/profile/account/two_factor_authentication.html
                メニュー:
                    GitLab project >> アカウント アイコン（右上）>> Edit profile >> Account（左）>> Enable Two-factor authentication ボタン
                Microsoft Authenticator for iPhone の場合:
                    ＋（右上）>> その他 >> カメラで QR コードを写す
                GitLab:
                    Pin code: Authenticator に表示されたコード
                    Register with two-factor app ボタン:
            2要素認証が設定されている場合、個人用アクセストークンを使う場合: #keyword: GitLab PAT,  GitLab personal access token  #ref: ~/.secret/gitlab-pat
                PAT とは:
                    ユーザー名の欄に 自分のアカウント名、
                    パスワード欄に 取得した PAT を書くと、GitLab にアクセスできます
                必要になるケースの 1つの エラー メッセージ: |
                    [vagrant@localhost ~]$ git clone https://gitlab.com/takakiriy1/first
                    Cloning into 'first'...
                    Username for 'https://gitlab.com': takakiriy1
                    Password for 'https://takakiriy1@gitlab.com': 
                    remote: HTTP Basic: Access denied. The provided password or token is incorrect or your account has 2FA enabled and you must use a personal access token instead of a password.
                        See https://gitlab.com/help/topics/git/troubleshooting_git#error-on-git-fetch-http-basic-access-denied
                    fatal: Authentication failed for 'https://gitlab.com/takakiriy1/first.git/'
                git clone する場合:  #search: git clone authentication
                個人用アクセストークンを作ります: #keyword: create GitLab PAT  #search: GitLab members
                    #// 作るとオーナーに通知メールを送信します
                    サインインします: https://gitlab.com/ >> Login（右上）
                    メニュー:
                        https://gitlab.com/-/profile/personal_access_tokens
                            または
                        アカウントのアイコン（右上）>> Edit profile >> Access Tokens（左）
                    Token name: first token  #// ← サンプル
                    権限:   #// ↓ サンプル
                        #// チェックを入れます
                        - read_repository
                        - write_repository
                    Create personal access token ボタン:
                        Your new personal access token （Token name の上）にトークンが表示されます。
                    トークンを保存します: |
                        -   必要なら VM やコンテナーにログインします
                        -   PasswordFile=~/.secret/gitlab-pat  #// このパスはサンプルです
                            mkdir -p  ${PasswordFile%/*}   #// left of last "/"
                            read -s -p "Enter password: "  _x  &&  echo "${_x}" > ${PasswordFile};  unset  _x  #search: input password file
                        -   chmod 600  ${PasswordFile}  #// 自分だけがアクセスできるようにします
                            unset  PasswordFile
                    （上記で GitLab PAT を作ったら）:
                        PAT の表示を消します:
                            ブラウザーをリロード 
                    #// バックアップは不要です。紛失したら再発行します
                個人用アクセストークンをコマンドラインで使います:  #keyword: git clone PAT  #focus: oauth2:$(cat ~/.secret/gitlab-pat)@
                    注意: git remote get-url で PAT が見えてしまいます
                    実行したいコマンド:
                        git clone  https://gitlab.com/takakiriy1/first    #template_: https://gitlab.com/__GitLabUser__/__ProjectName__
                    入力するコマンド:
                        #search: git clone token in URL risk
                        git clone  https://oauth2:$( cat ~/.secret/gitlab-pat )@gitlab.com/takakiriy1/first    #template_: https://gitlab.com/__GitLabUser__/__ProjectName__
                git credential approve: #search:
                参考:
                    GitLab >> 個人用アクセストークン:  #ref: https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html
                    アクセストークンを使用した認証:  #ref: https://knasmueller.net/gitlab-authenticate-using-access-token
                関連:
                    プロジェクト アクセス トークン:  #search: GitLab project access token
                    その他の認証:  #search: git clone authentication
            その他トークンなど:  #search: GitLab members
            プロキシ設定:
            ダウンロード:
                .zip ファイルでプロジェクトをダウンロードします: #keyword: GitLab .zip download  #// プロジェクト全体をダウンロードします
                    curl -L -o  __Project__.tar.gz  "https://gitlab.com/__UserName__/__Project__/-/archive/master/__Project__-master.tar.gz"
                    #// HTML がダウンロードされる場合、その内容が認証に失敗したという内容であれば、PAT などが必要です
                raw ファイル ダウンロード: #keyword: GitLab raw download   #search: GitLab download 1 file
                1つのファイルをダウンロードします: #keyword: GitLab download 1 file
                    ブラウザー を使う場合, WSL2 の場合:
                        ブラウザーで GitLab へログイン >> ファイルをクリックしてダウンロード >> \\wsl$\__DistoributionName__ の中へコピー  #search: \\wsl$\
                    curl を使う場合:
                        public リポジトリの場合:
                            curl -OL  https://gitlab.com/__UserName__/__Project__/-/raw/__Branch__/__FileRelativePath__
                        private リポジトリの場合: #keyword: GitLab private raw download
                            ❗注意: GitLab 11.5.1から、PRIVATE-TOKENヘッダを使用してrawリンクのダウンロードができなくなりました
                            curl GitLab API: |  #// 未確認
                                curl -L --header "PRIVATE-TOKEN: $( cat ~/.secret/gitlab-pat )" \
                                    --url "https://gitlab.com/api/v4/projects/__ProjectID__/repository/files/__EscapedFileRelativePath__/raw?ref=master&lfs=true"
                                    （GitLab の サイン イン HTML）
                                    <title>Sign in · GitLab</title>
                            __ProjectID__: #keyword: GitLab project ID
                                表示: プロジェクトのホームページの最初に表示されます  https://gitlab.com/__UserName__/__Project__
                            __EscapedFileRelativePath__:
                                / は %2F に置き換えてください
                            WSL2 + ブラウザー を使う場合:  #search: GitLab download 1 file
                            LFS が必要な場合:
                                yum install -y  git-lfs 
                                以降不明
            アップロード:
                1つのファイルをアップロードします: #keyword: GitLab upload 1 file
                    ブラウザー を使う場合, WSL2 の場合:
                        パンくずリストの ＋ >> Upload file
            編集: #keyword: edit GitLab code  #// WebUI でコードを編集します
                開きます:
                    GitLab >>（コードを表示）>> Open in Web IDE（右上）
                編集します:
                コミットします:
                    Create commit ボタン（左下）:
                    Commit Message:
                        最近の コミット メッセージ を参考に入力します。
                        省略すると、淡色表示されている内容になります。
                    （ブランチ）:
                        - Commit to master branch
                        - Create a new branch
                    Commit ボタン:
                （必要なら）マージ リクエスト でマージします:
            過去のバージョンを参照します:
                全体を表示します: #// 以下のいずれか
                    - （ファイルを表示します）>> History（右上）>> フォルダー ボタン（コミットの右端）
                    - （ファイルを表示します）>> History（右上）>>（コミット メッセージ）（コミットの左端）>>
                        View File（右上）
                差分を表示します: #// 以下のいずれか
                    - （ファイルを表示します）>> History（右上）>> フォルダー ボタン（コミットの右端）>>
                        （コミット メッセージ）（左上）
                    - （ファイルを表示します）>> History（右上）>>（コミット メッセージ）（コミットの左端）
            CI/CD を動かします: #search: install GitLab CI/CD
        画面: #keyword: GitLab URL
            プロジェクト:  #ref: https://gitlab.com/__Account__/__Repository__/activity
            リポジトリ:  #ref: https://gitlab.com/__Account__/__Repository__/
                Settings:
                    Repository: #keyword: GitLab repository settings
                        https://github.com/__Account__/__Repository__  >>  Settings（左） >> Repository（左）
                            または
                        https://gitlab.com/__Account__/__Repository__/-/settings/repository
            CI/CD:  #search: GitLab CI/CD
        構造:
            プロジェクト, リポジトリ:
                手順:
                    一覧: #ref: https://gitlab.com/takakiriy1
                    削除:
                        Dashboard（左上のアイコン, https://gitlab.com/dashboard/projects）>>
                        （プロジェクト名）>> Settings（左下）>>
                        Advanced（General ページの最も下）>> Delete project ボタン（最も下）
                ファイル: #keyword: GitLab files
                    raw 表示: #keyword: GitLab raw
                        URL の中にある blob を raw に変えたページを開きます。
                        ページの途中にジャンプさせるには、 #:~:text=
                ブランチ: 
                    手順 >> ロックします:  #keyword: lock GitLab branch steps
                        リポジトリの設定画面を開きます:  #search: GitLab repository settings
                        ロックします:
                            メニュー: リポジトリの設定画面 >> Protected branches  #keyword: GitLab branch protect,  GitLab protected branch
                            Branch: ____
                            Allowed to merge: No one
                            Allowed to push: No one
                            Protect ボタン:  #// 有効にならないときは、もう一度 Allowed to push を選びなおしてください
                        git push できないことを確認します: |  #// エラーメッセージの様子
                            $ git push
                            Locking support detected on remote "origin". Consider enabling it with:
                                $ git config lfs.https://github.com/__Account__/__Repository__/info/lfs.locksverify true
                            Enumerating objects: 4, done.
                            Counting objects: 100% (4/4), done.
                            Compressing objects: 100% (2/2), done.
                            Writing objects: 100% (3/3), 257 bytes | 257.00 KiB/s, done.
                            Total 3 (delta 1), reused 0 (delta 0), pack-reused 0
                            remote: GitLab: You are not allowed to push code to protected branches on this project.
                            To github.com:__Account__/__Repository__.git
                            ! [remote rejected] lock_test -> lock_test (pre-receive hook declined)
                            error: failed to push some refs to 'github.com:__Account__/__Repository__.git'
                グループ: #keyword: GitLab group
                    URL の中のプロジェクト名の左に表示されています。
                    https://gitlab.com/__GitLabGroup__/__ProjectName__
                private: #keyword: GitLab private project
                    private に設定します:
                        GitLab グループ >> Settings（左）>> Projects >>
                            https://gitlab.com/groups/__GitLabGroup__/-/projects
                        （対象プロジェクトの）Edit ボタン >> Visibility, project features, permissions >> Project visibility = Private >>
                        Save changes ボタン（下）
                    GitLab Package Registry が対応している場合: #keyword:  #search: GitLab Package Registry
                        対応している種類:  #ref: https://docs.gitlab.com/user/packages/package_registry/#accepting-contributions
                            private リポジトリでなければ使えるようです
                    nginx proxy で認証する場合:
                    git clone で認証する場合:
                        注意: ディスクの使用量が大きいです。不要な RPM もダウンロードするため
                        認証:  #search: GitLab PAT
                        RPM では オフライン インストール を使います:  #search: yum localinstall
                    URL でファイルをダウンロードする場合:
                        1つのファイルをダウンロードします: #search: GitLab download 1 file
                        RPM では オフライン インストール を使います:  #search: yum localinstall
                リポジトリ, レジストリ: #keyword: GitLab Package Registry
                    場所:
                        URL の場合: https://gitlab.com/__Account__/__Repository__/-/packages
                        メニュー の場合: GitLab のプロジェクトの Web ページ >> Packages & Registries（左）>> Package Registry
                        メニューに表示させる: GitLab のプロジェクトの Web ページ >> Settings（左）>> General >> Visibility >> Packages >> Save changes ボタン
                    #↓ 言語別
                    （private 対応状況）:  #search: GitLab private project
                    Python, PyPI: #keyword: GitLab PyPI
                        .whl をアップロードまたは削除します: #keyword: upload .whl to GitLab Package Registry
                            準備: |
                                cd  ~/__Project__  #// .whl ファイルがある場所
                                PAT=____  #search: create GitLab PAT
                                    #// Token name = __Project__ registry (例),  Scopes = [ api, read_api, read_package_registry, write_package_registry ]
                                projectID=1234  #search: GitLab project ID
                                whlFileName="zipp-3.15.0-py3-none-any.whl"
                                packageName="${whlFileName%%-*}"  &&  echo "${packageName}"  #// left of "-"
                                packageVersion=$( echo "${whlFileName}" | cut -d'-' -f2 )  &&  echo "${packageVersion}"  #// 2nd field split by '-'
                            登録:  #search: GitLab registry token
                                twine の場合: | #keyword: twine
                                    python -m twine upload  --repository-url "https://gitlab.com/api/v4/projects/${projectID}/packages/pypi"  -u __token__  -p "${PAT}" \
                                        zipp-3.4.0-py3-none-any.whl
                                curl の場合: |  #// pip install で 404 Not Found になるかもしれません  #search: pip install trouble .whl 404
                                    curl  --request POST  --header "PRIVATE-TOKEN: ${PAT}" \
                                            --form "content=@${whlFileName}"  --form "name=${packageName}"  --form "version=${packageVersion}" \
                                            https://gitlab.com/api/v4/projects/${projectID}/packages/pypi
                                        {"message":"201 Created"}
                            削除: |  #search: GitLab registry token
                                packageJSON="$( curl -s --header "PRIVATE-TOKEN: ${PAT}" \
                                    https://gitlab.com/api/v4/projects/${projectID}/packages?package_type=pypi&package_name=${packageName} )"  &&  echo "${packageJSON}"
                                packageID="$( echo "${packageJSON}"  |  jq -r ".[]  |  select( .version == \"${packageVersion}\" ) | .id" )"  &&  echo "${packageID}"
                                curl  --request DELETE  --header "PRIVATE-TOKEN: ${PAT}" \
                                        https://gitlab.com/api/v4/projects/${projectID}/packages/${packageID}
                                    #// 何も表示されなければ成功
                    Ruby gems: #keyword: GitLab Ruby gems  #ref: https://docs.gitlab.com/user/packages/rubygems_registry/
                        gem push:  認証できます
                        ダウンロード: git clone などで download してから ローカル リポジトリ が使えます
                    #↓ 共通
                    登録に使えるトークン: #keyword: GitLab registry token  #// .whl ファイルをレジストリへ登録、削除
                        _: Personal Access Token (PAT),  Group Access Token
                        使えないトークン:
                            CI_JOB_TOKEN,  Deploy Token
                        実験: |  #focus: CI_JOB_TOKEN, DEPLOY_TOKEN
                            read -s -p "Enter PAT: "  PAT
                            curl -s --header "PRIVATE-TOKEN: ${PAT}"  https://gitlab.com/api/v4/projects/1234/packages?package_type=pypi
                                ...
                            read -s -p "Enter GroupAccessToken: "  GroupAccessToken
                            curl -s --header "PRIVATE-TOKEN: ${GroupAccessToken}"  https://gitlab.com/api/v4/projects/1234/packages?package_type=pypi
                                ...
                            curl -s --header "JOB-TOKEN: ${CI_JOB_TOKEN}"  https://gitlab.com/api/v4/projects/1234/packages?package_type=pypi
                                {"message":"404 Project Not Found"}
                            read -s -p "Enter DEPLOY_TOKEN_USERNAME: "  DEPLOY_TOKEN_USERNAME
                            read -s -p "Enter DEPLOY_TOKEN: "  DEPLOY_TOKEN
                            curl -s --header "Deploy-Token: ${DEPLOY_TOKEN}"  https://gitlab.com/api/v4/projects/1234/packages?package_type=pypi
                                {"message":"404 Project Not Found"}
                            curl -s -u "${DEPLOY_TOKEN_USERNAME}:${DEPLOY_TOKEN}"  https://gitlab.com/api/v4/projects/1234/packages?package_type=pypi
                                {"message":"404 Project Not Found"}
                            curl -s --header "PRIVATE-TOKEN: ${DEPLOY_TOKEN}"  https://gitlab.com/api/v4/projects/1234/packages?package_type=pypi
                                {"message":"401 Unauthorized"}
            メンバー, アカウント, トークン: #keyword: GitLab members
                アクセストークン: #keyword: GitLab access token
                    PAT, 個人用アクセストークン:  #search: GitLab PAT
                    プロジェクト アクセス トークン: #keyword: GitLab project access token  #ref: https://git.____/help/user/project/settings/project_access_tokens.md
                        メニュー: プロジェクト の Web ページ >> Settings（左下）>> Access Tokens >> Project Access Tokens（のページ）
                        作成: #keyword: create GitLab project access token
                            作成します:
                                Token name: __Name__
                                Expiration date: __Date__  #// 数年後など
                                Select scopes: read_repository など
                                Create project access token ボタン:
                                Your new project access token: __ProjectAccessToken__  #// 値をコピー
                                （ローカルの安全な場所にあるメモに貼り付け）:
                                ブラウザーのリロード（token を閉じます）:
                            保存します:  #// ${HOME}/.secret/gitlab-__ProjectName__-access-token
                                クライアントにログインします:
                                    docker exec -it gitlab-runner-1 bash
                                    su --login  gitlab-runner
                                    #search: GitLab specific runners log in
                                ファイルに保存します:
                                    mkdir -p ~/.secret
                                    tee ~/.secret/gitlab-__ProjectName__-access-token  > /dev/null
                                    （ __ProjectAccessToken__ を貼り付けて Ctrl + D）
                                    clear
                                自分だけがアクセスできるようにします:
                                    chmod 600 ~/.secret/gitlab-__ProjectName__-access-token
                                #// バックアップは不要です。紛失したら再発行します
                        使用:
                            個人用アクセストークンと同じです。
                            リンク先の ~/.secret/gitlab-pat を ~/.secret/gitlab-__ProjectName__-access-token に置き換えてください
                            #search: git clone PAT
                    グループ アクセス トークン: #keyword: GitLab group access token  #ref: https://git.____/help/user/group/settings/group_access_tokens
                        グループ:  #search: GitLab group
                        メニュー: グループ の Web ページ >> Settings（左下）>> Access Tokens >> Group Access Tokens（のページ）
                        作成:
                            プロジェクト アクセス トークン の作成を参照:  #search: create GitLab project access token
                            グループ用ボットユーザー:  #ref: https://gitlab-docs.creationline.com/ee/user/group/settings/group_access_tokens.html#グループ用ボットユーザー
                                グループ アクセス トークン を作るとユーザー group_993_bot のような名前のユーザーが作られます
                デプロイトークン: #keyword: GitLab deploy token  #// git clone やレジストリ用途ならこちらが安全。アクセストークンより限定的。デプロイキー とは異なります
                    注意:
                        ~/.netrc に複数のデプロイトークン（複数のリポジトリ）を設定することはできません。毎回内容を書き換えるならできます  #search: ~/.netrc
                    作成: #keyword: create GitLab deploy token
                        メニュー:
                            https://gitlab.com/__Account__/__Repository__/-/settings/repository  >> Deploy tokens（中央）
                                または
                            GitLab グループ または プロジェクト のページ >> Settings（左下）>> Repository >> Deploy tokens（中央）
                        Name: ____  #// Web 上での識別名
                        Expiration date: ____
                        Scopes: read_repository
                        Create deploy token ボタン:
                        生成されたもの:
                            Deploy Token username: gitlab+deploy-token-____  #// これはデフォルトの場合。____ の部分は数字
                            Deploy token: ____
                        保存します:
                            場所の例:  #// git clone などを使うホストの中
                                ~/.secret/gitlab-deploy-__ProjectName__-name
                                ~/.secret/gitlab-deploy-__ProjectName__
                            #search: make password file
                        トークンを非表示にします:
                            Settings >> Repository などのメニュー項目  #// リロードでは、もう一度生成してしまいます
                        #// DEV, STG, PRD 環境でトークンを分けると、ローテーション作業が少なくなります。PRD 環境を触る必要が少なくなります
                    トークンを使います:
                        ~/.netrc に保存する場合:
                            #search: ~/.netrc
                        変数に設定する場合:
                            #search: GitLab runner secrets
                        git clone に指定する場合:
                            #search: git clone token in URL risk
                            git clone  https://__DeployUser__:__DeployToken__@gitlab.com/__Account__/__Repository__.git
                        参考:  #search: secret zero
                デプロイキー:  #keyword: GitLab deploy key  #ref: https://gitlab.com/help/user/project/deploy_keys/index
                    _: プロジェクトに紐づけられた SSH キー相当。 複数のプロジェクト間で共有可能。
                        作成時に定義されたスコープがあり、それは作成後に変更できません。
                        デプロイトークンとは異なります。
                CI_JOB_TOKEN, CI/CD ジョブトークン:  #ref: https://gitlab-docs.creationline.com/ee/ci/jobs/ci_job_token.html
                ロール: #keyword: GitLab Roles,  GitLab 権限  #ref: https://docs.gitlab.com/ee/user/permissions.html
                    概要:
                        - 操作に必要な権限 (permissions) は、GitLab Roles を逆検索してください  #mutual: GitLab Roles
                        - Guest, Reporter, Developer, Maintainer, Owner, Minimal Access
                    概要表:
                        .           | Repository              | Container Registry  
                        ----------- | ----------------------- | --------------------
                        Owner       | 同下                    | 同下                
                        Maintainer  | 同下, Change protection | 同下, create, delete
                        Developer   | 同下, push, make branch | 同下, push          
                        Reporter    | 同下, view commit       | 同下                
                        Guest       | pull                    | pull                
                        その他の権限の詳細は https://docs.gitlab.com/ee/user/permissions.html
                手順 >> 何に使われているか調べます:
                    #ref: https://gitlab.com/groups/__Group__/-/group_members >>
                        #// または  #ref: https://gitlab.com/__Group__  >> Group information（左上）>> Members >>
                    （Account の列の名前）>> Activity（左半分）
                グループ:  #search: GitLab group
            コード: #keyword: GitLab code  #// コードを読みます。または、コードを見せます
                URL を取得する場合: #keyword: GitLab code URL  #// コミットの URL なので内容が変化しません
                    GitLab の Code タブを選びます:
                        https://gitlab.com/__Account__/__Repository__
                    取得方法:
                        リポジトリの Web ページ >> Repository（左）>> Commits >>（任意のコミット）>>
                        View file ボタン（ファイル パス の右端）>>（行番号）
                    URL のサンプル:
                        https://gitlab.com/____/____/-/blob/__CommitID__/__RelativePath__#L__LineNum__
                編集します:  #search: edit GitLab code
            マージ リクエスト: #keyword: GitLab merge request,  GitLab pull request ではない  #// GitHub のプルリクエストに相当します
                新規作成:
                    ブランチを作り git push します:
                        git checkout -b "__NewBranch__"
                        git add "."
                        git commit -m "____"
                        git push
                    プロジェクトのページを開きます:
                        サンプル: #ref: https://gitlab.com/takakiriy1/first/
                    メニュー:
                        Merge requests（左）>> New merge request（下）>> Select source branch（上）>>
                        Compare branches and continue ボタン（左下：青）
                    Title: ____
                    Description: ____
                    Create merge request ボタン（下へスクロール、左下）:
                    （レビューします）:
                    マージを受け入れます:
                        Merge ボタン（左下：青）
            Docker: #keyword: GitLab Docker  #// Docker Container レジストリ
                イメージのアップロード:  #search: GitLab upload Docker image
                権限: #keyword: GitLab Docker permissions
                    Container registry:
                        （メニュー）: #search: プライベート Docker リポジトリ
                        Everyone With Access: docker pull, run などはできます。docker push は docker login が必要です
                        Only Project Members: docker pull, run なども docker login が必要です  #// 他にも必要かも？
            CI/CD: #keyword: GitLab CI/CD,  CI/CD, Continuous Integration Delivery Deployment  #ref: https://gitlab-docs.creationline.com/ee/ci/introduction/
                手順: #keyword: install GitLab CI/CD
                    最初のサンプル: #keyword: GitLab first CI/CD example  #ref: https://gitlab-docs.creationline.com/ee/ci/quick_start/README.html
                        注意: ここで説明している Shared runner を使う場合、Validate account するためにクレジットカードの登録が必要です
                        プロジェクトを作ります:  #// サイン イン したときに作ったものでも構いません
                        git clone します:
                            Git bash など:
                                mkdir __Desktop__/gitlab1
                                cd    __Desktop__/gitlab1
                                git clone https://gitlab.com/takakiriy1/first
                            Authorize ボタン: #// 初回のみ
                            Git bash (2):
                                cd __Desktop__/gitlab1/first  #// ここを __Project__ とする
                        __Project__/.gitlab-ci.yml : |  #// 下記は docker を使います
                            image: "ruby:2.5"
                            rspec:
                                script:
                                    -   apt-get update -qq && apt-get install -y -qq sqlite3 libsqlite3-dev nodejs
                                    -   ruby -v
                                    -   which ruby
                                    -   gem install bundler --no-document
                        git push します。自動的にパイプラインが動作します:
                        User validation required エラーになるとき:
                            クレジットカードの番号を登録します:
                            Validate account ボタン:
                        再度パイプラインを実行します:
                            新: Build（左）>> Pipelines >> Run pipeline（右上）>>（ブランチを選択）>> Run pipeline ボタン
                            旧: CI/CI（左）>> Pipelines >> Run pipeline（右上）>>（ブランチを選択）>> Run pipeline ボタン
                            #// Run pipeline が無いときは、ログインしてください
                        エラーの原因を調べます:  #// 実行したコマンドとエラーメッセージを表示します
                            Build（左）>> Pipelines >> failed（status列）>> rspec など（ジョブ名）
                    マニュアル アクション:  #// 本番デリバリー ボタン など
                        誤操作防止:  #// 誤って本番デリバリーさせないようにします
                            ユーザー権限:
                                環境保護:  #// Protected Environments
                                ビルド パーミッション:
                            パイプラインの承認:  #//（Premium, Ultimate）
                                特定のユーザーやグループの承認が必要。
                    デバッグ実行する場合: #keyword: start GitLab CI/CD,  debug GitLab CI/CD
                        Schedules を使う場合:  #search: GitLab pipeline schedule
                            日時を設定しない Schedule を設定して、即時実行します
                        Run pipeline を使う場合:  #// 非推奨。入力の手間がかかるため
                            メニュー:
                                https://gitlab.com/__Account__/____/-/pipelines  >> Run pipeline（右上）
                                    または
                                GitLab 内の .gitlab-ci.yml ファイル があるプロジェクト >> CI/CD（左）>> Run pipeline（右上）
                            Run for branch name or tag: （対象の .gitlab-ci.yml ファイル があるブランチ）
                            Variables:  #// .gitlab-ci.yml ファイル の仕様によります
                                - Variable
                                - 変数名
                                - 値
                            Run pipeline ボタン:
                    定期実行する場合:  #search: GitLab pipeline schedule
                    共有ランナーを使う場合:  #search: GitLab runner
                    特定のランナーを使う場合:  #search: install GitLab runner
                    bash を使う場合:
                    Jenkinsからの移行: #keyword: Jenkins to GitLab  #ref: https://gitlab-docs.creationline.com/ee/ci/jenkins/
                        シンプルな移行: GitLab インスタンスの Runner に既存の Jenkins Agent を設定し、Jenkins ラッパーを使います
                        移行手順:  #ref: https://gitlab-docs.creationline.com/ee/ci/jenkins/
                            まずはGitLab CI/CDクイックスタートガイドと重要な製品の違いを読むことから始めましょう。
                            組織移行管理の重要性を学びます。
                            GitLab インスタンス にRunnerを追加します。
                            開発者が、プロ​​ジェクトで次のステップを自身で実行できるように教育します。
                                Jenkinsラッパーを使用することで、Jenkinsジョブを変更なく一時的に維持できます。
                            一般的なCI/CDジョブの定義を把握し、それらのテンプレートを作成して共有します。
                    構成の設計:  #search: CI/CD design
                構成, 概念: #keyword: GitLab CI/CD concept
                    （構成）:
                        パイプライン :
                            _: #// 以下のいずれか
                                - .gitlab-ci.yml >> ジョブ
                                - .gitlab-ci.yml >> ステージ >> ジョブ
                            ジョブ:  #search: GitLab job stage
                            ステージ:  #search: GitLab job stage
                                ジョブ:
                        CI アーキテクチャ:
                            #ref: https://docs.gitlab.com/ee/development/cicd/#ci-architecture-overview
                        サーバー構成:
                            GitLab インスタンス: #keyword:  #// GitLab の WebUI と Web API と各種サービス
                                ランナー:  #// CI/CD 環境のサーバー  #search: GitLab runner
                                    共有ランナー:  #search: GitLab shared runners
                                    特定のランナー:  #search: GitLab specific runners
                                    GitLab インスタンスとの通信: #search:
                                    Executor: #search: GitLab executor
                                        shell:  #// デフォルト。最も軽量です
                                        docker:  #// Docker コンテナーで実行します  #search: GitLab docker executor
                    パイプライン: #keyword: GitLab pipeline
                        種類:
                            基本的なパイプライン: #ref: https://docs.gitlab.com/ee/ci/pipelines/pipeline_architectures.html#basic-pipelines
                                build, test, deploy のステージがあります
                            有向非循環グラフパイプライン: #ref: https://docs.gitlab.com/ee/ci/pipelines/pipeline_architectures.html#directed-acyclic-graph-pipelines
                                通常のステージの順序とは異なる順序でステージを実行します。needs で前のステージを指定します
                                #ref: https://docs.gitlab.com/ee/ci/yaml/index.html#needs
                            子パイプライン/親パイプライン: #ref: https://docs.gitlab.com/ee/ci/pipelines/pipeline_architectures.html#child--parent-pipelines
                                trigger/include で子パイプラインの YAML を指定します
                            その他のパイプライン: #ref: https://docs.gitlab.com/ee/ci/pipelines/#types-of-pipelines
                        ファイル:  #search: .gitlab-ci.yml
                        設計:  #keyword: CI/CD design  #// Docker を使う場合の構成の設計
                            設定ファイルのリポジトリのテスト:
                                test ステージの実行で yum install などを実行しないでください。
                                別のプロジェクトの CI/CD で docker build コマンドの実行と
                                Docker イメージをレジストリに登録し、
                                その Dokcer image から実行します。
                    ステージ, ジョブ: #keyword: GitLab job stage  #ref: https://docs.gitlab.com/ee/ci/yaml/index.html#stages
                        実行順序:
                            - 同じステージ内のジョブは並列に実行されます
                            - 次のステージのジョブは、前のステージのジョブが正常に完了した後に実行されます
                            - いずれかのジョブが失敗した場合、後のステージのジョブは開始されません
                            - .gitlab-ci.yml ファイルの before_script で、すべてのジョブを開始する前に共通の処理を指定できます
                                #ref: https://gitlab-docs.creationline.com/ee/ci/quick_start/README.html#シンプルな-gitlab-ciyml-ファイルの作成する
                        .gitlab-ci.yml ファイル:  #search: .gitlab-ci.yml
                        トリガー: #keyword: GitLab CI/CD trigger  #// 実行開始条件
                            特定のファイルが更新されたときだけ動かす:  #focus: changes
                                job-1:
                                    script:
                                        ____
                                    rules:
                                        - changes:
                                            -   input/*.yml
                            定期実行, スケジュール:  #search: GitLab pipeline schedule
                            ワークフロー:  #search: GitLab workflow
                        実行環境:  #search: GitLab job environment
                    ワークフロー: #keyword: GitLab workflow  #ref: https://docs.gitlab.com/ee/ci/yaml/index.html#workflow
                        _: ジョブを実行する条件を指定できます
                    定期実行, スケジュール, 簡易起動: #keyword: GitLab pipeline schedule
                        設定:  #// Web UI で設定します
                            メニュー:
                                - （プロジェクトのページ）>> CI/CD（左）>> Schedules
                                    #// または
                                - https://gitlab.com/takakiriy1/first/-/pipeline_schedules  #template: https://gitlab.com/__User__/__Repository__/-/
                            Create a new pipeline schedule ボタン（中央青）:
                            Description: __Description__  #// 一覧に表示される名前
                            Interval Pattern:  #// 日時設定
                                日時設定する場合:  #// 日時を設定しても、ボタンを押して実行開始することもできます
                                    近いパターンを選んでから編集します。
                                    0 19 * * *  #// cron 式  #search: cron
                                日時設定しない場合:  #// ボタンを押すだけで実行できるようにするための場合
                                    後で Active をオフにするため、日時はデフォルトのままで構いません
                            Run for branch name or tag:  #// ブランチ
                                （対象の .gitlab-ci.yml ファイル があるブランチ）
                            Variables:  #// 変数。 .gitlab-ci.yml ファイル の仕様によります
                                - Variable
                                - 変数名
                                - 値
                            Save pipeline schedule ボタン:
                        即時実行:
                            メニュー: https://gitlab.com/takakiriy1/first/-/pipeline_schedules  #template: https://gitlab.com/__User__/__Repository__/-/
                            ▼再生 ボタン（右）:
                            #// スケジュールが Inactive でも即時実行できます
                        ジョブの制限:  #// スケジュールでのみ実行する場合
                            nightly_job:
                                only:  #// rules:? 最初のステージのジョブだけでなく全てのジョブに書いてください。schedules だけ設定しても手動で開始することはできます
                                    - schedules
                    通知: #keyword: GitLab CI/CD 通知
                        CI/CD の失敗をメール通知する宛先を設定します:
                            https://gitlab.com/takakiriy1/first/-/settings/integrations/pipelines_email/edit  >>  Recipients
                    ランナー: #keyword: GitLab runner  #// 実行環境  #ref: https://gitlab-docs.creationline.com/ee/ci/runners/index.html
                        手順:
                            インストール: #keyword: install GitLab runner  #ref: https://docs.gitlab.com/runner/install/docker.html
                                for WSL2 Ubuntu 20.04:  #// WSL2 を特定のランナーとして登録して CI/CD パイプラインを動かします
                                    Docker あり:  #// OS を汚しません
                                        gitlab-runner をダウンロードしてバージョンを確認します:  #// Docker イメージをダウンロードします
                                            docker run --rm -it  gitlab/gitlab-runner --help
                                                #// バージョンなどが表示されます
                                                #// 16.6.0 (3046fee8)  gitlab/gitlab-runner:ubuntu-v16.6.0  in 2023-11-20
                                        （必要なら）docker サービスが使うプロキシを設定します: #keyword: docker.service.d proxy   #// Docker インストール時に済んでいる可能性が高いです
                                            -   sudo mkdir -p /etc/systemd/system/docker.service.d/
                                            - |
                                                cat << _HERE_DOCUMENT | sudo tee /etc/systemd/system/docker.service.d/10-proxy.conf > /dev/null
                                                [Service]
                                                Environment="HTTP_PROXY=http://__Proxy__:8080"
                                                Environment="HTTPS_PROXY=http://__Proxy__:8080"
                                                Environment="NO_PROXY=localhost,127.0.0.1"
                                                _HERE_DOCUMENT
                                            -   sudo systemctl daemon-reload
                                        Runner を起動します:  #// GitLab ランナーの Docker イメージをダウンロードして起動します
                                            -   echo  ${http_proxy}, ${https_proxy}  #// URL が表示されること
                                            -   docker run -d --name gitlab-runner-1 --restart always \
                                                -v /srv/gitlab-runner/config:/etc/gitlab-runner \
                                                -v /var/run/docker.sock:/var/run/docker.sock \
                                                -e http_proxy=${http_proxy}/  -e https_proxy=${https_proxy}/ \
                                                gitlab/gitlab-runner:latest
                                        登録に必要な情報を集めます:
                                            #search: GitLab runner register information
                                        ランナーをリポジトリに登録します:  #keyword: gitlab-runner register --non-interactive
                                            docker exec -i  gitlab-runner-1  gitlab-runner register  --url https://gitlab.com  --token glrt-zzqB9sc4QGnV8QShRsjR \
                                                --non-interactive  --name my-runner  --tag-list my-runner  --executor shell
                                            #template-at(-2): --url __URL__  --token __Token__
                                            #// バージョンによってオプションが異なります  #search: gitlab-runner register
                                        ランナーのログを表示し続けます:
                                            docker logs  gitlab-runner-1  --follow
                                        参考:
                                            公式:  #ref: https://docs.gitlab.com/runner/install/docker.html
                                            gitlab-runner を Proxy 環境で使う:
                                                #ref: https://qiita.com/fkshom/items/54080b35892fa9a48aee
                                                #ref: https://docs.gitlab.com/runner/configuration/proxy.html#adding-the-proxy-to-the-docker-containers
                                    Docker なし:  #// OS にインストールしますz
                                        WSL2 Ubuntu 20.04 を起動します:
                                            #// このサンプルは Docker が無くても動きます。シェル スクリプト だけの処理なら Docker を使うメリットはありません
                                            #search: restore Docker for WSL2
                                        ランナーを作ります:
                                            （プロキシがある環境の場合）:
                                                プロキシの環境変数を設定します:
                                                    /etc/profile ファイルと /etc/apt/apt.conf.d/98proxy ファイルを作ります: |  #// 上書きします
                                                        cat <<_HERE_DOCUMENT | sudo tee /etc/profile > /dev/null
                                                        export http_proxy=http://__Proxy__:8080/
                                                        export https_proxy=http://__Proxy__:8080/
                                                        export no_proxy=localhost,127.0.0.1
                                                        _HERE_DOCUMENT
                                                        #
                                                        cat <<_HERE_DOCUMENT | sudo tee /etc/apt/apt.conf.d/98proxy > /dev/null
                                                        Acquire::http::Proxy "http://__Proxy__:8080";
                                                        Acquire::https::Proxy "http://__Proxy__:8080";
                                                        _HERE_DOCUMENT
                                                    #// インデントを削除して実行してください
                                            リポジトリの情報をインストールします:
                                                curl -L "https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh" | sudo --login bash
                                            gitlab-runner（ソフトウェア）をインストールします:
                                                sudo apt-get install gitlab-runner
                                        ランナーを登録します:
                                            登録に必要な情報を集めます: #keyword: GitLab runner register information
                                                メニュー: https://gitlab.com/takakiriy1/first/-/settings/ci_cd#js-runners-settings
                                                    #template: https://gitlab.com/__User__/__Repository__/-/settings/ci_cd#js-runners-settings
                                                    #search: GitLab CI/CD menu
                                                Runners >>（Project runners）New project runner ボタン:
                                                Tags: my-runner-tag  #// ←サンプル。 今から登録する Runner を説明する単語等。Runners の一覧ページに表示されます
                                                Create runner ボタン（下）:
                                                Step 1: |  #// 表示されたコマンドをメモします
                                                        gitlab-runner register  --url https://gitlab.com  --token glrt-zzqB9sc4QGnV8QShRsjR
                                                    #template: --url __URL__  --token __Token__
                                                    #// バージョンによってオプションが異なります  #search: gitlab-runner register
                                                #// このページ（Register runner）を開いたまま次に進みます
                                            ランナーをリポジトリに登録します:
                                                コマンド: #focus: --executor  #ref: https://docs.gitlab.com/runner/commands/
                                                    sudo --login \
                                                        gitlab-runner register  --url https://gitlab.com  --token glrt-zzqB9sc4QGnV8QShRsjR \
                                                        --non-interactive  --name my-runner  --executor shell
                                                    #template-at(-2): --url __URL__  --token __Token__
                                                    #// バージョンによってオプションが異なります  #search: gitlab-runner register
                                            （2回目以降）古い登録があれば削除します:
                                                sudo vi /etc/gitlab-runner/config.toml
                                                #// また、WebUI からも削除します
                                                #// sudo --login gitlab-runner unregister  --url __ --token __ は機能しません  https://qiita.com/crnls1985/items/23f6a4628540fcd5faaa
                                        ランナーを起動します:  #// 状況を把握しやすいように一旦フォアグランドで起動します
                                            コマンド:  #// GitLab と通信します。GitLab には Last contatct ～分前 が表示されます
                                                sudo --login  gitlab-runner run  #// フォアグランドで実行します
                                                #// このまま次に進みます。後でバックグラウンドに変えます
                                            ランナーを GitLab が認識したことを確認します:
                                                Register runner >> Step 3（の下）: |  #// 以下が表示されれば成功です
                                                    🎉 You've created a new runner!
                                                    To view the runner, go to Project › CI/CD Settings › Runners.
                                            Go to runners page ボタン:  #// New project runner のページの最後
                                            トラブルシューティング:  #search: GitLab runner trouble
                                        CI/CD のサンプルを動かします:  #keyword: GitLab runner 1st example
                                            Run untagged jobs にチェックを入れます: #keyword: GitLab Run untagged jobs  #// このサンプルではこれにチェックを入れないとランナーが反応しません
                                                https://gitlab.com/takakiriy1/first/-/settings/ci_cd#js-runners-settings  >>（Runner のハッシュ値）>>
                                                    Run untagged jobs - Indicates whether this runner can pick jobs without tags（にチェック）
                                                #template-at(-2): https://gitlab.com/__User__/__Repository__/-/
                                            git init または git clone など:
                                            __Project__/.gitlab-ci.yml : |  #// CI/CD の設定ファイル
                                                #ref: https://docs.gitlab.com/ee/ci/quick_start/index.html#create-a-gitlab-ciyml-file
                                                build-job:
                                                    stage: build
                                                    script:
                                                        -   echo "Hello, $GITLAB_USER_LOGIN!"

                                                test-job1:
                                                    stage: test
                                                    script:
                                                        -   echo "This job tests something"

                                                test-job2:
                                                    stage: test
                                                    script:
                                                        -   echo "This job tests something, but takes more time than test-job1."
                                                        -   echo "After the echo commands complete, it runs the sleep command for 20 seconds"
                                                        -   echo "which simulates a test that runs 20 seconds longer than test-job1"
                                                        -   sleep 20

                                                deploy-prod:
                                                    stage: deploy
                                                    script:
                                                        -   echo "This job deploys something from the $CI_COMMIT_BRANCH branch."
                                                    environment: production
                                            コミット＆プッシュします:
                                                git add "."  &&  git commit -m update  &&  git push
                                            ランナーの動作結果を確認します:
                                                https://gitlab.com/takakiriy1/first/-/pipelines
                                                    #template: https://gitlab.com/__User__/__Repository__/-/pipelines
                                                #// ランナーは GitLab に対して常にポーリングしています
                                                #search: GitLab runner trouble
                                        ランナーをバックグラウンドで起動します:
                                            #// 未確認
                                            フォアグランドで起動していたら終了します:
                                                Ctrl + C
                                            memo: |
                                                sudo --login  gitlab-runner start
                                                sudo --login  gitlab-runner status  エラー
                                                sudo --login  gitlab-runner stop
                                        Docker で gitlab-runner を起動する場合:  #ref: https://qiita.com/fkshom/items/54080b35892fa9a48aee
                                            #// 未確認
                                            サービスを起動します:  #focus: http_proxy,  https_proxy
                                                docker run -d --name gitlab-runner --restart always \
                                                    -v /srv/gitlab-runner/config:/etc/gitlab-runner \
                                                    -v /var/run/docker.sock:/var/run/docker.sock \
                                                    -e http_proxy=http://__Proxy__:8080/ \
                                                    -e https_proxy=http://__Proxy__:8080/ \
                                                    gitlab/gitlab-runner:latest
                                        参考:
                                            gitlab-runner を Proxy 環境で使う:  #ref: https://qiita.com/fkshom/items/54080b35892fa9a48aee
                                仕組み:
                                    GitLab インスタンスとの通信: #keyword:
                                        インスタンス（パイプライン？）とランナーの通信は HTTP または HTTPS で行われます。
                                        GitLab Runner のインストールと設定の際に、GitLab インスタンスの URL を指定することで、GitLab Runner はその URL にアクセスします。
                                        ポーリングするので NAT を挟んでいても大丈夫です。
                            疎通確認:  #// GitLab specific runner のコンテナーが GitLab のクラウドと通信できているか確認します
                                #search: gitlab-runner verify
                            ランナーを指定します:  #search: GitLab runner tag
                            ランナーを動かします:
                                #search: install GitLab CI/CD
                                #search: .gitlab-ci.yml
                            ランナーを終了します: #keyword: remove GitLab runner,  GitLab runner destroy delete  
                                WebUI から登録削除します:
                                    GitLab >> Available specific runners >> Remove runner  #ref: https://gitlab.com/____/____/-/settings/ci_cd#js-runners-settings
                                Docker コンテナ－ を終了させます:
                                    docker stop
                            シークレットを設定します: #keyword: GitLab runner secrets
                                Shared runner を使ってもよいか検討します:
                                    機密性の高いシークレットの場合は、専用の runner（specific/group runner）を使うことを検討します
                                トークンの種類を決めて生成します:
                                    Project Access Token や Deploy Token
                                    外部サービスの場合はOIDC（OpenID Connect）による認証も検討
                                環境変数にシークレットの値を設定します:  #keyword: GitLab CI/CD environment variable
                                    メニュー: プロジェクト設定 > CI/CD > Variables
                                    Masked: チェック  #// ログに表示されないようにします
                                    Protected: チェック  #// protected なブランチ でのみ定義されます。❗private なリポジトリでも定義されない（参照できない）場合があります
                                        #search: GitLab branch protect
                                        #search: 漏洩リスク
                                    スコープ: ____  #// production, staging など
                                （参考）アンチパターン:
                                    - .gitlab-ci.yml ファイルに直接記述
                                    - echoなどでログに出力される可能性のある処理
                                    - 暗号化されていない形での保存  #// 正規の多くのクラウドの環境変数は暗号化されています
                                トラブルシューティング:  #keyword: GitLab CI/CD environment variable trouble
                                    変数を参照できない:
                                        Protected な変数なら参照できる条件を確認します:
                                            #search: GitLab CI/CD environment variable
                        画面:
                            CI/CD: #keyword: GitLab CI/CD menu
                                - GitLab project >> Settings（左下）>> General >> Visibility, project features, permissions >>
                                    CI/CD（オン）>> Save changes
                                - GitLab project >> Settings（左下）>> CI/CD
                            Runners: #keyword: GitLab runnners web,  Available specific runners, GitLab runners URL
                                GitLab project >> Settings（左下）>> CI/CD >> Runners
                                https://gitlab.com/____/____/-/settings/ci_cd#js-runners-settings
                        コマンド: #glossary: GitLab
                            gitlab-runner register:  #ref: https://gitlab-docs.creationline.com/runner/commands/#gitlab-runner-register
                                （サンプル）:
                                    #search: gitlab-runner register prompt
                                    #search: gitlab-runner register --non-interactive
                                バージョンによる違い:  #// オプションが異なります
                                    トークン:  #// gitlab-runner register コマンドの登録トークンを指定するオプション
                                        GitLab Enterprise Edition 16.7.0-pre: --token glrt-zzqB9sc4QGnV99999999  #// サンプル
                                        GitLab Community Edition 15.0.2:  --registration-token GR1348941WhR2LCxz9Zvd99999999  #// サンプル
                                man による説明: |  #keyword: gitlab-runner register man
                                    Runtime platform                                    arch=amd64 os=linux pid=170 revision=3046fee8 version=16.6.0
                                    NAME:
                                    gitlab-runner register - register a new runner

                                    USAGE:
                                    gitlab-runner register [command options] [arguments...]

                                    OPTIONS:
                                    -c value, --config value                                                                   Config file (default: "/etc/gitlab-runner/config.toml") [$CONFIG_FILE]
                                    --template-config value                                                                    Path to the configuration template file [$TEMPLATE_CONFIG_FILE]
                                    --tag-list value                                                                           Tag list [$RUNNER_TAG_LIST]
                                    -n, --non-interactive                                                                      Run registration unattended [$REGISTER_NON_INTERACTIVE]
                                    --leave-runner                                                                             Don't remove runner if registration fails [$REGISTER_LEAVE_RUNNER]
                                    -r value, --registration-token value                                                       Runner's registration token [$REGISTRATION_TOKEN]
                                    --run-untagged                                                                             Register to run untagged builds; defaults to 'true' when 'tag-list' is empty [$REGISTER_RUN_UNTAGGED]
                                    --locked                                                                                   Lock Runner for current project, defaults to 'true' [$REGISTER_LOCKED]
                                    --access-level value                                                                       Set access_level of the runner to not_protected or ref_protected; defaults to not_protected [$REGISTER_ACCESS_LEVEL]
                                    --maximum-timeout value                                                                    What is the maximum timeout (in seconds) that will be set for job when using this Runner (default: "0") [$REGISTER_MAXIMUM_TIMEOUT]
                                    --paused                                                                                   Set Runner to be paused, defaults to 'false' [$REGISTER_PAUSED]
                                    --maintenance-note value                                                                   Runner's maintenance note [$REGISTER_MAINTENANCE_NOTE]
                                    --name value, --description value                                                          Runner name (default: "b37812e0e09c") [$RUNNER_NAME]
                                    --limit value                                                                              Maximum number of builds processed by this runner (default: "0") [$RUNNER_LIMIT]
                                    --output-limit value                                                                       Maximum build trace size in kilobytes (default: "0") [$RUNNER_OUTPUT_LIMIT]
                                    --request-concurrency value                                                                Maximum concurrency for job requests (default: "0") [$RUNNER_REQUEST_CONCURRENCY]
                                    --unhealthy-requests-limit value                                                           The number of 'unhealthy' responses to new job requests after which a runner worker will be disabled (default: "0") [$RUNNER_UNHEALTHY_REQUESTS_LIMIT]
                                    --unhealthy-interval value                                                                 Duration for which a runner worker is disabled after exceeding the unhealthy requests limit. Supports syntax like '3600s', '1h30min' etc
                                    -u value, --url value                                                                      GitLab instance URL [$CI_SERVER_URL]
                                    -t value, --token value                                                                    Runner token [$CI_SERVER_TOKEN]
                                    --tls-ca-file value                                                                        File containing the certificates to verify the peer when using HTTPS [$CI_SERVER_TLS_CA_FILE]
                                    --tls-cert-file value                                                                      File containing certificate for TLS client auth when using HTTPS [$CI_SERVER_TLS_CERT_FILE]
                                    --tls-key-file value                                                                       File containing private key for TLS client auth when using HTTPS [$CI_SERVER_TLS_KEY_FILE]
                                    --executor value                                                                           Select executor, eg. shell, docker, etc. [$RUNNER_EXECUTOR]
                                    --builds-dir value                                                                         Directory where builds are stored [$RUNNER_BUILDS_DIR]
                                    --cache-dir value                                                                          Directory where build cache is stored [$RUNNER_CACHE_DIR]
                                    --clone-url value                                                                          Overwrite the default URL used to clone or fetch the git ref [$CLONE_URL]
                                    --env value                                                                                Custom environment variables injected to build environment [$RUNNER_ENV]
                                    --pre-clone-script value                                                                   [DEPRECATED] Use pre_get_sources_script instead [$RUNNER_PRE_CLONE_SCRIPT]
                                    --post-clone-script value                                                                  [DEPRECATED] Use post_get_sources_script instead [$RUNNER_POST_CLONE_SCRIPT]
                                    --pre-get-sources-script value                                                             Runner-specific commands to be executed on the runner before updating the Git repository an updating submodules. [$RUNNER_PRE_GET_SOURCES_SCRIPT]
                                    --post-get-sources-script value                                                            Runner-specific commands to be executed on the runner after updating the Git repository and updating submodules. [$RUNNER_POST_GET_SOURCES_SCRIPT]
                                    --pre-build-script value                                                                   Runner-specific command script executed just before build executes [$RUNNER_PRE_BUILD_SCRIPT]
                                    --post-build-script value                                                                  Runner-specific command script executed just after build executes [$RUNNER_POST_BUILD_SCRIPT]
                                    --debug-trace-disabled                                                                     When set to true Runner will disable the possibility of using the CI_DEBUG_TRACE feature [$RUNNER_DEBUG_TRACE_DISABLED]
                                    --safe-directory-checkout value                                                            When set to true, Git global configuration will get a safe.directory directive pointing the job's working directory' [$RUNNER_SAFE_DIRECTORY_CHECKOUT]
                                    --shell value                                                                              Select bash, sh, cmd, pwsh or powershell [$RUNNER_SHELL]
                                    --custom_build_dir-enabled                                                                 Enable job specific build directories [$CUSTOM_BUILD_DIR_ENABLED]
                                    --cache-type value                                                                         Select caching method [$CACHE_TYPE]
                                    --cache-path value                                                                         Name of the path to prepend to the cache URL [$CACHE_PATH]
                                    --cache-shared                                                                             Enable cache sharing between runners. [$CACHE_SHARED]
                                    --cache-max_uploaded_archive_size value                                                    Limit the size of the cache archive being uploaded to cloud storage, in bytes. (default: "0") [$CACHE_MAXIMUM_UPLOADED_ARCHIVE_SIZE]
                                    --cache-s3-server-address value                                                            A host:port to the used S3-compatible server [$CACHE_S3_SERVER_ADDRESS]
                                    --cache-s3-access-key value                                                                S3 Access Key [$CACHE_S3_ACCESS_KEY]
                                    --cache-s3-secret-key value                                                                S3 Secret Key [$CACHE_S3_SECRET_KEY]
                                    --cache-s3-bucket-name value                                                               Name of the bucket where cache will be stored [$CACHE_S3_BUCKET_NAME]
                                    --cache-s3-bucket-location value                                                           Name of S3 region [$CACHE_S3_BUCKET_LOCATION]
                                    --cache-s3-insecure                                                                        Use insecure mode (without https) [$CACHE_S3_INSECURE]
                                    --cache-s3-authentication_type value                                                       IAM or credentials [$CACHE_S3_AUTHENTICATION_TYPE]
                                    --cache-s3-server-side-encryption value                                                    Server side encryption type (S3, or KMS) [$CACHE_S3_SERVER_SIDE_ENCRYPTION]
                                    --cache-s3-server-side-encryption-key-id value                                             Server side encryption key ID (alias or Key ID) [$CACHE_S3_SERVER_SIDE_ENCRYPTION_KEY_ID]
                                    --cache-gcs-access-id value                                                                ID of GCP Service Account used to access the storage [$CACHE_GCS_ACCESS_ID]
                                    --cache-gcs-private-key value                                                              Private key used to sign GCS requests [$CACHE_GCS_PRIVATE_KEY]
                                    --cache-gcs-credentials-file value                                                         File with GCP credentials, containing AccessID and PrivateKey [$GOOGLE_APPLICATION_CREDENTIALS]
                                    --cache-gcs-bucket-name value                                                              Name of the bucket where cache will be stored [$CACHE_GCS_BUCKET_NAME]
                                    --cache-azure-account-name value                                                           Account name for Azure Blob Storage [$CACHE_AZURE_ACCOUNT_NAME]
                                    --cache-azure-account-key value                                                            Access key for Azure Blob Storage [$CACHE_AZURE_ACCOUNT_KEY]
                                    --cache-azure-container-name value                                                         Name of the Azure container where cache will be stored [$CACHE_AZURE_CONTAINER_NAME]
                                    --cache-azure-storage-domain value                                                         Domain name of the Azure storage (e.g. blob.core.windows.net) [$CACHE_AZURE_STORAGE_DOMAIN]
                                    --feature-flags value                                                                      Enable/Disable feature flags https://docs.gitlab.com/runner/configuration/feature-flags.html (default: "{}") [$FEATURE_FLAGS]
                                    --ssh-user value                                                                           User name [$SSH_USER]
                                    --ssh-password value                                                                       User password [$SSH_PASSWORD]
                                    --ssh-host value                                                                           Remote host [$SSH_HOST]
                                    --ssh-port value                                                                           Remote host port [$SSH_PORT]
                                    --ssh-identity-file value                                                                  Identity file to be used [$SSH_IDENTITY_FILE]
                                    --ssh-disable-strict-host-key-checking value                                               Disable SSH strict host key checking [$DISABLE_STRICT_HOST_KEY_CHECKING]
                                    --ssh-known-hosts-file value                                                               Location of known_hosts file. Defaults to ~/.ssh/known_hosts [$KNOWN_HOSTS_FILE]
                                    --docker-host value                                                                        Docker daemon address [$DOCKER_HOST]
                                    --docker-cert-path value                                                                   Certificate path [$DOCKER_CERT_PATH]
                                    --docker-tlsverify                                                                         Use TLS and verify the remote [$DOCKER_TLS_VERIFY]
                                    --docker-hostname value                                                                    Custom container hostname [$DOCKER_HOSTNAME]
                                    --docker-image value                                                                       Docker image to be used [$DOCKER_IMAGE]
                                    --docker-runtime value                                                                     Docker runtime to be used [$DOCKER_RUNTIME]
                                    --docker-memory value                                                                      Memory limit (format: <number>[<unit>]). Unit can be one of b, k, m, or g. Minimum is 4M. [$DOCKER_MEMORY]
                                    --docker-memory-swap value                                                                 Total memory limit (memory + swap, format: <number>[<unit>]). Unit can be one of b, k, m, or g. [$DOCKER_MEMORY_SWAP]
                                    --docker-memory-reservation value                                                          Memory soft limit (format: <number>[<unit>]). Unit can be one of b, k, m, or g. [$DOCKER_MEMORY_RESERVATION]
                                    --docker-cpuset-cpus value                                                                 String value containing the cgroups CpusetCpus to use [$DOCKER_CPUSET_CPUS]
                                    --docker-cpus value                                                                        Number of CPUs [$DOCKER_CPUS]
                                    --docker-cpu-shares value                                                                  Number of CPU shares (default: "0") [$DOCKER_CPU_SHARES]
                                    --docker-dns value                                                                         A list of DNS servers for the container to use [$DOCKER_DNS]
                                    --docker-dns-search value                                                                  A list of DNS search domains [$DOCKER_DNS_SEARCH]
                                    --docker-privileged                                                                        Give extended privileges to container [$DOCKER_PRIVILEGED]
                                    --docker-services_privileged value                                                         When set this will give or remove extended privileges to container services [$DOCKER_SERVICES_PRIVILEGED]
                                    --docker-disable-entrypoint-overwrite                                                      Disable the possibility for a container to overwrite the default image entrypoint [$DOCKER_DISABLE_ENTRYPOINT_OVERWRITE]
                                    --docker-user value                                                                        Run all commands in the container as the specified user. [$DOCKER_USER]
                                    --docker-group-add value                                                                   Add additional groups to join [$DOCKER_GROUP_ADD]
                                    --docker-userns value                                                                      User namespace to use [$DOCKER_USERNS_MODE]
                                    --docker-cap-add value                                                                     Add Linux capabilities [$DOCKER_CAP_ADD]
                                    --docker-cap-drop value                                                                    Drop Linux capabilities [$DOCKER_CAP_DROP]
                                    --docker-oom-kill-disable                                                                  Do not kill processes in a container if an out-of-memory (OOM) error occurs [$DOCKER_OOM_KILL_DISABLE]
                                    --docker-oom-score-adjust value                                                            Adjust OOM score (default: "0") [$DOCKER_OOM_SCORE_ADJUST]
                                    --docker-security-opt value                                                                Security Options [$DOCKER_SECURITY_OPT]
                                    --docker-services-security-opt value                                                       Security Options for container services [$DOCKER_SERVICES_SECURITY_OPT]
                                    --docker-devices value                                                                     Add a host device to the container [$DOCKER_DEVICES]
                                    --docker-device-cgroup-rules value                                                         Add a device cgroup rule to the container [$DOCKER_DEVICE_CGROUP_RULES]
                                    --docker-gpus value                                                                        Request GPUs to be used by Docker [$DOCKER_GPUS]
                                    --docker-disable-cache                                                                     Disable all container caching [$DOCKER_DISABLE_CACHE]
                                    --docker-volumes value                                                                     Bind-mount a volume and create it if it doesn't exist prior to mounting. Can be specified multiple times once per mountpoint, e.g. --docker-volumes 'test0:/test0' --docker-volumes 'test1:/test1' [$DOCKER_VOLUMES]
                                    --docker-volume-driver value                                                               Volume driver to be used [$DOCKER_VOLUME_DRIVER]
                                    --docker-volume-driver-ops value                                                           A toml table/json object with the format key=values. Volume driver ops to be specified (default: "{}") [$DOCKER_VOLUME_DRIVER_OPS]
                                    --docker-cache-dir value                                                                   Directory where to store caches [$DOCKER_CACHE_DIR]
                                    --docker-extra-hosts value                                                                 Add a custom host-to-IP mapping [$DOCKER_EXTRA_HOSTS]
                                    --docker-volumes-from value                                                                A list of volumes to inherit from another container [$DOCKER_VOLUMES_FROM]
                                    --docker-network-mode value                                                                Add container to a custom network [$DOCKER_NETWORK_MODE]
                                    --docker-ipcmode value                                                                     Select IPC mode for container [$DOCKER_IPC_MODE]
                                    --docker-mac-address value                                                                 Container MAC address (e.g., 92:d0:c6:0a:29:33) [$DOCKER_MAC_ADDRESS]
                                    --docker-links value                                                                       Add link to another container [$DOCKER_LINKS]
                                    --docker-wait-for-services-timeout value                                                   How long to wait for service startup (default: "0") [$DOCKER_WAIT_FOR_SERVICES_TIMEOUT]
                                    --docker-allowed-images value                                                              Image allowlist [$DOCKER_ALLOWED_IMAGES]
                                    --docker-allowed-privileged-images value                                                   Privileged image allowlist [$DOCKER_ALLOWED_PRIVILEGED_IMAGES]
                                    --docker-allowed-privileged-services value                                                 Privileged Service allowlist [$DOCKER_ALLOWED_PRIVILEGED_SERVICES]
                                    --docker-allowed-pull-policies value                                                       Pull policy allowlist [$DOCKER_ALLOWED_PULL_POLICIES]
                                    --docker-allowed-services value                                                            Service allowlist [$DOCKER_ALLOWED_SERVICES]
                                    --docker-pull-policy value                                                                 Image pull policy: never, if-not-present, always [$DOCKER_PULL_POLICY]
                                    --docker-isolation value                                                                   Container isolation technology. Windows only [$DOCKER_ISOLATION]
                                    --docker-shm-size value                                                                    Shared memory size for docker images (in bytes) (default: "0") [$DOCKER_SHM_SIZE]
                                    --docker-tmpfs value                                                                       A toml table/json object with the format key=values. When set this will mount the specified path in the key as a tmpfs volume in the main container, using the options specified as key. For the supported options, see the documentation for the unix 'mount' command (default: "{}") [$DOCKER_TMPFS]
                                    --docker-services-tmpfs value                                                              A toml table/json object with the format key=values. When set this will mount the specified path in the key as a tmpfs volume in all the service containers, using the options specified as key. For the supported options, see the documentation for the unix 'mount' command (default: "{}") [$DOCKER_SERVICES_TMPFS]
                                    --docker-sysctls value                                                                     Sysctl options, a toml table/json object of key=value. Value is expected to be a string. (default: "{}") [$DOCKER_SYSCTLS]
                                    --docker-helper-image value                                                                [ADVANCED] Override the default helper image used to clone repos and upload artifacts [$DOCKER_HELPER_IMAGE]
                                    --docker-helper-image-flavor value                                                         Set helper image flavor (alpine, ubuntu), defaults to alpine [$DOCKER_HELPER_IMAGE_FLAVOR]
                                    --docker-container-labels value                                                            A toml table/json object of key-value. Value is expected to be a string. When set, this will create containers with the given container labels. Environment variables will be substituted for values here. (default: "{}")
                                    --docker-enable-ipv6                                                                       Enable IPv6 for automatically created networks. This is only takes affect when the feature flag FF_NETWORK_PER_BUILD is enabled.
                                    --docker-ulimit value                                                                      Ulimit options for container (default: "{}") [$DOCKER_ULIMIT]
                                    --docker-network-mtu value                                                                 MTU of the Docker network created for the job IFF the FF_NETWORK_PER_BUILD feature-flag was specified. (default: "0")
                                    --parallels-base-name value                                                                VM name to be used [$PARALLELS_BASE_NAME]
                                    --parallels-template-name value                                                            VM template to be created [$PARALLELS_TEMPLATE_NAME]
                                    --parallels-disable-snapshots                                                              Disable snapshoting to speedup VM creation [$PARALLELS_DISABLE_SNAPSHOTS]
                                    --parallels-time-server value                                                              Timeserver to sync the guests time from. Defaults to time.apple.com [$PARALLELS_TIME_SERVER]
                                    --parallels-allowed-images value                                                           Image (base_name) allowlist [$PARALLELS_ALLOWED_IMAGES]
                                    --virtualbox-base-name value                                                               VM name to be used [$VIRTUALBOX_BASE_NAME]
                                    --virtualbox-base-snapshot value                                                           Name or UUID of a specific VM snapshot to clone [$VIRTUALBOX_BASE_SNAPSHOT]
                                    --virtualbox-base-folder value                                                             Folder in which to save the new VM. If empty, uses VirtualBox default [$VIRTUALBOX_BASE_FOLDER]
                                    --virtualbox-disable-snapshots                                                             Disable snapshoting to speedup VM creation [$VIRTUALBOX_DISABLE_SNAPSHOTS]
                                    --virtualbox-allowed-images value                                                          Image allowlist [$VIRTUALBOX_ALLOWED_IMAGES]
                                    --virtualbox-start-type value                                                              Graphical front-end type [$VIRTUALBOX_START_TYPE]
                                    --machine-max-growth-rate value                                                            Maximum machines being provisioned concurrently, set to 0 for unlimited (default: "0") [$MACHINE_MAX_GROWTH_RATE]
                                    --machine-idle-nodes value                                                                 Maximum idle machines (default: "0") [$MACHINE_IDLE_COUNT]
                                    --machine-idle-scale-factor value                                                          (Experimental) Defines what factor of in-use machines should be used as current idle value, but never more then defined IdleCount. 0.0 means use IdleCount as a static number (defaults to 0.0). Must be defined as float number. (default: "0") [$MACHINE_IDLE_SCALE_FACTOR]
                                    --machine-idle-count-min value                                                             Minimal number of idle machines when IdleScaleFactor is in use. Defaults to 1. (default: "0") [$MACHINE_IDLE_COUNT_MIN]
                                    --machine-idle-time value                                                                  Minimum time after node can be destroyed (default: "0") [$MACHINE_IDLE_TIME]
                                    --machine-max-builds value                                                                 Maximum number of builds processed by machine (default: "0") [$MACHINE_MAX_BUILDS]
                                    --machine-machine-driver value                                                             The driver to use when creating machine [$MACHINE_DRIVER]
                                    --machine-machine-name value                                                               The template for machine name (needs to include %s) [$MACHINE_NAME]
                                    --machine-machine-options value                                                            Additional machine creation options [$MACHINE_OPTIONS]
                                    --kubernetes-host value                                                                    Optional Kubernetes master host URL (auto-discovery attempted if not specified) [$KUBERNETES_HOST]
                                    --kubernetes-cert-file value                                                               Optional Kubernetes master auth certificate [$KUBERNETES_CERT_FILE]
                                    --kubernetes-key-file value                                                                Optional Kubernetes master auth private key [$KUBERNETES_KEY_FILE]
                                    --kubernetes-ca-file value                                                                 Optional Kubernetes master auth ca certificate [$KUBERNETES_CA_FILE]
                                    --kubernetes-bearer_token_overwrite_allowed                                                Bool to authorize builds to specify their own bearer token for creation. [$KUBERNETES_BEARER_TOKEN_OVERWRITE_ALLOWED]
                                    --kubernetes-bearer_token value                                                            Optional Kubernetes service account token used to start build pods. [$KUBERNETES_BEARER_TOKEN]
                                    --kubernetes-image value                                                                   Default docker image to use for builds when none is specified [$KUBERNETES_IMAGE]
                                    --kubernetes-namespace value                                                               Namespace to run Kubernetes jobs in [$KUBERNETES_NAMESPACE]
                                    --kubernetes-namespace_overwrite_allowed value                                             Regex to validate 'KUBERNETES_NAMESPACE_OVERWRITE' value [$KUBERNETES_NAMESPACE_OVERWRITE_ALLOWED]
                                    --kubernetes-privileged value                                                              Run all containers with the privileged flag enabled [$KUBERNETES_PRIVILEGED]
                                    --kubernetes-runtime-class-name value                                                      A Runtime Class to use for all created pods, errors if the feature is unsupported by the cluster [$KUBERNETES_RUNTIME_CLASS_NAME]
                                    --kubernetes-allow-privilege-escalation value                                              Run all containers with the security context allowPrivilegeEscalation flag enabled. When empty, it does not define the allowPrivilegeEscalation flag in the container SecurityContext and allows Kubernetes to use the default privilege escalation behavior. [$KUBERNETES_ALLOW_PRIVILEGE_ESCALATION]
                                    --kubernetes-cpu-limit value                                                               The CPU allocation given to build containers [$KUBERNETES_CPU_LIMIT]
                                    --kubernetes-cpu-limit-overwrite-max-allowed value                                         If set, the max amount the cpu limit can be set to. Used with the KUBERNETES_CPU_LIMIT variable in the build. [$KUBERNETES_CPU_LIMIT_OVERWRITE_MAX_ALLOWED]
                                    --kubernetes-cpu-request value                                                             The CPU allocation requested for build containers [$KUBERNETES_CPU_REQUEST]
                                    --kubernetes-cpu-request-overwrite-max-allowed value                                       If set, the max amount the cpu request can be set to. Used with the KUBERNETES_CPU_REQUEST variable in the build. [$KUBERNETES_CPU_REQUEST_OVERWRITE_MAX_ALLOWED]
                                    --kubernetes-memory-limit value                                                            The amount of memory allocated to build containers [$KUBERNETES_MEMORY_LIMIT]
                                    --kubernetes-memory-limit-overwrite-max-allowed value                                      If set, the max amount the memory limit can be set to. Used with the KUBERNETES_MEMORY_LIMIT variable in the build. [$KUBERNETES_MEMORY_LIMIT_OVERWRITE_MAX_ALLOWED]
                                    --kubernetes-memory-request value                                                          The amount of memory requested from build containers [$KUBERNETES_MEMORY_REQUEST]
                                    --kubernetes-memory-request-overwrite-max-allowed value                                    If set, the max amount the memory request can be set to. Used with the KUBERNETES_MEMORY_REQUEST variable in the build. [$KUBERNETES_MEMORY_REQUEST_OVERWRITE_MAX_ALLOWED]
                                    --kubernetes-ephemeral-storage-limit value                                                 The amount of ephemeral storage allocated to build containers [$KUBERNETES_EPHEMERAL_STORAGE_LIMIT]
                                    --kubernetes-ephemeral-storage-limit-overwrite-max-allowed value                           If set, the max amount the ephemeral limit can be set to. Used with the KUBERNETES_EPHEMERAL_STORAGE_LIMIT variable in the build. [$KUBERNETES_EPHEMERAL_STORAGE_LIMIT_OVERWRITE_MAX_ALLOWED]
                                    --kubernetes-ephemeral-storage-request value                                               The amount of ephemeral storage requested from build containers [$KUBERNETES_EPHEMERAL_STORAGE_REQUEST]
                                    --kubernetes-ephemeral-storage-request-overwrite-max-allowed value                         If set, the max amount the ephemeral storage request can be set to. Used with the KUBERNETES_EPHEMERAL_STORAGE_REQUEST variable in the build. [$KUBERNETES_EPHEMERAL_STORAGE_REQUEST_OVERWRITE_MAX_ALLOWED]
                                    --kubernetes-service-cpu-limit value                                                       The CPU allocation given to build service containers [$KUBERNETES_SERVICE_CPU_LIMIT]
                                    --kubernetes-service-cpu-limit-overwrite-max-allowed value                                 If set, the max amount the service cpu limit can be set to. Used with the KUBERNETES_SERVICE_CPU_LIMIT variable in the build. [$KUBERNETES_SERVICE_CPU_LIMIT_OVERWRITE_MAX_ALLOWED]
                                    --kubernetes-service-cpu-request value                                                     The CPU allocation requested for build service containers [$KUBERNETES_SERVICE_CPU_REQUEST]
                                    --kubernetes-service-cpu-request-overwrite-max-allowed value                               If set, the max amount the service cpu request can be set to. Used with the KUBERNETES_SERVICE_CPU_REQUEST variable in the build. [$KUBERNETES_SERVICE_CPU_REQUEST_OVERWRITE_MAX_ALLOWED]
                                    --kubernetes-service-memory-limit value                                                    The amount of memory allocated to build service containers [$KUBERNETES_SERVICE_MEMORY_LIMIT]
                                    --kubernetes-service-memory-limit-overwrite-max-allowed value                              If set, the max amount the service memory limit can be set to. Used with the KUBERNETES_SERVICE_MEMORY_LIMIT variable in the build. [$KUBERNETES_SERVICE_MEMORY_LIMIT_OVERWRITE_MAX_ALLOWED]
                                    --kubernetes-service-memory-request value                                                  The amount of memory requested for build service containers [$KUBERNETES_SERVICE_MEMORY_REQUEST]
                                    --kubernetes-service-memory-request-overwrite-max-allowed value                            If set, the max amount the service memory request can be set to. Used with the KUBERNETES_SERVICE_MEMORY_REQUEST variable in the build. [$KUBERNETES_SERVICE_MEMORY_REQUEST_OVERWRITE_MAX_ALLOWED]
                                    --kubernetes-service-ephemeral_storage-limit value                                         The amount of ephemeral storage allocated to build service containers [$KUBERNETES_SERVICE_EPHEMERAL_STORAGE_LIMIT]
                                    --kubernetes-service-ephemeral_storage-limit-overwrite-max-allowed value                   If set, the max amount the service ephemeral storage limit can be set to. Used with the KUBERNETES_SERVICE_EPHEMERAL_STORAGE_LIMIT variable in the build. [$KUBERNETES_SERVICE_EPHEMERAL_STORAGE_LIMIT_OVERWRITE_MAX_ALLOWED]
                                    --kubernetes-service-ephemeral_storage-request value                                       The amount of ephemeral storage requested for build service containers [$KUBERNETES_SERVICE_EPHEMERAL_STORAGE_REQUEST]
                                    --kubernetes-service-ephemeral_storage-request-overwrite-max-allowed value                 If set, the max amount the service ephemeral storage request can be set to. Used with the KUBERNETES_SERVICE_EPHEMERAL_STORAGE_REQUEST variable in the build. [$KUBERNETES_SERVICE_EPHEMERAL_STORAGE_REQUEST_OVERWRITE_MAX_ALLOWED]
                                    --kubernetes-helper-cpu-limit value                                                        The CPU allocation given to build helper containers [$KUBERNETES_HELPER_CPU_LIMIT]
                                    --kubernetes-helper-cpu-limit-overwrite-max-allowed value                                  If set, the max amount the helper cpu limit can be set to. Used with the KUBERNETES_HELPER_CPU_LIMIT variable in the build. [$KUBERNETES_HELPER_CPU_LIMIT_OVERWRITE_MAX_ALLOWED]
                                    --kubernetes-helper-cpu-request value                                                      The CPU allocation requested for build helper containers [$KUBERNETES_HELPER_CPU_REQUEST]
                                    --kubernetes-helper-cpu-request-overwrite-max-allowed value                                If set, the max amount the helper cpu request can be set to. Used with the KUBERNETES_HELPER_CPU_REQUEST variable in the build. [$KUBERNETES_HELPER_CPU_REQUEST_OVERWRITE_MAX_ALLOWED]
                                    --kubernetes-helper-memory-limit value                                                     The amount of memory allocated to build helper containers [$KUBERNETES_HELPER_MEMORY_LIMIT]
                                    --kubernetes-helper-memory-limit-overwrite-max-allowed value                               If set, the max amount the helper memory limit can be set to. Used with the KUBERNETES_HELPER_MEMORY_LIMIT variable in the build. [$KUBERNETES_HELPER_MEMORY_LIMIT_OVERWRITE_MAX_ALLOWED]
                                    --kubernetes-helper-memory-request value                                                   The amount of memory requested for build helper containers [$KUBERNETES_HELPER_MEMORY_REQUEST]
                                    --kubernetes-helper-memory-request-overwrite-max-allowed value                             If set, the max amount the helper memory request can be set to. Used with the KUBERNETES_HELPER_MEMORY_REQUEST variable in the build. [$KUBERNETES_HELPER_MEMORY_REQUEST_OVERWRITE_MAX_ALLOWED]
                                    --kubernetes-helper-ephemeral_storage-limit value                                          The amount of ephemeral storage allocated to build helper containers [$KUBERNETES_HELPER_EPHEMERAL_STORAGE_LIMIT]
                                    --kubernetes-helper-ephemeral_storage-limit-overwrite-max-allowed value                    If set, the max amount the helper ephemeral storage limit can be set to. Used with the KUBERNETES_HELPER_EPHEMERAL_STORAGE_LIMIT variable in the build. [$KUBERNETES_HELPER_EPHEMERAL_STORAGE_LIMIT_OVERWRITE_MAX_ALLOWED]
                                    --kubernetes-helper-ephemeral_storage-request value                                        The amount of ephemeral storage requested for build helper containers [$KUBERNETES_HELPER_EPHEMERAL_STORAGE_REQUEST]
                                    --kubernetes-helper-ephemeral_storage-request-overwrite-max-allowed value                  If set, the max amount the helper ephemeral storage request can be set to. Used with the KUBERNETES_HELPER_EPHEMERAL_STORAGE_REQUEST variable in the build. [$KUBERNETES_HELPER_EPHEMERAL_STORAGE_REQUEST_OVERWRITE_MAX_ALLOWED]
                                    --kubernetes-allowed-images value                                                          Image allowlist [$KUBERNETES_ALLOWED_IMAGES]
                                    --kubernetes-allowed-pull-policies value                                                   Pull policy allowlist [$KUBERNETES_ALLOWED_PULL_POLICIES]
                                    --kubernetes-allowed-services value                                                        Service allowlist [$KUBERNETES_ALLOWED_SERVICES]
                                    --kubernetes-pull-policy value                                                             Policy for if/when to pull a container image (never, if-not-present, always). The cluster default will be used if not set [$KUBERNETES_PULL_POLICY]
                                    --kubernetes-node-selector value                                                           A toml table/json object of key:value. Value is expected to be a string. When set this will create pods on k8s nodes that match all the key:value pairs. Only one selector is supported through environment variable configuration. (default: "{}") [$KUBERNETES_NODE_SELECTOR]
                                    --kubernetes-node_selector_overwrite_allowed value                                         Regex to validate 'KUBERNETES_NODE_SELECTOR_*' values [$KUBERNETES_NODE_SELECTOR_OVERWRITE_ALLOWED]
                                    --kubernetes-node-tolerations value                                                        A toml table/json object of key=value:effect. Value and effect are expected to be strings. When set, pods will tolerate the given taints. Only one toleration is supported through environment variable configuration. (default: "{}") [$KUBERNETES_NODE_TOLERATIONS]
                                    --kubernetes-image-pull-secrets value                                                      A list of image pull secrets that are used for pulling docker image [$KUBERNETES_IMAGE_PULL_SECRETS]
                                    --kubernetes-helper-image value                                                            [ADVANCED] Override the default helper image used to clone repos and upload artifacts [$KUBERNETES_HELPER_IMAGE]
                                    --kubernetes-helper-image-flavor value                                                     Set helper image flavor (alpine, ubuntu), defaults to alpine [$KUBERNETES_HELPER_IMAGE_FLAVOR]
                                    --kubernetes-helper-image-autoset-arch-and-os                                              When set, it uses the underlying OS to set the Helper Image ARCH and OS [$KUBERNETES_HELPER_IMAGE_AUTOSET_ARCH_AND_OS]
                                    --kubernetes-terminationGracePeriodSeconds value                                           Duration after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal.DEPRECATED: use KUBERNETES_POD_TERMINATION_GRACE_PERIOD_SECONDS and KUBERNETES_CLEANUP_GRACE_PERIOD_SECONDS instead. [$KUBERNETES_TERMINATIONGRACEPERIODSECONDS]
                                    --kubernetes-pod_termination_grace_period_seconds value                                    Pod-level setting which determines the duration in seconds which the pod has to terminate gracefully. After this, the processes are forcibly halted with a kill signal. Ignored if KUBERNETES_TERMINATIONGRACEPERIODSECONDS is specified. [$KUBERNETES_POD_TERMINATION_GRACE_PERIOD_SECONDS]
                                    --kubernetes-cleanup_grace_period_seconds value                                            When cleaning up a pod on completion of a job, the duration in seconds which the pod has to terminate gracefully. After this, the processes are forcibly halted with a kill signal. Ignored if KUBERNETES_TERMINATIONGRACEPERIODSECONDS is specified. [$KUBERNETES_CLEANUP_GRACE_PERIOD_SECONDS]
                                    --kubernetes-cleanup_resources_timeout value                                               The total amount of time for Kubernetes resources to be cleaned up after the job completes. Supported syntax: '1h30m', '300s', '10m'. Default is 5 minutes ('5m'). [$KUBERNETES_CLEANUP_RESOURCES_TIMEOUT]
                                    --kubernetes-poll-interval value                                                           How frequently, in seconds, the runner will poll the Kubernetes pod it has just created to check its status (default: "0") [$KUBERNETES_POLL_INTERVAL]
                                    --kubernetes-poll-timeout value                                                            The total amount of time, in seconds, that needs to pass before the runner will timeout attempting to connect to the pod it has just created (useful for queueing more builds that the cluster can handle at a time) (default: "0") [$KUBERNETES_POLL_TIMEOUT]
                                    --kubernetes-resource-availability-check-max-attempts value                                The maximum number of attempts to check if a resource (service account and/or pull secret) set is available before giving up. There is 5 seconds interval between each attempt (default: "0") [$KUBERNETES_RESOURCE_AVAILABILITY_CHECK_MAX_ATTEMPTS]
                                    --kubernetes-pod-labels value                                                              A toml table/json object of key-value. Value is expected to be a string. When set, this will create pods with the given pod labels. Environment variables will be substituted for values here. (default: "{}")
                                    --kubernetes-pod_labels_overwrite_allowed value                                            Regex to validate 'KUBERNETES_POD_LABELS_*' values [$KUBERNETES_POD_LABELS_OVERWRITE_ALLOWED]
                                    --kubernetes-scheduler-name value                                                          Pods will be scheduled using this scheduler, if it exists [$KUBERNETES_SCHEDULER_NAME]
                                    --kubernetes-service-account value                                                         Executor pods will use this Service Account to talk to kubernetes API [$KUBERNETES_SERVICE_ACCOUNT]
                                    --kubernetes-service_account_overwrite_allowed value                                       Regex to validate 'KUBERNETES_SERVICE_ACCOUNT' value [$KUBERNETES_SERVICE_ACCOUNT_OVERWRITE_ALLOWED]
                                    --kubernetes-pod-annotations value                                                         A toml table/json object of key-value. Value is expected to be a string. When set, this will create pods with the given annotations. Can be overwritten in build with KUBERNETES_POD_ANNOTATION_* variables (default: "{}")
                                    --kubernetes-pod_annotations_overwrite_allowed value                                       Regex to validate 'KUBERNETES_POD_ANNOTATIONS_*' values [$KUBERNETES_POD_ANNOTATIONS_OVERWRITE_ALLOWED]
                                    --kubernetes-pod-security-context-fs-group value                                           A special supplemental group that applies to all containers in a pod [$KUBERNETES_POD_SECURITY_CONTEXT_FS_GROUP]
                                    --kubernetes-pod-security-context-run-as-group value                                       The GID to run the entrypoint of the container process [$KUBERNETES_POD_SECURITY_CONTEXT_RUN_AS_GROUP]
                                    --kubernetes-pod-security-context-run-as-non-root value                                    Indicates that the container must run as a non-root user [$KUBERNETES_POD_SECURITY_CONTEXT_RUN_AS_NON_ROOT]
                                    --kubernetes-pod-security-context-run-as-user value                                        The UID to run the entrypoint of the container process [$KUBERNETES_POD_SECURITY_CONTEXT_RUN_AS_USER]
                                    --kubernetes-pod-security-context-supplemental-groups value                                A list of groups applied to the first process run in each container, in addition to the container's primary GID
                                    --kubernetes-pod-security-context-selinux-type value                                       The SELinux type label that applies to all containers in a pod
                                    --kubernetes-init_permissions_container_security_context-capabilities-add value            List of capabilities to add to the build container [$KUBERNETES_INIT_PERMISSIONS_CONTAINER_SECURITY_CONTEXT_CAPABILITIES_ADD]
                                    --kubernetes-init_permissions_container_security_context-capabilities-drop value           List of capabilities to drop from the build container [$KUBERNETES_INIT_PERMISSIONS_CONTAINER_SECURITY_CONTEXT_CAPABILITIES_DROP]
                                    --kubernetes-init_permissions_container_security_context-privileged value                  Run container in privileged mode [$KUBERNETES_INIT_PERMISSIONS_CONTAINER_SECURITY_CONTEXT_PRIVILEGED]
                                    --kubernetes-init_permissions_container_security_context-run-as-user value                 The UID to run the entrypoint of the container process [$KUBERNETES_INIT_PERMISSIONS_CONTAINER_SECURITY_CONTEXT_RUN_AS_USER]
                                    --kubernetes-init_permissions_container_security_context-run-as-group value                The GID to run the entrypoint of the container process [$KUBERNETES_INIT_PERMISSIONS_CONTAINER_SECURITY_CONTEXT_RUN_AS_GROUP]
                                    --kubernetes-init_permissions_container_security_context-run-as-non-root value             Indicates that the container must run as a non-root user [$KUBERNETES_INIT_PERMISSIONS_CONTAINER_SECURITY_CONTEXT_RUN_AS_NON_ROOT]
                                    --kubernetes-init_permissions_container_security_context-read-only-root-filesystem value   Whether this container has a read-only root filesystem. [$KUBERNETES_INIT_PERMISSIONS_CONTAINER_SECURITY_CONTEXT_READ_ONLY_ROOT_FILESYSTEM]
                                    --kubernetes-init_permissions_container_security_context-allow-privilege-escalation value  AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process [$KUBERNETES_INIT_PERMISSIONS_CONTAINER_SECURITY_CONTEXT_ALLOW_PRIVILEGE_ESCALATION]
                                    --kubernetes-init_permissions_container_security_context-selinux-type value                The SELinux type label that is associated with the container process
                                    --kubernetes-init_permissions_container_security_context-proc-mount value                  Denotes the type of proc mount to use for the container. Valid values: default | unmasked. Set to unmasked if this container will be used to build OCI images. [$KUBERNETES_INIT_PERMISSIONS_CONTAINER_SECURITY_CONTEXT_PROC_MOUNT]
                                    --kubernetes-build_container_security_context-capabilities-add value                       List of capabilities to add to the build container [$KUBERNETES_BUILD_CONTAINER_SECURITY_CONTEXT_CAPABILITIES_ADD]
                                    --kubernetes-build_container_security_context-capabilities-drop value                      List of capabilities to drop from the build container [$KUBERNETES_BUILD_CONTAINER_SECURITY_CONTEXT_CAPABILITIES_DROP]
                                    --kubernetes-build_container_security_context-privileged value                             Run container in privileged mode [$KUBERNETES_BUILD_CONTAINER_SECURITY_CONTEXT_PRIVILEGED]
                                    --kubernetes-build_container_security_context-run-as-user value                            The UID to run the entrypoint of the container process [$KUBERNETES_BUILD_CONTAINER_SECURITY_CONTEXT_RUN_AS_USER]
                                    --kubernetes-build_container_security_context-run-as-group value                           The GID to run the entrypoint of the container process [$KUBERNETES_BUILD_CONTAINER_SECURITY_CONTEXT_RUN_AS_GROUP]
                                    --kubernetes-build_container_security_context-run-as-non-root value                        Indicates that the container must run as a non-root user [$KUBERNETES_BUILD_CONTAINER_SECURITY_CONTEXT_RUN_AS_NON_ROOT]
                                    --kubernetes-build_container_security_context-read-only-root-filesystem value              Whether this container has a read-only root filesystem. [$KUBERNETES_BUILD_CONTAINER_SECURITY_CONTEXT_READ_ONLY_ROOT_FILESYSTEM]
                                    --kubernetes-build_container_security_context-allow-privilege-escalation value             AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process [$KUBERNETES_BUILD_CONTAINER_SECURITY_CONTEXT_ALLOW_PRIVILEGE_ESCALATION]
                                    --kubernetes-build_container_security_context-selinux-type value                           The SELinux type label that is associated with the container process
                                    --kubernetes-build_container_security_context-proc-mount value                             Denotes the type of proc mount to use for the container. Valid values: default | unmasked. Set to unmasked if this container will be used to build OCI images. [$KUBERNETES_BUILD_CONTAINER_SECURITY_CONTEXT_PROC_MOUNT]
                                    --kubernetes-helper_container_security_context-capabilities-add value                      List of capabilities to add to the build container [$KUBERNETES_HELPER_CONTAINER_SECURITY_CONTEXT_CAPABILITIES_ADD]
                                    --kubernetes-helper_container_security_context-capabilities-drop value                     List of capabilities to drop from the build container [$KUBERNETES_HELPER_CONTAINER_SECURITY_CONTEXT_CAPABILITIES_DROP]
                                    --kubernetes-helper_container_security_context-privileged value                            Run container in privileged mode [$KUBERNETES_HELPER_CONTAINER_SECURITY_CONTEXT_PRIVILEGED]
                                    --kubernetes-helper_container_security_context-run-as-user value                           The UID to run the entrypoint of the container process [$KUBERNETES_HELPER_CONTAINER_SECURITY_CONTEXT_RUN_AS_USER]
                                    --kubernetes-helper_container_security_context-run-as-group value                          The GID to run the entrypoint of the container process [$KUBERNETES_HELPER_CONTAINER_SECURITY_CONTEXT_RUN_AS_GROUP]
                                    --kubernetes-helper_container_security_context-run-as-non-root value                       Indicates that the container must run as a non-root user [$KUBERNETES_HELPER_CONTAINER_SECURITY_CONTEXT_RUN_AS_NON_ROOT]
                                    --kubernetes-helper_container_security_context-read-only-root-filesystem value             Whether this container has a read-only root filesystem. [$KUBERNETES_HELPER_CONTAINER_SECURITY_CONTEXT_READ_ONLY_ROOT_FILESYSTEM]
                                    --kubernetes-helper_container_security_context-allow-privilege-escalation value            AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process [$KUBERNETES_HELPER_CONTAINER_SECURITY_CONTEXT_ALLOW_PRIVILEGE_ESCALATION]
                                    --kubernetes-helper_container_security_context-selinux-type value                          The SELinux type label that is associated with the container process
                                    --kubernetes-helper_container_security_context-proc-mount value                            Denotes the type of proc mount to use for the container. Valid values: default | unmasked. Set to unmasked if this container will be used to build OCI images. [$KUBERNETES_HELPER_CONTAINER_SECURITY_CONTEXT_PROC_MOUNT]
                                    --kubernetes-service_container_security_context-capabilities-add value                     List of capabilities to add to the build container [$KUBERNETES_SERVICE_CONTAINER_SECURITY_CONTEXT_CAPABILITIES_ADD]
                                    --kubernetes-service_container_security_context-capabilities-drop value                    List of capabilities to drop from the build container [$KUBERNETES_SERVICE_CONTAINER_SECURITY_CONTEXT_CAPABILITIES_DROP]
                                    --kubernetes-service_container_security_context-privileged value                           Run container in privileged mode [$KUBERNETES_SERVICE_CONTAINER_SECURITY_CONTEXT_PRIVILEGED]
                                    --kubernetes-service_container_security_context-run-as-user value                          The UID to run the entrypoint of the container process [$KUBERNETES_SERVICE_CONTAINER_SECURITY_CONTEXT_RUN_AS_USER]
                                    --kubernetes-service_container_security_context-run-as-group value                         The GID to run the entrypoint of the container process [$KUBERNETES_SERVICE_CONTAINER_SECURITY_CONTEXT_RUN_AS_GROUP]
                                    --kubernetes-service_container_security_context-run-as-non-root value                      Indicates that the container must run as a non-root user [$KUBERNETES_SERVICE_CONTAINER_SECURITY_CONTEXT_RUN_AS_NON_ROOT]
                                    --kubernetes-service_container_security_context-read-only-root-filesystem value            Whether this container has a read-only root filesystem. [$KUBERNETES_SERVICE_CONTAINER_SECURITY_CONTEXT_READ_ONLY_ROOT_FILESYSTEM]
                                    --kubernetes-service_container_security_context-allow-privilege-escalation value           AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process [$KUBERNETES_SERVICE_CONTAINER_SECURITY_CONTEXT_ALLOW_PRIVILEGE_ESCALATION]
                                    --kubernetes-service_container_security_context-selinux-type value                         The SELinux type label that is associated with the container process
                                    --kubernetes-service_container_security_context-proc-mount value                           Denotes the type of proc mount to use for the container. Valid values: default | unmasked. Set to unmasked if this container will be used to build OCI images. [$KUBERNETES_SERVICE_CONTAINER_SECURITY_CONTEXT_PROC_MOUNT]
                                    --kubernetes-host_aliases value                                                            Add a custom host-to-IP mapping
                                    --kubernetes-cap-add value                                                                 Add Linux capabilities [$KUBERNETES_CAP_ADD]
                                    --kubernetes-cap-drop value                                                                Drop Linux capabilities [$KUBERNETES_CAP_DROP]
                                    --kubernetes-dns-policy value                                                              How Kubernetes should try to resolve DNS from the created pods. If unset, Kubernetes will use the default 'ClusterFirst'. Valid values are: none, default, cluster-first, cluster-first-with-host-net [$KUBERNETES_DNS_POLICY]
                                    --kubernetes-priority_class_name value                                                     If set, the Kubernetes Priority Class to be set to the Pods [$KUBERNETES_PRIORITY_CLASS_NAME]
                                    --custom-config-exec value                                                                 Executable that allows to inject configuration values to the executor [$CUSTOM_CONFIG_EXEC]
                                    --custom-config-args value                                                                 Arguments for the config executable
                                    --custom-config-exec-timeout value                                                         Timeout for the config executable (in seconds) [$CUSTOM_CONFIG_EXEC_TIMEOUT]
                                    --custom-prepare-exec value                                                                Executable that prepares executor [$CUSTOM_PREPARE_EXEC]
                                    --custom-prepare-args value                                                                Arguments for the prepare executable
                                    --custom-prepare-exec-timeout value                                                        Timeout for the prepare executable (in seconds) [$CUSTOM_PREPARE_EXEC_TIMEOUT]
                                    --custom-run-exec value                                                                    Executable that runs the job script in executor [$CUSTOM_RUN_EXEC]
                                    --custom-run-args value                                                                    Arguments for the run executable
                                    --custom-cleanup-exec value                                                                Executable that cleanups after executor run [$CUSTOM_CLEANUP_EXEC]
                                    --custom-cleanup-args value                                                                Arguments for the cleanup executable
                                    --custom-cleanup-exec-timeout value                                                        Timeout for the cleanup executable (in seconds) [$CUSTOM_CLEANUP_EXEC_TIMEOUT]
                                    --custom-graceful-kill-timeout value                                                       Graceful timeout for scripts execution after SIGTERM is sent to the process (in seconds). This limits the time given for scripts to perform the cleanup before exiting [$CUSTOM_GRACEFUL_KILL_TIMEOUT]
                                    --custom-force-kill-timeout value                                                          Force timeout for scripts execution (in seconds). Counted from the force kill call; if process will be not terminated, Runner will abandon process termination and log an error [$CUSTOM_FORCE_KILL_TIMEOUT]
                            gitlab-runner verify:  #ref: https://gitlab-docs.creationline.com/runner/commands/#gitlab-runner-verify
                                疎通確認します:  #// GitLab specific runner のコンテナーが GitLab のクラウドと通信できているか確認します
                                    ランナーからクラウドにアクセスします:
                                        -   gitlab-runner verify --delete
                                        #// または
                                        -   docker exec gitlab-runner-1  gitlab-runner verify --delete
                                        #// --delete オプションは古い設定を削除します
                                    クラウドが検知したことを確認します:
                                        #search: GitLab runnners web  >>（ランナーのハッシュ値）>> Last contact
                                実行例: |  #focus: alive,  removed  #// 古いトークンがあると removed エラーになります
                                    $ (docker exec) gitlab-runner-1 gitlab-runner verify
                                    Runtime platform                                    arch=amd64 os=linux pid=29 revision=3046fee8 version=16.6.0
                                    Running in system-mode.                            
                                                                                    
                                    ERROR: Verifying runner... is removed               runner=aaaaaaaa status=POST https://__GitLab__/api/v4/runners/verify: 403 Forbidden
                                    Verifying runner... is alive                        runner=bbbbbbbb
                                    FATAL: Failed to verify runners                    
                                古いトークンの削除:  #// クラウドから削除されたランナーのトークンをランナーから消します
                                    -   gitlab-runner verify --delete
                                    #// または
                                    -   docker exec gitlab-runner-1  gitlab-runner verify --delete
                        構造:
                            タグ: #keyword: GitLab runner tag  #// ランナーを特定します
                                ランナー:  #// ランナーに付けるタグ
                                    https://gitlab.com/__User__/__Repository__/-/settings/ci_cd#js-runners-settings  >>
                                    Edit（鉛筆ボタン）>> Tags（最も下）
                                .gitlab-ci.yml: |  #// ジョブにランナーを関連付けます
                                    __Job__:
                                        tags: [__RunnerTag__]
                            種類 >> 共有ランナー, 特定のランナー:  #search: GitLab shared runners, GitLab specific runners
                                共有ランナー, SaaS runner: #keyword: GitLab shared runners
                                    #ref: https://gitlab-docs.creationline.com/ee/ci/runners/#共有runner
                                    一覧: #ref: https://gitlab.com/____/____/-/settings/ci_cd#js-runners-settings
                                    選択:  #search: .gitlab-ci.yml tags
                                    シークレットを設定します:  #search: GitLab runner secrets
                                特定のランナー: #keyword: GitLab specific runners,  GitLab self-managed runner,  GitLab project runners  #// 特別な権限、または特殊な用途や性能を持ったサーバー
                                    #ref: https://gitlab-docs.creationline.com/ee/ci/runners/#特定のランナー
                                    共有より特定が良い場合:
                                        - 資格が必要なデプロイの仕事など、特定の条件があるジョブ
                                        - CIアクティビティが多く、他のRunnerから分離することで恩恵を受けることができるプロジェクト
                                    新規作成:  #search: install GitLab runner
                                    情報: #keyword: GitLab specific runners page  #// ランナーの情報を表示します
                                        #search: GitLab CI/CD settings
                                        Assigned project runners（左下）>> △#__Number__ (__RunnerID__)
                                    選択:  #search: .gitlab-ci.yml tags
                                    ログイン, 実行環境:  #search: GitLab job environment
                                    シークレットを設定します:  #search: GitLab runner secrets
                                実行環境:  #keyword: GitLab runner job environment
                                    ログイン: #keyword: GitLab specific runners log in
                                        -   su --login  __User__
                                        #// または
                                        -   docker exec -it gitlab-runner-1 bash
                                            su --login  __User__
                                    カレント フォルダー:
                                        場所:
                                            _: /home/__LinuxUser__/builds/__RunnerID__/__Num__/__GitAccount__/__GitRepository__
                                                #// ログに表示されます
                                            __RunnerID__:  #search: GitLab specific runners page
                                            __Num__: 0。パイプラインが動くたびに増えることはありません
                                            __GitAccount__/__GitRepository__:  #search: GitHub URL
                                        内容:
                                            開始時:  #// Git ワーキング フォルダー の内容。git clone __Repository__ して cd __RepositoryName__ したときの内容。
                                                補足:
                                                    .git フォルダーもあります。
                                                    Git に入っていないファイルは削除されます
                                                Git ワーキング フォルダー を作らないようにする場合:
                                                    .gitlab-ci.yml: |
                                                        __Job__:
                                                            variables:
                                                                GIT_STRATEGY: none
                                            終了時: 実行した直後の内容が残っています
                                        容量不足対応: #keyword: GitLab runner delete folder  #// 使っていないフォルダーを削除します
                                            古い __RunnerID__ で使っていたフォルダー:
                                                #// ↓ランナーが動いている場所
                                                コンテナーの場合:
                                                    #(@ランナーの Docker ホスト)
                                                    sudo rm -rf /var/lib/docker/volumes/__VolumeID__/_data/builds/__RunnerID__
                                    環境変数:
                                        PATH: CI/CD からトリガーされたときと、ログインしたときで同じ内容です
                                    OS >> コンテナーの場合: #keyword: GitLab runner docker OS  #ref: https://gitlab-docs.creationline.com/runner/install/docker.html
                                        Ubuntu または Alpine
                                    関連:  #search: GitLab executor
                            Executor: #keyword: GitLab executor
                                shell:  #// デフォルト。最も軽量です
                                docker: #keyword: GitLab docker executor  #// Docker コンテナーで実行します
                                    動作条件:
                                        #// 下記のうち上に書かれた image が優先的に使われます。使われる image は 1つだけです
                                        .gitlab-ci.yml ファイルのジョブに image セクションが存在するとき: |
                                            ...
                                                build_job:
                                                    stage: build
                                                    image: $DOCKER_IMAGE
                                                    script:
                                                        -   echo "ビルドスクリプトをここに配置"
                                        /etc/gitlab-runner/config.toml ファイルの executor が docker で image が存在するとき: |
                                            [[runners]]
                                                ...
                                                executor = "docker"
                                                [runners.docker]
                                                    ...
                                                    image = "alpine:latest"   
                                    動作内容:
                                        .gitlab-ci.yml ファイルのジョブの script セクションに書かれたコマンドをすべて含むシェルスクリプトのファイルを作り、
                                        docker run コマンドでそのスクリプトを実行する動きになります
                        環境変数:  #search: GitLab CI/CD environment variable
                        ログ: #keyword: GitLab runner log
                            bash:
                                sudo journalctl -u gitlab-runner -f
                                sudo tail -f /var/log/gitlab-runner/gitlab-runner.log
                            Dockerで実行している場合:
                                docker logs gitlab-runner
                                docker logs -f gitlab-runner
                            状態:  #search: GitLab runnners web
                        トラブルシューティング:  #keyword: GitLab runner trouble
                            proxyconnect tcp:;; dial tcp:;; lookup proxy.____ on __IPAddress__:;; server misbehaving:
                                手順: gitlab-runner register
                                エラー: |
                                    "\u001b[31;1mERROR: Registering runner... failed               \u001b[0;m  \u001b[31;1mrunner\u001b[0;m=GR13____ \u001b[31;1mstatus\u001b[0;m=couldn't execute POST against https://git.____/api/v4/runners: Post \"https://git.____/api/v4/runners\": proxyconnect tcp: dial tcp: lookup proxy.____ on __IPAddress__: server misbehaving",
                                対処:
                                    Docker コンテナー内で名前解決ができない場合:  #search: docker DNS trouble
                                        https_proxy 環境変数の値を IP アドレスに変えます:  #search: IP address https_proxy
                            gitlab-runner register WARNING:;; If you want to register use the '-r' instead of '-t'.:
                                手順: gitlab-runner register
                                エラー: |
                                    WARNING: If you want to register use the '-r' instead of '-t'.
                                    ERROR: Verifying runner... failed  runner=__Token__ status=couldn't execute POST against https://gitlab.com/api/v4/runners/verify: Post "https://gitlab.com/api/v4/runners/verify": proxyconnect tcp: dial tcp: lookup __ProxyFQDN__ on __IPAddress__:53: server misbehaving
                                対処A:
                                    gitlab-runner register コマンドの --token オプションに指定したトークンが正しいことを確認してください
                                対処B:
                                    - プロキシを設定してください  #search: https_proxy
                                    - コンテナー内の場合、IP アドレスにする必要があるかもしれません  #search: IP address https_proxy
                                対処C:
                                    バージョンによってオプションが異なります  #search: gitlab-runner register
                            成功時の デバッグ ログ のサンプル:
                                手順: sudo --login  gitlab-runner --debug run
                                ログ: |
                                    $ sudo --login  gitlab-runner --debug run
                                    Runtime platform                                    arch=amd64 os=linux pid=5612 revision=3046fee8 version=16.6.0
                                    Starting multi-runner from /etc/gitlab-runner/config.toml...  builds=0 max_builds=0
                                    Checking runtime mode                               GOOS=linux uid=0
                                    Running in system-mode.                            
                                                                                    
                                    Configuration loaded                                builds=0 max_builds=1
                                    listenaddress: ""
                                    sessionserver:
                                        listenaddress: ""
                                    ....
                                    sentrydsn: null
                                    modtime: 2023-11-17T13:11:01.97+09:00
                                    loaded: true
                                    shutdowntimeout: 0
                                        builds=0 max_builds=1
                                    Waiting for stop signal                             builds=0 max_builds=1
                                    listen_address not defined, metrics & debug endpoints disabled  builds=0 max_builds=1
                                    [session_server].listen_address not defined, session endpoints disabled  builds=0 max_builds=1
                                    Initializing executor providers                     builds=0 max_builds=1
                                    Feeding runners to channel                          builds=0 max_builds=1
                                    Feeding runner to channel                           builds=0 max_builds=1 runner=fpcRx3W8s
                                    Starting worker                                     builds=0 max_builds=1 worker=0
                                    Processing runner                                   builds=0 max_builds=1 runner=fpcRx3W8s
                                    Acquiring executor from provider                    builds=0 max_builds=1 runner=fpcRx3W8s
                                    Acquiring job slot                                  builds=0 max_builds=1 runner=fpcRx3W8s
                                    Acquiring request slot                              builds=0 max_builds=1 runner=fpcRx3W8s
                                    Dialing: tcp proxy.____.jp:8080 ...                
                                    Checking for jobs...no content                      runner=fpcRx3W8s status=204 No Content
                                    Feeding runners to channel                          builds=0 max_builds=1
                                    Feeding runner to channel                           builds=0 max_builds=1 runner=fpcRx3W8s
                                    Processing runner                                   builds=0 max_builds=1 runner=fpcRx3W8s
                                    Acquiring executor from provider                    builds=0 max_builds=1 runner=fpcRx3W8s
                                    Acquiring job slot                                  builds=0 max_builds=1 runner=fpcRx3W8s
                                    Acquiring request slot                              builds=0 max_builds=1 runner=fpcRx3W8s
                                    Feeding runners to channel                          builds=0 max_builds=1
                                    Feeding runner to channel                           builds=0 max_builds=1 runner=fpcRx3W8s
                                    Checking for jobs...no content                      runner=fpcRx3W8s status=204 No Content

                                    （約1分ごとにメッセージを繰り返しますが、トリガされたら数秒で動き始めます。）
                                    （以下は 後で行うパイプラインが動いたときのログ）
                                    Acquiring request slot                              builds=0 max_builds=1 runner=fpcRx3W8s
                                    Checking for jobs... received                       job=5558639435 repo_url=https://gitlab.com/takakiriy1/first.git runner=fpcRx3W8s
                                    Processing chain                                    chain-leaf=[0xc0009eab00 0xc0009eb080 0xc000c4ab00] context=certificate-chain-build resolve-full-chain=false
                                    Added job to processing list                        builds=1 job=5558639435 max_builds=1 project=39463327 repo_url=https://gitlab.com/takakiriy1/first.git
                                    Failed to requeue the runner                        builds=1 max_builds=1 runner=fpcRx3W8s
                                    Running with gitlab-runner 16.6.0 (3046fee8)        job=5558639435 project=39463327 runner=fpcRx3W8s
                                        on my-runner fpcRx3W8s, system ID: s_f9e31d154c93  job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Preparing the "shell" executor          job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Shell configuration: command: bash
                                    arguments:
                                    -   -l
                                    cmdline: bash -l
                                    dockercommand:
                                    -   sh
                                    -   -c
                                    -   "if [ -x /usr/local/bin/bash ]; then\n\texec /usr/local/bin/bash -l\nelif [ -x /usr/bin/bash
                                        ]; then\n\texec /usr/bin/bash -l\nelif [ -x /bin/bash ]; then\n\texec /bin/bash
                                        -l\nelif [ -x /usr/local/bin/sh ]; then\n\texec /usr/local/bin/sh -l\nelif [ -x
                                        /usr/bin/sh ]; then\n\texec /usr/bin/sh -l\nelif [ -x /bin/sh ]; then\n\texec /bin/sh
                                        -l\nelif [ -x /busybox/sh ]; then\n\texec /busybox/sh -l\nelse\n\techo shell not
                                        found\n\texit 1\nfi\n\n"
                                    passfile: false
                                    extension: ""
                                        job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Using Shell (bash) executor...                      job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Waiting for signals...                              job=5558639435 project=39463327 runner=fpcRx3W8s
                                    No referees configured                              job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Executing build stage                               build_stage=prepare_script job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Preparing environment                   job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Using new shell command execution                   job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Executing build stage                               build_stage=get_sources job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Getting source from Git repository      job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Using new shell command execution                   job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Executing build stage                               build_stage=restore_cache job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Skipping stage (nothing to do)                      build_stage=restore_cache job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Executing build stage                               build_stage=download_artifacts job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Skipping stage (nothing to do)                      build_stage=download_artifacts job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Executing build stage                               build_stage=step_script job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Executing "step_script" stage of the job script  job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Using new shell command execution                   job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Executing build stage                               build_stage=after_script job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Skipping stage (nothing to do)                      build_stage=after_script job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Executing build stage                               build_stage=archive_cache job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Skipping stage (nothing to do)                      build_stage=archive_cache job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Executing build stage                               build_stage=upload_artifacts_on_success job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Skipping stage (nothing to do)                      build_stage=upload_artifacts_on_success job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Skipping referees execution                         job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Executing build stage                               build_stage=cleanup_file_variables job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Cleaning up project directory and file based variables  job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Using new shell command execution                   job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Job succeeded                                       duration_s=1.4983125 job=5558639435 project=39463327 runner=fpcRx3W8s
                                    Appending trace to coordinator...ok                 code=202 job=5558639435 job-log=0-1295 job-status=running runner=fpcRx3W8s sent-log=0-1294 status=202 Accepted update-interval=1m0s
                                    Updating job...                                     bytesize=1295 checksum=crc32:40749b89 job=5558639435 runner=fpcRx3W8s
                                    Submitting job to coordinator...accepted, but not yet completed  bytesize=1295 checksum=crc32:40749b89 code=202 job=5558639435 job-status= runner=fpcRx3W8s update-interval=1s
                                    Feeding runners to channel                          builds=1 max_builds=1
                                    Feeding runner to channel                           builds=1 max_builds=1 runner=fpcRx3W8s
                                    Updating job...                                     bytesize=1295 checksum=crc32:40749b89 job=5558639435 runner=fpcRx3W8s
                                    Submitting job to coordinator...ok                  bytesize=1295 checksum=crc32:40749b89 code=200 job=5558639435 job-status= runner=fpcRx3W8s update-interval=0s
                                    Removed job from processing list                    builds=0 job=5558639435 max_builds=1 project=39463327 repo_url=https://gitlab.com/takakiriy1/first.git
                                    Processing runner                                   builds=0 max_builds=1 runner=fpcRx3W8s
                                    Acquiring executor from provider                    builds=0 max_builds=1 runner=fpcRx3W8s
                                    Acquiring job slot                                  builds=0 max_builds=1 runner=fpcRx3W8s
                                    Acquiring request slot                              builds=0 max_builds=1 runner=fpcRx3W8s
                                    Checking for jobs... received                       job=5558639439 repo_url=https://gitlab.com/takakiriy1/first.git runner=fpcRx3W8s
                                    Processing chain                                    chain-leaf=[0xc0009eab00 0xc0009eb080 0xc000c4ab00] context=certificate-chain-build resolve-full-chain=false
                                    Added job to processing list                        builds=1 job=5558639439 max_builds=1 project=39463327 repo_url=https://gitlab.com/takakiriy1/first.git
                                    Failed to requeue the runner                        builds=1 max_builds=1 runner=fpcRx3W8s
                                    Running with gitlab-runner 16.6.0 (3046fee8)        job=5558639439 project=39463327 runner=fpcRx3W8s
                                        on my-runner fpcRx3W8s, system ID: s_f9e31d154c93  job=5558639439 project=39463327 runner=fpcRx3W8s
                                    Preparing the "shell" executor          job=5558639439 project=39463327 runner=fpcRx3W8s
                                    Shell configuration: command: bash
                                    arguments:
                                    -   -l
                                    cmdline: bash -l
                                    dockercommand:
                                    -   sh
                                    -   -c
                                    -   "if [ -x /usr/local/bin/bash ]; then\n\texec /usr/local/bin/bash -l\nelif [ -x /usr/bin/bash
                                        ]; then\n\texec /usr/bin/bash -l\nelif [ -x /bin/bash ]; then\n\texec /bin/bash
                                        -l\nelif [ -x /usr/local/bin/sh ]; then\n\texec /usr/local/bin/sh -l\nelif [ -x
                                        /usr/bin/sh ]; then\n\texec /usr/bin/sh -l\nelif [ -x /bin/sh ]; then\n\texec /bin/sh
                                        -l\nelif [ -x /busybox/sh ]; then\n\texec /busybox/sh -l\nelse\n\techo shell not
                                        found\n\texit 1\nfi\n\n"
                            git push しても反応しない:
                                手順: git push
                                対処: #search: GitLab Run untagged jobs
                            Pending >> This job is stuck because the project doesn't have any runners online assigned to it.:
                                手順: git push
                                エラー:
                                    Pipeline: |  #ref: https://gitlab.com/takakiriy1/first/-/pipelines  #template: https://gitlab.com/__User__/__Repository__/-/
                                        Pending（オレンジ色）
                                    Jobs: |  #ref: https://gitlab.com/takakiriy1/first/-/jobs/__Hash__  #template: https://gitlab.com/__User__/__Repository__/-/
                                        Pending（オレンジ色）
                                        This job is stuck because the project doesn't have any runners online assigned to it.
                                This job is stuck ～ が表示されるとき:
                                    対処A:  #search: GitLab Run untagged jobs
                                This job is stuck ～ が表示されないとき:
                                    対処A:
                                        gitlab-runner のサービスが起動していることを確認します
                                    対処B:
                                        sudo --login  gitlab-runner --debug run で状況を確認します
                            Forbidden:
                                手順: sudo --login  gitlab-runner run
                                エラー: |
                                    ERROR: Checking for jobs... forbidden  runner=aszT9Psna status=POST https://gitlab.com/api/v4/jobs/request: 403 Forbidden
                                対処:
                                    古い登録を削除します:
                                        sudo vi /etc/gitlab-runner/config.toml
                            gitlab-runner status - the service is not installed:
                                手順: sudo --login  gitlab-runner status
                                エラー: |
                                    gitlab-runner: the service is not installed
                                対処:
                                    gitlab-runner run を実行したとき:
                                        the service is not installed は無視できます
                    アーティファクト: #keyword: GitLab job artifacts  #// 成果物
                        定義:  #// 前のステージでアーティファクトの場所を設定します
                            #focus: artifact,  build_deploy_tar_gz_job
                            .gitlab-ci.yml:
                                build_deploy_tar_gz_job:
                                    stage: build
                                    tags: [dev_runner]
                                    script:
                                        -   echo "Build something here"  >  ./artifact
                                    artifacts:
                                        paths:
                                            -   ./artifact    #// 定義。親フォルダーにあるファイルなどを指定したら失敗します
                                get_deploy_tar_gz_job:
                                    stage: deploy
                                    tags: [stg_runner]
                                    dependencies:
                                        -   build_deploy_tar_gz_job
                                    script:
                                        -   cat  ./artifact    #// 使用
                        使用:  #// 後のステージでアーティファクトを参照します
                            定義のサンプルを参照  #focus: get_deploy_tar_gz_job
                        #ref: https://docs.gitlab.com/ee/ci/yaml/index.html#artifacts
                        #ref: https://docs.gitlab.com/ee/ci/pipelines/job_artifacts.html
                    環境変数: #keyword: GitLab CI/CD environment variable
                        シークレットを設定します:  #search: GitLab runner secrets
                        設定チェック:  #// 環境変数が設定されていることをチェックします
                            test  "${GITLAB_REGISTRY_GROUP_ACCESS_TOKEN}" != ""  ||  ( echo  "❌ GITLAB_REGISTRY_GROUP_ACCESS_TOKEN is not set."  >&2  &&  exit 1 )
                画面:
                    CI/CD を表示します:  #search: GitLab CI/CD menu
                    Pipelines, CI/CD の実行ログ: #keyword: GitLab CI/CD log
                        リポジトリのページ >> CI/CD（左）>> Status 列 >> ジョブ名
                        #// 実行するまで、表（Status 列）は表示されません
                        #search: GitLab runner tag
                        #search: GitLab CI/CD trigger
                    Editor, 現在のライプライン:
                        リポジトリのページ >> CI/CD（左）>> Editor >> Visualize
                    Schedules, 定期実行する場合:  #search: GitLab pipeline schedule
                ログ:
                    パイプライン実行時:  #search: GitLab CI/CD log
                    ランナー自体:  #search: GitLab runner log
                ファイル:
                    .gitlab-ci.yml ファイル: #keyword: .gitlab-ci.yml  #// パイプラインの設定ファイル
                        場所:
                            __Project__/.gitlab-ci.yml
                            #// git push すると設定されます
                        スタイル: スネークケース  #search: https://docs.gitlab.com/ee/ci/yaml/#default
                        書式:  #focus: __StageName__,  __JobName__,  __Command__  #ref: https://docs.gitlab.com/ee/ci/yaml/index.html
                            基本:
                                stages:  #// .pre, build, test, deploy, .post.  #ref: https://docs.gitlab.com/ee/ci/yaml/index.html#stage
                                    - __StageName__
                                    - __StageName__
                                __JobName__:
                                    stage: __StageName__
                                    tags: [__RunnerName__]  #keyword: .gitlab-ci.yml tags example
                                    script:
                                        -   __Command__
                                        -   __Command__  #// 上に書いたコマンドで環境変数の値を設定した場合、ここでもその環境変数の値を参照することができます
                                        - |  #// bash を使い、関数を定義する場合  #keyword: GitLab CI/CD bash function,  .gitlab-ci.yml bash
                                            cat > /tmp/ci_cd_1.sh << 'HERE_DOCUMENT'
                                                #!/bin/bash
                                                echo  "bash ${BASH_VERSION}"
                                                echo  "CI_PROJECT_ID: ${CI_PROJECT_ID}"

                                                #// Set default values. "! -v" means that variable is not defined.
                                                if ! [[ -v Operation ]]; then  Operation="Update"  ;fi  #// "Clean", "AddAll", "Update"

                                                test  "${GITLAB_REGISTRY_GROUP_ACCESS_TOKEN}" != ""  ||  { echo  "❌ GITLAB_REGISTRY_GROUP_ACCESS_TOKEN is not set."  >&2;  exit 1; }

                                                function  Main() {
                                                    echo  "✅ Pass."
                                                }
                                                Main
                                            HERE_DOCUMENT

                                        -   cat -n  /tmp/ci_cd_1.sh
                                        -   bash -n  /tmp/ci_cd_1.sh  # Check syntax

                                        -   /bin/bash  /tmp/ci_cd_1.sh  # Run
                                        -   rm  /tmp/ci_cd_1.sh
                            詳細:
                                before_script:
                                __JobName__:
                                    image: Docker Image
                                    rules: #keyword: .gitlab-ci.yml rules
                                        サンプル:
                                            -   if: '$CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"'
                                                changes:
                                                    -   "*.whl"
                                                    -   ".gitlab-ci.yml"
                                    before_script: #keyword: .gitlab-ci.yml before_script
                                        グローバル（インデントがない部分）の before_script の内容を完全に置き換えます
                                        ログには before_script と script の違いが明確に書かれて見やすくなります。
                                        このため、パッケージのインストールなどはここに書きます。
                                        before_script も script もエラーになったら続きを実行しません
                                    after_script:
                                        script でエラーになったらすぐに実行します
                                        script が正常に実行されたときも実行します
                                after_script:
                        文法: #ref: https://docs.gitlab.com/ee/development/cicd/cicd_reference_documentation_guide.html#documenting-the-gitlab-ciyml-keywords
                        サンプル:
                            サンプルA:  #// シンプル
                                example_job:
                                    stage: build
                                    tags: [dev_runner]
                                    script:
                                        -   echo "Build something here"  >  path/to/build/artifact
                                    artifacts:
                                        paths:
                                            -   path/to/build/artifact
                            サンプルB:  #// 複数の Job
                                stages:
                                    -   build
                                    -   test

                                build_code_job:
                                    stage: build
                                    script:
                                        -   echo "Check the ruby version, then build some Ruby project files:"
                                        -   ruby -v
                                        -   rake

                                test_code_job1:
                                    stage: test
                                    script:
                                        -   echo "If the files are built successfully, test some files with one command:"
                                        -   rake test1

                                test_code_job2:
                                    stage: test
                                    script:
                                        -   echo "If the files are built successfully, test other files with a different command:"
                                        -   rake test2
                            関数定義する場合:  #search: GitLab CI/CD bash function
                        エラー時の動き, set -e:  #keyword: GitLab CI set -e
                            デフォルト: .gitlab-ci.yml ファイルの script に指定したコマンドは、終了コードが 0 以外でも続きを実行します（set -e 無効）
                            エラーで中断させる場合:  #// YAML の script フィールド 続きを実行させないようにします
                                #focus: exit
                                -   __Command__  ||  exit $?
                                -   __Command1__  &&  __Command2__  ||  exit $?
                            set -e を有効にする場合:
                                ボツ:  #//  以下は期待通りに動きません。終了コードが 0 以外でも続行します
                                    .gitlab-ci.yml ファイル: |  #focus: set -e
                                        ...
                                        before_script:
                                            - set -e
                                        example_job:
                                            script:
                                                -   echo "Build something here"  >  path/to/build/artifact
                        参考: #ref: https://docs.gitlab.com/ee/ci/yaml/gitlab_ci_yaml.html
                        tag: #keyword: .gitlab-ci.yml tags  #// ランナーを選びます
                            サンプル:  #search: .gitlab-ci.yml tags example
                            パイプラインが動作するランナーの決定方法:
                                - 複数指定したら AND 条件でマッチする特定の runner が使われます
                                - 1つも存在しないランナーが指定されたら CI/CD パイプラインが Pending 状態になります
                            複数のランナーに同じジョブを動かす:
                                tag にそれぞれのランナーのタグを指定することはできません。
                                ランナーごとにジョブを分けてください
                        ブランチ: #// コミットしたブランチ名が入っている変数
                            $CI_COMMIT_BRANCH
                参考:
                    Pipeline architecture: #ref: https://docs.gitlab.com/ee/ci/pipelines/pipeline_architectures.html
                関連:  #search: GitHub Actions
            Pages: #keyword: GitLab Pages  #// 静的サイト  #ref: https://docs.gitlab.com/user/project/pages/
                公開します:
                    プロジェクトを新規作成します:
                        メニュー: https://gitlab.com/takakiriy1 >> New project（右上）>> Create blank project
                        Project name: ____
                        Project deployment target: GitLab Pages
                        Create project ボタン（下）:
                    pages ジョブを書きます: #keyword: simple .gitlab-ci.yml pages
                        __Project__/.gitlab-ci.yml: |
                            pages:
                                stage: deploy
                                script:
                                    -   mkdir public
                                    -   cp *.html public/    #// （必要なら）ここを編集します
                                    -   cp *.css public/     #// （必要なら）ここを編集します
                                artifacts:
                                    paths:
                                        -   public
                                only:
                                    -   main   #// このブランチの内容が公開されます
                    public フォルダーに公開する内容を作ります: #keyword: simple GitLab Pages index.html
                        #// 上記の pages ジョブの場合、プロジェクトの直下に .html ファイルと .css ファイルを配置して、コミットします
                        __Project__/index.html: |
                            <!DOCTYPE html>
                            <html>
                            <head>
                                <title>My GitLab Pages Site</title>
                                <link rel="stylesheet" href="style.css">
                            </head>
                            <body>
                                <h1>Hello GitLab Pages!</h1>
                                <p>This is my first GitLab Pages site.</p>
                            </body>
                            </html>
                        __Project__/style.css: |
                            /* 空 */
                    #// pages ジョブはコミットしたら自動的に実行されます
                    ページを表示します:
                        https://__User__.gitlab.io/__Project__/
                        #ref: https://takakiriy1.gitlab.io/my-page
                    トラブルシューティング:
                        Settings（左下）>> General >> Visibility, project features, permissions >> CI/CD オン
                        Settings（左下）>> CI/CD >> Runners >> Enable shared runners for this project オン
                        Settings（左下）>> Pages に公開したページの URL
                        __Project__ の部分が違うと、ログイン画面がダウンロードされます
            GitLab 本体:
                バージョン >> 調べます:  #keyword: GitLab version
                    ヘルプを表示します:
                        (?) を押します:
                            GitLab Enterprise Edition 16.7.0-pre: 左下
                            GitLab Community Edition 15.0.2: 右上
                        Help を選びます:
                            #// バージョンが表示されます
                            #// Community Edition か Enterprise Edition かも表示されます
        コマンド:
            glab:
                glab コマンドをインストールします:  #ref: https://docs.gitlab.co.jp/ee/integration/glab/
                    https://gitlab.com/gitlab-org/cli/-/releases
                        glab_1.45.0_Windows_x86_64_installer.exe
                    glabCommand="C:\Program Files (x86)\glab\glab.exe"
                    "${glabCommand}" --version
                    gitLabHost="gitlab.com"
                    "${glabCommand}" auth login  --hostname "${gitLabHost}"  --token $( cat ~/.secret/gitlab-pat-LFS-downloader )
                    "${glabCommand}" auth status  --hostname "${gitLabHost}"
                    rm  "${HOME}/.config/glab-cli/config.yml"  #// ログアウト
                    #// 新しいターミナルを開いても gitlab auth status を見るとログインしています。
        ファイル:
            プロジェクトのファイル:  #search: GitLab files
            .gitlab-ci.yml ファイル:  #search: .gitlab-ci.yml
        文書設定: #settings:
            __URL__: https://gitlab.com
            __Token__: glrt-zzqB9sc4QGnV8QShRsjR
            __User__: takakiriy1
            __Repository__: first
        トラブルシューティング:
            raw ダウンロードができない:  #search: GitLab private raw download
    リポジトリを作ります:  #keyword: Git new repository
        プロジェクトの first commit を git push します: #keyword: GitHub new repository
            settings: #settings:
                __GitHubUser__: Takakiriy
                __Repository__: nextjs-blog
            GitHub でリポジトリを新規作成します:
                GitHub にある自分のリポジトリの一覧のページを開きます:
                    https://github.com/Takakiriy?tab=repositories  #template: /__GitHubUser__?
                New ボタン（右上）:
                Repository name: nextjs-blog  #template: __Repository__
                Public or Private:
                Create repository ボタン:
            コミットして push します:
                -   cd  nextjs-blog  #// ファイルがすでにあるフォルダー  #template: __Repository__
                -   rm -rf .git
                    git init
                    git branch -m main
                    git add "."
                    git config user.name
                    git config user.email
                -   git commit -m "1st commit"
                -   git remote add origin https://github.com/Takakiriy/nextjs-blog.git  #template: /__GitHubUser__/__Repository__.git
                -   git push --set-upstream origin main
        サーバーなしの .git フォルダーを作ります:  #keyword: Git local work
            設定: #settings:
                __RepositoryName__: project_1
            サーバーなしの .git フォルダーを作ります:  #keyword: git init
                コマンド:
                    #Git Bash
                    -   mkdir -p  $HOME/GitProjects/WithoutServer/project_1
                        cd        $HOME/GitProjects/WithoutServer/project_1
                            #template-at(-2): __RepositoryName__
                            #template-at(-2): __RepositoryName__
                    -   git init -b main  #// .git フォルダーが作られます。main ブランチが作られます
                            #// git コマンドが見つからなかったら #search: install Git
                            #// -b オプションが使えなかったら git init で master ブランチを作ります
                    -   git config --local user.email "yourname@example.com"
                        git config --local user.name  "Your Name"
                スクリプト:
                    #search: MakeNewFirstCommit
                    #search: MakeGitWorkingInBackUpIfNew
            （必要になったら）バックアップします:
                .zip ファイルに圧縮して別のPCにコピーします:
                    暗号化付きの場合:
                        メニュー: .git（フォルダーを右クリック）>> 7-zip >> 圧縮
                        アーカイブ形式: zip
                        パスワード: __________________________
                    .git.zip を別のPCにコピーします:
            （必要になったら）リポジトリを GitHub にインポートします:  #ref: https://docs.github.com/ja/github/importing-your-projects-to-github/importing-source-code-to-github/adding-an-existing-project-to-github-using-the-command-line
            リモートと接続するように変更します:  #search: git remote set-url
        ローカルにリポジトリ（サーバー）を作ります: #keyword: Git local repository  #// リポジトリを MyPrivateCode やその他クラウド等に置けないとき
            注意: リポジトリを使う実験用。それ以外は、サーバーなしの .git フォルダーが簡単です  #search: Git local work
            設定: #settings:
                __RepositoryName__: try_git
            locommit コマンドを使う場合:  #// 内容は カレント フォルダー（Git working directory であること）
                locommit init-bare-push __NewRepositoryFolder__
            リポジトリを作ってすぐ削除する場合:
                新しい方法: |
                    git --version  #// git version 2.25.1
                    GitWorkingFolder="$HOME/_work"
                    cd  "${GitWorkingFolder}"

                    rm -rf  "${GitWorkingFolder}/_repository.git"
                    git init --bare --shared=true  "${GitWorkingFolder}/_repository.git"

                    rm -rf  "${GitWorkingFolder}/back_up"
                    mkdir   "${GitWorkingFolder}/back_up"
                    cd      "${GitWorkingFolder}/back_up"
                    echo  "aaa" > "a.txt"
                    git init
                    git add  "."
                    git commit -m "First commit"
                    git remote add origin  file://${GitWorkingFolder}/_repository.git
                    git push --set-upstream origin master

                    rm -rf  "${GitWorkingFolder}/_work"
                    git clone  file://${GitWorkingFolder}/_repository.git  "${GitWorkingFolder}/_work"
                    cat  "${GitWorkingFolder}/_work/a.txt"

                    cd  "${GitWorkingFolder}"
                    rm -rf  "${GitWorkingFolder}/_work"
                    rm -rf  "${GitWorkingFolder}/_repository.git"
                    rm -rf  "${GitWorkingFolder}/back_up"
                古い方法:
                    リポジトリのフォルダーを作ります:
                        (Git bash): |
                            mkdir -p  $HOME/try_git/repository/try_git    #template: __RepositoryName__/repository/__RepositoryName__
                            cd        $HOME/try_git/repository/try_git    #template: __RepositoryName__/repository/__RepositoryName__
                            git init --bare --shared=true
                    ローカルのリポジトリからクローンし、できたワークへ移動します:
                        (Git bash): |
                            mkdir -p  $HOME/try_git/work    #template: __RepositoryName__/work
                            cd        $HOME/try_git/work    #template: __RepositoryName__/work
                            rm -rf  try_git                         #template: __RepositoryName__
                            git clone file://$HOME/try_git/repository/try_git    #template: __RepositoryName__/repository/__RepositoryName__
                            cd  $HOME/try_git/work/try_git    #template: __RepositoryName__/work/__RepositoryName__
            リポジトリをローカルに残す場合:
                ローカルにリポジトリ（サーバー）を作ります: #keyword: git init --bare --shared
                    （新規の場合）:
                        #Git Bash
                        - mkdir -p  $HOME/repositories/try_git  #template: __RepositoryName__
                        - cd        $HOME/repositories/try_git  #template: __RepositoryName__
                        - git init --bare --shared=true --initial-branch=main
                            #// --bare はリポジトリを作ります。公式に .git フォルダーもリポジトリであり、
                            #// .git がないフォルダーをワーキングコピーを持たないリポジトリと呼びます。
                            #// --shared=true は git push できるようにします。公式には共有可能にすると言います。
                    （既存の場合）: #keyword: Git working to local repository  #// サーバーなしの .git フォルダーを共有可能にします
                        #// バックアップを作ってから作業してください
                        - cd  __LocalRepositoryPath__
                        - git config --bool  core.bare  true
                        - git init --shared=all
                            #ref: https://stackoverflow.com/questions/3242282/how-to-configure-an-existing-git-repo-to-be-shared-by-a-unix-group
                            #ref: https://stackoverflow.com/questions/11117823/git-push-error-refusing-to-update-checked-out-branch
                ローカルのリポジトリからクローンします:
                    #Git Bash
                    - cd  $HOME
                    - rm -rf  
                    - git clone file://$HOME/repositories/try_git  #template: __RepositoryName__
                ローカルのリポジトリをバックアップします（例）:
                    Git Bash を使って手動でバックアップします:
                        - mkdir -p  $HOME/repositories/back_up  #// 初回のみ
                        - cd        $HOME/repositories/back_up
                        - tar cvzf  "__Folder__-$(date "+%Y-%m-%d").tar.gz"  "../__Folder__"
                    スクリプトでバックアップします:
                        スクリプトを実行します: |  #// 作り方は下記
                            "%USERPROFILE%\repositories\cmd menu.bat"  #// 1. Back up repositories
                        スクリプトを作ります:
                            cmd menu.bat: |
                                @echo off
                                echo 1. Back up repositories
                                set key=

                                set /p key=number^>
                                if "%key%" == "1"  goto :back_up_repositories
                                echo Unknown command error. & set errorlevel=1
                                goto :finally

                                :back_up_repositories
                                PATH=%PATH%;C:\Program Files\Git\usr\bin
                                "C:\Program Files\Git\usr\bin\bash.exe" -c "./commands.sh"
                                echo Done.
                                pause
                                goto :finally

                                :finally
                                if "%errorlevel%" == "0" echo Done.
                                if not "%errorlevel%" == "0"  echo You can close this window.
                                if not "%errorlevel%" == "0"  set /p dummy=
                                exit %errorlevel%
                            commands.sh: |  #// repositories の内容は対象のリポジトリ名に変更してください
                                repositories=( "try_git" )  #template: __RepositoryName__
                                cd  back_up
                                for  repository  in  "${repositories[@]}" ;do
                                    tar cvzf  "$(date "+%Y-%m-%d") ${repository}.tar.gz"  "../${repository}"
                                done
        GitHubお試し環境を作ります。１～２人で編集しているリポジトリを作ります:  #keyword: GitHub partner contributor repository try
            概要:
                owner: takakiriy ＠ gmail.com  #// ＠は置き換えてください
                contributor: ts-neko ＠ sage-p.com  #// ＠は置き換えてください
            新しくリポジトリを作ります:
                メニュー: (owner@) https://github.com/Takakiriy/ >> Repositories（タブ）>> New（右上）
                    #// owner@ は、オーナーの役割を持つユーザーの GitHub アカウントを表します
                Repository name: shared
                Create Repository ボタン:
            (owner@) git clone して commit, push します:
                Git bash: |
                    cd  __Desktop__
                    mkdir -p "_owner"
                    cd  "__Desktop__/_owner"
                    git clone https://github.com/Takakiriy/shared
                    cd shared
                    git config --local user.email "takakiriy ＠ gmail.com"  #// ＠は置き換えてください
                    git config --local user.name  "Takakiriy"
                    echo a > a.txt
                    git add "."
                    git commit -m "new"
                    git push
            (contributor@) git clone して commit, push します:
                Git bash: |
                    cd  __Desktop__
                    mkdir -p "_contributor@"
                    cd  "__Desktop__/_contributor@"
                    git clone https://github.com/Takakiriy/shared
                    cd shared
                    git config --local user.email "ts-neko ＠ sage-p.com"  #// ＠は置き換えてください
                    git config --local user.name  "TsNeko"
                    cat a.txt
                    echo b > a.txt
                    git add "."
                    git commit -m "update"
                    git push
            関連:
                プルリクエスト: #search: GitHub pull request steps
        シンボリック リンク を含むリポジトリを作ります:  #keyword: Git symbolic link repository example
            Windows の場合:
                Git をインストールします:  #search: install Git
                新しいリポジトリ try_link（とする）を GitHub などに作ります:
                空のリポジトリの内容をダウンロード(git clone)します:
                    #// Git bash
                    - git clone __RepositoryURL__
                    - cd  try_link
                    - git config --local user.email "you@example.com"
                    - git config --local user.name "Your Name"
                シンボリック リンク を作ります:
                    #// Git bash の続き
                    - mkdir main  #// シンボリック リンク のリンク先
                    - echo a > main/a.txt  #// フォルダーだけではリポジトリに登録されないため
                    - sub1 から main への シンボリック リンク を作ります  #search: mklink
                コミット＆プッシュします:
                    #// Git bash の続き
                    - git add .
                    - git commit -m "first"
                    - git push
                シンボリック リンク を含むリポジトリからダウンロードする場合: #search: Git symbolic link repository
    ダウンロードします:  #search: git clone
    .git.zip: #keyword:
        関連 >> project with base:  #search: project with base
        ブランチをマージを扱うための .git.zip:  #search: .git.zip in commit
        親リポジトリの中に ワーキング フォルダー のコピーを置いたときの .git.zip:
            .git フォルダーがあると親リポジトリの管理下に置けないために
            一時的に .git フォルダー を無効にするための .git.zip ファイル。
            コミットできる状態になったら、親リポジトリの外に移動し、.git フォルダーを復活させて git pull します。
    .git.zip in commit: #keyword:  #ref: ${GitHub}/MyPrivateCode/ansible_vagrant/multi_vm_ansible/branch_all/.git.zip
        サンプル:  #ref: ${GitHub}/MyPrivateCode/ansible_vagrant/multi_vm_ansible
        メモ: .git.zip を作る目的は、リポジトリ内にある複数のブランチ（に相当するフォルダー）をマージするためです
        手順:
            （共通）作業開始:  #keyword: start .git.zip
                branch_all フォルダーのコピー（.git.zip を展開したフォルダー）にファイルが既にある場合:
                    コミットから変更がないことを確認します:
                        git status
                    （変更があったら）.git.zip を別のフォルダーに展開して対処します:
                    （変更が無くなったら）次へ:
                    既存の .git.zip と同期します:
                        （既存の .git.zip を展開した内容と異なるなら）:
                            ブランチ名とコミットIDをメモします:
                            .git フォルダーをバックアップして、.git.zip から .git フォルダーを展開します:
                            コミットIDがあることを確認します:
                                gitlog など
                branch_all フォルダーのコピー（.git.zip を展開したフォルダー）が無い場合:
                    Git bash:
                        - mkdir -p __Project__  #// branch_docker など
                        - cp  ____/branch_all/.git.zip  __Project__
                        - cd  __Project__
                        - unzip  .git.zip
                        - rm .git.zip
            （新規ブランチの場合）ブランチを新規作成します:  #keyword: .git.zip new branch,  create .git.zip branch
                （親）>> 作業開始:
                    #search: start .git.zip
                (Git bash):
                    common から枝分かれするブランチを作ります:
                        - git checkout "."
                        - git checkout common
                        - git checkout  -b "__NewBranchName__"
                    ファイルを編集します。使わない common のファイルを削除します:
                    コミットします:
                        - git add .
                        - git commit -m "__CommitMessage__"
                        - （.git.zip を使う場合は git push しません）
            ブランチをチェックアウトします:  #keyword: .git.zip checkout
                （親）>> 作業開始:
                    #search: start .git.zip
                bash:
                    -   git checkout "."
                    -   git branch
                    -   git checkout __BranchName__
                コミットを禁止します: #search: disable git commit
            ブランチを更新します:  #🌟  #keyword: .git.zip commit,  update .git.zip  #// チェックアウト, 更新, コミット
                新しい branch_all フォルダーに最新の .git.zip をコピーします:
                    #ref: ${GitHub}/MyPrivateCode/ansible_vagrant/multi_vm_ansible/branch_all/.git.zip
                .git を復活します:
                    注意: ブランチを合わせるまで、新しいフォルダーで作業してください
                    Git bash:
                        -   cd  ____/branch_all
                        -   rm -rf .git
                            unzip  .git.zip
                            rm .git.zip
                    ブランチを変更します:
                        -   git branch
                        -   git checkout __BranchName__
                    （新しい内容が入ったフォルダーに戻って作業する場合）:
                        .git フォルダーを新しい内容が入ったフォルダーに移動します:
                        新しい branch_all フォルダーを削除します:
                    （新しい branch_all フォルダーで作業する場合）:
                        チェックアウトします:
                            注意: 上書きされます
                            プロジェクトを復活します:
                                Git bash:
                                    - git checkout "."  #// ファイルを復活します
                            既存のブランチを更新する場合:
                                Git bash:
                                    - git branch  #// ブランチを一覧します
                                    - git checkout __BranchName__  #// ブランチを切り替えます
                            新しいブランチを作る場合:
                                Git bash:
                                    - git checkout newroot  #// ファイルが無いブランチから始めます
                                    - git checkout -b  __NewBranchName__
                        更新します:
                            #// branch_all フォルダーの中のファイルを置き換えます
                #（locommit ができたため不要）
                # コミット禁止をオフにします:  #keword: enable dit commit  #search: disable git commit
                #     rm -rf  git-config
                コミットします:
                    #// git push は不要です
                    git status
                    git add "."
                    git commit -m "____"
                必要なら common ブランチと同期します:
                    #search: update common branch
                .zip ファイルを作ります:  #keyword: make .git.zip
                    Windows:
                        (git bash):
                            エクスプローラーの 7-zip で .zip ファイルを作ります
                    CentOS7:  #// Vagrant/Ansible で作った CentOS7 の VM から .git.zip をダウンロードします
                        (@control):  #// 192.168.33.59
                            cd  __GitIncludingFolder__
                            zip -r  ".git.zip"  ".git"
                        (vagrant@Windows Git bash):
                            cd  __VagrantProject__
                            scp -i .vagrant/machines/control/virtualbox/private_key  vagrant@192.168.33.59:/home/vagrant/____/.git.zip "."
                .git.zip ファイルを元の場所に戻します（更新します）:
                    #ref: ${GitHub}/MyPrivateCode/ansible_vagrant/multi_vm_ansible/branch_all/.git.zip
            .git の移動:  #// 最新 .git フォルダーを他のブランチがあるフォルダーに移動します
                #search: .git.zip commit
            ブランチをすべてチェックアウトします:  #search: extract_git_branches
            common からマージします:  #search: Git common branch
            空のルートコミットがない場合:
                新しくルートになるべるブランチを作り、
                不明  https://stackoverflow.com/questions/645450/insert-a-commit-before-the-root-commit-in-git
    SourceForge: #keyword:
        ダウンロードする URL の例:
            #ref: https://sourceforge.net/projects/gnuwin32/files/zip/3.0/zip-3.0-bin.zip
Node.js から Git を使う:  #keyword: Git Node.js
    simple-git:  #keyword: simple-git
        URL: https://www.npmjs.com/package/simple-git
        注意:
            git 本体: 実行するには git 本体がインストールされている必要があります
            説明: simpleGit() を呼び出したときに返る git オブジェクトは、
                git のコマンドの対象となる ワーキング フォルダー のパスを内部に持っており、
                プロセスの カレント フォルダー とは別に存在します。
                そのパスは simpleGit() を呼び出したときのプロセスの カレント フォルダー です
            サンプル コード: |
                import simpleGit from 'simple-git';  // const simpleGit = require('simple-git');
                process.chdir(__DotGitParentFolderPath__);  #search: process.chdir finally
                const git = simpleGit();  // "git" object has current folder separated from process current folder.
        ブランチを一覧します: |  #keyword: Node.js  simple-git  git.branch
            import simpleGit from 'simple-git';  // const simpleGit = require('simple-git');
            process.chdir(__DotGitParentFolderPath__);  #search: process.chdir finally
            const  git = simpleGit();  // The git object has current folder separated from process current folder.

            const  branchOutput = await  git.branch();
            const  branchNames = Object.keys(branchOutput.branches).filter((branchName)=>(!branchName.includes('/')));
            const  branches = branchOutput.branches;
            console.log(Object.keys( branches ));  // master, remotes/origin/master
        チェックアウトします: |  #keyword: Node.js  simple-git  git.checkout
            process.chdir(__DotGitParentFolderPath__);

            const  git = simpleGit();  // The git object has current folder separated from process current folder.
            await  git.checkout('.');  #// テスト実行する前にプロジェクトを git commit してください
mac Git:
    Git を mac にインストールします:
        参考:
            - https://git-scm.com/download/mac
            - https://dezanari.com/homebrew-without-xcode/
            - https://qiita.com/uhooi/items/81a54cd8002c0e26ff81
        git コマンドでインストールします:
            git コマンドを入力すると、インストール方法が表示されます
        Xcode なしで homebrew をインストールします:
            mac >> 端末:
                - xcode-select --install  #// 約5分
                - /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
                    #// 約5分
                - echo 'eval "$(/opt/homebrew/bin/brew shellenv)"' >> ${HOME}/.zprofile
                - eval "$(/opt/homebrew/bin/brew shellenv)"
        Git をインストールします:
            mac >> 端末:
                - brew install git  #// 不要？
iPhone Git:
    Working Copy and Textastic:  #keyword: Working Copy, Textastic
        注意❗️: リポジトリと同期したら Tectastic を一度閉じること。同期した内容をロードさせるため
        共有使用:
            初期設定:
                改行を入れたときにインデントさせないようにします:
                    （キーボードが表示されていたら）キーボード ボタン（キーボードの右上）>>
                    歯車アイコン（右下）>> Code Editor（上）>>
                    （TEXT EDITING）Indent Based on Syntax（をオフにする）
            ファイルを開きます:  #// Textasitic でなくても構いません
                新しく開きます: Textastic（左上）>> Open... >> ＜（左上）>> Working Copy >> ...
                最近開いたファイルを開きます: Textastic（左上）>> Recent Files（下）
                Working Copy フォルダーが無いとき:
                    メニュー: Textastic >> Open... >> ＜（左上）>> (…)（右上）>> 編集 >> Working Copy（をオン）>> 完了
                Working Copy フォルダーを開くと原因不明のエラーになるとき:
                    回避策: Working Copy のエディター >> ↑（右上）>> Textastic >>（編集します）>> 全て選択 >> コピー >>（Working Copyへ）貼り付け
                    エラーを出なくする: 不明
            全文検索します:
                Textasitic:
                    ファイルを開き、虫眼鏡アイコン（左上）
                Working Copy:
                    メニュー: Working Copy >> Repositories >> (リポジトリ名) >> （検索ボックス）（上）
            git pull します:
                メニュー: Working Copy >> アプリのアイコン（右下）>> Pull
        Textastic:
            URL スキーム:  #search: Xcode URL scheme
                ファイル >> サンプル:
                    textastic://x-callback-url/open?location=fullPath&path=%2Fprivate%2Fvar%2Fmobile%2FContainers%2FShared%2FAppGroup%2F23F62319-FB9C-4F7E-AF92-A8531A58E1B0%2FFile%20Provider%20Storage%2FRepositories%2Fsteps%2F0_tmp.yaml
                        #ref: file:///private/var/mobile/Containers/Shared/AppGroup/23F62319-FB9C-4F7E-AF92-A8531A58E1B0/File%20Provider%20Storage/Repositories/steps/0_tmp.yaml
                外部フォルダー >> サンプル:
                    textastic://x-callback-url/open?location=external&externalUUID=D9D27A14-E8EA-4639-A950-64C6F82B0B5A
            外部フォルダー: #keyword: Textastic external folder  #// ショートカット相当
                外部フォルダーを作ります:
                    Textastic >> Textastic（左上）>> Add External Folder ... >>（フォルダーの内容を表示します）>> 開く（右上）  #// 現在内容を表示しているフォルダーが対象になります
                ExternalUUID を取得します:
                    Textastic >> Textastic（左上）>> EXTERNAL FILES AND FOLDERS（のフォルダーを長押し）>> Copy Identifier (UUID)
                #ref: https://www.textasticapp.com/v9/manual/integration_other_apps/external_files_folders.html#add-third-party-file-providers
        Working Copy:  #ref: https://workingcopyapp.com/
            Extending iOS:  #ref: https://workingcopyapp.com/manual/extending-ios
            URL スキーム:  #ref: https://workingcopyapp.com/url-schemes.html  #// ファイルの read write やリポジトリの clone pull push などができます
                Listing file status:  #// コミットのファイル一覧の画面を開きます
                    "working-copy://x-callback-url/status?key=__APIKey__&repo=MyPrivateCode&depth=9999&clipboard=no&no_unchanged=empty&no_path=empty"
                Reading files:  #// ファイルの内容の画面を開きます
                    "working-copy://x-callback-url/read?key=__APIKey__&repo=steps&path=0_memo.yaml&type=auto&clipboard=no"
            コンフリクトが iPhone で発生した場合:  #keyword: conflict in iPhone
セマンティック バージョニング: #keyword: セマンティック バージョニング, semantic varsioning, semver, バージョン番号
    規格: #ref: https://semver.org/
    概要: バージョン 1.0.0 のように３つの数字に標準的な意味を持たせたバージョン番号。
        1. APIの変更に互換性のない場合はメジャーバージョンを、
        2. 後方互換性があり機能性を追加した場合はマイナーバージョンを、
        3. 後方互換性を伴うバグ修正をした場合はパッチバージョンを上げます。
    リリース修飾子: #keyword: release qualifier  #// alpha, beta, dev, rc, stable など
    番号の範囲の記法: #keyword: semantic varsioning caret,  semver ^ ~  #// ~（チルダ, tilde）ではない
        一般:  #// Poetry (Python), npm/yarn (JS), Cargo (Rust), Composer (PHP)
            "^1.0.0": 1.0.0 以上、2.0.0 未満  #// 2.0.0 以上で破壊的変更があるものとして自動更新の範囲外
            "^0.1.0": 0.1.0 以上、0.2.0 未満  #// 0.x の場合、0.2.0 以上で破壊的変更があるものとして自動更新の範囲外
        Bundler (Ruby):
            - 記号が違う~> で同等
            - gem 'rails', '~> 7.0.0'  # 7.0.0 ≤ version < 7.1.0 (マイナー固定)
            - gem 'rails', '~> 7.0'    # 7.0.0 ≤ version < 8.0.0 (メジャー固定)
        破壊的変更を許容する場合:
            設定ファイル（pyproject.toml など）を開いて ^2.0.0 のように編集し、更新コマンドを実行します
    Snap Note: #ref: ${programming}/方法論/バージョン管理.svg#semver
    Python:  #search: Python semantic versioning
    Go言語:  #search: Go semantic versioning
    bash:
        比較:  #search: compare RPM version
    Gradle, nebula.ospackage:  #search: nebula.ospackage version number
    関連:
        stable release: #keyword: stable release,  安定版,  suitable sutable ではない
            安定版  #ref: https://en.wikipedia.org/wiki/Software_release_life_cycle#Stable_release
Gradle: #keyword:  #ref: ${programming}/方法論/CVS/SubVersion.svg#Gradle
    Gradle（本体）:
        公式: #ref: https://gradle.org/ >> Docs
            注意: ドキュメントが対象とする Gradle のバージョンを合わせてください
                https://docs.gradle.org/current/userguide/userguide.html >>（左上のバージョン番号）
        手順:  #// プロジェクトの作成から実行までの手順を説明します
            インストール, バージョン アップ:
                Gradle Wrapper (gradlew) を使う場合:  #// 推奨
                    既存のプロジェクトに gradlew がある場合:
                        以下をコピーします:
                            - gradlew
                            - gradle/wrapper/gradle-wrapper.jar  #// gradlew があるフォルダーからの相対パス
                            - gradle/wrapper/gradle-wrapper.properties
                        バージョン番号を表示します:
                            gradlew --version
                    コピーする gradlew が無い場合:  #// 未確認
                        gradle をインストールします:
                        gradlew を作ります:
                            gradle wrapper
                    バージョン アップ する場合: #keyword: Gradle version up  #ref: https://gradle.org/install/  >> Upgrade with the Gradle Wrapper
                        -   cd  __GradlewFolder__
                        -   ./gradlew wrapper --gradle-version=8.7 --distribution-type=bin
                            #// または
                        -   ./gradlew wrapper --gradle-version=8.7 --distribution-type=bin  -Pgit.root=../  #search: Gradle -Pgit.root
                        -   ./gradlew --version  #// In first execution, this doawnloads gradle binary
                グローバルにインストールする場合:  #// Linux の localhost 全体にインストールする場合
                    Gradle を CentOS にインストールします: #keyword: CentOS Gradle
                        shell:
                            sudo yum -y install java-1.8.0-openjdk java-1.8.0-openjdk-devel unzip zip
                            curl -s "https://get.sdkman.io" | bash
                            source "$HOME/.sdkman/bin/sdkman-init.sh"
                            sdk install gradle 5.5.1
                            gradle --version
                        プロキシがある LAN の場合: #keyword: Gradle proxy
                            - mkdir ~/.gradle
                            - nano ~/.gradle/gradle.properties : |  #// __URL_Domain__ は proxy の http://__URL_Domain__:__PortNum__
                                systemProp.http.proxyHost=__URL_Domain__
                                systemProp.http.proxyPort=__PortNum__
                                systemProp.https.proxyHost=__URL_Domain__
                                systemProp.https.proxyPort=__PortNum__
                        #// Gradle Language Support という VSCode の拡張機能があるようです
            チュートリアル:  #// スクリプトの基礎を使うプロジェクトを作り実行します
                参考:  #ref: https://docs.gradle.org/5.6.4/userguide/tutorial_using_tasks.html
                hello タスクを定義して起動します:  #keyword: Gradle hello
                    #see-above: Gradle をインストールします
                    プロジェクトを作ります:
                        - mkdir ~/try_gradle_script_hello
                        - cd    ~/try_gradle_script_hello
                        - gradle init : |  #input:
                            $ gradle init  #input: gradle init

                            Select type of project to generate:
                            1: basic
                            2: application
                            3: library
                            4: Gradle plugin
                            Enter selection (default: basic) [1..4] 2  #input: 2

                            Select implementation language:
                            1: C++
                            2: Groovy
                            3: Java
                            4: Kotlin
                            Enter selection (default: Java) [1..4] 3  #input: 3

                            Select build script DSL:
                            1: Groovy
                            2: Kotlin
                            Enter selection (default: Groovy) [1..2] 1  #input: 1

                            Select test framework:
                            1: JUnit 4
                            2: TestNG
                            3: Spock
                            4: JUnit Jupiter
                            Enter selection (default: JUnit 4) [1..4]   #input: (Enter)

                            Project name (default: try_gradle):    #input: (Enter)
                            Source package (default: try_gradle):  #input: (Enter)

                            > Task :init
                            Get more help with your project: https://docs.gradle.org/5.5.1/userguide/tutorial_java_projects.html

                            BUILD SUCCESSFUL in 5m 54s
                            2 actionable tasks: 2 executed
                    build.gradle ファイルを作ります:  #keyword: build.gradle hello
                        build.gradle の最後に下記を追加します : |
                            task hello {    // #search: Gradle task
                                doLast {
                                    println 'Hello world!'  // comment  /* comment */  #keyword: Gradle comment
                                }
                            }
                    実行します:
                        gradle hello : |  #input:
                            $ gradle hello  #input:

                            > Task :hello
                            Hello world!

                            BUILD SUCCESSFUL in 980ms
            コードの内容:  #// .gradle ファイルが何をしているのかを調べます  #search: Gradle code
            クリーン, リビルド:
                クリーン: #keyword: Gradle clean
                    clean タスクを実行します:
                        ./gradlew __Parameters__ clean
                リビルド: #keyword: Gradle rebuild
                    リビルドする場合:  #focus: --rerun-tasks
                        ./gradlew buildRpm --info  --rerun-tasks
                    clean タスクとビルドするタスクを実行する場合:
                        ./gradlew __Parameters__ clean buildRpm
            実行順序: #🌟 #// Gradle がどの build.gradle ファイルから実行していくかを説明します
                基本: #keyword: Gradle execute order basic
                    説明: #🌟
                        Initialize >> Task Configure >> Task doFirst >> commandLine >> Task doLast の順に実行します。
                    サンプル出力: |  #// 上から下へ実行順序を表します
                        $ gradle  testBoth myTest
                        Initialize / "settings.gradle" file global

                        > Configure project :
                        Configure / "build.gradle" file global (1)
                        Configure / task configured
                        Configure / "build.gradle" file global (2)
                        Configure / task testBoth

                        > Task :testBoth
                        Task / testBoth.doFirst{}
                        Task / testBoth.doLast{}

                        > Task :myTest
                        Task / myTest.doLast{}
                    コード:  #focus: Initialize, Configure, Task, doFirst, doLast
                        __Project__/settings.gradle : |
                            rootProject.name = 'try_gradle'
                            println 'Initialize / "settings.gradle" file global'
                        __Project__/build.gradle: |
                            println 'Configure / "build.gradle" file global (1)'

                            task configured {
                                println 'Configure / task configured'
                            }

                            println 'Configure / "build.gradle" file global (2)'

                            task myTest {
                                doLast {
                                    println 'Task / myTest.doLast{}'
                                }
                            }

                            task testBoth {
                                doFirst {
                                    println 'Task / testBoth.doFirst{}'  // #keyword: doFirst Gradle example code
                                }
                                doLast {
                                    println 'Task / testBoth.doLast{}'  // #keyword: doLast Gradle example code
                                }
                                println 'Configure / task testBoth'
                            }
                    参照:
                        #search: Gradle commandLine example
                        #search: build_life_cycle_1
                #// 実行順序は多岐にわたります。下記のサンプルコードの１つ１つは実行順序の一部について説明しています
                build_life_cycle_1 サンプル コード: #keyword: build_life_cycle_1  #// フェーズの実行順序
                    参考: https://docs.gradle.org/5.6.4/userguide/build_lifecycle.html#build_lifecycle
                    内容: 初期化フェーズ(Initialize)、構成フェーズ(Configure)、実行フェーズ(Task) の順で実行します
                    準備:
                        プロジェクトを新しく作ります:
                            #search: Gradle hello
                        __Project__/settings.gradle : |
                            rootProject.name = 'try_gradle'
                            println 'Initialize / "settings.gradle" file global'
                        __Project__/build.gradle: |
                            println 'Configure / "build.gradle" file global (1)'

                            task configured {
                                println 'Configure / task configured'
                            }

                            println 'Configure / "build.gradle" file global (2)'

                            task myTest {
                                doLast {
                                    println 'Task / myTest.doLast{}'
                                }
                            }

                            task testBoth {
                                doFirst {
                                    println 'Task / testBoth.doFirst{}'  // #keyword: doFirst Gradle example code
                                }
                                doLast {
                                    println 'Task / testBoth.doLast{}'  // #keyword: doLast Gradle example code
                                }
                                println 'Configure / task testBoth'
                            }
                    実行: |
                        $ gradle myTest
                        Initialize / "settings.gradle" file global

                        > Configure project :
                        Configure / "build.gradle" file global (1)
                        Configure / task configured
                        Configure / "build.gradle" file global (2)
                        Configure / task testBoth

                        > Task :myTest
                        Task / myTest.doLast{}
                    実行します（２つのタスク）: |  #// 実行フェーズは指定して順に実行します
                        $ gradle  testBoth myTest
                        Initialize / "settings.gradle" file global

                        > Configure project :
                        Configure / "build.gradle" file global (1)
                        Configure / task configured
                        Configure / "build.gradle" file global (2)
                        Configure / task testBoth

                        > Task :testBoth
                        Task / testBoth.doFirst{}     #keyword: doFirst Gradle example order
                        Task / testBoth.doLast{}      #keyword: doLast Gradle example order

                        > Task :myTest
                        Task / myTest.doLast{}
                    実行します（-qオプションあり）: |
                        $ gradle -q myTest
                        Initialize / "settings.gradle" file global
                        Configure / "build.gradle" file global (1)
                        Configure / task configured
                        Configure / "build.gradle" file global (2)
                        Configure / task testBoth
                        Task / myTest.doLast{}
                    実行します（--infoオプションあり）: |
                        $ gradle --info  myTest
                        （省略。実行順序が詳細に表示されます）
                sub_project_1 サンプルコード:
                    参考: https://docs.gradle.org/5.6.4/userguide/multi_project_builds.html#sec:defining_common_behavior
                    内容 >> このサンプルで説明する実行順序:
                        - 複数のプロジェクトの同じ名前のタスクを実行します。対象プロジェクトは個別に指定します。
                    準備: #see-above: hello タスクを定義して起動します
                    実行します: |  #input:  #// 下記のファイルを作成した後で実行できます
                        $ gradle hello

                        > Task :hello
                        doLast in root_project project

                        > Task :sub_project:hello
                        doLast in sub_project project
                    __Project__/settings.gradle : |
                        rootProject.name = 'root_project'
                        include 'sub_project'
                    __Project__/build.gradle: |
                        Closure introduce = { task -> println "doLast in $task.project.name project" }
                        task('hello').doLast(introduce)
                        project(':sub_project') {
                            task('hello').doLast(introduce)
                        }
                allprojects_subprojects サンプルコード:
                    参考: https://docs.gradle.org/5.6.4/userguide/multi_project_builds.html#sec:subproject_configuration
                    内容 >> このサンプルで説明する実行順序:
                        - 複数のプロジェクトに入っている、同じ名前のタスクを実行します。対象プロジェクトは include したすべてです
                        - allprojects のブロックの中に、タスクの定義を書きます
                        - subprojects のブロックの中は、ルートのプロジェクトが対象外になります
                        - build.gradle ファイルは、サブ フォルダーにも配置できます。プロジェクトのブロックは不要です
                    準備: #see-above: hello タスクを定義して起動します
                    実行します: |  #input:  #// 下記のファイルを作成した後で実行できます
                        $ gradle hello  #input:

                        > Task :hello
                        doLast in root_project (by allprojects)

                        > Task :sub_project_1:hello
                        doLast in sub_project_1 (by allprojects)
                        doLast in sub_project_1 (by subprojects)
                        doLast in 'sub_project_1/build.gradle'

                        > Task :sub_project_2:hello
                        doLast in sub_project_2 (by allprojects)
                        doLast in sub_project_2 (by subprojects)
                        doLast in sub_project_2 (by sub_project_2)
                        doLast in 'sub_project_2/build.gradle'
                    指定したプロジェクトだけ実行します: |  #input:  #// 下記のファイルを作成した後で実行できます
                        $ gradle :sub_project_2:hello  #input:

                        > Task :sub_project_2:hello
                        doLast in sub_project_2 (by allprojects)
                        doLast in sub_project_2 (by subprojects)
                        doLast in sub_project_2 (by sub_project_2)
                        doLast in 'sub_project_2/build.gradle'
                    __Project__/settings.gradle : |
                        rootProject.name = 'root_project'
                        include 'sub_project_1', 'sub_project_2'
                    __Project__/build.gradle: |
                        allprojects {
                            task hello {
                                doLast { task ->
                                    println "doLast in $task.project.name (by allprojects)"
                                }
                            }
                        }
                        subprojects {
                            hello {  // hello タスクの追加。 コードを task hello にすると、allprojects の中で定義済みなので、エラーになります
                                doLast { task ->
                                    println "doLast in $task.project.name (by subprojects)"
                                }
                            }
                        }
                        project(':sub_project_2').hello {  // .hello は、ショートカット記法です
                            doLast { task ->
                                println "doLast in $task.project.name (by sub_project_2)"
                            }
                        }
                    __Project__/sub_project_1/build.gradle: |
                        hello.doLast {
                            println "doLast in 'sub_project_1/build.gradle'"
                        }
                    __Project__/sub_project_2/build.gradle: |
                        hello.doLast {
                            println "doLast in 'sub_project_2/build.gradle'"
                        }
                project_name_filtering サンプルコード:
                    参考: https://docs.gradle.org/5.6.4/userguide/multi_project_builds.html#sub:project_filtering
                    内容: subprojects.findAll に対象プロジェクトの条件式を付けることができます
                    準備: #see-above: hello タスクを定義して起動します
                    実行します: |  #input:  #// 下記のファイルを作成した後で実行できます
                        $ gradle hello  #input:

                        > Task :sub_project_1:hello
                        doLast in sub_project_1 (by it.name != sub_project_2)

                        > Task :sub_project_3:hello
                        doLast in sub_project_3 (by it.name != sub_project_2)  
                    __Project__/settings.gradle : |
                        rootProject.name = 'root_project'
                        include 'sub_project_1', 'sub_project_2', 'sub_project_3'
                    __Project__/build.gradle: |
                        configure(subprojects.findAll {it.name != 'sub_project_2'}) {
                            hello {
                                doLast { task ->
                                    println "doLast in $task.project.name (by it.name != sub_project_2)"
                                }
                            }
                        }
                project_property サンプルコード:
                    参考: https://docs.gradle.org/5.6.4/userguide/multi_project_builds.html#ssub:filtering_by_properties
                    内容:
                        - 評価フェーズで設定したプロパティの値によってタスクの内容を変更できます
                        - afterEvaluate は、評価フェーズの直後のフェーズです
                    準備: #see-above: hello タスクを定義して起動します
                    実行します: |  #input:  #// 下記のファイルを作成した後で実行できます
                        $ gradle hello  #input:

                        > Task :sub_project_1:hello
                        doLast (by afterEvaluate)
                    __Project__/settings.gradle : |
                        rootProject.name = 'root_project'
                        include 'sub_project_1', 'sub_project_2'
                    __Project__/build.gradle: |
                        subprojects {
                            task hello {
                            }
                            afterEvaluate { Project project ->
                                if (project.myProperty) {
                                    hello.configure {
                                        doLast {
                                            println 'doLast (by afterEvaluate)'
                                        }
                                    }
                                }
                            }
                        }
                    __Project__/sub_project_1/build.gradle: |
                        ext.myProperty = true
                    __Project__/sub_project_2/build.gradle: |
                        ext.myProperty = false  // この行は省略できません
                依存関係:
                    タスク間の依存関係:  #// 未確認
                        taskA → taskB : |  #// → は実行順序、子→親 を表す
                            task taskA {
                                // タスク A の設定
                            }

                            task taskB(dependsOn: taskA) {
                                // タスク B の設定
                            }
                    プロジェクト間の依存関係:  #// 未確認
                        projectA → projectB :
                            projectB build.gradle : |
                                dependencies {
                                    compile project(":projectA")
                                }
                シェルのコマンドの実行:
                    Exec タスクを使う場合: |  #// 未確認
                        task runShellCommand(type: Exec) {
                            commandLine 'sh', '-c', 'echo "Hello, world!"'
                        }
                    ProcessBuilder を使う場合: |  #// 未確認
                        task runShellCommand {
                            doLast {
                                def process = new ProcessBuilder('sh', '-c', 'echo "Hello, world!"').start()
                                process.waitFor()
                            }
                        }
                その他:
                    依存関係: #ref: https://docs.gradle.org/5.6.4/userguide/multi_project_builds.html#sec:dependencies_which_dependencies
                    プロジェクトの lib 依存関係: #ref: https://docs.gradle.org/5.6.4/userguide/multi_project_builds.html#sec:project_jar_dependencies
                    別のプロジェクトによって生成されるタスク出力に応じて: #ref: https://docs.gradle.org/5.6.4/userguide/multi_project_builds.html#sec:depending_on_output_of_another_project
                    並列プロジェクト実行: #ref: https://docs.gradle.org/5.6.4/userguide/multi_project_builds.html#sec:parallel_execution
                    分離されたプロジェクト: #ref: https://docs.gradle.org/5.6.4/userguide/multi_project_builds.html#sec:decoupled_projects
                    マルチプロジェクトの構築とテスト: #ref: https://docs.gradle.org/5.6.4/userguide/multi_project_builds.html#sec:multiproject_build_and_test
                    マルチプロジェクトと buildSrc: #ref: https://docs.gradle.org/5.6.4/userguide/multi_project_builds.html#sec:multi_project_and_buildsrc
            実行結果:
                公式: #ref: https://docs.gradle.org/current/userguide/more_about_tasks.html#sec:task_outcomes
                書式: |
                    > Task :__TaskNames__ __Outcomes__
                出力例: |
                    > Task :buildSrc:build UP-TO-DATE
                __Outcomes__: #// 実行結果
                    EXECUTED: 実行しました
                    UP-TO-DATE: 実行しましたが出力は変わりませんでした
                    FROM-CACHE: キャッシュから復元できます(?) しました(?)
                    SKIPPED: 実行しませんでした。最終成果に関連しない(?)
                    NO-SOURCE: 入力がありません。実行しませんでした(?)
            デバッグ:  #search: Gradle pause method
            （書きかけ）Building Java Applications with libraries Sample（公式）:
                （書きかけ）Gradle version 7:
                    #// Gradle version 5.5.1 では、複数のプロジェクトを作るメニューが選べない
                    参考: https://docs.gradle.org/current/samples/sample_building_java_applications_multi_project.html
                    #// アプリケーションと複数のライブラリプロジェクトで構成される Javaアプリケーションをビルドします。
                    上記「Gradle を CentOS にインストールする」:
                    memo:
                        - mkdir ~/try_gradle
                        - cd    ~/try_gradle
                        - gradle init
            （書きかけ）:
                参考: https://agency-star.co.jp/column/gradle/ >> Gradleの使い方
                bash:
                    - mkdir ~/try_gradle
                    - cd    ~/try_gradle
                    - gradle init :
                        Select type of project to generate: "1: basic"
                        Select build script DSL: "1: Groovy"
                        Project name: try_gradle
                    - ./gradlew tasks  #// タスクを一覧します
            Exec タイプのタスク: #search: Gradle Exec task type
            OS パッケージ を作ります: #search: nebula.ospackage version number
        コマンド, オプション: #keyword: gradlew options
            gradlew:  #ref: https://docs.gradle.org/current/userguide/command_line_interface.html#sec:command_line_completion
                ./gradlew __TaskName__:  #// ルート プロジェクト の指定したタスクを実行します
                ./gradlew __TaskName1__ __TaskName2__:  #// 2つのタスクを実行します
                ./gradlew :__Package__:__TaskName__:  #// パッケージ内のタスクを実行します
                    (:__Package__:__TaskName__) の部分の書式は include の書式と同じです  #search: Gradle include
                ./gradlew __SubCommandName__:  #// タスクを実行すること以外のコマンド
                    ./gradlew tasks:  #// タスクを一覧します
                    ./gradlew dependencies:
                    ./gradlew release:
                        --dry-run オプション:  #// タスクの実行順序を表示し、実行は行いませんｚ
                オプション: #glossary: gradlew
                    -i: #// 情報を詳細に表示します
                    -P: #// プロパティの指定  #search: gradle.properties
                    --build-cache: #// ビルドキャッシュ機能を有効にします
                        gradle.properties ファイルで有効になっている場合は指定不要です
                実行時メッセージ:  #search: gradlew messages
            関連:
                nebula-release-plugin のオプション:  #search: nebula-release-plugin options
        概念: #keyword: Gradle concept  #glossary: Gradle
            DSL: Gradle が直接呼び出すスクリプト言語の抽象。 2021年現在、Kotlin と Groovy があります。
                https://stackoverflow.com/questions/38336576/what-does-dsl-mean-in-gradle
                #search: Gradle DSL 文法
            Gradle DSL: #keyword:
                buildRpm:  #search: buildRpm task
                    task あり: |
                        // task は DSL キーワード。 buildRpm タスクを定義します
                        task buildRpm {
                            ...
                        }
                    task なし: |
                        // Groovy の通常のメソッド呼び出し構文です。 buildRpm タスクを configure します
                        buildRpm {
                            ...
                        }
                Groovy DSL との関係:
                    Groovy 言語:
                        ├── 通常のメソッド呼び出し
                        ├── クロージャ
                        ├── ラベル構文（colon を省略可能）
                        └── メタプログラミング（methodMissing, propertyMissing）
                    Gradle DSL:  #// Groovy の上に構築
                        ├── task buildRpm { ... }   ← ここが独自拡張
                        ├── copy { from ... }       ← 独自拡張
                        ├── buildRpm { ... }        ← メソッド呼び出しとして解釈
                        └── plugins { id "..."}     ← 独自拡張
                    Gradle が利用している Groovy の機能:
                        propertyMissing: |
                            未知のプロパティ参照をフックする
                            buildRpm { ... }
                            Groovy: 「buildRpm というプロパティが見つからない」
                            Gradle: 「あ、それ TaskContainer にあるから返します」
                            → 既存タスクをプロパティのように参照できる
                        methodMissing: |
                            未知のメソッド呼び出しをフックする
                                foo {
                                    ...
                                }
                            Groovy: 「foo() というメソッドは無い」
                            Gradle: 「foo というタスク名を探して configure しよう」
                            → taskName { ... } が “既存タスク設定” として働く
            フェーズ: #search: build_life_cycle_1
            タスク:  #keyword: Gradle task
                基本, 定義サンプル: |  #// hello タスク
                    task hello {  // template: task __Name__
                        doLast {
                            println 'Hello world!'  // template: __Statements__
                        }
                    }
                    task execTask(type: Exec) {  // タイプ指定  #search: Gradle Exec task type
                    }
                    buildRpm {  // 設定ブロック  #search: Gradle task configuration block
                    }
                Copy タイプ: #keyword: Gradle Copy task type  #ref: https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Copy.html
                    動作: コピーします。ただし、コピーが不要と判断したらコピーしません
                    サンプル:
                        基本: |
                            task copyTask(type: Copy) {
                                from("${Project}/src")
                                into("build")
                            }
                        ２つのファイルをコピーします: |
                            task copyTask(type: Copy) {
                                from("${Project}/src")
                                into("build")
                                include 'file1.txt', 'file2.properties'
                            }
                        ２つのフォルダーをマージします: |
                            task extractBinary(type: Copy) {
                                from rpmExtracted
                                from rpmExtracted2
                                from rpmExtracted3

                                into "${binaryDir}/dest"
                                duplicatesStrategy 'exclude'
                            }
                        ２つのフォルダーをコピーします: |
                            task copy1Task(type: Copy) {
                                from("${Project}/src1")
                                into("build/1")
                            }
                            task copy2Task(type: Copy) {
                                from("${Project}/src2")
                                into("build/2")
                            }
                        ２つのサブフォルダーをコピーします: |
                            task extractBinary(type: Copy) {
                                from(rpmExtracted) {
                                    into "dest1"       // ルートの into からの相対パス。"${binaryDir}/dest1" にコピーされます
                                }
                                from(rpmExtracted2) {
                                    into "dest2"       // ルートの into からの相対パス。"${binaryDir}/dest2" にコピーされます
                                }
                                into "${binaryDir}"    #// . は指定できません
                            }
                    メソッド:  #// from, into, include, rename, ...  #search: Gradle method
                        from: コピー元のフォルダーまたはファイルのパス。inputs が省略されると、この値が inputs にも暗黙的に指定されます
                        into: コピー先のフォルダーまたはファイルのパス。outputs が省略されると、この値が outputs にも暗黙的に指定されます
                        include: from や into に指定したフォルダーの中の一部のファイルやフォルダーを指定します
                        rename: ファイル名を変更します  #//  フォルダー名も変更できる？
                Exec タイプ: #keyword: Gradle Exec task type  #ref: https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Exec.html
                    概要: exec を task ブロックの直下に書くことができます
                    メソッド: #// commandLine など  #search: Gradle method
                        commandLine: #keyword: Gradle commandLine  #// シェルから実行するように子プロセスを起動する予約をします
                            注意: 複数の commandLine を書いても、最後の commandLine しか有効になりません
                            サンプル:
                                commandLine 'ruby', '-v'
                            全体のサンプル:
                                #search: Gradle commandLine example
                            パイプを使う場合:
                                commandLine "bash", "-c", "rpm2cpio ${binarySourceRpm} | cpio -ivd"
                            実行タイミング:
                                commandLine は指定したコマンド（上記 ruby や bash）を起動することを予約します。
                                指定したコマンドが起動されるタイミングは、doFirst の中のスクリプトを実行した後です。
                        workingDir: #keyword: Gradle workingDir  #// コマンドを実行するときの カレント フォルダー を指定します
                            サンプル:
                                workingDir "build"
                            指定したフォルダーが存在しないとき:
                                フォルダーが作られてから commandLine に指定したコマンドを起動します。
                                なので、doFirst で通常は mkdir する必要はありません。
                    無名タイプとの違い:
                        Exec タイプの場合: |  #keyword: Gradle commandLine example  #search: Gradle commandLine
                            task myTask(type: Exec) {
                                commandLine 'cmd', '/c', 'whoami'  #// ここでは cmd は起動しません。doFirst の中のスクリプトを実行した後で起動します
                                standardOutput = new ByteArrayOutputStream()
                                doFirst {
                                    mkdir "sub"
                                }
                                doLast {
                                    println "Output: $standardOutput"
                                }
                            }
                        無名タイプの場合: |
                            task myTask() {
                                doLast {
                                    def stdout = new ByteArrayOutputStream()
                                    exec {
                                        commandLine 'cmd', '/c', 'whoami'
                                        standardOutput = stdout
                                    }
                                    println "Output: $stdout"
                                }
                            }
                        参考: #ref: https://stackoverflow.com/questions/58542083/gradle-exec-task-fails-with-execcommand-null
                設定ブロック: | #keyword: Gradle task configuration block,  Gradle task customize  #// 既存のタスクをカスタマイズします。パラメーターを追加指定できます。
                    buildRpm {     // nebula.ospackage が定義している buildRpm タスクをカスタマイズします
                        メソッド呼び出し:  #search: Gradle method
                    }
                全 タスク タイプ 共通?:  #// メソッド
                    メソッド: #// doLast など  #search: Gradle method  #ref: https://docs.gradle.org/current/dsl/org.gradle.api.Task.html#N18B59
                        doFirst: #keyword:
                            概要: タスクを実行する必要があるときだけ実行します
                                Exec タイプのタスクでは、commandLine に指定したコマンドを実行するより前に
                                doFirst の中のスクリプトを実行します。
                            サンプル:
                                #search: Gradle commandLine example
                                #search: doFirst Gradle example code
                        doLast: #keyword:
                            概要: タスクを実行する必要があるときだけ実行します
                                無名タイプのタスクでは、doLast の中に入れないと、常に実行されてしまいます。
                                Exec タイプのタスクでは、タスクを実行する必要があるときだけ実行します。
                                #ref: https://stackoverflow.com/questions/58542083/gradle-exec-task-fails-with-execcommand-null
                            サンプル: #search: doLast Gradle example code
                            文法的意味: スーパークラスである task のメソッド doLast を呼び出し、
                                通常、第1引数 action に指定する { } で囲まれた無名関数を、doLast のタイミングで呼び出します
                            参考: #ref: https://docs.gradle.org/current/dsl/org.gradle.api.Task.html#N18B59 (Methods)
                        inputs: #keyword: Gradle inputs
                            file: inputs.file __FilePath__
                            folder: inputs.dir __FolderPath__
                        outputs: #keyword: Gradle outputs
                            1つのファイル:
                                outputs.file __FilePath__
                            2つのファイル:  #// outputs.file は複数書いても両方とも有効です。commandLine とは違います  #search: Gradle commandLine
                                outputs.file __FilePathA__
                                outputs.file __FilePathB__
                            フォルダ―:  #// フォルダーの中のすべてのファイルが設定されます
                                outputs.dir __FolderPath__
                タイプ一覧: #ref: https://docs.gradle.org/current/dsl/#N104C2
                変数:  #keyword: Gradle variable
                    書式: |
                        task __TaskName__ {
                            def __LocalVariableName__ = __Value__
                        }
                        def __GlobalVariableName__ = __Value__
                    ❗注意:  #// 変数名は固有にすること
                        - ローカル変数であるかグローバル変数であるかの識別ができないため、定義場所を探すのが難しいです
                        - ローカル変数でもグローバルで（他のファイルも含めて）固有の名前になるように変数名を付けます
                    サンプル: |
                        task execTask {
                            def localVar1 = "value"
                            def localVar2 = variable
                            def localVar3 = "variable = ${variable}"
                        }
                        def globalVar = "value"
                一覧: ./gradlew tasks
                検索:  #// タスクの設定ブロックなどを検索します
                    タスクの定義の場合:
                        task hello { ____ }  #// hello タスク
                    タスクへの代入の場合:
                        project.rootProject.tasks.release.dependsOn(buildRpm)  #// release タスク
                起動:
                    #search: Gradle hello
            プロジェクト:  #// settings.gradle ファイルで include されたフォルダーはプロジェクトです
                一覧: gradle -q projects  #// 一覧します。-q は、メッセージを明確にします 
                ルート: settings.gradle ファイルがあるフォルダー
            ラッパー:
                gradle コマンドのプロジェクト固有部分。 gradlew の w (wrapper) のこと。
            RPM:  #// 作成する RPM のバージョンなど  #search: nebula.ospackage version number
        ファイル:  #// フォルダー構成、Gradle 関連のファイル:  #glossary: Gradle  #// build.gradle, gradlew, settings.gradle
            build.gradle: #keyword: build.gradle file  #// メインのスクリプト(1) Groovy DSL 言語で書きます
                基本:  #search: build.gradle hello
                文法:  #search: Gradle DSL 文法
                タスク:  #search: Gradle task
                Copy タスク タイプ:  #search: Gradle Copy task type
                Exec タスク タイプ:  #search: Gradle Exec task type
                サンプル >> make コマンド:  #search: Gradle make
            build.gradle.kts:  #// メインのスクリプト(1) Kotlin DSL 言語で書きます
            settings.gradle:  #// プロジェクトの構成や依存関係の設定ファイル。ルートのプロジェクトにのみ存在します
            gradle.properties:  #// 一般的な設定に関する設定ファイル
                場所:  #// 定義場所。同じプロパティ名の定義がある場合、下記の上側に書かれたファイルで定義された値ほど優先されます
                    - （コマンドの -P オプション）
                    - __SubProject__/gradle.properties  #// あまり使いません
                    - __RootProject__/gradle.properties
                    - ~/.gradle/gradle.properties  #// あまり使いません
                内容:
                    書式:
                        __Name__=__Value__
                    サンプル:
                        myCustomProperty=HelloWorld
                    org.gradle.jvmargs:
                        org.gradle.jvmargs=-Xmx2048m
                    git.root: #keyword: Gradle -Pgit.root  #// Git ワーキング フォルダー のルートの位置
                        これを設定しないと Gradle はエラーになります
                コマンドでの定義:
                    ./gradlew _____ -P__Name__=__Value__
                参照:
                    Groovy DSL (build.gradle): |
                        - "${__Name__}"
                        - "__Others__${__Name__}__Others__"
                    Kotlin DSL (build.gradle.kts)での参照: |
                        - "${findProperty("__Name__")}"
                        - "__Others__${findProperty("__Name__")}__Others__"
            buildSrc/build.gradle: メインのスクリプト(2)  #search: build.gradle file
            buildSrc/___/___/___.gradle: プラグインとしてのスクリプト
            gradle: ラッパー
            gradlew: ラッパーを使う gradle コマンド
            gradlew.bat: ラッパーを使う gradle コマンド (Windows用)
            __Project__: アプリケーションやライブラリをビルドするプロジェクト
            __Project__/build.gradle: アプリケーションに関するスクリプト
            ____.groovy:  #// ビルドする内容が書かれたファイル。.grooby ではない
                println: 
                    println "rpmVersion=${rpmVersion}, rpmRelease=${rpmRelease}"
            参考:  #ref: https://docs.gradle.org/current/samples/sample_building_java_applications_multi_project.html#run_the_init_task
        コード:  #keyword: Gradle code,  .gradle,  Gradle Grooby code
            概要:
                - メタ的な処理のコードを、どのように理解すればいいか  #ref: ${typrm_files}/ref/Git/GradleCode.md
                - plugins { ... } に書かれたパッケージ名から処理の概要を知ることができます。
                    たとえば、nebula.ospackage が書かれていたら RPM などのパッケージをビルドします。
            実行タスク:  #// どのタスクが実行されるのかを知りたい場合
                gradlew コマンドを実行するときのパラメーターに指定します。
                下記は my_service:buildRpm タスクを実行します。
                    ./gradlew :my_service:buildRpm -i -Pgit.root=../
                通常、多くのタスクが定義されており、特定のタスクだけ実行することもよくあります。
            チュートリアル:  #ref: ${typrm_files}/ref/Git-AI.yaml#label: Gradle code
            設定:
                settings.gradle: #search:  #// プロジェクトの構成や依存関係の設定
                gradle.properties: #search:  #// その他一般的な設定
                環境変数:
            ライブラリ:
                Task インターフェース:
                    dependsOn メソッド: | #keyword: Gradle dependsOn
                        task __TaskName__ {
                            dependsOn '__DependsOnTaskName1__', '__DependsOnTaskName2__', '__DependsOnTaskName3__'
                        }
            文法: #🌟 #keyword: Gradle DSL 文法  #// タスクなど  .gradle ファイル
                コメント: // 行末までコメント
                キーワードから意味を知りたい場合:  #glossary: Gradle
                    buildRpm: gradle-ospackage-plugin が定義しているタスク。設定ブロックを書くことでタスクの設定を指定できます。
                        #search: buildRpm task
                    include:  #// サブプロジェクトをインクルードします
                        - include '__FolderName__'
                        - include '__FolderName__:__SubFolderName__'
                        - include ':__FolderName__:__SubFolderName__'
                        #// コロンはフォルダーの区切りを表します
                        #// 先頭のコロンは ルート プロジェクト を表します
                    ospackage: nebula.ospackage プラグインが提供している拡張(extension)  #search: ospackage task
                    plugins から始まる行: #keyword: Gradle plugins  #// 使うプラグインの指定
                    project から始まる行: #keyword: Gradle project code  #// プロジェクトの設定  #search: Gradle プロジェクト
                        project.rootProject.tasks.__TaskName__:
                        project.rootProject.tasks.release.dependsOn(__DependentTask__): #keyword: Gradle release,  Gradle dependsOn
                            buildRpm タスク → release タスクの順に実行します。
                            ただし、buildRpm タスクだけで完了することもできます。
                            ルートプロジェクトの release タスクが buildRpm タスクに依存しています。
                    task から始まる行:  #// task の定義  #search: task (Gradle)
                    ${ }:  #// プロパティの参照  #search: gradle.properties
                    型（緑色）から始まる行: 定数の定義
                    タスクの設定ブロック:  #search: task (Gradle)
                    その他: |  #// プラグイン（拡張）が定義しているタスクに対する「設定ブロック」
                        __Others__ {
                            ____
                        }
                        __Others__.____
                    （概念）:  #search: Gradle concept
                コアタイプ: #// タスクなど
                    #ref: https://docs.gradle.org/current/dsl/#N100CA
                スクリプト:
                    公式: #ref: https://docs.gradle.org/current/dsl/org.gradle.api.Script.html
                    mkdir: #keyword: Gradle mkdir  #ref: https://docs.gradle.org/current/dsl/org.gradle.api.Script.html >> mkdir
                プロパティ:
                    設定の書き方:
                        __PropertyName__ __Value__:  #// Gradle, Kotlin DSL で推奨。メソッド呼び出し形式。__PropertyName__ = __Value__ と同じ解釈がされます
                            packageName 'myapp'
                        __PropertyName__ = __Value__:  #// Groovy で推奨。プロパティへの直接代入
                            packageName = 'myapp'
                    projectDir: ルートの build.gradle ファイルがあるフォルダー  https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:projectDir
                    projectName: プロジェクト名。プロジェクトはタスクの集まり
                    gradle.properties: #search:
                メソッド: #keyword: Gradle method
                    呼び出しの書き方:
                        __MethodName__ __Parameters__:
                            from 'src/main/resources'
                        __MethodName__(__Parameters__):  #// __MethodName__ __Parameters__ と同じ解釈がされます
                            from('src/main/resources')
                        __MethodName__(__Parameters__) { __Closure__ }: |
                            from('src/main/resources') {
                                include '**/*.txt'
                                exclude 'temp/**'
                            }
                    サンプル, pause メソッド: #keyword: Gradle pause method
                        定義:  #focus: pause
                            build.gradle: |  #// 下記は、build.gradle に暗黙的に存在する Project クラスのメソッドになります
                                void pause(String message) {
                                    println ''
                                    String yellow = "\u001B[33m"
                                    println "${yellow}@@@ Press Enter to continue... ${message}"   // print では表示されません
                                    System.in.read()
                                }
                        使用例:
                            build.gradle: |
                                task exampleTask {
                                    doLast {
                                        pause("")
                                    }
                                }
        トラブルシューティング(Gradle): #keyword: Gradle trouble shooting
            デバッグ:
                リビルド:  #search: Gradle rebuild
                Configure フェーズ:
                    println:
                        サンプル コード: println '111'
                    project.logger.lifecycle:
                        コード:
                            - project.logger.lifecycle('eeeeeee')  #// 標準出力へ出力して続行します。オプション指定不要
                            - project.logger.error('eeeeeeee')  #// 標準エラー出力へ出力して停止します
                            - project.logger.warning('eeeeeeee')  #// 標準出力へ出力して停止します
                        出力: |
                            Configure project:__Project__:__Method__
                            ...
                            eeeeeeee
                        #ref: https://stackoverflow.com/questions/40878923/in-gradle-how-to-print-out-a-message-in-the-console-event-log
                    例外を発生させます:
                        throw new GradleException("user exception")
                Task フェーズ:
                    commandLine:
                        注意: 1つのタスクに複数の commandLine が指定された場合、最後の commandLine 以外は実行されません
                        コード:
                            - commandLine "echo", "aaaaaaaa"
                            - commandLine "python3", "--version"
                        出力: |
                            Task :__Project__:__Method__
                            ...
                            Starting process 'command 'python3''. Working directory: __WorkingDirectory__ Command: __CommandLine__
                        補足:
                            オプション不要: commandLine 関数で起動したプロセスの標準出力も --debug オプションなしに表示されます
                            captureStandardOutput 不要: 下記コードは不要です
                                logging.captureStandardOutput LogLevel.LIFECYCLE
            エラー:
                - エラーメッセージの解析: #keyword: gradlew messages
                    全体:
                        エラーメッセージの例: |
                            FAILURE: Build failed with an exception.

                            * Where:
                            Build file '/home/____/try_gradle/build.gradle' line: 55

                            * What went wrong:
                            Execution failed for task ':sub_project_2:hello'.
                            > Could not get unknown property 'task' for task ':sub_project_2:hello' of type org.gradle.api.DefaultTask.

                            * Try:
                            Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.
                        上記から分かること:
                            - エラーが発生した場所が Where に書かれています
                            - プロジェクト名とタスク名が What went wrong に書かれています
                            - Could not get unknown property '____' は、未定義エラーです
                            - オプションを付けて実行すると詳細が分かります。--info がオススメです
                    Caching disabled for task:
                        メッセージ: |
                            Caching disabled for task ':__Folder__:__Task__' because:
                                Build cache is disabled
                                Caching has been disabled for the task
                        上記から分かること:
                            - ビルド キャッシュ が無効になっています  #search: gradlew --build-cache
                    Task ____ is not up-to-date because:
                        メッセージ: |
                            Task ':__Folder__:__Task__' is not up-to-date because:
                                Output property 'archiveFile' file /home/user1/__Folder__-4.0.0~dev.6.d5c4248.x86_64.rpm has been removed.
                        上記から分かること:
                            - 更新済みではないため、__Task__ を実行します
                    Starting process, Successfully started process, Resolve mutations for:
                        メッセージ: |
                            Task ':__FolderA__:__TaskA__' is not up-to-date because:
                                Task has not declared any outputs despite executing actions.     #search: 
                            Starting process 'command '__Command__''. Working directory: __WorkingFolder__ Command: __Command__ 
                            Successfully started process 'command '__Command__''
                            __CommandOutput__
                            Resolve mutations for :__FolderB__:__TaskB__ (Thread[Execution worker Thread __ThreadID__,__Priority__,__ThreadGroup__]) started.
                            :__FolderB__:__TaskB__ (Thread[Execution worker Thread __ThreadID__,__Priority__,__ThreadGroup__]) started.
                        上記から分かること:
                            - 更新済みではないため、__TaskA__ を実行します
                            - __Command__ が __WorkingFolder__ で実行開始されたことを表します
                            - コマンドの出力が __CommandOutput__ に表示されます
                            - __TaskA__ を実行したことによって __TaskB__ がトリガーされます


                    Got an empty spec from org.gradle.api.internal.file.copy.NormalizingCopyActionDecorator$StubbedFileCopyDetails for __Path__:
                        メッセージ: |
                            Got an empty spec from org.gradle.api.internal.file.copy.NormalizingCopyActionDecorator$StubbedFileCopyDetails for __Path__
                        上記から分かること:
                            - __Path__ で示されたフォルダーの直下には何もファイルがコピーされないことを助言しています
                            - このメッセージは期待通りなら無視できます
                - ChatGPT の活用: #keyword:
                    エラーメッセージからプライベートな部分を置き換えて、
                    エラーメッセージを ChatGPT GPT4o に示して解決方法を教えてもらうと
                    多くの場合対応できます
                - #// Could not find __Package__.__Version__  #keyword: gradle version dependency trouble,  gradle deprecated trouble
                    手順: ./gradlew ____
                    エラー: |
                        * What went wrong:
                        A problem occurred configuring root project 'packages'.
                        > Could not resolve all artifacts for configuration ':classpath'.
                            > Could not find org.ajoberstar.grgit:grgit-core:3.1.1.
                                Searched in the following locations:
                                    - https://plugins.gradle.org/m2/org/ajoberstar/grgit/grgit-core/3.1.1/grgit-core-3.1.1.pom
                                Required by:
                                    project : > nebula.release:nebula.release.gradle.plugin:14.0.3 > com.netflix.nebula:nebula-release-plugin:14.0.3
                    エラーの説明:
                        -   project は nebula.release または nebula-release-plugin を要求しています（以後 nebula.release）
                        -   nebula.release は grgit-core:3.1.1. を要求しています
                        -   org.ajoberstar.grgit:grgit-core:3.1.1. が Web に見つかりません。
                                https://plugins.gradle.org/m2/org/ajoberstar/grgit/grgit-core/ にアクセスすると 3.x は無くなっています
                    対処:
                        nebula.release のバージョンを上げます
                - #// Reason: Task ':__ParentTask__' uses this output of task ':__ChildTask__' without declaring an explicit or implicit dependency.
                    手順: ./gradlew ____
                    エラー: |
                        * What went wrong:
                        A problem was found with the configuration of task ':extractBinary' (type 'Exec').
                            -   Gradle detected a problem with the following location: '/home/user1/common-packages/elasticsearch/build/packaging'.
                                Reason: Task ':extractBinary' uses this output of task ':buildPackageFiles' without declaring an explicit or implicit dependency. This can lead to incorrect results being produced, depending on what order the tasks are executed.
                                Possible solutions:
                                    1. Declare task ':buildPackageFiles' as an input of ':extractBinary'.
                                    2. Declare an explicit dependency on ':buildPackageFiles' from ':extractBinary' using Task#dependsOn.
                                    3. Declare an explicit dependency on ':buildPackageFiles' from ':extractBinary' using Task#mustRunAfter.
                    対処: |
                        このエラーは、extractBinary タスクが buildPackageFiles タスクの出力に依存していることを自動的に検出したが、
                        明示的に依存関係が書かれていないときに発生します。
                        buildPackageFiles → extractBinary の順に実行するのが正しい動作です。

                        Possible solutions の 1～3 のどれでも構いません。

                        1
                            tasks.named('extractBinary') {
                                inputs.dir(tasks.named('buildPackageFiles').get().outputs.files)
                            }

                        2
                            tasks.named('extractBinary') {
                                dependsOn tasks.named('buildPackageFiles')
                            }
                        または
                            extractBinary.dependsOn buildPackageFiles

                        3
                            tasks.named('extractBinary') {
                                mustRunAfter tasks.named('buildPackageFiles')
                            }
                - #// Could not find method compile()
                    手順: ./gradlew ____
                    エラー: |
                        Could not find method compile() for arguments [org.gradle.api.internal.artifacts.dependencies.DefaultFileCollectionDependency_Decorated@9e89d81] on object of type org.gradle.api.internal.artifacts.dsl.dependencies.DefaultDependencyHandler.
                    対処:
                        - compile を implementation に置き換えます
                        - testCompile を testImplementation に置き換えます
                - #// Git repository not found
                    手順: ./gradlew ____
                    エラー: |
                        Git repository not found at __CheckedPath__ -- __Task__ tasks will not be available. Use the git.root Gradle property to specify a different directory.
                    対処:
                        gradle.properties に git.root プロパティを追加してリポジトリのパスを指定します:
                            ./gradlew ____ -Pgit.root=../  #search: Gradle -Pgit.root
                - #// nebula.ospackage version was not found in any of the following sources
                    手順: ./gradlew ____
                    エラー: |
                        Plugin [id: 'nebula.ospackage', version: '11.4.0'] was not found in any of the following sources:
                    対処:
                        修正前:
                            plugins {
                                id 'nebula.ospackage' version '11.4.0'
                        修正後:
                            plugins {
                                id 'com.netflix.nebula.ospackage' version '11.4.0'
                    原因:
                        nebula.ospackage は NetFlix に移管されました
                - #// ビルドに失敗した後、build.gradle ファイルに意味のない空白を追加するとビルドが通る謎の現象
                    手順: ./gradlew buildRpm
                    対処:
                        Gradle Wrapper も 5.5.1 → 最新 8.7 など更新、
                        ospackage を 6.2.0 → 最新 11.4.0 などに更新します
                        #search: Gradle version up
                - #// Project '__SubProject__' not found in root project '__RootProject__'.
                    手順: gradlew コマンド
                    エラー: |
                        * What went wrong:
                        Project '__SubProject__' not found in root project '__RootProject__'.
                    対処:
                        ルートの settings.gradle ファイルに include ':__SubProject__' を追加します。
                - #// Final and candidate builds require all changes to be committed into Git.
                    手順: gradle コマンド
                    エラー: |
                        An exception occurred applying plugin request [id: 'nebula.release', version: '14.0.2']
                            > Failed to apply plugin [id 'nebula.release']
                                > Final and candidate builds require all changes to be committed into Git.
                                    Found unstaged changes:
                                    [+] folder/file
                    対処:
                        git status をクリーン状態にします。
                        .gitignore が古いと、最新の .gitignore で無視されるファイルに対してこのエラーになることがあります。
                        ただし、エラーメッセージに表示される相対パスは、カレント フォルダー ではなく
                        プロジェクトのルートからの相対パスです。
                - #// execCommand == null!
                    手順: gradle コマンド
                    エラー: |
                        Execution failed for task ':extractBinary'.
                        > execCommand == null!
                    対処:
                        commandLine を書きます  #search: Gradle commandLine
                - #// File '__Path__' specified for property '$1' is not a file.
                    手順: gradle コマンド
                    エラー: |
                        File '__Path__' specified for property '$1' is not a file.
                    原因: input.file などの file（の第1引数）に指定した値 __Path__ がファイルではないため
                    対処:
                        __Path__ がフォルダーの場合:
                            input.file を input.dir に修正します
                        その他:
                            rm .gradle または mv .gradle .gradle_bk
                            #ref: https://stackoverflow.com/questions/41254303/what-does-mean-specified-for-property-resdir-does-not-exist
                - #// Task has not declared any outputs despite executing actions.
                    手順: gradle コマンド
                    エラー: |
                        Task has not declared any outputs despite executing actions.
                    対処:
                        Exec タイプのタスクには、outputs.dir を書く必要があります
                    補足:
                        このメッセージは、タスクが出力を宣言しなかったことを示します。
                        Gradleは、タスクの入力と出力を使用して、タスクを実行する必要があるかどうかを判断します(最新の状態)。
                - #// Plugin [id: '____', version: '____'] was not found in any of the following sources:
                    手順: gradle コマンド
                    エラー: |
                        Plugin [id: '____', version: '____'] was not found in any of the following sources:
                    対処:
                        プロキシを設定します  #search: Gradle proxy
                - #// A problem occurred starting process 'command 'python3',  commandLine 関数で起動したプロセス
                    手順: gradle 実行時エラー
                        Successfully started process 'command '__CommandName__'' と表示されていない
                    エラー: |
                        * What went wrong:
                        Execution failed for task ':__ProjectName__:__TaskName__'.
                        > A problem occurred starting process 'command '__CommandName__''
                    対処:
                        Gradle の外でコマンドを実行できるようにしてみてください
                    メモ:
                        プロセスの起動が成功して、そのプロセスがエラーを返した場合、プロセスの起動は成功したと表示されます: |
                            Successfully started process 'command 'python3''
                                :
                - #// Authentication is required
                    手順: gradle 実行時エラー
                    エラー: |
                        Authentication is required but no CredentialsProvider has been registered
                    対処:
                        git push がパスワードなしで実行できるようにします:
                            #search: ssh-agent
            OS package 関連:  #search: gradle-ospackage-plugin
    nebula-release-plugin: #keyword: nebula-release-plugin, nebula.release, com.netflix.nebula.release, RPM Git rc version  #// Git リポジトリににタグをつける？
        #ref: https://github.com/nebula-plugins/nebula-release-plugin
        _: RPM のファイル名や Git タグ に含まれるバージョン番号を自動的に更新します
        手順:
            プロジェクトをビルドします:  #search: gradlew nebula-release-plugin
            ブランチ名に使えるパターンを追加します: #keyword: nebula-release-plugin  addReleaseBranchPattern
                手順: nebula.release プラグイン を指定している .gradle ファイルに addReleaseBranchPattern メソッドを追加します
                build.gradle ファイル: |  #// nebulaRelease のブロックを追加します。下記パターンで使えるブランチ名の例は release-3.12.feature 
                    plugins {
                        id 'nebula.release' version '14.0.2'
                    }
                    nebulaRelease {
                        addReleaseBranchPattern(/(release(-|\/))?\d+(\.\d+)?\..*/)
                    }
                プロジェクトのバージョン番号には影響しません:  #search: nebula-release-plugin version number trouble
                #ref: https://github.com/nebula-plugins/nebula-release-plugin?tab=readme-ov-file#extension-provided
                #ref: https://github.com/nebula-plugins/nebula-release-plugin/issues/71
        機能, 構成:
            git タグ:  #// バージョン番号を自動的に上げて、git タグ を追加します
                できる Git タグ名: v3.12.0-rc.1 など  #// ./gradlew candidate コマンドの場合、そのコマンドでできる標準な名前と同じです
            マージ漏れチェック:  #// develop ブランチへマージし忘れた release ブランチを検出できます
        コマンド:  #keyword: nebula-release-plugin options
            サンプル: #keyword: gradlew nebula-release-plugin
                - ./gradlew :__FolderName__:buildRpm  #// develop バージョンの一部のパッケージを作ります
                - ./gradlew devSnapshot  #// develop バージョンの全てのパッケージを作ります  #search: -Prelease.scope
                - ./gradlew candidate  #// RC バージョン（rc-1など）を上げて release candidate バージョンの全てのパッケージを作ります
                - ./gradlew final  #// release バージョンの全てのパッケージを作ります
            オプション:
                -Prelease.version: #keyword:  #// バージョン番号を明示的に指定します。ただし、release バージョン (final) にしか使えません
                    サンプル: -Prelease.version=3.8.0
                    #ref: https://github.com/nebula-plugins/nebula-release-plugin#overriding-version-from-the-command-line
                    #search: nebula-release-plugin version number trouble
                -Prelease.scope: #keyword:
                    サンプル: -Prelease.scope=major
                    major: メジャーバージョンを上げます
                    minor: マイナーバージョンを上げます
                    patch: パッチバージョンを上げます
                    #search: nebula-release-plugin version number trouble
                -Pgit.root: #keyword:  #// .git があるフォルダーの指定が必要です
                    サンプル: -Pgit.root=../
                関連:
                    gradlew のオプション:  #search: gradlew options
        トラブルシューティング(nebula-release-plugin):
            - 状況を表示します:
                コマンド:
                    ./gradlew debugNebulaRelease -Pgit.root=__DotGitParentFolder__
                出力例: |
                    > Configure project :
                    Inferred project: packages, version: 4.0.0-dev.23.uncommitted+4b418b8

                    > Task :debugNebulaRelease
                    Project version: 4.0.0-dev.23.uncommitted+4b418b8
                    Nebula Release plugin found: nebula.plugin.release.ReleasePlugin
                    Nebula Release extension found
                    Release branch patterns:
                    - master
                    - HEAD
                    - main
                    - (release(-|/))?\d+(\.\d+)?\.x
                    - v?\d+\.\d+\.\d+
                    - (release(-|/))?\d+(\.\d+)?\..*
                    Current project version: 4.0.0-dev.23.uncommitted+4b418b8
                    grgit not available, cannot determine current branch

                    BUILD SUCCESSFUL in 1s
                build.gradle ファイルに必要な追加: |
                    task debugNebulaRelease {
                        doLast {
                            println "Project version: ${project.version}"
                            def plugin = project.plugins.findPlugin('com.netflix.nebula.release')
                            if (plugin) {
                                println "Nebula Release plugin found: ${plugin.class.name}"
                                
                                def extension = project.extensions.findByName('nebulaRelease')
                                if (extension) {
                                    println "Nebula Release extension found"
                                    if (extension.hasProperty('releaseBranchPatterns')) {
                                        println "Release branch patterns:"
                                        extension.releaseBranchPatterns.each { pattern ->
                                            println "  - ${pattern}"
                                        }
                                    } else {
                                        println "releaseBranchPatterns property not found in extension"
                                    }
                                } else {
                                    println "Nebula Release extension not found"
                                }

                                println "Current project version: ${project.version}"

                                if (project.hasProperty('grgit')) {
                                    println "Current branch: ${grgit.branch.current().name}"
                                } else {
                                    println "grgit not available, cannot determine current branch"
                                }
                            } else {
                                println "Nebula Release plugin not found"
                            }
                        }
                    }
            - #// 期待したバージョン番号にならない  #keyword: nebula-release-plugin version number trouble
                #search: nebula.ospackage version number
                手順: ./gradlew :__FolderName__:buildRpm など
                対処A:  #// v3.7 の rc 番号を 1 に戻したいとき
                    すでにローカルにあるけど要らない Git タグを削除します:  #search: delete git tag
                        $ git tag | grep v3.7
                        v3.7.0-rc.1
                        v3.7.0-rc.2
                        $ git tag -d  "v3.7.0-rc.2"
                        $ git tag -d  "v3.7.0-rc.1"
                対処B:  #// マイナーバージョン（2つ目の数）を上げたいとき
                    release-__Major__.__Minor__.x ブランチ を作ります:  #// dev パッケージを作るときは、一時的に作ります
                        コマンドのサンプル:
                            git checkout -b release-4.0.x  __CommitID__
                        git push しないこと:
                            ブランチを git push すると、リポジトリによってはブランチの削除または git push --force ができなくなります。
                            nebula-release-plugin は、ローカルにあるブランチから判定するので git push する必要はありません。
                            少なくとも develop ブランチにマージするまで git push しないでください。
                        ____.wip ブランチ:
                            addReleaseBranchPattern(/(release(-|\/))?\d+(\.\d+)?\..*/) にマッチする release-4.0.x.wip ブランチを作っても、
                            project.version（バージョン番号）には影響しません。
                            addReleaseBranchPattern は STG や PRD 環境にリリースできるブランチ名をチェックするためだけに使われます。
                        双方向マージした場合:
                            たとえば、release-3.9.x ブランチ と release-4.0.x ブランチ で相互マージした場合、4.0 の RPM を作りたい場合は、
                            相互マージした後のコミットに release-4.0.x ブランチを移動してください。
                    期待するバージョン番号の直前のタグを作ります:  #// 下記は v3.8.0 のパッケージを作りたい場合
                        git checkout develop
                        git tag -a  "v3.7.7"  -m "Fix the version number for nebula-release-plugin"
                        #// パッチ バージョン（3つ目の数）はデフォルトではどんな値でも構いません  #search: -Prelease.scope
                        #// ローカルに作るだけで構いません。タグをサーバーにアップロードする必要はありません  #search: git tag create
                対処C:  #// パッチ バージョン（3つ目の数値）を上げたいとき
                    ./gradlew コマンドに -Prelease.scope=patch オプションを付けます  #// 未確認
            - #// Host key verification failed.
                手順: ./gradlew :__FolderName__:buildRpm など
                エラー: |
                    org.eclipse.jgit.api.errors.TransportException: git@____.git: Host key verification failed.
                対処:
                    git@____.git に対して git fetch して、Are you sure you want to continue connecting (yes/no)? に yes と入力してください。
            - #// Branch does not match one of the included patterns: [master, HEAD, (release(-|/))?\d+(\.\d+)?\.x, v?\d+\.\d+\.\d+]
                #search: nebula-release-plugin  addReleaseBranchPattern
        参考: #ref: ${programming}/方法論/CVS/SubVersion.svg#nebula-release-plugin
    gradle-ospackage-plugin: #keyword: gradle-ospackage-plugin, nebula.ospackage, com.netflix.nebula.ospackage  #// Debian パッケージや RPM パッケージを作ります
        公式情報:  #ref: https://plugins.gradle.org/plugin/com.netflix.nebula.ospackage
        参考: #ref: ${programming}/方法論/CVS/SubVersion.svg#gradle_ospackage_plugin
        手順:
            .rpm ファイルを作ります:
                gradle-ospackage-plugin を使った .gradle ファイルを作ります:
                gradle コマンドを実行します:
                    #search: Gradle execute order basic
        ファイル:
            .gradle ファイル:
                サンプル >> make コマンド 相当: | #keyword: Gradle make  #// Go 言語 など make コマンドを実行してできた実行ファイルが入った RPM を作ります
                    plugins {
                        id 'com.netflix.nebula.ospackage' version '11.4.0'
                    }

                    ospackage {
                        packageName "myapp"
                        os LINUX
                        arch X86_64

                        version "1.0.0"
                        release 1

                        from('build/command') {
                            into "/home/user1/bin"
                            fileMode 0755
                        }
                    }

                    task buildTask(type: Exec) {
                        workingDir "src"
                        commandLine "make"
                    }

                    task copyTask(type: Copy) {
                        from "src"
                        into "build"
                        include "command"
                    }

                    copyTask.dependsOn buildTask
                    buildRpm.dependsOn copyTask
                ospackage: #keyword: ospackage task,  ospackage  #// RPM や DEB などのパッケージ
                    （参考）:  #search: buildRpm task
                    カスタマイズ:  #search: Gradle task customize
                        パッケージのメタデータを設定します: |
                            ospackage {
                                packageName = 'myapp'
                                version = '1.0.0'
                                release = '1'
                                arch = 'x86_64'
                                os = LINUX

                                summary = 'My application RPM package'
                                description = 'This package contains the binary and configuration files of myapp.'

                                license = 'Apache-2.0'
                                vendor = 'MyCompany'
                                url = 'https://mycompany.com/myapp'
                            }
                        パッケージに含めるファイルやディレクトリを指定します: |
                            ospackage {
                                from("${projectDir}/build/slog") {
                                    into '/usr/local/bin'
                                    fileMode 0755  // 実行権限
                                }
                                from("${projectDir}/config") {
                                    into '/etc/myapp'
                                    fileMode 0644  // 読み取り専用
                                    dirMode 0755  // ディレクトリの権限
                                    user 'root'
                                    group 'root'
                                }
                            }
                        パッケージの依存関係を設定します: |
                            ospackage {
                                requires 'java-1.8.0-openjdk'
                                requires 'bash'
                            }
                        スクリプトを設定します: |
                            ospackage {
                                preInstall file('scripts/preInstall.sh')  // インストール前のスクリプト
                                postInstall file('scripts/postInstall.sh')  // インストール後のスクリプト
                                preUninstall file('scripts/preUninstall.sh')  // アンインストール前のスクリプト
                                postUninstall file('scripts/postUninstall.sh')  // アンインストール後のスクリプト
                            }
                buildRpm: #keyword: buildRpm task, buildRpm, buildscript, buildDeb  #// ospackage の RPM 固有部分。ospackage の設定より優先されます
                    概要: |
                        buildRpm タスクは自動的に定義されます。 nebula/gradle-ospackage を apply すると、自動的に buildRpm タスクが作られます。
                        buildRpm タスクは ospackage の設定を全部引き継ぎます。
                        下記サンプルのように configure することができます。 #search: Gradle DSL
                    サンプル: |
                        buildRpm {      // #search: Gradle task configuration block
                            addParentDirs false  // RPM パッケージに親フォルダーを含まないようにします
                            directory(__Path__)  // RPM パッケージに含めるフォルダーを指定します。__Path__の例＝"${packagePrefix}/etc"
                        }
                        buildRpm.dependsOn __TaskName__  // 依存関係を設定します。指定したタスクが先に実行されます
                    task キーワードの有無:  #search: Gradle DSL
                    サンプル2:
                        自作:
                            詳細:  #ref: ${typrm_files}/ref/Git-AI.yaml#label: Gradle code
                            .gradle ファイルの読み方:  #search: Gradle code
                        公式:  #ref: https://github.com/nebula-plugins/gradle-ospackage-plugin/wiki/Usage-Example
                    カスタマイズ:  #search: Gradle task customize
                        パッケージに含めるファイルやディレクトリを追加します: |
                            buildRpm {
                                from("${goSourceDir}/build/slog") {
                                    into '/usr/local/bin'  // バイナリファイルを配置
                                    fileMode 0755  // 実行権限
                                }
                                from("${projectDir}/config") {
                                    into '/etc/myapp'  // 設定ファイルを配置
                                    fileMode 0644  // 読み取り専用
                                    user 'root'
                                    group 'root'
                                }
                            }
                        パッケージのメタデータを上書き設定します: |  #// ospackage と同じ項目を変更できます
                            buildRpm {
                                packageName = 'myapp'
                                version = '1.2.0'
                                release = '1'
                                arch = 'x86_64'
                                os = LINUX

                                summary = 'My application RPM package'
                                description = 'This package contains my application binary and configuration files.'

                                license = 'Apache-2.0'
                                vendor = 'MyCompany'
                                url = 'https://mycompany.com/myapp'
                            }
                        スクリプトを上書き設定します: |
                            buildRpm {
                                preInstall = file('scripts/preInstall.sh')  // インストール前のスクリプト
                                postInstall = file('scripts/postInstall.sh')  // インストール後のスクリプト
                                preUninstall = file('scripts/preUninstall.sh')  // アンインストール前のスクリプト
                                postUninstall = file('scripts/postUninstall.sh')  // アンインストール後のスクリプト
                            }
                        パッケージの依存関係を追加設定します: |
                            ospackage {
                                requires 'java-1.8.0-openjdk'
                                requires 'bash'
                            }
                        buildRpm 相当の新規タスクを追加します: |  #// buildRpm タスク をカスタマイズする代わりに、独自のタスクを作成してカスタマイズします
                            task customRpm(type: Rpm) {
                                packageName = 'mycustomapp'
                                version = '2.0.0'
                                
                                from("${projectDir}/build/slog") {
                                    into '/usr/local/bin'
                                    fileMode 0755
                                }

                                from("${projectDir}/config") {
                                    into '/etc/mycustomapp'
                                    fileMode 0644
                                }
                            }
            RPM ファイル名: #keyword: nebula.ospackage RPM file name  #ref: ${typrm_files}/ref/Git-AI.yaml#label: Gradle RPM file name
                書式: |
                    [packageName]-[version]-[release].[arch].rpm
                バージョン番号の決定方法: #keyword: nebula.ospackage version number,  Gradle RPM version number
                    #search: セマンティック バージョニング
                    #search: nebula-release-plugin version number trouble
                    エラーメッセージ:  #// 不具合対応のヒント
                        基本: |  #focus: Invalid branch
                            * What went wrong:
                            A problem occurred evaluating root project 'packages'.
                            > Invalid branch (release-4.1.x) for nearest normal (3.11.0).
                        コマンドを含むサンプル: | #keyword: nebula-release-plugin error sample  #focus: Invalid branch, describe HEAD
                            Successfully started process 'command 'git''
                            Using development default strategy because repo is clean and no stage defined
                            Falling back to default strategy: development
                            Beginning version inference using development strategy and input scope (null) and stage (dev)
                            Starting process 'command 'git''. Working directory: /home/user1/system/packages Command: git --git-dir=/home/user1/system/packages/../.git --work-tree=/home/user1/system/packages/.. describe HEAD --tags --long --match v* --exclude *-rc.*
                            Successfully started process 'command 'git''
                            Starting process 'command 'git''. Working directory: /home/user1/system/packages Command: git --git-dir=/home/user1/system/packages/../.git --work-tree=/home/user1/system/packages/.. rev-list -n 1 v3.11.0
                            Successfully started process 'command 'git''
                            Starting process 'command 'git''. Working directory: /home/user1/system/packages Command: git --git-dir=/home/user1/system/packages/../.git --work-tree=/home/user1/system/packages/.. tag --points-at 2e055398d43230d6dee1f3c6911bccfbf79b0dfd
                            Successfully started process 'command 'git''
                            Starting process 'command 'git''. Working directory: /home/user1/system/packages Command: git --git-dir=/home/user1/system/packages/../.git --work-tree=/home/user1/system/packages/.. describe HEAD --tags --long --match v*
                            Successfully started process 'command 'git''
                            Starting process 'command 'git''. Working directory: /home/user1/system/packages Command: git --git-dir=/home/user1/system/packages/../.git --work-tree=/home/user1/system/packages/.. rev-list -n 1 v4.1.0-rc.2
                            Successfully started process 'command 'git''
                            Starting process 'command 'git''. Working directory: /home/user1/system/packages Command: git --git-dir=/home/user1/system/packages/../.git --work-tree=/home/user1/system/packages/.. tag --points-at 2ae48429ab1eb5c66260f0e49a5e82746eaa0ca3
                            Successfully started process 'command 'git''
                            Starting process 'command 'git''. Working directory: /home/user1/system/packages Command: git --git-dir=/home/user1/system/packages/../.git --work-tree=/home/user1/system/packages/.. rev-parse HEAD
                            Successfully started process 'command 'git''

                            FAILURE: Build failed with an exception.

                            * Where:
                            Build file '/home/user1/system/packages/build.gradle' line: 25

                            * What went wrong:
                            A problem occurred evaluating root project 'packages'.
                            > Invalid branch (release-4.1.x) for nearest normal (3.11.0).
                    バージョンを上げる場合:  #// バージョン番号をインクリメントする場合
                        -   nebula.ospackage プラグイン は Git のタグを利用してバージョン番号を決定することができます
                        -   バージョン番号を変えたいときは、git tag コマンドでタグを追加します
                        -   _:
                                PRD リリースした後で、rc が付いていない git tag（例 v4.1.0）が無ければ、追加してから gradlew を実行します
                                    #search: nebula-release-plugin error sample
                            コマンドのサンプル: |
                                git tag | grep v4\.0    #// 一覧
                                git tag -a  "v4.0.0"  -m "v4.0.0"  "v4.0.0-rc.6"   #// 最新 rc と同じコミットに rc なし git tag を付ける
                                git push origin  "v4.0.0"  #// タグのアップロード
                                git checkout release-4.1.x
                                gradlew _____
                                #// v4.1.0 ができます
                            パッチバージョンを上げる場合:  #search: セマンティック バージョニング
                                タグ v4.0.0 があり、release-4.0.x ブランチで gradlew を実行すると、
                                v4.0.1 ができます。
                    メジャー バージョン アップ する場合: #keyword: nebula.ospackage major version up
                        ブランチ release-4.0.x を作ります:    #template: release-__VersionMM__.x
                            dev:
                                -   カレント ブランチ を release-4.0.x ブランチにします    #template: release-__VersionMM__.x
                                        #// release ブランチの最新コミットを含む別の名前のブランチが カレント ブランチ のときはうまくいきません
                                -   release ブランチは、まだ git push しないこと
                                        #search: nebula-release-plugin version number trouble
                            rc 以降:
                                -   エラー Execution failed for task ':releaseCheck' が出るときは、ブランチ名を addReleaseBranchPattern のパターン制約を満たすようにします。
                            #search: nebula-release-plugin
                        #// （以下は不要か？）
                        タグ v4.0.0-rc.1 を作ります:  #search: git tag add
                            （初回）タグを作ります:
                                -   git tag -a  "v4.0.0-rc.1"  -m "__Comment__"  "__CommitID__"  #// __CommitID__ は省略できます
                                        #template: git tag -a  "__TagName__"  -m "__Comment__"  "__CommitID__"
                                -   git push origin  "v4.0.0-rc.1"  #// git push だけ（パラメーターなし）ではサーバーに反映されません
                                        #template: git push origin  "__TagName__"
                            （2回目以降）タグを移動します:
                                #// コミットを追加したらタグをそのコミットに移動しないと gradle はエラーになります
                                -   git tag -d  "v4.0.0-rc.1"
                                -   git push origin :refs/tags/v4.0.0-rc.1
                                -   git tag -a  "v4.0.0-rc.1"  -m "__Comment__"
                                -   git push origin  "v4.0.0-rc.1"
                                    #template-at(-4): git tag -d  "__TagName__"
                                    #template-at(-4): refs/tags/__TagName__
                                    #template-at(-4): git tag -a  "__TagName__"
                        バージョンを上げないでビルドします:
                            ./gradlew candidate -i -Pgit.root=../ -Prelease.useLastTag=true  #search: nebula.ospackage -Prelease.useLastTag
                        設定: #settings:
                            __TagName__: v4.0.0-rc.1
                            __VersionMM__: 4.0
                        ボツ案:
                            -Pversion:
                                -Pver./gradlew buildRpm -Pversion=2.0.0 を指定しても
                                ospackage {
                                    version = project.version /
                                を書かないと動かないようです。副作用は未調査
                    バージョンを上げない場合: #keyword: nebula.ospackage -Prelease.useLastTag  #// バージョン番号をインクリメントしない場合
                        DEV 環境用の場合:  #// 未確認
                            Git タグを付けます:
                                v3.0.0-rc.0
                                #// nebula.ospackage は、現在(HEAD)のコミットに付けられたローカルにある Git タグを参照します
                            コマンド:  #// バージョン番号がファイル名に付いた RPM を作ります
                                ./gradlew ____ -Prelease.useLastTag=true
                            できるタグとファイル名:
                                #//  __GitTag__: __RPM_FileName__
                                （タグは追加されません）  #// example-3.0.0~dev.1-1111111.noarch.rpm
                        STG 環境用の場合:
                            Git タグを付けます:
                                v3.0.0-rc.1
                            コマンド:  #// バージョン番号がファイル名に付いた RPM を作ります
                                ./gradlew candidate ____  #// -Prelease.useLastTag=true は効果がありません


                            できるタグとファイル名:
                                #//  __GitTag__: __RPM_FileName__
                                v3.0.0-rc.1   #// example-3.0.0~rc.1-1.noarch.rpm
                    並行する場合:  #// 2つ以上の メジャー バージョン などを平行して開発する場合
                        #// 未確認
                        -   このプラグインはGitのタグに基づいて自動的にバージョン番号をインクリメントするため、
                            ブランチごとに異なるタグを使用することで、4.x系と5.x系を平行して管理することができます
                    release 番号を変える場合: #keyword: gradle release number,  gradle build number
                        ____.groovy: |
                            ospackage {
                                release = System.getenv('BUILD_NUMBER') ?: '1'
                        .rpm ファイルを作るコマンド:
                            BUILD_NUMBER=2  ./gradlew final -i -Pgit.root=../
        トラブルシューティング(ospackage):
            - バージョン番号の決定方法:  #search: nebula.ospackage version number
                エラーメッセージに含まれる git コマンド:  #search: nebula-release-plugin error sample
            - #// Cannot add task 'buildRpm' as a task with that name already exists.
                手順: ./gradlew :__FolderName__:buildRpm など
                エラー: |
                    * What went wrong:
                    Cannot add task 'buildRpm' as a task with that name already exists.
                対処A:
                    別の名前に変えます
                対処B:
                    既存のタスクにカスタマイズを追加します
            - #// できる RPM ファイル名にバージョン番号が付かない  #keyword: Gradle RPM version file name
                手順: ./gradlew :__FolderName__:buildRpm など
                エラー: なし
                状況: できる RPM ファイル名にバージョン番号が付かない
                対処:
                    ospackage のバージョンを上げます: |
                        plugins {
                            id 'nebula.ospackage' version '6.2.0'
Jenkins:  #keyword:
    #snote: Jenkins
    手順:
        ノードのインストール:  #search: install Jenkins node
        プロジェクトの新規作成: #keyword: new Jenkins project
            既存のプロジェクトをコピーする場合:
                メニュー: ダッシュボード（ルート） >> 新規ジョブ作成（左上）
                アイテム名: （新しいプロジェクト名）
                Copy from: （既存のプロジェクト名）
                OK ボタン:
            ノードを変更する場合: #keyword: Jenkins change node  #// プロジェクトのジョブを実行するサーバーを設定します
                プロジェクトのページ >> 設定 >> General タブ >> 実行するノードを制限（最も下)
        周期実行の書式: #search: cron
    画面:
        ダッシュボード: #keyword: Jenkins dashboard  #// Jenkins マスター がインストールされたサーバーにブラウザーでアクセスします。コンソール
            プロジェクトのページ:  #ref: https://jenkins.____/job/__ProjectName___/
                ビルド実行: #keyword: Jenkins ビルド実行
                設定:
                    ビルド タブ:  #// （Jenkins プロジェクトのページ）>> 設定 >> ビルド タブ
            ノードのページ:  #ref: https://jenkins.____/computer/__AgentName___/
    概念:
        （構成）:
            Jenkins マスター:  #// Jenkins メイン サーバー。ビルドジョブの設定、ジョブのスケジューリング、ユーザーインターフェース、APIの提供など
                Jenkins ノード:  #search: Jenkins node  #// エージェント。 Jenkins サブ サーバー。ジョブの処理を行います
                    プロジェクト:  #// Jenkins が処理する設定の集まりの基本単位
                        ジョブ:  #// プロジェクトの中の処理単位
                            ワークスペース:  #search: Jenkins workspace  #// ジョブの実行を開始するときの カレント フォルダー
                            成果物:  #search: Jenkins 成果物
                    プラグイン:  #search: Jenkins plug in
        Jenkins マスター:  #// Jenkins メイン サーバー。ビルドジョブの設定、ジョブのスケジューリング、ユーザーインターフェース、APIの提供など
            ダッシュボード: #search: Jenkins dashboard
        Jenkins ノード: #keyword: Jenkins node,  Jenkins agent slave  #// Jenkins サブ サーバー。ジョブの処理を行います
            URL: https://jenkins.____/computer/__AgentName___/
            インストール: #keyword: install Jenkins node  #ref: https://qiita.com/yasuhiroki/items/d618796a1ba1366c4f80
            実行するプロジェクト:
                参照:  #search: https://jenkins.____/computer/__AgentName___/
                変更:  #search: Jenkins change node
        プロジェクト: #keyword: Jenkins project
            URL: https://jenkins.____/job/__ProjectName___/
            新規作成:  #search: new Jenkins project
            プロジェクト連携:  #search: Jenkins next project
        ワークスペース: #keyword: Jenkins workspace, Jenkins current directory, Jenkins current folder
            #// Jenkins ノード がジョブ（シェル コマンド）の実行を開始するときの カレント フォルダー
            初期設定値: /var/lib/jenkins/workspace (=$HOME/workspace)  #keyword: /var/lib/jenkins/workspace
            ビルド履歴から:
                メニュー: Jenkins >>（ビルド履歴のどれか：左下）>> コンソール出力
                メッセージ: Building remotely on __Host__ in workspace __CurrentFolder__
        成果物: #keyword: Jenkins 成果物  #// 他のプロジェクトの成果物を現在のプロジェクトへコピーできます
            コピーするように設定します:
                成果物を作るプロジェクトの設定:
                    メニュー: Jenkins コンソール >> 設定（左）>> ビルド後の処理 タブ >> 成果物を保存
                    保存するファイル: （ファイル名）
                    プロジェクト連携: #keyword: Jenkins next project  #// ビルド後にビルドする他のプロジェクトを設定します
                        先行するプロジェクトに設定する場合:  #// 通常こちら
                            メニュー: 設定 >> ビルド後の処理 タブ >> 他のプロジェクトのビルド
                            対象プロジェクト: （プロジェクト名、コンマ区切り）
                        ビルド後のプロジェクトに設定する場合:  #// あまり使われません
                            パラメータ付きビルドのトリガー:
                ビルド後のプロジェクトの設定:
                    メニュー: Jenkins コンソール >> 設定（左）>> ビルド タブ >> 他プロジェクトから成果物をコピー
                    プロジェクト: （コピー元のプロジェクト）
                    ビルド: 最新の成功ビルド（など）
                    コピーする成果物: （ファイル名）
        環境変数 >> GIT_BRANCH:
            - ${GIT_BRANCH} #// ビルドのスクリプトで参照できます
            - branch_name=$(basename $GIT_BRANCH)
        プラグイン: #keyword: Jenkins plug in  #ref: https://plugins.jenkins.io/
            RabbitMQ プラグイン: #keyword: RabbitMQ plug in
                #ref: https://plugins.jenkins.io/rabbitmq-consumer/
コンパイラー コンパイラー プログラミング言語:  #keyword:
    コンパイラー・インタープリターの開発言語:
        V8(JavaScript, Node.js): C++  #ref: https://github.com/v8/v8
        TypeScript: TypeScript  #ref: https://github.com/microsoft/TypeScript…
        Python: Python, C  #ref: https://github.com/python/cpython
        Ruby: Ruby, C  #ref: https://github.com/ruby/ruby
        Go: Go  #ref: https://github.com/golang/go
    同じ言語の最新版で作られているコンパイラー（インタープリター）を作る仕組み:
        1. 以前作ったコンパイラーインスタンスで作ったインスタンス
        2. そのインスタンスでコンパイルして作ったインスタンス
        3. その…
        …
        を繰り返して最終的にはコンパイルを実行するインスタンスと同じクラスのインスタンスができる
    yacc: #keyword:  #// パーサージェネレーター
トラブルシューティング:
    - #// error: RPC failed; HTTP 400 curl 22 The requested URL returned error: 400
        手順: git push
        ログ: |
            Enumerating objects: 13, done.
            Counting objects: 100% (13/13), done.
            Delta compression using up to 8 threads
            Compressing objects: 100% (9/9), done.
            error: RPC failed; HTTP 400 curl 22 The requested URL returned error: 400
            send-pack: unexpected disconnect while reading sideband packet
            Writing objects: 100% (9/9), 3.30 MiB | 5.46 MiB/s, done.
            Total 9 (delta 3), reused 0 (delta 0), pack-reused 0
            fatal: the remote end hung up unexpectedly
            Everything up-to-date
        対処:
            postBuffer を増やします:
                - git config --local  http.postBuffer  #// 何も表示されなければデフォルトの 2MiB
                - git config --local  http.postBuffer  12340000   #// 約10MB に設定
                - git config --local  http.postBuffer  524288000  #// 約 500MB に設定
    - #// ブランチの削除が拒否されたけど削除したいとき
        対処: ブランチ名を変えてから削除します  #search: rename Git branch
    - #// HEAD が ブランチと関連付かない  #keyword: Git HEAD branch
        手順: git clone
        状況:
            gitlog を実行すると:
                期待：(HEAD -> master, origin/master, origin/HEAD)
                実際：(HEAD, origin/master, origin/HEAD, master)
            git commit すると:
                期待：
                    (HEAD -> master)
                    (origin/master, origin/HEAD)
                実際：
                    (HEAD)
                    (origin/master, origin/HEAD, master)
        原因:
            git version 1.8.3.1 で発生？
        対処:
            最新の Git がある VM で実行するか、最新の Git に更新します
    - #// シンボリックリンクがリポジトリに入っていて削除または復帰できない  #keyword: Git remove symbolic link
        手順: GitHub で見るとフォルダーのアイコンに矢印が付いている。.gitignore で指定されたように git コマンドが無視されるフォルダー
        対処:
            git rm コマンドで削除します:
                - git status  #// clean 状態であること
                - git rm __PathToSymbolicLink__
                - git add __PathToNotSymbolicLink__  #// 存在するフォルダーに置き換える場合（未確認）
                - git commit -m "Removed a symbolic link."
                - git push
    - #// '__Branch__' could be both a local file and a tracking branch.
        手順: git checkout __Branch__
        エラー: |
            fatal: '__Branch__' could be both a local file and a tracking branch.
            Please use -- (and optionally --no-guess) to disambiguate
        原因:
            ブランチ名とフォイル名またはフォルダー名と衝突しています
        対処:
            ブランチを切り替える場合:
                git checkout __Branch__ --
            ファイルを戻す場合:
                git checkout -- __FileName__
    - #// 過去の操作を調べる  #search: git reflog  #// コミットが消えた？と思ったとき
    - #// 削除したファイルを復元する。ファイルが消えた？と思ったとき
        対処:
            ファイル名が分かっている場合:
                git log --full-history -- __FilePath__
                git checkout __CommitID__
            git log に残っていない場合:  #// ファイル名が分かっていても見つからない場合
                GitHub で見たときにファイルが入っているフォルダーがリンクになっている場合:
                    リンクを削除してコミットします:
                    git add してコミットします:
                        どこかのクライアントにのみあるはずです
    #// エラーメッセージ別
    - #// The namespace you were looking for could not be found.
        手順: git fetch
        ログ: |
            debug1: Authentication succeeded (publickey).
            Authenticated to github.com
            ///
            debug1: Sending command: git-upload-pack 'user/projconfig/.git'
            remote: 
            remote: ========================================================================
            remote: 
            remote: The namespace you were looking for could not be found.
            remote: 
            remote: ========================================================================
            remote: 
            debug1: client_input_channel_req: channel 0 rtype exit-status reply 0
            debug1: client_input_channel_req: channel 0 rtype eow@openssh.com reply 0
            debug1: channel 0: free: client-session, nchannels 1
        対処:
            LDAP のパスワードを変えた場合:
                git clone からやり直します
    - #// warning: in the working copy of '__FilePath__', LF will be replaced by CRLF the next time Git touches it
        手順: git add "."
        ログ: |
            warning: in the working copy of 'README.md', LF will be replaced by CRLF the next time Git touches it
            warning: in the working copy of '.gitattributes', LF will be replaced by CRLF the next time Git touches it
        対処:  #// 不明
            git config core.autoCRLF しても効果なし。 --global --local を付けても。
    - #// error: src refspec master does not match any. failed to push some refs to 'https:...
        手順: git push
        エラー: |
            error: src refspec master does not match any
            error: failed to push some refs to 'https:...
        対処:
            .git フォルダーを作り直してください
            #search: git clone .git
    - #// git clone error: RPC failed; result=22, HTTP code = 422  fatal: The remote end hung up unexpectedly
        手順: git clone
        エラー: |
            error: RPC failed; result=22, HTTP code = 422
            fatal: The remote end hung up unexpectedly
        対処A:
            git 1.8.3.1 の場合、URL の最後に .git を追加します
        対処B:
            git を最新バージョンにします
        対処C:
            別の VM やローカルで git clone して、対象の VM に転送します
    - #// README.md に埋め込んだ画像がプレビュー表示されない。 Relative image URLs require a repository with HTTPS protocol to be specified in the package.json
        手順: README.md に画像を埋め込む
        エラー: |
            Relative image URLs require a repository with HTTPS protocol to be specified in the package.json
        対処:
            _: GitHub で画像を表示する場合、URL のベースを指定する必要があります。
            package.json : |
                {
                    "repository": {
                        "type": "git",
                        "url": "https://github.com/your-username/your-repository.git"
    - #// warning: remote HEAD refers to nonexistent ref, unable to checkout.
        手順: git clone
        エラー: |
            warning: remote HEAD refers to nonexistent ref, unable to checkout.
        対処:
            リポジトリにデフォルトのブランチを設定します:
                Git 2.28 以降:
                    git init --bare --shared=true --initial-branch=mybranch
                全バージョン:
                    cd  __GitRepository__
                    git symbolic-ref HEAD refs/heads/__Branch__
    - #// fatal: ambiguous argument 'HEAD^': unknown revision or path not in the working tree.
        手順: git reset --soft HEAD^
        エラー: |
            fatal: ambiguous argument 'HEAD^': unknown revision or path not in the working tree.
            Use '--' to separate paths from revisions, like this:
            'git <command> [<revision>...] -- [<file>...]'
        対処:
            指定したコミットが存在しません。 #serach: HEAD^
    - #// error: src refspec master does not match any
        手順: git push --set-upstream origin "__Branch__"
        エラー: |
            error: src refspec master does not match any
            error: failed to push some refs to '____'
        対処:
            __Branch__ を修正してください。
            git branch コマンド（パラメーターなし）で表示されるブランチ名を指定できます。
    - #// fatal: in unpopulated submodule 'locommit'
        手順: git add  "."
        エラー: |
            fatal: in unpopulated submodule 'locommit'
        対処:
            __Sub__/.git があるときに git init して __Sub__/.git を削除すると __Sub__ で git add すると発生します。
            .git を削除して __Sub__/.git を削除してから git init してください。
    - #// ローカル ブランチ と同じ名前の リモート ブランチ が枝分かれしてしまったとき
        手順: "git branch -D __BranchName__"
        状況: |
            *   081db70  (origin/tmp, tmp)
            |\  
            | * 8827530  (HEAD -> __BranchName__)
            * | c451ea8  (origin/__BranchName__, origin/HEAD)
            |/  
            * 3cd0238
        エラー: |
            error: Cannot delete branch '__BranchName__' checked out at '____'
                #// または
            fatal: It seems that there is already a rebase-merge directory, and
            I wonder if you are in the middle of another rebase.  If that is the case, please try
                    git rebase (--continue | --abort | --skip)
            If that is not the case, please
                    rm -fr ".git/rebase-merge"
            and run me again.  I am stopping in case you still have something valuable there.
        対処: |
            git fetch
            git checkout __BranchName__
            git rebase origin/__BranchName__
            コンフリクトが発生したら
                git add ____
                リベースを完了させるには git rebase --continue を実行します。
                リベースをキャンセルする場合は、git rebase --abort を実行します。
            git push --force-with-lease
        --force-with-lease:
            リモートリポジトリに他のユーザーによる変更がない場合に限り、強制的にプッシュ
    - #// CONFLICT (modify/delete)
        手順: git merge  __OtherBranch__  --no-edit  > /dev/null
        エラー: |
            CONFLICT (modify/delete): __FilePath__ deleted in HEAD and modified in __OtherBranch__. Version __OtherBranch__ of __FilePath__ left in tree.
            Automatic merge failed; fix conflicts and then commit the result.
        状況:
            片方のブランチで編集があり、もう片方のブランチで削除がありました
    - #// error: The following untracked working tree files would be overwritten by merge
        手順: git merge  __OtherBranch__  --no-edit  > /dev/null
        エラー: |
            error: The following untracked working tree files would be overwritten by merge:
                __FilePath__
            Please move or remove them before you merge.
            Aborting
        状況:
            ワーキング フォルダー の .gitignore にパスが追加されたとき、
            .gitignore に追加される前のコミットをマージしようとすると発生します。
        対処A:
            __OtherBranch__ の .gitignore を更新してからマージします
        対処B:
            __FilePath__ のファイルを一時的に（__FilePath___ours などに）改名して、
            git merge を再実行し、
            __FilePath__ のファイルを手動でマージします。
    - #// fatal: cannot create directory at '__Build__': 許可がありません  #keyword: git checkout cannot create directory
        手順: git checkout __Branch__
        エラー: |
            fatal: cannot create directory at '__Build__': 許可がありません
        対処:
            Docker コンテナーが作ったフォルダーが root などの場合:
                #search: Docker volume permission
    - #// error: Your local changes to the following files would be overwritten by checkout:
        手順:
            git checkout __Branch__ でファイルの変更が拒否された後の git checkout __Branch__
        エラー: |
            error: Your local changes to the following files would be overwritten by checkout:
                    __FilePath__
            Please commit your changes or stash them before you switch branches.
            Aborting
        対処:
            git checkout "."  #// 一部変更されたファイルを元に戻します
    - #// error: The following untracked working tree files would be overwritten by checkout:
        手順:
            git checkout __Branch__ でファイルの変更が拒否された後の git checkout __Branch__
        エラー: |
            error: The following untracked working tree files would be overwritten by checkout:
                    __FilePath__
            Please move or remove them before you switch branches.
            Aborting
        対処:
            - git status で表示された Untracked なファイルをバックアップして削除します  #// 一部追加されたファイルを削除します
            - git checkout __Branch__
            - バックアップと比較します
    - #// fatal: in unpopulated submodule 'test/_testing'
        手順: git add test/_testing
        エラー: |
            fatal: in unpopulated submodule 'test/_testing'
        対処:
            #// 未確認
            cd test
            git rm --cached -rf _testing  #// _testing は削除されるかもしれません（未確認）
    - #// error: Your local changes to the following files would be overwritten by checkout:
        手順: git checkout __BranchName__
        エラー: |
            error: Your local changes to the following files would be overwritten by checkout:
                    __File__
            Please commit your changes or stash them before you switch branches.
            Aborting
        対処:
            戻します: #search: git reset --hard
    - #// 同じ名前のブランチがローカルとサーバーで枝分かれした
        手順: git push
        エラー: |
            ! [rejected]        master -> master (non-fast-forward)
            error: failed to push some refs to 'https://github.com/____/____.git'
            hint: Updates were rejected because the tip of your current branch is behind
            hint: its remote counterpart. Integrate the remote changes (e.g.
            hint: 'git pull ...') before pushing again.
            hint: See the 'Note about fast-forwards' in 'git push --help' for details.
        状況: |  #// gitlog
            * 1111111  (HEAD -> master)
            | * 2222222  (origin/master, origin/HEAD)
            |/
            * 3333333
        対処A:
            git rebase origin/master  #template__: git rebase origin/__Branch__
        対処?A:
            コンフリクトを解消します:
                git add "."
                git commit -m "_______"
        対処?B:
            マージします:
                git merge origin/master --no-edit
    - #// unable to delete '__Branch__': remote ref does not exist
        手順: git push  --delete origin __Branch__
        エラー: |
            error: unable to delete '__Branch__': remote ref does not exist
            error: failed to push some refs to 'https://github.com/Takakiriy/typrm'
        対処:
            リモートに存在しなくなったリモート追跡ブランチを削除します  #search: git fetch -p
    - #// git config --global user.name "Your Name" が要求される
        手順: git commit
        警告: |
            [__Branch__ __CommitID__] __CommitMessage__
            Committer: __UserName__ <__UserEMail__>
            on your username and hostname. Please check that they are accurate.
            You can suppress this message by setting them explicitly:
                git config --global user.name "Your Name"
                git config --global user.email you@example.com
            After doing this, you may fix the identity used for this commit with:
                git commit --amend --reset-author
        原因:
            git config user.name や git config user.email が前回のコミットから変わったため
        対処:
            カレント フォルダー のパスを確認します:
                user.name などを変更すべきでないフォルダーで変更してしまったかもしれないため
            user.name 等を戻す場合:
                git config --local user.name "Your Name"
                git config --local user.email you@example.com
            user.name 等の変更を確定する場合:
                git commit --amend --reset-author
    - #// fatal: Need to specify how to reconcile divergent branches
        手順: git commit してから git pull
        エラー: |
            hint: You have divergent branches and need to specify how to reconcile them.
            hint: You can do so by running one of the following commands sometime before
            hint: your next pull:
            hint: 
            hint:   git config pull.rebase false  # merge
            hint:   git config pull.rebase true   # rebase
            hint:   git config pull.ff only       # fast-forward only
            hint: 
            hint: You can replace "git config" with "git config --global" to set a default
            hint: preference for all repositories. You can also pass --rebase, --no-rebase,
            hint: or --ff-only on the command line to override the configured default per
            hint: invocation.
            fatal: Need to specify how to reconcile divergent branches
        対処:
            - git reset --soft HEAD^  #search: git commit cancel
            - git stash
            - git pull
            - git stash pop
            - #// git add  commit, push
    - #// git-lfs filter-process: git-lfs: コマンドが見つかりません
        手順: git pull
        エラー: |
            git-lfs filter-process: git-lfs: コマンドが見つかりません
        対処:
            sudo yum install git-lfs -y
    - #// too many levels of symbolic links シンボリックリンクの階層が多すぎます  #keyword: Too many levels of symbolic links
        手順: git add "."
        エラー: |
            warning: unable to access '__LinkPath__.gitignore': シンボリックリンクの階層が多すぎます
        対処A:
            無視します
        対処B:
            シンボリック リンク ではなくファイルの実体（コピー）に置き換えます
                #search: symbolic link copy
        原因:
            git 2.32 から .gitignore などの特殊ファイルが シンボリック リンク にできなくなります。
            この方針には反発もあります。
            https://tweakers.net/downloads/56286/git-232.html
        公式見解:
            https://github.com/git/git/blob/master/Documentation/RelNotes/2.32.0.txt
            「.gitattributes」、「.gitignore」、「.mailmap」のシンボリックリンクは、
            オブジェクトストアから使用できるはずなので、意味がありません
            （HEAD：.mailmapなどが使用されているベアリポジトリを考えてみてください）。 
            これらのファイルがシンボリックリンクである場合、
            以前はそれらが指すファイルの内容を誤って読み取っていましたが、これは修正されています。
    - #// HEAD detached at __BranchName__
        手順: git branch
        エラー: |
            * (HEAD detached at __BranchName__)
        対処:
            git checkout __BranchName__
    - #// Pull request creation failed. Validation failed: You can't perform that action at this time.
        手順: Create pull request ボタン
        エラー: |
            Pull request creation failed. Validation failed: You can't perform that action at this time.
        対処:
            コメントを入力してください
    - #// Missing or invalid credentials.
        手順: VSCode の Git bash で git push
        エラー: |
            Missing or invalid credentials.
            Error: connect ECONNREFUSED /run/user/1000/vscode-git-0e5b645d73.sock
        対処:
            VSCode のウィンドウを開きなおします
    - #// Protected branch update failed
        手順: git merge
        エラー: |
            remote: error: GH006: Protected branch update failed for refs/heads/main.
            remote: error: Changes have been requested.
        原因: GitHub の設定によってマージ先が保護されたブランチ
        対処: 
            pull request の承認が必要です
    - #// Git bash RAM ドライブ
        手順:
        エラー: |
            $ npm test

            > TypeScript@0.0.1 test C:\Users\user1\Desktop\VSCode
            > jest --watchAll

            Error: Cannot find module 'C:\Users\user1\Desktop\VSCode'
            Require stack:
            - R:\home\mem_cache\MyDoc\src\TypeScript\node_modules\jest-config\build\readConfigFileAndSetRootDir.js
            - R:\home\mem_cache\MyDoc\src\TypeScript\node_modules\jest-config\build\index.js
            - R:\home\mem_cache\MyDoc\src\TypeScript\node_modules\jest\node_modules\jest-cli\build\cli\index.js
            - R:\home\mem_cache\MyDoc\src\TypeScript\node_modules\jest\node_modules\jest-cli\bin\jest.js
            - R:\home\mem_cache\MyDoc\src\TypeScript\node_modules\jest\bin\jest.js
                at Function.Module._resolveFilename (internal/modules/cjs/loader.js:965:15)
                at Function.Module._load (internal/modules/cjs/loader.js:841:27)
                at Module.require (internal/modules/cjs/loader.js:1025:19)
                at require (internal/modules/cjs/helpers.js:72:18)
                at readConfigFileAndSetRootDir (R:\home\mem_cache\MyDoc\src\TypeScript\node_modules\jest-config\build\readConfigFileAndSetRootDir.js:119:22)
                at readConfig (R:\home\mem_cache\MyDoc\src\TypeScript\node_modules\jest-config\build\index.js:217:65)
                at readConfigs (R:\home\mem_cache\MyDoc\src\TypeScript\node_modules\jest-config\build\index.js:406:32)
                at runCLI (R:\home\mem_cache\MyDoc\src\TypeScript\node_modules\@jest\core\build\cli\index.js:231:29)
                at Object.run (R:\home\mem_cache\MyDoc\src\TypeScript\node_modules\jest\node_modules\jest-cli\build\cli\index.js:163:62)
                at Object.<anonymous> (R:\home\mem_cache\MyDoc\src\TypeScript\node_modules\jest\node_modules\jest-cli\bin\jest.js:16:27)
            npm ERR! Test failed.  See above for more details.
        対処:
            RAM ドライブを使わない
    - #// Sorry, this pull request couldn’t be reverted automatically. It may have already been reverted, or the content may have changed since it was merged.
        手順: GitHub でプルリクエストの画面で revert ボタン  #search: GitHub revert steps
        エラー: |
            Sorry, this pull request couldn’t be reverted automatically. It may have already been reverted, or the content may have changed since it was merged.
        対処A:
            複数のマージをリバートする場合、新しいマージからリバートします
        対処B:
            ローカルでリバートして GitHub に反映させます  #search: GitHub local revert
    - #// fatal: '__BranchName__' could be both a local file and a tracking branch.
        手順: git checkout __BranchName__
        エラー: |
            fatal: '__BranchName__' could be both a local file and a tracking branch.
            Please use -- (and optionally --no-guess) to disambiguate
        原因:
            ブランチ名とファイル名が衝突しているためでうｓ
        対処:
            カレント フォルダー を移動してから git checkout します。
                cd __AnyFolder__
                git checkout __BranchName__
