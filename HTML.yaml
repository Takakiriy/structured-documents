#keyword: HTML.yaml, HTML  #ref: ${programming}/HTML ブラウザ/HTML文法.svg
記号:
    <>, </>: #search: React.Fragment
HTML バージョン:
    Baseline:  #ref: https://www.publickey1.jp/blog/23/webbaselinewebwebmdn.html
        クロスブラウザ対応
    HTML Living Standard:  #// HTML 5.1 の次
        #ref: https://www.tohoho-web.com/html/memo/htmlls.htm
サンプル: |  #keyword: 1st HTML
    <!DOCTYPE HTML>
    <html><head>
    <!-- Character Code Encoding: "WHITE SQUARE" is □ -->
    <meta charset="UTF-8">
    <title>無題</title>
    </head><body>

    <p>
    HTMLです。
    </p>
    </body></html>
HTML タグ:  #keyword: HTML tag  #ref: ${programming}/HTML ブラウザ/HTML文法.svg
    サンプル HTML ファイル:  #search: 1st HTML
    要素: #keyword: HTML 要素  #glossary: HTML
        <button>: #keyword: Next.js <button>  #ref: https://developer.mozilla.org/ja/docs/Web/HTML/Element/button
            HTML:
                サンプル:
                    <button>OK</button>
            Next.js: |  #focus: button,  handleButtonClick  #ref: ${GitHub}/MyPrivateCode/Next_js/try_Next_js_examples/pages/button/button.tsx#handleButtonClick
                import { useRouter } from 'next/router'

                const Home: NextPage = () => {
                    const router = useRouter();  // #keyword: Next.js router

                    function  handleButtonClick(e: React.MouseEvent<HTMLButtonElement, MouseEvent>) {
                        router.push(`/about`);  // __Project__/pages/about.tsx を表示します
                    }
                    return (
                        <button className={styles.submit} type="button" value="#search:"
                            onClick={(e) => {handleButtonClick(e)}}>OK</button>
        <div>: #keyword: div  #// ブロック要素  #ref: ${programming}/HTML ブラウザ/CSS.svg#div
            概要: 1行全体を占有します
            手順:
                横に並べる:  #// 複数の div 要素を横に並べます
                    概要: 行に相当する親の div を作り、その中に並べる要素を複数入れます
                    サンプル: |
                        <div>
                            <div style="float: left"> A </div>
                            <div style="float: left"> B </div>
                        </div>
                    プロジェクト内サンプル:
                        div 部分: #ref: ${GitHub}/MyPrivateCode/Next_js/try_Next_js_examples/pages/index.tsx#横に並べるため
                        CSS 部分: #ref: ${GitHub}/MyPrivateCode/Next_js/try_Next_js_examples/styles/Home.module.css#横に並べるため
                    参考: #ref: https://migisanblog.com/block-side-method/
            属性:
                class:  #search: getElementsByClassName  #search: CSS selector
                id:  #search: getElementById  #search: CSS selector
            JavaScript 連携:  #search: HTML JavaScript
        <span>: #keyword:  #// インライン要素
            JavaScript 連携:  #search: HTML JavaScript
            関連: #search: <div>
        <form>: #keyword:
            JavaScript を実行するサンプル（Next.js 以外）:
                <form>
                    <input  type="text"   name="query" />
                    <input  type="button" value="Search" onclick="console.log('pushed');"/>
                </form>
            Next.js で JavaScript を実行するサンプル:
                #focus: handleSearchClick
                HTML 部分:
                    <form>
                        <input  type="text"   name="query" />
                        <input  type="button" value="Search" onClick="(e)=>{ handleSearchClick(e); }"/>
                    </form>
                JavaScript 部分: |
                    function  handleSearchClick(e: React.MouseEvent<HTMLInputElement, MouseEvent>) {
                        const  keyword = (document.getElementsByName("q")[0] as HTMLInputElement).value;
                        router.push(`/JavaScript.yaml?q=${keyword}#L55`);
                    };
            POST メソッドを送るサンプル:
                <form  action="http://www.google.com/search">
                    <input  type="text"   name="query" />
                    <input  type="submit" value="Search" />
                </form>
            値: #search: HTML value
            参考: #ref: ${programming}/HTML ブラウザ/HTML文法.svg#form
        <img>: #keyword:  #// 画像  #ref: ${programming}/HTML ブラウザ/HTML文法.svg#img
            文章の中の画像:  #// 上記 HTML文法.svg を参照
            ページの中の位置(left, top)を指定する:  #// 上記 HTML文法.svg を参照  #search: div
            HTML ファイルに画像を埋め込む:
                サンプルA:  #ref: ${GitHub}/MyPrivateCode/HTML/SVG_to_PNG.html
                サンプルB: | #keyword: <img> src read  #focus: imgElement.src
                    document.getElementById('upload-image').addEventListener('change', function(event) {

                        const file = event.target.files[0];
                        if (file) {
                            const reader = new FileReader();
                            reader.onload = fileReaderOnLoad;

                            reader.readAsDataURL(file);
                        }

                        function  fileReaderOnLoad(e) {
                            const imgElement = document.getElementById('display-image');

                            imgElement.src = e.target.result;
                        };
                    });
            placeholder.com:
            CSS: #keyword: HTML img CSS
                width:  #search: CSS width
                zoom:  #// 元の画像から拡大縮小
        <input>: #keyword:
            値: #search: HTML value
        <table>:
            表の縦結合:  #ref: ${typrm_files}/ref/JavaScript-AI.yaml#label: React rowspan   #// rawspan ではない
    プロパティ:  #// 属性、イベント
        disable:  #keyword: HTML disable,  HTML readonly, グレーアウト
        値: #keyword: HTML value  #// <span> や <input> の値
            <form><input>:  #ref: ${programming}/HTML ブラウザ/HTML文法.svg#input_tag_text
                書式: document.form1.keyword1.value
                サンプル:  #focus: form1,  result1
                    HTML 部分:
                        <form name="form1">
                            <input type="text" id="result1" value="" size="40" maxlength="40"/>
                        </form>
                    JavaScript 部分:
                        getElementById 等を使う場合: #keyword: form getElementById value
                            document.getElementById("result1").value;
                            document.getElementsByName("result1")[0].value;
                        document のプロパティを使う場合:
                            const  value = document.form1.result1.value;
        data-____: #// カスタム データ 属性  #keyword: HTML custom data attribute  #ref: ${programming}/HTML ブラウザ/HTML文法.svg#data_
        イベント: #keyword: HTML event,  JavaScript event  #glossary: HTML
            onchange:  #// 文字列を入力してフォーカスを失ったとき
            oninput:  #// 1文字入力し・削除したとき
    文字実体参照, 数値文字参照, &nbsp; : #keyword:  #ref: ${programming}/HTML ブラウザ/HTML文法.svg
        （関連）:  #search: サニタイズ
    JavaScript 連携:  #keyword: HTML JavaScript
        HTML 部分:
            <div id="result1"></div>
        JavaScript 部分:
            getElementById: #keyword:
                <script>
                    document.getElementById("result1").innerHTML = 'OK';
                </script>
            関連:
                #search: getElementsByName
                #search: innerHTML
                #search: getElementById value
ブラウザー:  #glossary: browser
    本体:
        共通:
            同じドメインで異なるパスワード:
                異なるサーバーでも同じパスワードを使えるようにするためか、同じドメインで異なるパスワードはブラウザーに設定できません。
                サイトの問題になります。 #ref: https://support.google.com/chrome/thread/14398139/複数パスワードの保存?hl=ja
        Chrome: #keyword:
            アップデート:
                手動: …（右上）>> ヘルプ >> Google Chrome について
            開発者ツール: #search: Chrome developer tools
            初期設定:
                ホームの URL を変更します: chrome://settings/?search=ホーム
                開いたときのページ:
                    起動時:
                        Chrome >> …（右上）>> 設定 >> 起動時（左下）>> 詳細（New Tab Redirect）>> 拡張機能のオプション（下から4番目）>>
                    新しいタブ:
                        任意のページ:
                            New Tab Redirect: #keyword:
                                インストールします:
                                    #ref: https://chrome.google.com/webstore/detail/new-tab-redirect/icpgjfneehieebagbmdbhnlpiopdcmna?hl=ja
                                設定します:
                                    Chrome >> …（右上）>> 設定 >> 拡張機能（左下）>> 
                            #ref: https://support.google.com/chrome/thread/11105259/新しいタブを作成した時にchromeに設定しているホームページが表示できるようにしたい?hl=ja
                        検索ページ:
                            Chrome >> …（右上）>> 設定 >> 検索エンジン
            スーパー リロード: #keyword: super reload
                クライアント側: Ctrl + F5
                サーバー側: nginx のキャッシュなど  #search: nginx cache
            シークレット モード: #keyword: シークレット モード, シークレット ブラウジング
                #ref: https://support.google.com/chrome/answer/95464
                Cookie をリセットしたウィンドウを開きます。
                Cookie を削除してウィンドウを閉じます。
                情報を守る機能ではありません。IPアドレスや閲覧データは漏洩します。
                #ref: https://www.gizmodo.jp/amp/2022/10/google-incognito-mode-google-chrome.html
        Edge (ブラウザー): #keyword: Microsoft Edge
            Windows:
                ホームを変更します:
                    Custom New Tab URL をインストールします:
                        #ref: https://microsoftedge.microsoft.com/addons/detail/custom-new-tab-url/oeibmbobgpgnbnlbaffdgebpeepfbnhi
                    参考:
                        #ref: https://atmarkit.itmedia.co.jp/ait/articles/2105/17/news024.html
                        #ref: http://www.sage-p.com/rxml/inet_bookmark.svg
                ブラウザーのネットワークのログを記録します: #search: browser network log
            Linux:  #// 未確認
                #ref: https://learn.microsoft.com/en-us/windows/wsl/tutorials/gui-apps
                #ref: https://www.microsoft.com/ja-jp/edge/download/insider?platform=linux-deb >> コマンドラインインストール
                #search: restore WSL2
                Ubuntu 20.04 bash: |  #// 未確認
                    curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor > microsoft.gpg
                    sudo install -o root -g root -m 644 microsoft.gpg /usr/share/keyrings/
                    sudo sh -c 'echo "deb [arch=amd64 signed-by=/usr/share/keyrings/microsoft.gpg] https://packages.microsoft.com/repos/edge stable main" > /etc/apt/sources.list.d/microsoft-edge-beta.list'
                    sudo rm microsoft.gpg
                    sudo apt update
                    sudo apt install -y microsoft-edge-beta
                    microsoft-edge
                        起動できない
        Firefox: #keyword:
            更新:  #ref: https://www.mozilla.org/ja/firefox/new/
            アクセスできない:
                プロキシを設定します: #search: Firefox proxy
                    設定 >> プロキシ（で検索：右上）>> 接続設定 >> このネットワークのプロキシー設定を自動検出する
            プロキシ: #keyword: Firefox cypress proxy
                cypress が開いた FireFox >> 三 >> Preferences >> Network Settings（）>> No proxy for:
                    192.168.0.0/16, 127.0.0.1/32
                #ref: https://support.mozilla.org/ja/kb/connection-settings-firefox
        Edge (EdgeHTML):
            サポート終了。ダウンロードできません。
            #ref: https://www.microsoft.com/en-us/edge?icid=SMC-IA-4501095 >> MICROSOFT EDGE LEGACY（左下）
            #ref: https://docs.microsoft.com/ja-jp/welcome-to-docs
        Safari: #search:
    周辺機能:
        ページ内検索:  #search: URL Scroll to Text Fragment
        開発者ツール: #search: Chrome developer tools
        ログを取ります: #search: browser network log
        ストレージ, Cookie:
            比較: |
                項目         | Cookie       | Web Storage
                ---------------------------------------------
                容量         | 4KB          | 5MB
                有効期限      | 必須         | オプション
                送信タイミング | HTTP 通信ごと | 指定時にサーバーへ
            Cookie: #keyword:
                概要: サーバー側が発行してクライアントのブラウザに保存します。セッション ベース 認証 にも使われます
                secure属性:  #search: Cookie secure 属性
                HttpOnly属性: #keyword: Cookie HttpOnly 属性
                    #ref: https://www.ipa.go.jp/security/awareness/vendor/programmingv2/contents/302.html
                    概要:
                        JavaScript が document.cookie.__CookieItem__ にアクセスすることを禁止するようサーバからブラウザーに要請します。
                        XSS の緩和。
                        #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Cookies#cookie_へのアクセス制限
                    設定方法:
                        nginx:
                            nginx.conf:
                                add_header Set-Cookie "Path=/; HttpOnly; Secure";
                            #または
                            ssl.conf または default.conf:
                                proxy_cookie_path / "/; HTTPOnly; Secure";
                        tomcat, ASP.NET MVC, Apache, php.ini, .htaccess, PHP:
                            #ref: https://at-virtual.net/securecoding/cookieのsecure属性-httponly属性の指摘と修正方法と脆弱性の解/ >>  HttpOnly属性の設定方法
                    補足:
                        完全に防げるわけではないが、HttpOnly属性 を設定しておく効果は大きい
                        #ref: https://at-virtual.net/securecoding/cookieのsecure属性-httponly属性の指摘と修正方法と脆弱性の解/ >>  HTTPOnly属性の理解と修正方法
                サード パーティー Cookie: #keyword:
                    テスト:  #// ユーザーがサードパーティーCookieをブロックする設定にしている場合などにサイトが正しく動作するのかを検証できる仕組み
                        #ref: https://gigazine.net/news/20250305-google-chrome-134/ >> サードパーティーCookie
            Web Storage: #keyword:
                #ref: https://atmarkit.itmedia.co.jp/ait/articles/1108/12/news093.html
            ブラウザーの JavaScript 変数:
            サーバーのプロセス:
        Web Push: #keyword:
            概要:
                - サーバーから通知をプッシュします。ユーザーが事前に許可する必要があります。
                - firebase ではフロント側でフィルターできなくもないですがあまりよくないという意見がある
                    #ref: https://stackoverflow.com/questions/58598948/filter-web-notifications-by-client-side
            aws:
                Amazon SNS + Lambda  #search: aws SNS 
        about:blank: #keyword: about:blank  #// 空白ページ
        パスワード: #keyword: browser password
            -   ドメインが同じ場合、同じアカウントであるとしてパスワードを自動入力します
            -   たとえば、aaa.bbb.com と ccc.bbb.com は同じと見なされます
            -   社内では、同じドメインで異なるアカウントが認証に使われることがあり、その場合は
                パスワードを共通にするかブラウザーに保存しないようにします
    開発者ツール: #keyword: Chrome developer tools,  debug MS Edge  #// F12 キー
        手順:
            エラー時にブレークします: #keyword: browser error break point
                ブラウザーの開発者ツール >> ソース タブ >> 例外の検出時に一時停止
            ログを取ります: #search: browser network log
            フォントのサイズを変更します:
                Ctrl + -, Ctrl + +
        タブ, 画面:
            要素:
                編集:
                    （親要素を右クリック）>> HTML として編集
                （CSS 関連）: #keyword: Chrome CSS
                    CSS の全ての属性をコピーする, 比較する:
                        Elements タブ で対象の要素を選ぶ >>（スタイル関係のビューの）Computed タブ >> Show All >>
                        属性をクリックして Ctrl + A >> Ctrl + C >> テキスト エディター などに貼り付け >>
                        比較するときは、貼り付けたテキストを diff 比較
            コンソール:  #keyword: Chrome console
            ソース:
                ソース ファイル を開きます:
                    Ctrl + P
                ブレークポイントを張ります:  #search: React break point
            ネットワーク:  #keyword: Chrome network tool
                ヘッダー:  #// URL, HTML ヘッダー  #keyword: Chrome network tool header
                ペイロード: リクエスト body  #search: ペイロード
                プレビュー:  #// レスポンスの概要  #keyword: Chrome network tool preview
                回答:  #// レスポンスの生データ
                ブラウザーのログを記録します: #search: browser network log
Google フォームでアンケート（フォーム）を作る:  #keyword: Google フォーム
    メニュー: https://www.google.com/intl/ja_jp/forms/about/ >> パーソナル >>
        （アカウントの選択）（右上）>> テンプレート ギャラリー（右上） >> お客様アンケート
    すでにいくつかの項目が登録されていますが編集できます:
    項目を編集する:
        1 ～ 5 の評価（均等目盛）の場合:
            項目をクリック:
            （記入の種類）（右上）: 均等目盛
            1（の内容）: ____
            5（の内容）: ____
            チェック: 必須（かどうか）
        自由記入欄（段落）の場合:
            項目をクリック:
            （記入の種類）（右上）: 段落
    アンケート入力後のメッセージを改良する:
        メニュー: （歯車アイコン）（右上）>> プレゼンテーション（タブ）
        確認メッセージ: アンケートが送信されました。お疲れさまでした。
            もし、回答内容を変更して再送信したいときは「回答を編集」を押してださい。
    アンケートが入力されたらメールで通知が来るようにする:
        #// 通知先はアンケートを入力している Gmail アカウント固定です（ただしスクリプトで変更可能）
        メニュー: 回答（タブ）>> …（右上）>> 新しい回答についてのメール通知を受け取る
        もう一度 … を押して、チェックが付いていることを確認します:
    フォームが完成したら:
        メニュー: 送信（右上）>> 送信方法＝⊂-⊃ >> （URLをコピー）
Google フォームに入力された回答を見る:
    メニュー: https://www.google.com/intl/ja_jp/forms/about/ >> パーソナル >>
        （アカウントの選択）（右上）>> 最近使用したフォーム（左下） >> お客様アンケート >>
        回答（タブ）
Web サーバー: #keyword: HTTP server,  Web server
    手順 >> 起動します:
        nginx: #keyword: install nginx  #// nginx の Docker イメージを使って Web サーバーを起動します
            HTTP アクセスにする場合:
                Docker をインストールします:
                    #search: Docker for Linux
                __Project__/public_html/index.html : |
                    <!DOCTYPE HTML>
                    <html><head>
                    <!-- Character Code Encoding: "WHITE SQUARE" is □ -->
                    <meta charset="UTF-8">
                    <title>無題</title>
                    </head><body>

                    <p>
                    HTMLです。
                    </p>
                    </body></html>
                docker コマンドを使う場合: #keyword: docker nginx
                    新しい bash:
                        cd  __Project__
                        docker run -it --rm  --name nginx1  -p "8080:80"  -v "../public_html:/usr/share/nginx/html"  nginx
                docker-compose を使う場合:
                    __Project__/docker/docker-compose.nginx.yml :  #// __Project__ の例： ~/_nginx_https
                        version: "2"
                        services:
                            nginx:  #// 任意の名前
                                image: nginx  #// nginx の Docker イメージをダウンロードして使います。ビルドは不要です
                                ports:
                                    - "8080:80"  #// : の左側が nginx Web サーバーにアクセスするときに指定するポート番号
                                volumes:
                                    - ../public_html:/usr/share/nginx/html  #// : の左側が HTML を入れる Docker のホスト OS のパス
                    新しい bash:
                        cd  __Project__
                        docker-compose  -f docker/docker-compose.nginx.yml  up  #// 起動に必要なモジュールのダウンロードも行われます
                HTTP リクエストを発行します:
                    CLI の場合:
                        bash:
                            curl http://192.168.56.102:8080/
                    ブラウザーの場合:
                        アドレスバー:
                            http://192.168.56.102:8080/
            HTTPS アクセスにする場合:
                HTTP アクセスできるようにします: 上記
                オレオレ サーバー 証明書を作ります: #keyword: oreore.ssl.crt  #search: SSL証明書
                    #search: SSL証明書
                    #// CACertificate も同様に作れます  #keyword: CACertificate  #// 認証局 (CA) の証明書
                    準備:
                        新しい bash:  #// secrets = 証明書を作る場所。またはそれをする一時的な場所
                            cd __Project__
                            mkdir -p secrets
                            cd secrets
                            ServerSecretKey="oreore.ssl.secret.key"
                            CsrFile="oreore.ssl.csr"
                            CrtFile="oreore.ssl.crt"
                            ConfigFile="x509v3_config.txt"
                    秘密鍵 oreore.ssl.secret.key を作ります:
                        - openssl genrsa -out "${ServerSecretKey}" 2048
                        - ls -l "${ServerSecretKey}"  #// サイズが 1675 ぐらいであること
                    証明書リクエスト oreore.ssl.csr を作ります:
                        手動入力する場合:
                            - openssl req -new -sha256 -key "${ServerSecretKey}" -out "${CsrFile}"
                            - JA  #// Country Name (2 letter code) [XX]
                            - （その他は Enter のみ）
                            - ls -l "${CsrFile}"  #// サイズが 952 ぐらいであること
                        自動入力する場合:  #search: ANSI-C Quoting
                            - sudo openssl req -new -sha256 -key "${ServerSecretKey}" -out "${CsrFile}"  <<< $'JA\n\n\n\n\n\n\n\n\n\n'
                            - ls -l "${CsrFile}"  #// サイズが 952 ぐらいであること
                    x509v3_config.txt を作ります:  #// x509v3_config.txt は、openssl コマンドでしか使われません
                        簡単な例: |
                            echo "subjectAltName = DNS: sample-site.example.com" > "${ConfigFile}"
                        開発時によくある内容: |
                            cat << _HERE_DOCUMENT  |  sudo tee "${ConfigFile}" > /dev/null
                            [alt_names]
                            DNS.1 = localhost
                            DNS.2 = *.localhost
                            IP.1 = 127.0.0.1
                            IP.2 = ::1
                            _HERE_DOCUMENT
                        #template__: DNS: __FQDN__
                        #ref: https://www.openssl.org/docs/man3.0/man5/x509v3_config.html
                    証明書 oreore.ssl.crt を作ります:
                            - openssl x509 -req -sha256 -days 3650 -signkey "${ServerSecretKey}" -in "${CsrFile}" -out "${CrtFile}" -extfile "${ConfigFile}"
                            - ls -l "${CrtFile}"  #// サイズが 1172 ぐらいであること
                        #ref: https://www.openssl.org/docs/man3.0/man1/openssl-x509.html >> -extfile
                    #↓ 参考
                    SSL証明書: #search:
                デフォルトの nginx の設定をバックアップします:
                    コマンド:
                        cd  __Project__
                        mkdir -p  nginx_conf.d
                        docker exec  -it docker_nginx_1  cat /etc/nginx/conf.d/default.conf > nginx_conf.d/default.conf.back_up
                        cp  nginx_conf.d/default.conf.back_up  nginx_conf.d/default.conf
                    （参考）nginx.conf の場所: #search: nginx.conf path
                nginx の 443ポート(HTTPS) を設定します:  #// HTTPS に変更します
                    __Project__/nginx_conf.d/default.conf :  #// 編集
                        編集前: |
                            server {
                                listen       80;
                                listen  [::]:80;
                                server_name  localhost;
                                    ...
                        編集後: |
                            server {
                                listen       443;
                                listen  [::]:443;
                                ssl on;
                                ssl_certificate /etc/nginx/oreore.ssl.crt;
                                ssl_certificate_key /etc/nginx/oreore.ssl.secret.key;
                                server_name sample-site.com;
                                    ...
                nginx の 80ポート(HTTP) を設定します:  #// HTTP リクエスト(80) を HTTPS にリダイレクトします
                    __Project__/nginx_conf.d/default.conf : |  #// 追加
                        server {
                            listen       80;
                            listen  [::]:80;
                            server_name sample-site.com;
                            return 301 https://sample-site.com;
                        }
                nginx_conf.d フォルダーをコンテナーの /etc/nginx/conf.d と共有して nginx を再起動します:
                    コンテナーを終了します:
                        - Ctrl + C  #// 終了
                        - docker-compose  -f docker/docker-compose.nginx.yml  down
                    __Project__/docker/docker-compose.nginx.yml を修正します:
                        編集前:
                            ports:
                                - "8088:80"
                            volumes:
                                - ../public_html:/usr/share/nginx/html
                        編集後:
                            ports:
                                - "8088:80"
                                - "8443:443"
                            volumes:
                                - ../public_html:/usr/share/nginx/html
                                - ../secrets/oreore.ssl.crt:/etc/nginx/oreore.ssl.crt
                                - ../secrets/oreore.ssl.secret.key:/etc/nginx/oreore.ssl.secret.key
                                - ../nginx_conf.d:/etc/nginx/conf.d
                    コンテナーを起動します:
                        docker-compose  -f docker/docker-compose.nginx.yml  up
                HTTP リクエストを発行します:
                    bash:
                        - curl  https://192.168.56.102:8443/   #// 警告されます
                        - curl --insecure  https://192.168.56.102:8443/  #// HTML が表示されます
        express: #keyword: express,  Node.js express,  install express  #// Node.js express を使って Web サーバーを起動します:
            関連:
                組み合わせて使う場合: #search: install Swagger UI
            設定: #settings:
                __Port__: 8080
                __HTML_Source__: public
            Node.js のプロジェクトを新規作成します:
                Git bash:
                    - mkdir  "webserver-express"
                      cd     "webserver-express"
                      npm init -y
                      npm install express
                    - code  "."  #// Open Visual Studio Code
            __Project__/server.js:
                HTML を返す場合: |
                    'use strict';
                    const express = require('express');
                    const app = express();

                    app.use(express.static('public'));  // #template: '__HTML_Source__'
                    app.listen( 8080, ()=> {  //#template: __Port__
                        console.log('Express Web Server');
                    });
                CORS に対応して HTML を返す場合:  #// ブラウザーの Fetch API からリクエストされる場合
                    サーバー側: | #keyword: express CORS  #focus: cors
                        'use strict';
                        const express = require('express');
                        const cors = require('cors')
                        const app = express();
                        app.use(cors());  // すべてのリクエストを許可します

                        app.use(express.static('public'));  // #template: '__HTML_Source__'
                        app.listen( 8080, ()=> {  //#template: __Port__
                            console.log('Express Web Server');
                        });
                    ブラウザー側: |
                        fetch('http://localhost:8080/index.html')
                            .then( (response) => {
                                console.log(response)
                                response.text().then((text)=>{
                                    console.log(text);
                                });
                            });
                    参考:
                        express の CORS: #ref: https://qiita.com/chenglin/items/5e563e50d1c32dadf4c3
                        Fetch API の body: #ref: https://developer.mozilla.org/ja/docs/Web/API/Fetch_API/Using_Fetch#body
                HTML を返し, HTTP GET の Web API にも対応する場合: |  #// app.get が HTTP GET の応答部分です
                    'use strict';
                    const express = require('express');
                    const app = express();

                    app.get('/api/v1', (req, res) => {
                        const  response = { status: 'OK' };

                        res.json( response );
                    });

                    app.use(express.static('public'));  //#template: '__HTML_Source__'

                    app.listen( 8080, ()=> {  //#template: __Port__
                        console.log('Express Web Server');
                    });
            __Project__/public に index.html などの HTML 関連のファイルを作成・コピーします:
                サンプル __Project__/public/index.html: |
                    <!DOCTYPE HTML><html><body>Node.js express</body></html>
            Web サーバーを起動します:
                Terminal:  #// VSCode >> Terminal >> New Terminal
                    node  server.js
                    #// 終了するときは Ctrl + C キー
            ブラウザーで開きます:
                HTML を表示する場合:
                    http://localhost:8080/
                        #template: localhost:__Port__
                HTTP GET の Web API を呼び出す場合:
                    http://localhost:8080/api/v1
                        #template: localhost:__Port__
        Python http.server:  #search: http.server
    nginx: #keyword:
        公式: #ref: http://nginx.org/en/docs/
        手順:
            起動します:  #search: install nginx
            現在公開しているポート番号を一覧します:
                sudo netstat -lnp | grep nginx  #search: Linux port
            設定のリロード:  #search: reload nginx
            脆弱性対応:
                TLS のバージョン: #keyword: nginx TLS version
                    #ref: ${typrm_files}/ref/HTML-AI.yaml#label: nginx TLS version from AI
                log4j の脆弱性 (nginx): #keyword: nginx log4j
                    Safe: NGINXはC言語で記述されJavaやJava Baseのライブラリを使用していないため
                    参考: #ref: https://www.nginx.co.jp/blog/mitigating-the-log4j-vulnerability-cve-2021-44228-with-nginx/
            監視対象フォルダー: #keyword: nginx folders monitoring  #// セキュリティのためにファイルの変更を監視するときの対象フォルダー
                対象:
                    設定ファイル: /etc/nginx/
                    ウェブ コンテンツ: /usr/share/nginx/html/ または /var/www/html/
                    SSL証明書: /etc/ssl/ や /etc/nginx/ssl/
                対象外:
                    ログ関連: /var/log/nginx/, /var/log/
                    実行時データ: /var/run/nginx/, /run/nginx/, /var/cache/nginx/, /tmp/nginx/
                    システム関連: /proc/, /sys/
        機能:
            リバース プロキシ 機能:
                構成: client → nginx → server → server2
                サーバーが https_proxy が必要なクライアントになる場合:
                    nginx は https_proxy 環境変数を使ったクライアントになることはできません:
                        client → nginx --(できない)→ プロキシ サーバー → server2
                    サーバー アプリケーション が https_proxy 環境変数を使ったクライアントになります:
                        client → nginx → server --(https_proxy 環境変数)→ プロキシ サーバー → server2
                    nginx.conf ファイル にあるもの: |
                        location / {
                            proxy_pass https://target.com;                 # nginx が代わりになる（背後にある）プロキシ サーバー 
                            proxy_via http://corporate-proxy:8080;         # 存在しない
                            upstream_proxy http://proxy.company.com:8080;  # 存在しない
        コマンド:  #glossary: nginx
            nginx -T:  設定ファイルの内容を一覧表示します  #search: reload nginx
        ログ: #keyword: nginx log  #glossary: nginx
            access_log:
                場所:
                    nginx.conf による:
                    デフォルト: /var/log/nginx/access.log (?)
                内容:
                    HTTP アクセス:
                        #// HTTPS だけリッスンしている場合でも記録されます
                    HTTPS のポートへ HTTP アクセスした場合:
                        __IpAddress__ - - [__TimeDate__] "POST /RPC HTTP/1.1" 400 __ResponseByteLength__ "-" "____/__Version__" "-"
                    HTTPS 認証が失敗した場合:
                        （ログは記録されません）
                    RPC アクセス:
                        __IpAddress__ - - [__TimeDate__] "POST /RPC HTTP/1.1" __ResponseStatusCode__ __ResponseByteLength__ "-" "____/__Version__" "-"
                        #search: nginx log_format
                    RPC アクセス >> メソッド名が違う場合:  #focus: 305
                        __IpAddress__ - - [__TimeDate__] "POST /RPC HTTP/1.1" __ResponseStatusCode__ 305 "-" "____/__Version__" "-"
            error_log: #keyword: nginx error.log
                出力するように設定します:
                    nginx.conf の設定を確認するか設定します: |  #// /var/log/nginx/conf.d/____.conf には書けません
                        error_log  /var/log/nginx/error.log  debug;
                        http {
                            access_log  /var/log/nginx/access.log;
                    補足:
                        デフォルトの場所: /var/log/nginx/error.log
                        debug の他: debug → info → notice → warn → error → crit → alert → emerg
                            上記 debug は、大量にログが出るデバッグ用の設定です
                    設定をロードします: |
                        sudo mkdir -p /var/log/nginx
                        ls -la  /var/log/nginx
                        sudo systemctl restart  nginx
                        systemctl status  nginx
                    動作確認します: |
                        curl -vvv  http://localhost:80/
                        sudo journalctl  -u nginx  -n 50
                        tail  /var/log/nginx/error.log
                トラブルシューティング:
                    手順:
                        curl -vvv  http://localhost:80/
                    error.log: |
                        2025/12/09 12:34:45 [error] open() "__Path__" failed (13: Permission denied), client: __IPAddress__, server: _, request: "GET __Path__ HTTP/1.1", host: "__Host__:__Port__"
                    対処:
                        nginx.conf の user 設定を確認します:
                            user ____;
                        そのユーザーが __Path__ にアクセスできるか確認します:
                            ls -l  __Path__
        ファイル: #keyword: nginx settings file
            HTML ファイルの置き場所:
                デフォルト: /usr/share/nginx/html/
            nginx 本体の場所: /sbin/nginx
            nginx.conf:  #keyword: nginx.conf
                設定の一覧とリロード:  #// nginx がリードするすべての .conf ファイルを結合して表示します
                    一覧コマンド: nginx -T
                    リロード: #search: reload nginx
                コメント:
                    nginx.conf は # でコメントになります
                nginx.conf ファイルの場所: | #keyword: nginx.conf path
                    cat /etc/nginx/nginx.conf
                    ls -l /etc/nginx/conf.d/*.conf
                    cat /etc/nginx/conf.d/default.conf
                        ...
                location: #keyword: nginx.conf location  #glossary: nginx.conf  #// URL のフォルダー (http____/__Folder__/___ の __Folder__) に対応する設定
                    （location の右のパス）:
                        URL の位置:
                            _: location の右に書く値 __Location__ は、必ずドメイン名のすぐ右の / から始まる位置になります。
                                URL に /__Location__/ より右がある場合（例：http://__Domain__/__Location__/index.html ）もマッチします。
                                ただし、他の location にマッチしなければ。
                            nginx.conf: location /__Location__/ {
                            URL: http://__Domain__/__Location__/
                        末尾の /:
                            書いても書かなくても同じです
                    proxy_pass:  #// 転送先（proxy）
                        location /api {
                            proxy_pass http://backend_server/api;
                        location /api/sub {
                            proxy_pass http://backend_server/api/sub;
                    alias: #keyword: nginx.conf alias  #// 特定のURLリクエストを他のディレクトリにマッピングします
                        サンプル:
                            nginx.conf: |
                                location /images/ {
                                    alias /var/www/pictures/;
                                }
                            URL: http://yourdomain.com/images/photo.jpg
                            サーバー内パス: /var/www/pictures/photo.jpg
                        注意:
                            location と alias の末尾の / の有無は合わせてください。
                            #// 末尾が / ではないときは / 以外の文字でエイリアスができそう？
                    proxy_read_timeout: #keyword: nginx.conf  proxy_read_timeout  #// タイムアウト
                        タイムアウト時の動作:
                            nginx からサーバーへリクエストして返答が長い間無いときは、
                            nginx からレスポンスを返します。
                            サーバーの処理は継続します。
                            ユーザーが再度リクエストすると、サーバーの負荷が高まります。
                        一部の URL（サブ フォルダー）の設定を変える場合:
                            #search: nginx child setting
                    include: #keyword: nginx.conf include  #// 共通の設定値をインクルードします
                        nginx.conf: |  #:focus: include
                            location /api {
                                include /path/to/common_settings.conf;
                                proxy_read_timeout 60s;  # デフォルトのタイムアウト
                            }
                        /path/to/common_settings.conf:
                            proxy_pass http://backend_server;
                            proxy_set_header Host $host;
                            proxy_set_header X-Real-IP $remote_addr;
                            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    expires: #keyword: nginx expires  #ref: http://nginx.org/en/docs/http/ngx_http_headers_module.html
                        設定サンプル: #ref: https://serverfault.com/questions/23157/setting-the-expires-http-header-for-static-content-served-from-nginx
                            location ____ {
                                expires 30d;
                    （一部の URL（サブ フォルダー）の設定を変える場合）:  #keyword: nginx child setting
                        nginx.conf: |  #:focus: images
                            location /images/ {
                                proxy_pass http://backend_server/images/;
                                proxy_read_timeout 60s;
                                proxy_set_header Host $host;
                                proxy_set_header X-Real-IP $remote_addr;
                            }
                            
                            location /images/sub/ {                                 #// 子
                                proxy_pass http://backend_server/images/sub/;       #// location の右に書かれたパスに合わせる必要があります
                                proxy_read_timeout 120s;                            #// 親（/images/）と違う設定
                                proxy_set_header Host $host;                        #// 親（/images/）と同じ設定も必要。継承関係はありません
                                proxy_set_header X-Real-IP $remote_addr;
                            }
                    （親と子の間に継承関係はありません）:
                        _: URL の親（/images/）の設定は、子（/images/sub/）に継承されないため、明示的に設定を書く必要があります。  
                            下記の alias の設定は省略できません。
                        nginx.conf: |  #:focus: images
                            location /images/ {
                                alias /var/www/pictures/;
                            }
                            
                            location /images/sub/ {
                                alias /var/www/pictures/;
                            }
                upstream, ロードバランサー: #keyword: nginx.conf upstream
                    公式:
                        Load Balancing:
                            #ref: http://nginx.org/en/docs/http/load_balancing.html
                            #ref: https://www.nginx.com/products/nginx/load-balancing/
                    サンプル:
                        nginx.conf: |  #focus: upstream
                            http {
                                upstream myapp1 {
                                    server srv1.example.com;
                                    server srv2.example.com;
                                    server srv3.example.com;
                                }

                                server {
                                    listen 80;

                                    location / {
                                        proxy_pass http://myapp1;
                                    }
                                }
                            }
                        サンプルの説明:
                            - nginx が動いているサーバーに来たリクエストは srv1, srv2, srv3 に分散されます
                            - proxy_pass の値に含まれる myapp1 が srv1.example.com などに置き換わります
                    リバースプロキシの実装:
                        HTTP, HTTPS, FastCGI, uwsgi, SCGI, memcached, gRPC 
                    upstream ディレクティブ:
                        Unix ソケット を使う場合:
                            nginx.conf: |
                                upstream example_api {
                                    server unix:/run/example/socket;
                                }
                            Web API 呼び出し:
                                curl  --unix-socket /run/example/socket  http://localhost:12345/api/customers
                                    #// /run/example/socket は Unix ソケット のパスです。nginx.conf の設定を参照してください
                                    #// http://localhost:12345/api/customers は、nginx にリクエストされる URL を指定します。ポート番号など一部は無視されます
                        HTTP を使う場合: |  #focus: upstream
                            upstream myapp1 {
                                server srv1.example.com;
                            }
                        HTTPS および keepalived を使う場合: |  #focus: proxy_pass, https, backup  #search: keepalived
                            upstream myapp1 {
                                server srv1.example.com:443;
                                server srv2.example.com:443 backup;
                            }

                            server {
                                listen 80;
                                server_name example.com;

                                location / {
                                    proxy_pass https://backend;
                                    proxy_ssl_verify off;  # 必要に応じてSSL検証を無効にする
                                    proxy_ssl_server_name on;  # SNIを有効にする
                                }
                            }
                    参考: #ref: http://mogile.web.fc2.com/nginx/admin-guide/load-balancer.html
                http:
                    log_format: #keyword: nginx log_format  #ref: https://nginx.org/en/docs/http/ngx_http_log_module.html
                圧縮:
                    公式: http://nginx.org/en/docs/http/ngx_http_gzip_module.html
                    サンプル: #// 最も広い条件で圧縮を行う設定。ただし gzip_vary を使って設定場所が正しいことをチェックしてください。
                        nginx.conf ファイル: |
                            server {
                                gzip                on;
                                gzip_http_version   1.0;
                                gzip_types          *;
                                gzip_proxied        any;
                                gzip_vary           on;
                    フィールドの説明:
                        gzip_proxied:
                            any: リバース プロキシ の判定条件に関わらず、常に圧縮対象にします
                        gzip_vary: on なら HTTP レスポンスの Vary ヘッダーに Accept-Encoding が追加されます。
                            off でも Vary ヘッダーは付きますが、Accept-Encoding は含みません。
                            設定ファイルの場所が正しいことを確認するために使えます。
                キャッシュ: #keyword: nginx cache
                    サンプル: #// リバースプロキシにキャッシュさせません。下記はデフォルト値ではありません
                        server や loction など {
                            add_header Cache-Control "no-cache, no-store, must-revalidate";
                            add_header Pragma "no-cache";
                            add_header Expires 0;
                プロキシ: #keyword: nginx proxy
                    公式: #ref: http://nginx.org/en/docs/http/ngx_http_proxy_module.html
                    サンプル: #// デフォルト値
                        server {
                            proxy_buffer_size 1k;
                            proxy_buffers 2 1k;
                            proxy_busy_buffers_size 1k;
                    参考: #ref: https://parudou3.com/nginx/715/
        トラブルシューティング:
            - #// nginx: [emerg] unknown directive "ssl"  #keyword: nginx unknown directive ssl
                手順: systemctl restart nginx
                エラー: |
                    [root@server-dev ~]# systemctl status nginx  |  less
                        Jul 05 13:00:29 server.example.com nginx[386086]: nginx: [emerg] unknown directive "ssl" in /etc/nginx/conf.d/ct-api.conf:9
                対処:
                    ct-api.conf:  #ref: /etc/nginx/conf.d/ct-api.conf
                        編集前: |
                            listen 8415;
                            ssl on;
                        編集後: |
                            listen 8415 ssl;
                            # ssl on;  ssl is moved to listen field.
                        #ref: https://qiita.com/MATTENN/items/172a481993b4a1d53536
                    再起動:
                        sudo systemctl restart nginx
    nginx plus: #keyword:  #// 有料版  #ref: https://www.nginx.co.jp/blog/what-is-nginx/
        セッションパーシステンス機能や、APIによる動的設定変更機能、アクティブヘルスチェック機能など
    Apache: #keyword:
        http.conf ファイル:  #keyword: Apache http.conf
    Python: #keyword: http.server,  python HTTP sevrer
        新しいターミナルで: |
            cd  __PublicHTML__
            python3 -m http.server 8089
                Ctrl + C で終了
        ダウンロードします: |
            curl -OL http://localhost:8089/file.html
        シンボリックリンクを置いた場合:
            サーバーにシンボリックリンクがある場合、404 エラーになります
        IPアドレス制限: #keyword: python HTTP sevrer IPアドレス制限
            IP アドレス直指定: |  #// 未確認
                from http.server import HTTPServer, SimpleHTTPRequestHandler

                class IPRestrictedHandler(SimpleHTTPRequestHandler):
                    # 許可するIPアドレスのリスト
                    ALLOWED_IPS = ['127.0.0.1', '192.168.1.100']
                    
                    def handle(self):
                        client_ip = self.client_address[0]
                        if client_ip not in self.ALLOWED_IPS:
                            self.send_error(403, "Forbidden: IP not allowed")
                            return
                        super().handle()

                if __name__ == '__main__':
                    server = HTTPServer(('0.0.0.0', 8000), IPRestrictedHandler)
                    print("Server running on port 8000")
                    server.serve_forever()
            CIDR 指定: |  #// 未確認
                from http.server import HTTPServer, SimpleHTTPRequestHandler
                import ipaddress

                class IPRestrictedHandler(SimpleHTTPRequestHandler):
                    ALLOWED_NETWORKS = [
                        ipaddress.ip_network('127.0.0.0/8'),
                        ipaddress.ip_network('192.168.1.0/24'),
                    ]
                    
                    def handle(self):
                        client_ip = ipaddress.ip_address(self.client_address[0])
                        if not any(client_ip in network for network in self.ALLOWED_NETWORKS):
                            self.send_error(403, "Forbidden")
                            return
                        super().handle()
    PHP: #keyword:
        タイムゾーン: #keyword: PHP timezone
            確認:  #// Docker 内に PHP が Alpine Linux の上にあるときの PHP のタイムゾーンを調べます
                コマンド: |
                    cd ____
                    docker-compose -f compose.yml  up -d
                    docker exec  -it  zabbix-web-1  bash
                        cat  /etc/php7/php.ini  |  grep  zone
                        edit=./date.php
                        tee ${edit} > /dev/null
                        <?php
                        echo date_default_timezone_get();
                        ?>
                        (Ctrl+D)
                        apk add php7-cli
                        php ./date.php
                            Europe/Riga
                        php -i | grep "date.timezone"
                            date.timezone => Europe/Riga => Europe/Riga
                        exit
                Europe/Riga タイムゾーン: #keyword:
                    時差とサマータイム:
                        3月末～10月末 UTC+3
                        それ以外 UTC+2
                    Alpine Linux + PHP の Docker コンテナーのデフォルトらしい:
                        #ref: https://ytooyama.hatenadiary.jp/entry/2021/09/14/185907
                        #ref: https://www.neko6.info/archives/2634
    専用 Web サーバー を使う理由:
        - ユーザーからのリクエストをサーバー1台で並列に捌く
        - ユーザーからのリクエストを多数のサーバーで並列に捌く
        - ユーザーからのリクエストを捌きながら、ダウンタイムなくWebアプリの更新を行う
        - ユーザーからのリクエストで低速な処理の結果をキャッシュし、次回のリクエストを高速化する
        - ユーザーからリクエストの一部を代行する
        - ユーザーからのリクエストを処理する先を変更する
    既定のコマンドを実行する: #keyword: simple HTTP trigger
        コード: | #keyword: simple_web_hook.sh
            #!/bin/bash
            #// Command: __ThisScript__  __PortNum__  __Command__
            #// Example:
            #//     Server: ~/bin/simple_web_hook.sh  8080  echo  "received!"
            #//     Client: curl  ____:8080  --max-time 5

            PortNum="$1"
            shift

            function  StartCommand() {
                "$@"  2>&1  |  sed  "s/^/$( date --iso-8601=seconds ) /"
            }

            Response=\
            'HTTP/1.1 200 OK
            Content-Type: application/json

            {"status": "triggered"}'

            #// Main
            while true; do
                echo "${Response}"  |  nc -l -p ${PortNum}  > /dev/null  ||  exit  2

                StartCommand  "$@"
            done
webpack: #keyword:
    webpack.config.js:
        devServer:  #ref: https://webpack.js.org/configuration/dev-server/
            proxy:  #keyword: devServer proxy  #ref: https://webpack.js.org/configuration/dev-server/#devserverproxy
                機能: フォワーディングします
                サンプル: |  #// http://__Domain__/api にアクセスすると http://localhost:3000 にアクセスします
                    module.exports = {
                        devServer: {
                            proxy: {
                                '/api': 'http://localhost:3000',
                    または
                            proxy: {
                                '/api': {
                                    target: 'http://localhost:3000',
                headers: #search: devServer headers
            headers:  #keyword: devServer headers  #ref: https://webpack.js.org/configuration/dev-server/#devserverheaders
                機能: 公式では Adds headers to all responses レスポンスに追加？
                サンプル >> 同じドメインのすべてのパスに対する HTTP リクエスト: | #未確認
                    module.exports = {
                        devServer: {
                            headers: {
                                'X-Custom-Foo': 'bar',
                サンプル >> 同じドメインの /api に対する HTTP リクエスト: |
                    module.exports = {
                        devServer: {
                            proxy: {
                                '/api': {
                                    headers: {
                                        'X-Custom-Foo': 'bar',
                メモ: ヘッダーの名前 X- は非推奨になりました  #search: HTTP headers
Swagger UI: #keyword: Swagger UI
    概要:
        JSON などで書かれた API 仕様をブラウズします:
        メリット: 自動文書化、コードの自動生成、API エンドポイント Web UI
    インストール:  #keyword: install Swagger UI  #// Node.js express を使用、ブラウザーを開く PC にインストールします
        参考:
            - https://garafu.blogspot.com/2020/05/how-to-use-swagger-ui_6.html
            - https://github.com/swagger-api/swagger-ui/blob/master/docs/usage/installation.md
        設定: #settings:
            __Project__: swagger_ui
            __PortNum__: 50011
        既存のプロジェクトから Swagger UI をインストールする場合:
            Node.js をインストールします:
            プロジェクトをコピーします:
                コピー元: MyDoc\src\GitHub\MyPrivateCode\swagger_ui
                コピー先: ~/Downloads/swagger_ui
            新しいシェル:
                cd __Project__
                npm install --only=production
                #// シェルを閉じます
            ポート番号を調べます:
                __Project__/index.js の一部: |
                    app.listen(50011);
                        #template: __PortNum__
        プロジェクトを作る場合:
            Node.js をインストールします:
            Visual Studio Code をインストールします:
            Visual Studio Code で新しいフォルダー swagger_ui を開きます:  #template: __Project__
                VSCode >> File >> Open Folder >> デスクトップ >> 新しいフォルダー >> swagger_ui >> フォルダーの選択  #template: __Project__
            シェル:  #// VSCode >> Terminal >> New Terminal
                npm init -y
                npm install  swagger-ui-dist  express
            __Project__/package.json: |
                {
                    "scripts": {
                        "start": "node index.js"
            __Project__/index.js: |
                var { absolutePath } = require("swagger-ui-dist");
                var express = require("express");
                var app = express();
                
                app.use(express.static(absolutePath()));
                
                app.listen(50011);  //#template: __PortNum__
        Swagger UI サーバーを起動します:
            新しいシェル:
                cd __Project__
                npm start
        ブラウザーで開きます:
            http://localhost:50011/
                #template: __PortNum__
        Web API の URL を指定します:
            Explore ボタン（開いたブラウザーの右上）の左に Web API の URL を入力します
    関連:
        OpenAPI:
        Postman:
        AWS API Gateway:
HTML メール:
    - 見た目そのまま編集可能なオープンソースのHTMLメールデザインツール「SENDUNE」を使ってみた
        #ref: https://gigazine.net/news/20240810-sendune-open-source-html-email-designer/
    - メールクライアントごとにHTMLメールで使用できる機能を一目でわかる形式でまとめてくれるサイト「Can I email…」 - GIGAZINE
        #ref: https://gigazine.net/news/20240509-can-i-email/
WordPress:
    概要: ブログエンジンの一種, 細かい制御は PHP を使う
素材: #search:
コードに色をつける:  #keyword:
    google-code-prettify: #ref: https://blog.thingslabo.com/archives/000004.html
    splash syntax hilighter:
    HTML: #ref: https://stackoverflow.com/questions/31080818/what-is-the-best-practice-to-parse-html-in-swift
XML: #keyword:
    #ref: ${programming}/HTML ブラウザ/XML.svg
    文字: #keyword: XML HTML characters
        実体参照:  #keyword: 実体参照,  エンティティ参照
            XML: |  #ref: ${programming}/HTML ブラウザ/XML.svg#escape
                &   &amp;
                <   &lt;
                >   &gt;
                "   &quot;
                '   &apos;
            HTML: |  #ref: https://unicode-table.com/jp/html-entities/
                <   &lt;
                >   &gt;
                &   &amp;
                    &nbsp;
                など
        文字参照:  #ref: https://ja.wikipedia.org/wiki/文字参照
            10進数: |  #// &#____;
                &#9834;
            16進数: |  #// &#x____;
                &#x266A;
        関連: #search: Unicode signs
    正規化: #keyword: XML normalization
        正規化の主な目的は、文書の内容を変更せずに、文書をより一貫した形式にすることです。これにより、XML文書の解析や比較が容易になります。
            文字参照の置換
            エンティティ参照の展開
            改行文字の統一
            空白文字の整理（例えば、タグの間の不要な空白の削除）
    標準化: #keyword: XML standardization
        規格に従うこと
Web Vitals: #keyword:  #// Google が決めた Web のパフォーマンス指標の1つ。読み込み速度、レイアウト崩れなど  #ref: https://web.dev/vitals/#core-web-vitals
    Cumulative Layout Shift (CLS):  #// たとえば、警告表示で部品が移動してしまうのは悪い  #ref: https://web.dev/cls/
    Core Web Vitals 2024: #ref: https://gigazine.net/news/20230517-core-web-vitals-interaction-to-next-paint/
TCP/IP, UDP 通信: #keyword:
    TCP/IP: #// 同期式
        TCP reset (RST): #keyword:
            RST パケット: 接続要求を拒絶するときに送ります  #ref: https://e-words.jp/w/RSTパケット.html
        信頼性の機能:
            リトライ: #keyword: TCP/IP リトライ
                パケットの送信がリトライされても、アプリケーションでは気にする必要はありません。
                再送前のデータと再送したデータの両方が受信されることはありません。
            重複パケットの削除:
                リトライによってパケットが重複して受信した場合、重複したパケットは捨てられます
            順序付け:  #// 送信した順序と同じ順序で受信します
                パケットの順序: パケットに分けて並列に送信するためパケットレベルでは順序が変わる可能性がありますが、
                    TCP/IPレベルでは送信した順序と同じ順序で受信します
                バイトストリームの順序性: TCP はデータが完全に送信されるまで次のデータを送信しません。
                    このため、送信するデータ（パケットではない）の送信順序も保証します。
        並列送信:
            別々の TCP コネクション（データストリーム）を使います
    UDP: #// 非同期、投げっぱなし
    上に乗るプロトコル:
        HTTP: #search:
            REST: #search: REST API
            RPC:
        HTTPS:
        SSH: #search: ssh
        SNMP: #keyword:  #// エスエヌエムピー
            ポート番号:  #keyword: SNMP port
                SNMP エージェント: 161 (UDP)
                SNMP マネージャー: 162 (UDP)
            Zabbix SNMP エージェント:  #search: Zabbix SNMP agent
            SNMP マネージャー: #keyword: SNMP マネージャー
                snmp_walk:  #// Linux コマンド
                SNMP のコマンド:
                    Get, GetNext, GetBulk, Set
            net-snmp:  #// snmpd, snmptrapd, snmpget, snmpwalk, snmpset を含むパッケージ
                構成:
                    snmptrap (CLI) --> snmptrapd
                    snmpd --> snmptrapd
            snmpd: #keyword: snmpd, SNMP エージェント  #// 監視される側のデーモン
                SNMP trap: #keyword:  #// 監視対象のホストにある SNMP エージェントがリクエストのオーナーとして Zabbix サーバーに通知します
                    コマンド:
                        snmptrap: #keyword:
                            ログを出力します。Zabbix はログを解析します。
                            snmpd と通信します。snmptrapd と通信するのは、snmpd 経由です。
                            #search: SNMP trap
                            #ref: https://qiita.com/mishikawan/items/4cd9192e38501b6dfc1c
                            #ref: http://cyberfortress.jp/2020/04/17/blog-zabbix-setup-snmptrap/
                ファイル:
                    snmpd.conf:
                        コメント: |
                            # を行頭に書きます
                        exec:
                            SNMPデーモンがSNMPリクエストを受け取ったときにのみ実行されるよう設計されています。具体的には：
                                SNMPクライアントがSNMPデーモンに対してOIDにアクセスするリクエストを送信します
                                そのOIDがexecディレクティブに関連付けられている場合、SNMPデーモンは指定されたコマンドを実行します
                                コマンドの出力結果がSNMPレスポンスとして返されます
                                コマンドの実行が完了すると、そのプロセスは終了します
                            つまり、execで指定されたプロセスはリクエスト時にのみ実行され、処理が完了すると終了します。常駐プロセスとして動作するわけではありません。
                            もし常駐するプロセスと連携したい場合は、passディレクティブやextendディレクティブなど
                    main.conf:  #ref: /etc/snmp/config.d/main.conf
                        ディレクティブ: #glossary: snmpd  #// /etc/snmp/config.d/main.conf の内容
                            com2sec:  #// IPv4 用。SNMPコミュニティ文字列を セキュリティ名にマッピングします
                                #// SNMP v1 v2c
                                書式: com2sec __SecurityName__ __SnmpRequestSource__ __CommunityString__
                                サンプル: |
                                    com2sec local     localhost       public
                                    com2sec mynetwork 192.168.1.0/24  mystring
                                __SecurityName__:
                                __CommunityString__: 平文のパスワードのようなもの?
                                    第三者に知られると、その第三者がネットワークデバイスの設定にアクセスしたり、デバイスの設定を変更したりできてしまう
                            com2sec6:  #// IPv6 用
                            proc:  #// プロセスを監視します。プロセスが停止していたら、SNMPマネージャへ通知（SNMPトラップ）します
                                書式: proc __ProcessName__ __MininumProcessCount__ __MaximumProcessCount__
                                __ProcessName__: ps -e で表示されるプロセス名
            snmptrapd:  #// 監視する側のデーモン ポート162
            MIB: #keyword:  #// ミブ  #ref: https://www.zabbix.com/documentation/5.4/en/manual/config/items/itemtypes/snmp/mibs
                概要: Management Information Base
                    監視内容に対応する OID のツリー構造を持つ
                    #ref: https://qiita.com/Tocyuki/items/9aaae3de2858b2bfed7d#mibについて
                通信: SNMP プロトコルで MIB の中の監視内容を転送します  #search: SNMP
                MIB のバージョン:
                    標準MIB:  #// RFCによって定義された業界標準の規格
                        現在のバージョン: MIB-2 (RFC 1213に基づくMIB-2/MIB-II)
                        ルートの場所(OID): iso.org.dod.internet.mgmt.mib-2（1.3.6.1.2.1）
                    拡張MIB:  #// メーカーや装置によって情報内容が異なります
                        ルートの場所(OID): iso.org.dod.internet.private.enterprises（1.3.6.1.4.1）
                        オペレーション: MIBのオペレーションは標準MIB・拡張MIBともに共通です
                        #ref: https://business.ntt-east.co.jp/bizdrive/column/dr00101-027.html
                OID: #keyword: MIB OID
                    概要: MIB ファイルで定義している(?)項目の１つ１つに割り当てられた ID。
                    OID ドット表記: 1.3.6.1.2.1
                    OID 文字列: iso.org.dod.internet.mgmt.mib-2
                    OID バイト表記: 01 02 03 04 10 (1.2.3.4.16)  #ref: https://tex2e.github.io/blog/protocol/oids
                MIB ファイル:
                    標準的な MIB ファイル: #keyword: MIB file
                        Linux のディストリビューションに入っています
                    カスタム MIB ファイル, 拡張 MIB ファイル: CISCO や f5 などのベンダーから提供されます
                        #ref: https://www.zabbix.com/documentation/6.0/jp/manual/config/items/itemtypes/snmp/mibs  >>  カスタム MIB ファイルを使用する
HTTP 通信: #keyword: HTTP
    HTTP ヘッダー: #keyword: HTTP header
        手順 >> 実装:  #// HTTP ヘッダー
            表示:
                curl コマンド: curl -i
                #// ブラウザーの開発者ツールでは、最初のリクエストについては見ることができません
            サンプル HTTP ヘッダー:  #// 本章は以下の設定の実装方法が書かれています
                Content-Security-Policy: default-src 'self'; script-src 'self' 'https://trusted.cdn.com'; style-src 'self' 'https://trusted.cdn.com';
                #template__: _
            Web サーバー サービス に設定する場合:
                Apache:
                    <IfModule mod_headers.c>
                        Header set Content-Security-Policy "default-src 'self'; script-src 'self' 'https://trusted.cdn.com'; style-src 'self' 'https://trusted.cdn.com';"
                    </IfModule>
                nginx:  #keyword: nginx  add_header
                    設定サンプル:
                        add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'https://trusted.cdn.com'; style-src 'self' 'https://trusted.cdn.com';";
                    設定後:
                        systemctl reload nginx
                    設定場所: |  #focus: add_header
                        http {
                            add_header X-Global-Header "Value";

                            server {
                                add_header X-Server-Header "Value";

                                location /specific-path {
                                    add_header X-Location-Header "Value";

                                    if ($request_method = POST) {
                                        add_header X-Condition-Header "Value";
                                    }

                                    limit_except GET {
                                        add_header X-Method-Header "Value";
                                    }
                                }

                                types {
                                    application/json    json;
                                    add_header X-JSON-Header "Value";
                                }
                            }
                        }
                Node.js (express): |
                    const express = require('express');
                    const app = express();

                    // ミドルウェアとしてのHTTPヘッダー設定
                    app.use((req, res, next) => {
                        res.setHeader("Content-Security-Policy", "default-src 'self'");
                        res.setHeader("X-Frame-Options", "DENY");
                        res.setHeader("X-Content-Type-Options", "nosniff");
                        res.setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains");
                        res.setHeader("Referrer-Policy", "no-referrer");
                        next();
                    });

                    // ルート設定
                    app.get('/', (req, res) => {
                        res.send('Hello, world!');
                    });

                    // サーバーを起動
                    app.listen(3000, () => {
                        console.log('Server running on port 3000');
                    });
            コードに設定する場合:
                HTML:
                    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://trusted.com; style-src 'self' 'https://trusted.cdn.com';">
                Python Django: |  #search: Django HTTP header
                    #snip:
                        class MyMiddleware:
                            def __call__(self, request):
                                response = self.get_response(request)
                                response['Content-Security-Policy'] = "default-src 'self'; script-src 'self' 'https://trusted.cdn.com'; style-src 'self' 'https://trusted.cdn.com';"
                                return response
        構成:
            リクエスト HTTP ヘッダー:  #glossary: HTTP request header
                Authorization:  #// 認証情報を送信
                Content-Type:  #// 送信するデータの形式を指定
                Accept:  #// 受け入れ可能なレスポンスの形式を指定
            レスポンス HTTP ヘッダー:  #glossary: HTTP response header
                Content-Security-Policy:  #search: Content-Security-Policy
                X-Frame-Options:  #// クリックジャッキング攻撃を防ぐ
                X-Content-Type-Options:  #// MIMEタイプのスニッフィングを防ぐ
                    概要:
                        MIMEスニッフィングを禁止するようにサーバーからブラウザーに要求します。
                        Content-Type を悪用すること（XSSの一種）を防ぎます。
                        #ref: https://e-words.jp/w/X-Content-Type-Options.html
                        #search: XSS
                    サンプル: |
                        X-Content-Type-Options: nosniff
                    設定方法:
                        #search: Django HTTP header
                    関連 >> MIMEスニッフィング: #keyword:
                        -   メディアタイプの指定が無い場合やサーバ管理者が指定を誤った場合などでもコンテンツを適切に処理できるようにするために行われ、
                            ファイル名の拡張子やデータ本体に含まれる特徴的なパターンなどからデータ形式を推測する。Content-Typeが指定されている場合でも無視する。
                            #ref: https://e-words.jp/w/X-Content-Type-Options.html
                        -   サーバーへファイルをアップロードする機能があるサイトでのみ問題が発生する可能性があります。
                            悪意のあるスクリプトを含む HTML ファイルを、別の拡張子(.jpeg .zip など)に偽装してアップロードし、
                            その .jpeg などのファイルをブラウザーで表示すると、推測した結果 HTML ファイルとして表示するため、
                            XSS 攻撃につながります。
                            #ref: https://www.keycdn.com/support/what-is-mime-sniffing
                    #ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
                Strict-Transport-Security:  #// HTTPS通信を強制する
                Referrer-Policy:  #// リファラー情報の送信を制御
                Etag:  #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/ETag
                    値: 675af34563dc-tr34 のようなコンテンツのバージョンを識別する文字列。
                        キャッシュを使うかどうかの判定に使われます。
                    nginx:
                        location ____ {
                            etag on;
                Expires:  #// 非推奨。有効期限  #ref: https://datatracker.ietf.org/doc/html/rfc7234#section-5.3
                    #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Expires
                    #search: nginx expires
                    Cache-Control に max-age があるとき: Expires は無視されます
                    日付形式の問題: |
                            実装ミスが多いため推奨されなくなった
                            Expires: Tue, 28 Feb 2022 22:22:22 GMT
                        #ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#expires_or_max-age
                レスポンス待ち: #keyword:
                    Loading state, Pending state, Busy state, busy polling, Processing state
            リクエストとレスポンスの両方:
                Cache-Control:  #// 両方にある場合の基本的な説明もここにあります
                    Cache-Control の場合、リクエストとレスポンスの両方に付けられますが、
                    使えるディレクティブに違いがあります。
                    #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Cache-Control#キャッシュディレクティブ
            値, ディレクティブ: |  #focus: __DirectiveName__  #// ヘッダーの種類によって値の形式も異なります
                -   __HttpHeaderFieldName__: __Value__
                -   __HttpHeaderFieldName__: __DirectiveName__=__Value__
                -   __HttpHeaderFieldName__: __DirectiveName__=__Value__, __DirectiveName__=__Value__
                -   __HttpHeaderFieldName__: __Value__, __DirectiveName__=__Value__
                -   __HttpHeaderFieldName__: __DirectiveName__ '__Value__'
                -   __HttpHeaderFieldName__: __DirectiveName__ '__Value__' '__Value2__'
                -   __HttpHeaderFieldName__: __DirectiveName__ '__Value__'; __DirectiveName__ '__Value__';
            その他:  #glossary: HTTP header
                Cache-Control: #keyword:  #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Cache-Control
                    サンプル: |
                        -   Cache-Control: no-cache, no-store
                        -   Cache-Control: max-age=0
                        -   Cache-Control: private, no-cache, no-store, must-revalidate, max-age=0
                    no-cache: #keyword: Cache-Control  no-cache  #// クライアント側に再利用するコピーを保存できます。毎回リクエストを出します
                        概要:
                            新鮮であるか必ずサーバーに確認します。
                            新鮮であればキャッシュにある内容を使って早く表示します。
                        max-age=0 との関係:
                            内容: max-age=0, must-revalidate 相当
                            慣習: no-cache がしばらく実装されなかったため、max-age がよく使われます
                                #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Caching#強制的な再検証
                    no-store: #keyword: Cache-Control  no-store  #// クライアント側に再利用するコピーを保存できません。毎回リクエストを出します
                        コンテンツキャッシュ（CDN）にキャッシュさせません
                        ブラウザーが動いている PC のストレージに保存しません。
                        （過去に Chrome に保存されてしまうバグがあった。no-cache, no-store を使うとよい） #search: Cache-Control Chrome no-store
                    max-age: #keyword: Cache-Control  max-age
                        キャッシュの有効期限（新鮮な期間）が __MaxAge__ 秒 という設定です。すなわち、____秒間コンテンツがキャッシュされた後は強制的にオリジンサーバーを参照しにいきます。
                        ブラウザーが動いている PC のストレージに保存される可能性があります。
                        #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Cache-Control#レスポンスディレクティブ
                        #ref: https://blog.idcf.jp/entry/cdn2
                        #search: max-age=0
                        #search: no-cache
                    max-age=0: #keyword: Cache-Control  max-age=0
                        no-cache の代わり
                        #ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#max-age_2
                    戻るボタン:
                        #keyword: Cache-Control Chrome no-store
                        -   no-cache, no-store の場合、戻るボタンを押してもリロードされます。
                            （過去に Chrome に保存されてしまうバグがあった。no-cache, no-store を使うとよい）
                            #ref: https://stackoverflow.com/questions/29075375/cache-control-max-age-0-no-cache-but-browser-bypasses-server-query-and-hits
                            #ref: https://code.google.com/p/chromium/issues/detail?id=28035
                        -   （別の意見）
                            戻るボタンを使用するときにキャッシュ制御ヘッダーを無視することが推奨される動作です。
                            #ref: https://stackoverflow.com/questions/29075375/cache-control-max-age-0-no-cache-but-browser-bypasses-server-query-and-hits
                    関連フィールド:
                        #search: Etag HTTP response header
                        #search: Expires HTTP response header
                    参考:
                        ブラウザでリロードしながらキャッシュの挙動を確認してる全ての開発者へ:
                            #ref: https://blog.jxck.io/entries/2023-11-05/reload-and-cache.html
                X-Forwarded-For: #keyword: X-Forwarded-For, XFF  #// プロキシ（ロード バランサー）が追加するクライアントの IP アドレスと、プロキシの IP アドレス
                    書式: |
                        - X-Forwarded-For: __Client1__, __Proxy1__
                        - X-Forwarded-For: __Client1__, __Proxy1__, __Proxy2__, ...
                    セキュリティ:
                        改ざん: プロキシによる改ざんが簡単
                        漏洩: X-Forwarded-For を削除しないと、社内の IP アドレス が漏洩する
                    参考:
                        #ref: https://ja.wikipedia.org/wiki/X-Forwarded-For
                        #ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For
            独自ヘッダー:  #// X- ヘッダー
                X- は非推奨になりました:
                    私的な独自のヘッダーは、以前は X- 接頭辞を使用していましたが、この慣習は 2012 年 6 月の RFC 6648 で非推奨になりました
                    #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Headers
    HTTPS: #keyword:
        自己署名証明書: #search:
    HTTP/2, HTTP/3: #keyword:
        HTTP/3: #keyword:
            TCP と TLS を QUIC に置き換え
            プロトコルの部分も暗号化
            経路の QUIC のバージョンアップが不要に
            #ref: https://gigazine.net/news/20231009-http-3-quic-eating-world/
    HTTP リクエストを送るツール:  #glossary:  #keyword: HTTP request tool
        cURL (curl): #keyword: cURL  #// 読みは「カール」Client for URLs  #ref: https://curl.se/docs/faq.html#What_is_cURL >> curl0001.wav
            #// カールとは読めないので cURL が正規であることを示した後は curl と表記する。公式も同様  #ref: https://curl.se/docs/faq.html
            公式:
                #ref: https://github.com/curl/curl
                #ref: https://curl.se/docs/manpage.html
            Linux版:  #// CentOS7
                手順:
                    基本:
                        curl  http://example.com  #// HTTP の GET メソッドを送信します。標準出力に出力します
                    ダウンロード:
                        curl -O __URL__
                        curl -o "__SavePath__" __URL__
                    ダウンロードして先頭も表示します: |  #keyword: curl download echo head
                        file_name="____.zip"  &&  curl -O http://example.com/files/${file_name}  &&  echo "Response: $( head -c 50 ${file_name} )"
                    proxy を使わない:  #// 一部の送信先に対してプロキシに問い合わせをしないで送信します
                        --noproxy オプション:
                            curl -X POST -d 'json={"json":"message"}' http://192.168.33.1:8888/debug.test --noproxy "192.168.33.1"
                    POST メソッド: |  #keyword: curl POST,  curl JSON,  curl body,  Content-Type:application/json
                        curl -X POST  -i  http://example.com  -H "Content-Type:application/json"  -d '{"command": "save"}'
                    クエリーパラメーター:  #// URL の ? より右  #keyword: curl bash query parameter
                        パラメーターを区切る & をプロセス制御として解釈されないように \& に変えて指定します:
                            curl  http://localhost:8500/____?recurse\&pretty
                        pretty:  #keyword: curl pretty
                            内容: インデントを入れた JSON を表示します。多くの HTTP API で採用されています
                            コマンド例: curl  http://____?pretty
                    ベーシック認証しながら, -u, --user オプション: #keyword: curl user  #// ベーシック認証しながら HTTP アクセスします
                        コマンドにパスワードを指定する場合:
                            curl  -k  -u "__User__:__Password__"  https://____
                            curl  --insecure  --user "__User__:__Password__"  https://____
                        curl 実行時にパスワードを入力する場合:  #// 未確認
                            curl  -k  -u ":"  https://____
                    ACL 疎通確認 (cURL): #keyword:  #// 指定した IP アドレスのサーバーが存在するか、またはサーバーまでの経路の途中で拒否されていないかを確認します
                        注意: 必要なら ミラー サーバー も確認してください
                        # ↓状況と動き
                        サーバー到達済み:
                            ポート open:
                                サービス listen: |  #// ポートが開いていてサービスがリッスンしているときの動き
                                    $ curl --insecure --verbose 'https://__IP_Address__/api'  #// パスワードなし
                                    * About to connect() to __IP_Address__ port 443 (#0)
                                    *   Trying __IP_Address__...
                                    * Connected to __IP_Address__ (__IP_Address__) port 443 (#0)
                                        （以下略）
                                サービス stop: |  #// ポートは開いているがサービスが起動していないときの動き
                                    *   Trying 127.0.0.1... Connection refused <- 接続拒否
                            ポート close: |  #// ポートが開いていないときの動き。下記 3990 はポート番号。ポートが開いていないのはファイアウォールの設定
                                $ curl --insecure --verbose 'https://__IP_Address__/api'  #// パスワードなし
                                * About to connect() to __IP_Address__ port 443 (#0)
                                *   Trying __IP_Address__...
                                    （120秒後）
                                * Connection timed out
                                * Failed connect to __IP_Address__:443; Connection timed out
                                * Closing connection 0
                                curl: (7) Failed connect to __IP_Address__:443; Connection timed out
                        サーバー未到達:
                            プロキシ未設定: |
                                $ curl https://__FQDN__
                                curl: (7) Failed to connect to __FQDN__ port 443: No route to host
                                または
                                [Errno 14] curl#7 - \"Failed to connect to 2600:____:____:____:3:____:____:____: Network is unreachable\""
                            FQDN の指定ミス: |  #// DNS に登録されていないとき
                                $ curl https://__FQDN__
                                curl: (6) Could not resolve host: __FQDN__
                        #↓ 疎通確認
                        ポートの疎通確認:
                            -v オプションで詳細を表示します:
                            開いているとき: |  #focus: (35), など
                                curl --insecure https://192.168.34.21:8080
                                    curl: (35) SSL connect error
                            閉じているとき: |  #focus: (7)
                                curl --insecure https://192.168.34.21:99
                                    curl: (7) couldn't connect to host
                            プロキシが邪魔しているとき:  #// --noproxy オプションで疎通できることが多いです
                                curl --insecure http://192.168.34.21:8080
                                    （止まったまま）
                                curl --insecure --noproxy "*"  http://192.168.34.21:8080
                        関連 >> telnet による疎通確認:  #// 待たされません  #search: Linux telnet port
                    リトライ: #keyword: curl retry
                        while true; do
                            curl ____  &&  break
                            sleep  1s
                        done
                コマンド: #keyword: curl options
                    基本:
                        curl  http://example.com  #// HTTP の GET メソッドを送信します。標準出力に出力します
                    -k, --insecure オプション:  #// セキュアでないというエラーを無視して実行します
                        サンプル:  #search: curl user
                    -d, --data, --data-binary オプション:  #// ペイロードや JSON も指定します  #keyword: curl payload data
                        コマンド内:
                            サンプル: |
                                curl -X GET http://localhost:9200/logs-my_app-default/_search  -H "Content-Type: application/json" -d '{
                                        "query": {
                                            "match_all": { }
                                        }
                                    }'
                        ファイル内:
                            テキスト ファイル:
                                --data @__FilePath__
                            バイナリ ファイル:
                                --data-binary @__FilePath__
                    -O オプション: #keyword: curl -O,  cURL download  #// 標準出力ではなくファイルに保存します
                        -   curl -L  "http://example.com/index.html"  --output "index.html"  #// --output オプションにはフォルダーのパスを指定できません
                        -   curl -LO  "http://example.com/index.html"  #// ./index.html ファイルができます
                    -J オプション: #keyword; curl -J   #// -O オプションと一緒に使い、ファイル名を HTTP ヘッダー の Content-Disposition に変更します
                    -i オプション: #//🌟 ヘッダー情報と ステータス コード も表示します
                    -f, --fail オプション: #// HTTPステータスコードが 400以上（エラー）の場合、curl は終了コード 22 を返します
                    -s, --silent オプション: #// スピード表示をしないようにします
                        サンプル: curl -s  http://example.com  | grep "Example Domain"
                        スピード表示の例: |
                            . % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                                            Dload  Upload   Total   Spent    Left  Speed
                            100  1256  100  1256    0     0   5774      0 --:--:-- --:--:-- --:--:--  5788
                    -L, --location オプション:  #// リダイレクトがあったらリダイレクト先をダウンロードします
                        #ref: https://curl.se/docs/manpage.html#-L
                    -H オプション: #// ヘッダーを指定します  #search: curl payload data
                    --connect-timeout オプション: #// 接続するまでのタイムアウト
                        --connect-timeout __Seconds__
                    --max-time オプション: #keyword: curl time out  #// レスポンスするまでのタイムアウト
                        --max-time __Seconds__
                        #ref: https://unix.stackexchange.com/questions/94604/does-curl-have-a-timeout
                    --unix-socket オプション: #keyword: curl --unix-socket  #// HTTP の代わりに Unix ソケット を使います
                        curl  --unix-socket /run/example/socket http://localhost:0/api/customers
                    -v, --verbose オプション:
                        #ref: https://curl.se/docs/manpage.html#-v
            PowerShell版:
                Invoke-WebRequest:  #// このエイリアスが curl
                サンプル:
                    Invoke-WebRequest  https://github.com/Takakiriy/typrm/archive/refs/heads/main.zip -OutFile "typrm.zip"
                    curl  -Method Post  -Body 'param1=value1&param2=value2'  http://httpbin.org/post
                エラー Use -UseBasicParsing: #keyword: Invoke-WebRequest -UseBasicParsing
                    手順: curl (PowerShell 5.x)
                    ログ: |
                        Security Warning: Script Execution Risk
                        Invoke-WebRequest parses the content of the web page. Script code in the web page might be run when the page is parsed.
                            RECOMMENDED ACTION:
                                Use the -UseBasicParsing switch to avoid script code execution.
                        Do you want to continue?
                        [Y] はい(Y)  [A] すべて続行(A)  [N] いいえ(N)  [L] すべて無視(L)  [S] 中断(S)  [?] ヘルプ (既定値は "N"):
                    対処:
                        curl -UseBasicParsing ____
                    #ref: https://www.say-tech.co.jp/contents/blog/yamanxworld/2025news051
            Docker版:  #// curl だけを使えるコンテナー
                curl docker: #keyword:  #ref: https://hub.docker.com/r/curlimages/curl
                    multi_vm_ansible >> branch_docker:
                        #search: multi_vm_ansible
                    (@node1):
                        共通:
                            #search: docker sudo
                            - docker pull curlimages/curl
                            - docker run --rm curlimages/curl:7.82.0 --version
                        PROXY が無い場合:
                            - docker run --rm  curlimages/curl:7.82.0  -v -L https://curl.haxx.se
                        PROXY が有る場合:
                            - docker run --rm  --env HTTPS_PROXY=____  curlimages/curl:7.82.0  -v -L https://curl.haxx.se
            トラブルシューティング:
                - #// Docker コンテナーの中で疎通できなくなった。今まで疎通できていたが、Docker ホストの DNS や iptables などの変更があったらしい
                    手順とログ: |  #keyword: curl time out in docker
                        #// コンテナ―内は NG
                        $ docker exec -it __ContainerName__ bash
                            root@ff410888f2bc:/# curl https://server1.example.com/api/v4/
                                （長時間停止）^C
                            root@ff410888f2bc:/# curl -k https://100.100.100.100/api/v4/
                                （長時間停止）^C
                            root@ff410888f2bc:/# curl https://100.100.100.100/api/v4/
                                （長時間停止）^C
                        コンテナ―外は OK
                        $ curl -k https://server1.example.com/api/v4/
                            {"error":"404 Not Found"}  疎通できている OK
                        $ curl  https://server1.example.com/api/v4/
                            {"error":"404 Not Found"}  疎通できている OK
                        $ curl -k https://100.100.100.100/api/v4/
                            curl: (56) Received HTTP code 403 from proxy after CONNECT
                        $ curl -v -k https://100.100.100.100/api/v4/
                            詳細
                    対処:
                        docker サービスの再起動:
                            sudo systemctl restart docker
                        Docker コンテナ―の再起動:
                - #// curl を呼ぶと疎通できるようになる
                    対処:
                        未確認
                        #ref: ${typrm_files}/ref/HTML-AI.yaml#label: TCP/IP retry
                - #// SSL: no alternative certificate subject name matches target host name
                    手順: curl https://100.100.100.100/api/v4/
                    ログ: |
                        curl: (60) SSL: no alternative certificate subject name matches target host name '100.100.100.100'
                        More details here: https://curl.haxx.se/docs/sslcerts.html

                        curl failed to verify the legitimacy of the server and therefore could not
                        establish a secure connection to it. To learn more about this situation and
                        how to fix it, please visit the web page mentioned above.
                    原因:
                        このSSL証明書エラーは、IPアドレスでアクセスしているため証明書のサブジェクト名（通常はドメイン名）
                        と一致しないことが原因です。
                    対処:  #// 緊急時
                        curl -k https://100.100.100.100/api/v4/
                #search: network trouble shooting
                #search: sudo trouble shooting
        wget:  #search: curl
        http: | #keyword: http command, http command is not curl
            http example.com:8888/api/v1/schedule
            http PUT example.com:8888/api/v1/schedule spec='*/10 * * * *'
                curl -X PUT example.com:8888/api/v1/schedule -d "spec=*/10 * * * *"
                curl -X PUT example.com:8888/api/v1/schedule -d "spec=*/10 * * * *" -H "Content-Type: application/x-www-form-urlencoded"
                curl -X PUT example.com:8888/api/v1/schedule -d '{"spec": "*/10 * * * *"}' -H "Content-Type: application/json"
        Talend API Tester:  #keyword: Talend API Tester
            GET メソッドを発行して HTTP ヘッダーを確認します: #keyword: Talend API Tester GET
                インストールします:  #keyword: install Talend API Tester
                    URL: https://chrome.google.com/webstore/detail/talend-api-tester-free-ed/aejoelaoggembcahagimdiliamlcdmfm?hl=ja
                    Chrome に追加 ボタン:
                開きます:  #// Talend API Tester を開きます
                    メニュー: Chrome >> 拡張機能（右上のジグソーパズル アイコン） >> Talend API Tester
                    （初回のみ）Use Talend API Tester – Free Edition ボタン:
                GET メソッドを発行します:
                    METHOD（左上）: GET, https://____
                    Send ボタン（右上）:
                HTTP ヘッダーを確認します:
                    HTTP タブ（下半分）
            POST メソッドをテスト発行します:
                参考:
                    - https://qiita.com/ktr1211/items/c16cb4f99f91b998af46
                Talend API Tester のインストールと起動:
                    #search: install Talend API Tester
                POST メソッド発行:
                    METHOD（左上）: POST, https://____
                    BODY（右下）:
                        メニュー: Text（右）を Form に変更 >> Add form parameter ボタン
                        name: ____
                        text: ____
                    Send ボタン（右上）:
                    応答メッセージは HTTP タグに表示されます:
        Postman:
            （書きかけ）Postman で POST メソッドをテスト発行します:
                参考: https://kekaku.addisteria.com/wp/20180606063858
                インストール:
                    ダウンロード版:
                        URL: https://www.postman.com/downloads/ >> Download the App >> Windows 64-bit >>
                            Postman-win64-7.36.1-Setup.exe
                        アカウントを持っていない場合（未確認）:
                            ユーザー名: ____
                            メールアドレス: ____
                            パスワード: ____
                        アカウントを持っている場合:
                            Sign in with Single Sign-On (SSO) ボタン:
                            Sign in with Google or a Passowrd ボタン:
                        #// C:\Users\____\AppData\Local\Postman\Postman.exe にインストールされます
                    （書きかけ）Web 版:
                        URL: https://www.postman.com/
                        ユーザー名: ____
                        メールアドレス: ____
                        パスワード: ____
                        Create free account ボタン:
                        What's your name?: ____
                        Which of these roles is closest to yours?: ____
                        Continue ボタン:
                        Continue Without a Team ボタン:
    プロトコル:
        101 Switching Protocols: #keyword:  #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Status/101
            注意: HTTP2 では禁止です。HTTP 1.1 で使えます
            概要: 主に HTTP から WebSocket にプロトコルを切り替えるために使います。WebSocket ハンドシェイク と呼ばれます
                #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Status/101
                #ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Protocol_upgrade_mechanism
            WebSocket ハンドシェイク: #keyword:
                #ref: https://developer.mozilla.org/ja/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#websocket_ハンドシェイク
                TCP	66	58888 → 8000 [ACK] Seq=1 Ack=1 Win=29312 Len=0
                HTTP	260	GET /echo HTTP/1.1 
                        TCP	66	8000 → 58888 [ACK] Seq=1 Ack=195 Win=15616 Len=0
                        HTTP	195	HTTP/1.1 101 Switching Protocols 
                TCP	66	58888 → 8000 [ACK] Seq=195 Ack=130 Win=30336 Len=0
                WebSocket	87	WebSocket Text [FIN] [MASKED]
    HTTP サーバー:  #search: HTTP server
    モックサーバー: #keyword: Web API モック サーバー
        json-server: #keyword:  #// Node.js 用
            #ref: https://www.webprofessional.jp/mock-rest-apis-using-json-server/
        Mock Service Worker: #keyword:  #// Node.js 用
            #ref: https://github.com/mswjs/msw
            #ref: https://zenn.dev/ryo_kawamata/articles/mock-api-server-with-msw
        WireMock: #keyword:  #// Java 用, Docker 用
            公式:
                トップ: #ref: http://wiremock.org/
                MockLab 社: #ref: https://get.mocklab.io/
                    Start Mocking Now: Web API 呼び出しのパラメーターを設定する画面（ブラウザー内）
            概要:
                内部開発した Web API サーバーはモックにせず、外部 Web API サーバーをモックにするとよいでしょう:
            手順:  #// インストールなど
                基本:  #// インストール。モックに対して Web API を呼び出します
                    Docker イメージの WireMock を使う場合:  #keyword: WireMock Docker
                        公式 + docker コマンド の場合:
                            #ref: https://hub.docker.com/r/wiremock/wiremock
                            WSL2 と docker をインストールします:
                                #search: install Docker
                            Docker 版 WireMock を起動します:
                                HTTP の場合:
                                    mkdir -p  $HOME/WireMock/mappings
                                    docker run -it --rm  -p 8080:8080  -v $HOME/WireMock:/home/wiremock  wiremock/wiremock
                                HTTPS の場合:
                                    mkdir -p  $HOME/WireMock/mappings
                                    docker run -it --rm  -p 8443:8443  -v $HOME/WireMock:/home/wiremock  wiremock/wiremock  --https-port 8443
                                サンプル:
                                    #search: WireMock mappings basic
                            参考:
                                本家:
                                    バイナリ: #ref: https://hub.docker.com/r/wiremock/wiremock
                                    コード: #ref: https://github.com/wiremock/wiremock-docker
                                    バイナリ DEPRECATED: #ref: https://hub.docker.com/r/rodolpheche/wiremock
                                参考: #ref: https://qiita.com/nkg/items/0c391b7211286c7cbe41
                        公式 + docker-compose.yml の場合:
                            プロジェクト:
                                extension なし, try_WireMock_1: #keyword:  #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMock_1/README.yaml
                                レスポンス テンプレート有効, try_WireMockResponseTemplate: #keyword:  #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockResponseTemplate/README.yaml
                                    #search: WireMock response-template
                                extension あり, try_WireMockExtension: #keyword: try_WireMockExtension  #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockExtension/README.yaml
                                    エクステンションのバイナリ（.jar ファイル）をダウンロードして使うサンプル
                                    関連 >> エクステンションのビルド  #search: build WireMock extension
                                extension ソース, try_WireMockExtensionSource: #keyword: try_WireMockExtensionSource  #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockExtensionSource/README.yaml
                                    Maven 使用:  #search: Maven
                            Docker をインストールします:  #search: install Docker
                            __Project__/docker-compose.yml: |
                                wiremock:
                                    image: wiremock/wiremock:2.32.0
                                    command: --https-port 8443
                                    ports:
                                        -   "8080:8080"
                                        -   "8443:8443"
                                    volumes:
                                        -   "../mock:/home/wiremock"  #// ../mock/mappings に mappings フォルダーがある場合
                            #// volumes の値は編集してください
                            サンプル API:  #search: WireMock example
                        自作の場合:
                            __Project__/Dockerfile:
                                FROM  centos:7
                                RUN \
                                    yum install -y \
                                        java  && \
                                    mkdir -p ~/Downloads/wiremock  && \
                                    cd       ~/Downloads/wiremock  && \
                                    curl -O  https://repo1.maven.org/maven2/com/github/tomakehurst/wiremock-jre8-standalone/2.33.2/wiremock-jre8-standalone-2.33.2.jar
                                CMD \
                                    cd ~/Downloads/wiremock  && \
                                    java -jar  wiremock-jre8-standalone-2.33.2.jar  -port 8080
                                EXPOSE 8080/tcp
                            __Project__/mappings:
                                #search: Wiremock mappings-1
                            bash:
                                -   cd __Project__  #// not example folder
                                -   docker build  -t temporary-image:1  "."  &&  docker run -it --rm  -p 8080:8080  -v $(pwd)/mappings:/root/Downloads/wiremock/mappings  --name temporary_1 temporary-image:1
                            新しい bash:
                                curl localhost:8080/hello
                    Java を使うスタンドアローン版 WireMock を使う場合:
                        インストール:  #keyword: install WireMock
                            Java をインストールします:  #// ←インストールしていなければ
                                #search: install Java
                            WireMock のパッケージの URL をコピーします:  #// 以下、その URL を __WireMockURL__ とします
                                メニュー: http://wiremock.org/docs/download-and-installation/ >> Direct download（最も下）>> 右クリック >> リンクのコピー
                                例: https://repo1.maven.org/maven2/com/github/tomakehurst/wiremock-jre8-standalone/2.33.2/wiremock-jre8-standalone-2.33.2.jar
                                    https://repo1.maven.org/maven2/com/github/tomakehurst/wiremock-jre8-standalone/2.27.2/wiremock-jre8-standalone-2.27.2.jar
                                    #// URL に wiremock-jre8 が含まれていたら、Java 8 用です
                            ダウンロードします:
                                # 新しい bash
                                mkdir -p ~/Downloads/wiremock
                                cd       ~/Downloads/wiremock
                                curl -O  __WireMockURL__
                        WireMock を起動します:  #keyword: start WireMock
                            新しい bash:
                                cd  ~/Downloads/wiremock
                                java -jar  wiremock-jre8-standalone-2.33.2.jar  -port 8080
                                #template: java -jar  __WireMockJar__  -port __PortNum__
                                #参考: http://wiremock.org/docs/running-standalone/
                            成功したときの出力: |
                                LF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
                                SLF4J: Defaulting to no-operation (NOP) logger implementation
                                SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
                                /$$      /$$ /$$                     /$$      /$$                     /$$      
                                | $$  /$ | $$|__/                    | $$$    /$$$                    | $$      
                                | $$ /$$$| $$ /$$  /$$$$$$   /$$$$$$ | $$$$  /$$$$  /$$$$$$   /$$$$$$$| $$   /$$
                                | $$/$$ $$ $$| $$ /$$__  $$ /$$__  $$| $$ $$/$$ $$ /$$__  $$ /$$_____/| $$  /$$/
                                | $$$$_  $$$$| $$| $$  \__/| $$$$$$$$| $$  $$$| $$| $$  \ $$| $$      | $$$$$$/ 
                                | $$$/ \  $$$| $$| $$      | $$_____/| $$\  $ | $$| $$  | $$| $$      | $$_  $$ 
                                | $$/   \  $$| $$| $$      |  $$$$$$$| $$ \/  | $$|  $$$$$$/|  $$$$$$$| $$ \  $$
                                |__/     \__/|__/|__/       \_______/|__/     |__/ \______/  \_______/|__/  \__/

                                port:                         8080
                                enable-browser-proxying:      false
                                disable-banner:               false
                                no-request-journal:           false
                                verbose:                      false
                        API のモックの内容を手動で設定します: #keyword: WireMock example
                            /hello の API を定義します（サンプル）:
                                mappings/user.json に書く場合:  #keyword: WireMock mappings-1
                                    ~/Downloads/wiremock/mappings/hello.json: |  #// ファイル名は任意です。URL の一部に合わせなくてもいいです
                                        {
                                            "request": {
                                                "method": "GET",
                                                "url": "/hello"
                                            },
                                            "response": {
                                                "status": 200,
                                                "body": "More content\n"
                                            }
                                        }
                                    #// url の末尾の / の有無は厳密に合わせる必要があります
                                    #// 以下に続きます
                                API を使って定義する場合:
                                    リセットします:
                                        METHOD: POST
                                        URI: http://localhost:8080/__admin/mappings/reset
                                            #// user.json に定義されていない古い API は削除されます
                                    追加します:
                                        METHOD: POST
                                        URI: http://localhost:8080/__admin/mappings
                                        BODY: |
                                            {
                                                "request": {
                                                    "method": "GET",
                                                    "url": "/hello"
                                                },
                                                "response": {
                                                    "status": 200,
                                                    "body": "More content\n"
                                                }
                                            }
                                    #// 登録した内容は、.jar ファイルがあるフォルダーの中の mapping フォルダーの中に格納されます（未確認）
                                    #// 以下に続きます
                            ブラウザーからアクセスする場合:
                                定義した API にアクセスします:
                                    http://localhost:8080/hello
                                API を一覧します:
                                    URL を一覧する場合:
                                        ドメイン名より右に間違ったURLを書いてアクセスします:
                                            例: http://localhost:8080/not-found
                                                #// 404 エラーになりますが一覧が表示されます
                            curl コマンドでアクセスする場合:
                                curl -X GET  http://localhost:8080/hello
                tcpdump + WireMock (HTTP): #keyword: tcpdump Web API example  #// 例：Zabbix の Web API 呼び出しを tcpdump でキャプチャーして WireMock でサーバーのモックを作ります
                    概要:
                        キャプチャーできる内容:  #search: tcpdump Web API output example
                        モックの定義内容:  #search: tcpdump Web API mappings example
                    準備:
                        Zabbix のサンプル VM をインストールをします:
                            サンプル: #ref: ${GitHub}/MyPrivateCode/ansible_vagrant/multi_vm_ansible/branch_zabbix
                            手順: #search: .git.zip checkout
                        API の呼び出し元に tcpdump をインストールします:
                            (@control): sudo yum install -y  tcpdump
                    API 呼び出しをキャプチャーします:
                        （メモ）実際の開発で行うときのヒント:
                            同時立ち上げ: 可能なら、開発環境とサーバー環境を同時に立ち上げて作業します。
                            開発環境: デバッグ環境などリクエストをキャプチャーする環境のことです。
                                開発環境では下記 curl コマンドの代わりに、リクエストを出すプログラムを実行します
                            サーバー環境: 実際の通信相手のサーバーがいるレスポンスをキャプチャーする環境のことです。
                        開始:  #// tcpdump コマンドでキャプチャーを開始します
                            (@control): sudo tcpdump -nn -i eth1  port 80 -A
                        キャプチャー:  #// API 呼び出しを実行してキャプチャーします
                            送信側:
                                新しい bash (@control/2): |  #search: Zabbix API user.login
                                    curl -X GET -i -d '{
                                        "jsonrpc": "2.0",
                                        "method": "user.login",
                                        "params": {
                                            "user": "Admin",
                                            "password": "zabbix"
                                        },
                                        "auth": null,
                                        "id": 1
                                    }' -H "Content-Type: application/json-rpc"  'http://zabbix1/zabbix/api_jsonrpc.php'
                            受信側:
                                （キャプチャーした内容）
                        終了:  #// キャプチャーを終了します
                            (@control): Ctrl + C キー
                        内容確認:  #// キャプチャー中に表示された内容を確認します  #keyword: tcpdump Web API output example
                            リクエスト: |  #// 下記出力のうち、HTTP リクエストの内容  #focus: /zabbix/api_jsonrpc.php,  user.login
                                GET /zabbix/api_jsonrpc.php HTTP/1.1
                                User-Agent: curl/7.29.0
                                Host: zabbix1
                                Accept: */*
                                Content-Type: application/json-rpc
                                Content-Length: 160

                                {
                                    "jsonrpc": "2.0",
                                    "method": "user.login",
                                    "params": {
                                        "user": "Admin",
                                        "password": "zabbix"
                                    },
                                    "auth": null,
                                    "id": 1
                                }
                            レスポンス: |  #// 下記出力のうち、HTTP レスポンスの内容
                                HTTP/1.1 200 OK
                                Date: Thu, 16 Jun 2022 05:00:16 GMT
                                Server: Apache/2.4.6 (CentOS) PHP/5.4.16
                                X-Powered-By: PHP/5.4.16
                                Access-Control-Allow-Origin: *
                                Access-Control-Allow-Headers: Content-Type
                                Access-Control-Allow-Methods: POST
                                Access-Control-Max-Age: 1000
                                Content-Length: 68
                                Content-Type: application/json

                                {"jsonrpc":"2.0","result":"4978d94b7308230c1a13c0f33dad75b5","id":1}
                            出力全体: |  #focus: jsonrpc
                                tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
                                listening on eth1, link-type EN10MB (Ethernet), capture size 262144 bytes
                                05:00:16.474802 IP 192.168.33.59.47784 > 192.168.33.61.80: Flags [S], seq 3966650554, win 29200, options [mss 1460,sackOK,TS val 246170 ecr 0,nop,wscale 7], length 0
                                E..<. @.@.....!;..!=...P.nH.......r............
                                ............
                                05:00:16.475839 IP 192.168.33.61.80 > 192.168.33.59.47784: Flags [S.], seq 736612421, ack 3966650555, win 28960, options [mss 1460,sackOK,TS val 251864 ecr 246170,nop,wscale 7], length 0
                                E..<..@.@.v...!=..!;.P..+..E.nH...q .=.........
                                ............
                                05:00:16.475857 IP 192.168.33.59.47784 > 192.168.33.61.80: Flags [.], ack 1, win 229, options [nop,nop,TS val 246172 ecr 251864], length 0
                                E..4.!@.@.....!;..!=...P.nH.+..F...........
                                ........
                                05:00:16.476782 IP 192.168.33.59.47784 > 192.168.33.61.80: Flags [P.], seq 1:311, ack 1, win 229, options [nop,nop,TS val 246172 ecr 251864], length 310: HTTP: GET /zabbix/api_jsonrpc.php HTTP/1.1
                                E..j."@.@.....!;..!=...P.nH.+..F.....%.....
                                ........GET /zabbix/api_jsonrpc.php HTTP/1.1
                                User-Agent: curl/7.29.0
                                Host: zabbix1
                                Accept: */*
                                Content-Type: application/json-rpc
                                Content-Length: 160

                                {
                                    "jsonrpc": "2.0",
                                    "method": "user.login",
                                    "params": {
                                        "user": "Admin",
                                        "password": "zabbix"
                                    },
                                    "auth": null,
                                    "id": 1
                                }
                                05:00:16.479340 IP 192.168.33.61.80 > 192.168.33.59.47784: Flags [.], ack 311, win 235, options [nop,nop,TS val 251866 ecr 246172], length 0
                                E..4..@.@.o_..!=..!;.P..+..F.nI.....+......
                                ........
                                05:00:16.564314 IP 192.168.33.61.80 > 192.168.33.59.47784: Flags [P.], seq 1:387, ack 311, win 235, options [nop,nop,TS val 251951 ecr 246172], length 386: HTTP: HTTP/1.1 200 OK
                                E.....@.@.m...!=..!;.P..+..F.nI............
                                .../....HTTP/1.1 200 OK
                                Date: Thu, 16 Jun 2022 05:00:16 GMT
                                Server: Apache/2.4.6 (CentOS) PHP/5.4.16
                                X-Powered-By: PHP/5.4.16
                                Access-Control-Allow-Origin: *
                                Access-Control-Allow-Headers: Content-Type
                                Access-Control-Allow-Methods: POST
                                Access-Control-Max-Age: 1000
                                Content-Length: 68
                                Content-Type: application/json

                                {"jsonrpc":"2.0","result":"4978d94b7308230c1a13c0f33dad75b5","id":1}
                                05:00:16.564335 IP 192.168.33.59.47784 > 192.168.33.61.80: Flags [.], ack 387, win 237, options [nop,nop,TS val 246260 ecr 251951], length 0
                                E..4.#@.@.....!;..!=...P.nI.+..............
                                ......./
                                05:00:16.564934 IP 192.168.33.59.47784 > 192.168.33.61.80: Flags [F.], seq 311, ack 387, win 237, options [nop,nop,TS val 246261 ecr 251951], length 0
                                E..4.$@.@.....!;..!=...P.nI.+..............
                                ......./
                                05:00:16.567781 IP 192.168.33.61.80 > 192.168.33.59.47784: Flags [F.], seq 387, ack 312, win 235, options [nop,nop,TS val 251956 ecr 246261], length 0
                                E..4..@.@.o]..!=..!;.P..+....nI.....(......
                                ...4....
                                05:00:16.567792 IP 192.168.33.59.47784 > 192.168.33.61.80: Flags [.], ack 388, win 237, options [nop,nop,TS val 246263 ecr 251956], length 0
                                E..4.%@.@.....!;..!=...P.nI.+..............
                                .......4
                                ^C
                                10 packets captured
                                10 packets received by filter
                                0 packets dropped by kernel
                    モックを作ります:
                        WireMock の mappings ファイルを作ります:
                            参考:
                                基本形:  #search: WireMock mappings basic
                                リクエストのマッチング:  #search: WireMock request matching
                                レスポンスの内容:  #search: WireMock response
                            内容:  #keyword: tcpdump Web API mappings example  #// 作る mappings ファイルの内容  #focus: /zabbix/api_jsonrpc.php,  user.login,  4978d94b7308230c1a13c0f33dad75b5
                                {
                                    "mappings": [
                                        {
                                            "request": {
                                                "method": "GET",
                                                "url": "/zabbix/api_jsonrpc.php",
                                                "bodyPatterns" : [ {
                                                    "method": "user.login",
                                                    "ignoreExtraElements" : true,
                                                } ]
                                            },
                                            "response": {
                                                "status": 200,
                                                "headers": {
                                                    "Content-Type": "application/json"
                                                },
                                                "body": "{\"jsonrpc\":\"2.0\",\"result\":\"4978d94b7308230c1a13c0f33dad75b5\",\"id\":1}"
                                            }
                                        },
                                    ]
                                }
                    モックに対して API を呼び出します:
                        WireMock を起動します:
                            #search: start WireMock
                        curl を使って呼び出します: |
                            curl -X POST -i -d '{ "method": "user.login" }' -H "Content-Type: application/json"  http://localhost:8080/zabbix/api_jsonrpc.php
                tcpdump + WireMock (HTTPS): #keyword: WireMock HTTP example
                    概要:
                        開発環境に Web API のサーバー環境のモックを作ります
                    関連 >> HTTP版: #search: tcpdump Web API example
                    参考:
                        Web API のモック: #search: tcpdump Web API example
                        #ref: https://stackoverflow.com/questions/39850326/how-to-enable-https-for-standalone-wiremock
                        #ref: https://please-sleep.cou929.nu/decrypting-tls-traffic-packet-capture.html
                    設定: #settings:
                        __WireMockPort__: 10443
                        __SharedFolder__: /vagrant
                        __WireMockJar__: wiremock-jre8-standalone-2.33.2.jar
                    開発環境にインストールします:  #// 開発環境(@control)に tcpdump と HTTPS の WireMock をインストールします
                        tcpdump をインストールします:
                            (@control): sudo yum install -y  tcpdump
                        WireMock をインストールします:
                            #search: install WireMock
                        HTTPS の identity.jks ファイルを作ります:  #// WireMock が開発環境からアクセスする HTTPS サーバーになります
                            identity.jks ファイルを作ります:
                                (@control):
                                    mkdir -p ~/Downloads/wiremock/secret
                                    cd       ~/Downloads/wiremock/secret
                                    keytool -genkey -alias wiremock -keyalg RSA -keysize 1024 \
                                        -validity 3650 -keypass password -keystore identity.jks -storepass password
                                    （Enter 6 回）
                                    （y Enter）
                            oreore.ssl.crt ファイル（自己署名証明書）を作ります:
                                #search: oreore.ssl.crt
                                    変更箇所:
                                        x509v3_config.txt を作ります: |
                                            echo "subjectAltName = DNS: localhost" > x509v3_config.txt
                            identity.jks ファイルに oreore.ssl.crt を入れます:
                                cd  ~/Downloads/wiremock/secret
                                keytool -import -trustcacerts -alias mock -file oreore.ssl.crt -keystore identity.jks -storepass password
                                （y Enter）
                        WireMock の mappings ファイルを作ります:  #// テスト用 HTTP GET に正常応答する設定を作ります
                            ~/Downloads/wiremock/mappings/test.json: |  #keyword: WireMock test mappings  #search: curl WireMock test
                                {
                                    "mappings": [
                                        {
                                            "request": {
                                                "method": "POST",
                                                "url": "/test",
                                                "bodyPatterns" : [ {
                                                    "equalToJson" : { "id": "tester" },
                                                    "ignoreExtraElements" : true
                                                } ]
                                            },
                                            "response": {
                                                "status": 200,
                                                "headers": {
                                                    "Content-Type": "application/json"
                                                },
                                                "body": "{\"credential\":\"ABCDE12345\"}"
                                            }
                                        }
                                    ]
                                }
                    開発環境で HTTPS 通信をキャプチャーします:  #// HTTP リクエストをキャプチャーするため
                        WireMock（サーバー）を起動します:
                            新しい bash (WireMock):
                                cd ~/Downloads/wiremock
                                java -jar wiremock-jre8-standalone-2.33.2.jar  --https-port 10443 --https-keystore ./secret/identity.jks
                                    #template: java -jar __WireMockJar__  --https-port __WireMockPort__ --https-keystore ./secret/identity.jks
                        キャプチャー開始:
                            新しい bash (tcpdump) の続き: |
                                cd  ~/Downloads/wiremock
                                sudo tcpdump -A -i lo  host 127.0.0.1  and  port 10443  -w - -U | tee /vagrant/tcpdump.pcap | tcpdump -r -  #template: __SharedFolder__/tcpdump.pcap
                            #// 出力ファイルは上書き保存されます
                        通信:
                            新しい bash (curl): |  #// ここの curl は HTTPS クライアントとして動くプログラムの代わりです
                                cd  ~/Downloads/wiremock
                                rm -f  /vagrant/pre-master-secret.log  #template: __SharedFolder__/pre-master-secret.log
                                SSLKEYLOGFILE=/vagrant/pre-master-secret.log  curl -X POST --insecure  'https://127.0.0.1:10443/test'  -H "Content-Type: application/json"  -d '{
                                    "id": "tester"
                                }'
                            #// pre-master-secret.log ファイルの内容は今回の通信に対してのみ有効です
                        キャプチャーした内容が表示されるので確認します:
                            bash (tcpdump):
                                #// 内容は暗号化されています
                        キャプチャー終了:
                            bash (tcpdump) の続き:
                                Ctrl + C キー
                    HTTPS 通信の様子を表示します:  #// HTTP リクエストを表示するため
                        Wireshark for Windows の場合:
                            pre-master-secret.log ファイルのパスを設定します:
                                Wireshark >> 編集 メニュー >> 設定（最も下）>> Protocols（の左の>）>> TLS >> (Pre)-Master-Secret log filename >>
                                pre-master-secret.log ファイルのパス >> OK
                            （初回のみ）キャプチャーしたファイル tcpdump.pcap を開きます:
                                キャプチャーしたデータのファイルを Wireshark
                                のウィンドウにドラッグ＆ドロップします
                            （2回目以降）pre-master-secret.log と tcpdump.pcap をリロードします:
                                Ctrl + r
                            通信の様子:
                                ヘッダー:
                                    緑色の行 >> Hypertext Transfer Protocol
                                JSON の場合:
                                    緑色の行 >> JavaScript Object Notation（をダブルクリック）>>
                                        Object（を右クリック）>> コピー >> 印刷可能なテキストとして（下から 4番目）
                                text の場合:
                                    緑色の行 >> Line-based text data （を右クリック）>> コピー >> 値
                        tshark for CentOS7 の場合:  #// 未確認。 バージョン 1.10.14 では通信内容が出ない？
                            （初回のみ）tshark をインストールします:  #// wireshark に tshark が入っています
                                bash (tcpdump): |
                                    sudo yum install -y wireshark
                            キャプチャーした内容を表示します:
                                bash (tcpdump): |
                                    tshark -r /vagrant/tcpdump.pcap  -o "ssl.keylog_file: /vagrant/pre-master-secret.log"
                                        #template-at(-1): __SharedFolder__/tcpdump.pcap
                                        #template-at(-2): __SharedFolder__/pre-master-secret.log

                                    sudo tcpdump -w - | tshark -r - -T json    tshark 1.12.8 and later
                                    tshark -T pdml
                                    tshark -r ./tcpdump.pcap -Y 'http>0' -T text
                    サーバー環境でレスポンスの内容を調べます:  #// サーバー環境とは (@control) とは別のホストのこと
                        方法: 通常の curl コマンドで入力・出力とも分かります
                        コマンドの例: |  #keyword: curl WireMock test
                            curl -X POST --insecure  'https://127.0.0.1:10443/test'  -H "Content-Type: application/json"  -d '{
                                "id": "tester"
                            }'
                tcpdump + WireMock コンバーター:  #keyword: pcap2wiremock,  tcpdump + WireMock コンバーター,  .pcap .json mappings
                    pcap2wiremock:
                        #ref: ${GitHub}/MyPrivateCode/pcap2wiremock/pcap2wiremock.py
                    pcap2sh: #keyword:  #// tcpdump から curl を含む シェル スクリプト を生成します
                        #ref: ${GitHub}/MyPrivateCode/pcap2sh/pcap2sh.py
                キャプチャーと再生:
                    #ref: https://wiremock.org/docs/record-playback/
                    #ref: https://github.com/abstracta/wiresham
                エクステンションをビルドします: #keyword: build WireMock extension
                応答を変更します:  #search: WireMock scenario state
            コマンドライン:  #// WireMock
                基本: java -jar  wiremock-____.jar  -port __PortNum__
                --port: HTTP のポート番号。 0 を指定すると自動設定します。 HTTPS の場合は --https-port オプション
                --https-port: HTTPS のポート番号。--port オプションを指定しない場合、HTTP の 8080 ポートも使います
                --root-dir: 本書では __WireMockRoot__ と表します。 省略すると カレント フォルダー がルートになります。
                参考: #ref: http://wiremock.org/docs/running-standalone/
            ファイル >> mappings ファイル: #keyword: WireMock mappings  #// 応答内容
                置き場所:
                    - __WireMockRoot__/mappings/___.json
                    - __WireMockRoot__/mappings/___/____.json  #// サブフォルダーにも置けます
                    #// 拡張子が json 以外のファイルは使われません
                注意:
                    .json ファイルの内容を変更したら、WireMock を再起動してください。
                    再起動するには、Ctrl + C キー を押して、起動コマンドを再入力します。
                基本, mappings, 複数のコールを1つのファイルに定義する場合:  #keyword: WireMock mappings basic
                    mappings キーの配列の中に定義します:
                        mappings/example.json : |  #focus: mappings  #keyword: WireMock request response
                            {  // コメントを書くこともできます。 ファイル名の拡張子を .jsonc にすることはできません
                                "mappings": [  /* コメント */
                                    {
                                        "request": {
                                            "method": "GET",
                                            "url": "/hello"
                                        },
                                        "response": {
                                            "status": 200,
                                            "headers": {
                                                "Content-Type": "text/plain"
                                            },
                                            "body": "Hello world! /hello"
                                        }
                                    },
                                    {
                                        "request": {
                                            "method": "GET",
                                            "url": "/hello/json"
                                        },
                                        "response": {
                                            "status": 200,
                                            "headers": {
                                                "Content-Type": "application/json"
                                            },
                                            "body": "{\"name\": \"John\"}"
                                        }
                                    }
                                ]
                            }
                    curl を使って呼び出します:
                        curl -X GET  http://localhost:8080/hello/json
                    呼ばれた回数を表示します: |  #keyword: WireMock count example
                        curl -X POST  "http://localhost:8080/__admin/requests/count"  -d '{"method": "GET", "url": "/hello/json"}'
                            #// { "count": 1, "requestJournalDisabled": false }
                    （参考）1つのコールを1つのファイルに定義する場合:
                        #search: WireMock mappings-1
                    関連 >> POST メソッドの body の設定:  #search: bodyPatterns
                フィールド: #keyword: WireMock mappings fields
                    mappings:  #// 複数の設定を書くときに必要です
                    request:  #glossary: WireMock
                        method:  GET, POST など  #search: HTTP メソッド
                        url: URL  #// パターン マッチング する場合は urlPattern
                        urlPattern:  #ref: https://wiremock.org/docs/request-matching/
                            - "/user\\?offset=.*"  #// URL に含まれる ? は正規表現に解釈されないように \\ でエスケープします
                            - "\\?q=keyword(&option=no\\+password)?"  #// 空白は URL では + であり、+ は正規表現に解釈されないように \\ でエスケープします
                                #// メタ文字の (, ) はエスケープしません
                        urlPath:
                        urlPathPattern:  #// URL の パターン マッチング
                    response:
                        status:
                        headers:
                        body:
                        jsonBody:
                        bodyFileName:
                Web API をキャプチャーして mappings を作ります:  #search: tcpdump Web API example
                リクエストのマッチング:  #keyword: WireMock request matching  #// mappings の中のどの mapping にマッチするかの条件を設定します
                    必要なリクエストの内容を調べます:  #// 設定する前にマッチング条件を調べます
                        サンプル: |
                            | Closest stub   | Request    |
                            -------------------------------
                            GET              | GET
                            /hello/json      | /hello/yaml   <<<<< URL does not match
                        Closest stub: #keyword:  #// リクエストに近い存在する設定
                        Request: #keyword:  #// リクエストの内容。設定がない内容
                        長い URL のサンプル: |  #//  /hello/this_is_a_long_url の途中に URL does not match が入ります
                            | Closest stub   | Request    |
                            -------------------------------
                            GET              | GET
                            /hello/json      | /hello/this_is<<<<< URL does not match
                            _                | _a_long_url
                    URL や HTTP メソッドのマッチング: #// URL の値について、マッチングする条件を設定します
                        基本:
                            mappings/example.json : |  #focus: hello/json
                                "request": {
                                    "method": "GET",
                                    "url": "/hello/json"
                            curl を使って呼び出します:
                                curl -X GET  http://localhost:8080/hello/json
                        URL パラメーター: #keyword: WireMock URL parameter
                            サンプル: http://localhost:8080/items/(.*)
                            基本:
                                __WireMockRoot__/mappings/example.json : |  #focus: urlPattern, bodyFileName
                                    {
                                        "mappings": [
                                            {
                                                "request": {
                                                    "method": "GET",
                                                    "urlPattern": "/items/(.*)"
                                                },
                                                "response": {
                                                    "status": 200,
                                                    "bodyFileName": "items-{{ request.path.[1] }}.json"
                                                }
                                            }
                                        ]
                                    }
                                __WireMockRoot__/__files/items-123.json : |
                                    {"name": "Mark"}
                                curl を使って呼び出します:
                                    curl -X GET  http://localhost:8080/items/123
                            範囲あり:
                                mappings/example.json : |
                                    "request": {
                                        "method": "GET",
                                        "urlPattern": "/items/(\\d{1,3})"
                                curl を使って呼び出します:
                                    マッチする:
                                        curl -X GET  http://localhost:8080/items/123
                                    マッチしない:
                                        curl -X GET  http://localhost:8080/items/1234
                            URL の一部を埋め込む, request.path: #search: WireMock request.path
                            参考: #ref: https://qiita.com/rubytomato@github/items/c0f4f8f882c2069d91f0
                        関連:
                            URL に応じてレスポンスを変えます:  #search: WireMock dynamic response
                        設定: #settings:
                            __WireMockJar__: wiremock-jre8-standalone-2.33.2.jar
                    JSON body のマッチング: #keyword: WireMock JSON body  #// リクエストの内容が JSON で指定される場合に、JSON について、マッチングする条件を設定します
                        基本:  #focus: bodyPatterns, id, ignoreExtraElements
                            mappings/example.json : |  #keyword: bodyPatterns,  WireMock POST body
                                "request": {
                                    "method": "POST",
                                    "url": "/api",
                                    "bodyPatterns" : [{
                                        "equalToJson" :
                                            {"id": 4 },
                                        "ignoreExtraElements" : true
                                    }]
                            curl を使って呼び出します:
                                上記定義にマッチするコマンド: |  #focus: id
                                    curl -X POST -i -d '{ "id": 4 }' -H "Content-Type: application/json" http://localhost:8080/api
                                上記定義にマッチしないコマンド: |  #focus: additional
                                    curl -X POST -i -d '{ "id": 5 }' -H "Content-Type: application/json" http://localhost:8080/api
                        JSON 文字列でも指定できます: |
                            "bodyPatterns" : [ {
                                "equalToJson" : "{ \"id\": 4 }",
                        関心がないフィールドの違い:  #focus: ignoreExtraElements  #// 条件に指定したフィールド以外のフィールドは無視します
                            mappings/example.json : |  #// body 部分は { "id": 4 }
                                "bodyPatterns" : [ {
                                    "equalToJson" : { "id": 4 },
                                    "ignoreExtraElements" : true,
                            リクエスト body:
                                マッチする: |  #focus: additional
                                    { "id": 4, "additional":2 }
                                マッチしない: |  #focus: 55
                                    { "id": 55 }
                        完全一致:
                            mappings/example.json : |  #// ignoreExtraElements が省略されている
                                "bodyPatterns" : [ {
                                    "equalToJson" : { "id": 4 },
                            リクエスト body:
                                マッチする: |  #focus: id
                                    { "id": 4 }
                                マッチしない: |  #focus: additional
                                    { "id": 4, "additional":2 }
                        フィールド名のみ:  #// 型プレースホルダー ${json-unit.any-number}  #// フィールドの値が何であれマッチします
                            mappings/example.json : |
                                "bodyPatterns" : [ {
                                    "equalToJson" : { "id": "${json-unit.any-number}" },
                            リクエスト body:
                                マッチする: |
                                    { "id": 4 }
                                マッチしない: |
                                    { "id": "a" }
                            型プレースホルダーのバリエーション:
                                "${json-unit.any-number}":
                                "${json-unit.any-string}":
                                "${json-unit.any-boolean}":
                                #ref: https://github.com/lukas-krecan/JsonUnit#typeplc
                        正規表現:  #// [?($.name =~ /Req.*/i)]
                            基本:
                                mappings/example.json : |  #// [?( )] の中でのみ =~ 演算子が使えます  #search: =~
                                    "bodyPatterns" : [ {
                                        "matchesJsonPath" : "[?($.name =~ /Req.*/i)]"
                                リクエスト body:
                                    マッチする: |
                                        { "name": "Required" }
                                    マッチしない: |
                                        { "name": "NotRequired" }
                                        { "things": { "name": "Required" } }
                            子要素について:
                                mappings/example.json : |
                                    "bodyPatterns" : [ {
                                        "matchesJsonPath" : "$.things[?(@.name =~ /Required.*/i)]"
                                リクエスト body:
                                    マッチする: |
                                        { "things": { "name": "Required" } }
                                    マッチしない: |
                                        { "name": "Required" }
                        or:  #// [?($.id == 3  ||  $.id == 4)]
                            mappings/example.json : |
                                "bodyPatterns" : [ {
                                    "matchesJsonPath" : "[?($.id == 3  ||  $.id == 4)]"
                            リクエスト body:
                                マッチする: |
                                    { "id": 3 }
                                    { "id": 4 }
                                マッチしない: |
                                    { "id": 5 }
                        配列要素の順番の違い:  #// [4, 5], [5, 4] 
                            mappings/example.json : |
                                "bodyPatterns" : [ {
                                    "equalToJson" : { "ids": [4, 5] },
                            リクエスト body:
                                マッチする: |
                                    { "ids": [4, 5] }
                                マッチする (2): |
                                    { "ids": [5, 4] }
                                マッチしない: |
                                    { "ids": [4, 4] }
                        配列要素数:  #// $[?(@.ids.size() == 2)]
                            mappings/example.json : |
                                "bodyPatterns" : [ {
                                    "equalToJson" : "$[?(@.ids.size() == 2)]",
                            リクエスト body:
                                マッチする: |
                                    { "ids": [4, 5] }
                                マッチしない: |
                                    { "ids": [4] }
                                    { "ids": [4, 5, 6] }
                        関連 >> body の JSON に応じてレスポンスを変えます:  #search: WireMock dynamic response
                    ベーシック認証 のマッチング:  #// マッチングする条件を設定します
                        設定しない場合:
                            BASIC 認証があってもなくてもマッチします
                        指定した BASIC 認証の内容の場合のみマッチします:
                            mappings/example.json : |  #focus: basicAuthCredentials
                                "request": {
                                    "method": "GET",
                                    "url": "/hello/json",
                                    "basicAuthCredentials": {
                                        "username": "userName",
                                        "password": "Password"
                                    }
                            curl を使って呼び出します:
                                curl -X GET  --insecure  --user "userName:Password"  http://localhost:8080/hello/json
                レスポンスの内容:  #keyword: WireMock response
                    mappings ファイルに書く場合:  #search: WireMock mappings basic
                    bodyFileName:  #keyword: #// body の内容を mappings ファイルとは別のファイルに書く場合
                        概要: 
                            - bodyFileName フィールドにファイル名を書きます。
                            - 基準パスは __files フォルダーです  #keyword: WireMock __files
                            - サブフォルダーも指定できます（下記）
                        __WireMockRoot__/mappings/example.json : |  #focus: bodyFileName  #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockResponseTemplate/mappings/3_bodyFile.json
                            {
                                "mappings": [
                                    {
                                        "request": {
                                            "method": "GET",
                                            "url": "/users/profile"
                                        },
                                        "response": {
                                            "status": 200,
                                            "bodyFileName": "simple.json",
                                            "headers": {
                                                "Content-Type": "application/json"
                        __WireMockRoot__/__files/simple.json : |  #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockResponseTemplate/__files/3_bodyFile.json
                            {"name": "John"}
                        サブフォルダーも指定できます: |
                            mappings/____.json
                                "bodyFileName": "_build/____.json"
                            __files/_build/____.json
                        関連 >> パラメーター:  #search: WireMock parameters
                    動的レスポンス: #keyword: WireMock dynamic response  #// URL や body や状態に応じてレスポンスを変えます
                        response-template:  #search: WireMock response-template  #// URL や body に応じてレスポンスを変えます
                        body .hbs ファイル:  #search: WireMock .hbs
                        シナリオと状態: #search: WireMock scenario state  #// ユーザー定義の状態に応じてレスポンスを変えます
                        extensions: #search: WireMock extensions  #// 何でもありだが Java
                遅延したレスポンス: |  #// 3秒
                    "response": {
                        "fixedDelayMilliseconds": 3000
            概念:
                response-template: #keyword: WireMock response-template  #// URL や body に応じてレスポンスを変えます。標準で入っている extensions
                    #ref: https://wiremock.org/docs/response-templating/
                    プロジェクト: #search: try_WireMockResponseTemplate
                    起動時に追加するパラメーター:
                        --local-response-templating:
                            サンプル: |  #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockResponseTemplate/docker-compose.yml#--local-response-templating
                                command: --https-port 8443  --verbose  --local-response-templating
                        --global-response-templating: |
                            下記を省略できます（transformerParameters を使わない場合、検索して調べられなくなるので非推奨）
                                "transformers": ["response-template"], 
                    シンプルなサンプル:  #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockResponseTemplate/mappings/1_hello.json
                        mappings ファイル: |  #focus: transformers  #search: WireMock mappings
                            {
                                "request": {
                                    "urlPath": "/templated"
                                },
                                "response": {
                                    "body": "... {{ request.path.[0] }}",
                                    "transformers": ["response-template"]
                                }
                            }
                        コマンド:
                            curl -X GET  http://localhost:8080/templated
                        出力:
                            ... templated
                    基本サンプル: #keyword: WireMock template  #// URL の一部をテンプレートの辞書のキーにします。.hbs ファイルの中で変数定義します
                        注意:
                            - WireMock 起動時にパラメーターの追加を試してください  #search: WireMock response-template
                            - 大きい JSON や様々な内容の JSON のテンプレートでは Java のエラーになることがあります
                            - JSON を辞書の値にすると、変な形にエスケープされて期待通りになりません  #search: WireMock parameters JSON
                        解説:
                            #↓ body ファイルの assign に書く変数名
                            _id: |
                                {{#assign '_id' }} の右 {{ request.pathSegments.[1] }} が、_id の内容に関する定義です。
                                request.pathSegments.[1] は、URL http://localhost:8080/object/user1 の "user1" です。
                            _namePath: |
                                {{#assign '_namePath' }} の右 {{ join  _id  '.name'  '' }} が、_namePath の内容に関する定義です。
                                join  _id  '.name'  '' は、文字列の結合です。_id の値と、リテラル '.name' を結合した値 "user1.name" です。
                            _name: |
                                {{#assign '_name' }} の右 {{ jsonPath  parameters  _namePath }} が、_name の内容に関する定義です。
                                _namePath の値に直すと、{{ jsonPath  parameters  "user1.name" }} です。
                                jsonPath  parameters は transformerParameters の中の値を参照するので、_name の値は "Mario" です。
                                body ファイル の jsonPath  parameters にリテラル "user1.name" を直接書くこともできそうです。（未確認）
                        mappings ファイル: | #keyword: WireMock .hbs mappings  #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockResponseTemplate/mappings/6_object.json
                            {   // #focus: user1,  bodyFileName
                                "request": {
                                    "method": "GET",
                                    "urlPattern": "/object/.*"  // curl -X GET  http://localhost:8080/object/user1
                                },
                                "response": {
                                    "transformerParameters": {
                                        "user1": {
                                            "name": "Mario"
                                        }
                                    },
                                    "status": 200,
                                    "bodyFileName": "6_object.json.hbs",
                                        // {
                                        //     "_id": "user1",
                                        //     "_namePath": "user1.name",
                                        //     "_name": "Mario"
                                        // }
                                    "transformers": ["response-template"]
                                }
                            }
                        body .hbs ファイル: | #keyword: WireMock .hbs  #search: Handlebars  #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockResponseTemplate/__files/6_object.json.hbs
                            {{!  #focus: _id,  pathSegments,  _name
                            }}{{#assign '_id' }}{{ request.pathSegments.[1] }}{{/assign
                            }}{{#assign '_namePath' }}{{ join  _id  '.name'  '' }}{{/assign
                            }}{{#assign '_name' }}{{ jsonPath  parameters  _namePath }}{{/assign

                            }}{
                                "_id": "{{ _id }}",
                                "_namePath": "{{ _namePath }}",
                                "_name": "{{ _name }}"
                            }
                        出力: |
                            {
                                "_id": "user1",
                                "_namePath": "user1.name",
                                "_name": "Mario"
                            }
                        参考:
                            パラメーター:  #search: WireMock parameters
                            ヘルパー:  #search: WireMock helper
                                - request.pathSegments.[__Index__]
                                - request.query.__Parameter__
                                #search: WireMock helper
                            Handlebars のタグ: |  #search: Handlebars
                                    {{#if __Condition__ }}__ContentsIfTrue__{{else}}__ContentsIfFalse__{{/if}}
                                #search: Handlebars
                    埋め込む内容:
                        リファレンス, 文法: #keyword: WireMock response-template grammar
                            プロパティ アクセス: #keyword: WireMock object
                                parameters:  #search: WireMock parameters  #// mappings ファイルの中で定義します
                            ヘルパー, 関数:  #keyword: WireMock helper,  WireMock function  #// 関数
                                文法:
                                    呼び出し: | #keyword: WireMock call
                                        {{ __HelperName__ }}
                                        {{__HelperName__}}
                                        {{ __HelperName__ __Argument1__ }}
                                        {{ __HelperName__ __Argument1__ __Argument2__ }}
                                        {{ __HelperName__ __Argument1__ __Argument2__ __Argument3__ }}
                                    引数内で呼び出す: |  #// カッコで囲みます
                                        {{ __OuterHelperName__ (__InnerHelperName__ __Argument1__) }}
                                #↓カタログ
                                オブジェクト, JSON のヘルパー:  #glossary: WireMock
                                    lookup:
                                    jsonPath:
                                        - jsonPath  parameters  'name'
                                        - jsonPath  parameters  'id1.name'
                                        #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockResponseTemplate/__files/6_object.json.hbs#jsonPath
                                URL, body のヘルパー:  #glossary: WireMock
                                    request:  #glossary: WireMock
                                        path:
                                        pathSegments:  #search: WireMock request.pathSegments
                                            #snip: request.pathSegments.[__Index__]
                                        query:
                                            - request.query.__Parameter__
                                        body:  #search: WireMock request.body
                                    #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockResponseTemplate/mappings/5a_urlPatternEtc.json
                                文字列ヘルパー:  #glossary: WireMock
                                    join:  #// 文字列を連結します
                                        join  _id  'name'  ', '  #// 最古のパラメーターは区切り文字
                                        #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockResponseTemplate/__files/6_object.json.hbs#join
                                        #ref: https://wiremock.org/studio/docs/response-templating/string-helpers/#join
                                数値や計算のヘルパー:  #glossary: WireMock
                                    math:
                                        定義時のサンプル: |  #// + ではなく '+' または "+" と書く理由は、+ という名前の変数であると解釈されるからです。数値は 0 でも '0' でも構いません
                                            {{#assign '__NewVariableName__'}}{{ math userId '+' 100 }}{{/assign
                                            }}
                                        埋め込み時のサンプル: |
                                            {{ math userId '+' 100 }}
                            ブロック ヘルパー: |  #search: Handlebars block helper  #// if など
                                {{#if __Condition__ }}__ContentsIfTrue__{{else}}__ContentsIfFalse__{{/if}}
                        パラメーター:  #keyword: WireMock parameters,  WireMock transformerParameters  #ref: https://wiremock.org/docs/response-templating/  >>  Using transformer parameters
                            mappings ファイル: |  #focus: MyCustomParameter  #search: WireMock mappings  #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockResponseTemplate/mappings/2_transformerParameters.json
                                {
                                    "request": {
                                        "urlPath": "/parameter"
                                    },
                                    "response": {
                                        "transformerParameters": {
                                            "MyCustomParameter": "Parameter Value"
                                        },
                                        "body": "... {{ parameters.MyCustomParameter }}",
                                        "transformers": ["response-template"]
                                    }
                                }
                            コマンド:
                                curl -X GET  http://localhost:8080/parameter
                            出力:
                                ... Parameter Value
                        URL の一部を埋め込む, request.pathSegments: #keyword: WireMock request.pathSegments  #search: WireMock URL parameter
                            __WireMockRoot__/mappings/example.json : |  #focus: urlPattern, bodyFileName, transformers
                                {
                                    "mappings": [
                                        {
                                            "request": {
                                                "method": "GET",
                                                "urlPattern": "/items/(.*)"
                                            },
                                            "response": {
                                                "status": 200,
                                                "bodyFileName": "items-{{ request.pathSegments.[1] }}.json",
                                                "headers": {
                                                    "Content-Type": "application/json"
                                                },
                                                "transformers": [
                                                    "response-template"
                                                ]
                                            }
                                        }
                                    ]
                                }
                            （補足）request.pathSegments.[i] の i:  #// '/' で区切った部分の番号。response-template を指定したときのみ有効
                                #// URL が __Domain__/items/123 の場合
                                0: items
                                1: 123
                            __WireMockRoot__/__files/items-123.json : |
                                {"name": "Mark"}
                            --local-se-templating オプションをつけて WireMock を起動します:
                                java -jar wiremock-jre8-standalone-2.33.2.jar --local-se-templating  #template: __WireMockJar__
                            関連 >> JSON body のマッチング:  #search: WireMock JSON body
                        JSON の一部を埋め込む, request.body: #keyword: WireMock request.body
                            サンプル: |
                                {{ jsonPath request.body '$.user.id' }}
                                {{ math (jsonPath request.body '$.user.id') '-' 1 }}
                        JSON を埋め込みます: #keyword: WireMock parameters JSON
                            #ref: https://stackoverflow.com/questions/74793536/how-can-i-embed-json-from-wiremock-transformerparameters
                            #search: WireMock request.body
                    body ファイル,  bodyFileName: #keyword: WireMock bodyFileName
                        サンプル:
                            基本, 基準パス:  #search: WireMock __files
                            パラメーターあり:  #focus: MyCustomParameter
                                mappings ファイル:  |  #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockResponseTemplate/mappings/4_fileParameter.json
                                    {
                                        "request": {
                                            "urlPath": "/file-parameter"
                                        },
                                        "response": {
                                            "transformerParameters": {
                                                "MyCustomParameter": "Parameter Value"
                                            },
                                            "bodyFileName": "4_fileParameter.json",
                                            "transformers": ["response-template"]
                                        }
                                    }
                                body ファイル: |  #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockResponseTemplate/__files/4_fileParameter.json
                                    { "parameger": "{{ parameters.MyCustomParameter }}" }
                    ヘルパー, 関数:  #search: WireMock helper
                    オブジェクト:  #search: WireMock object
                    Handlebars のタグ: |  #search: Handlebars
                            {{#if __Condition__ }}__ContentsIfTrue__{{else}}__ContentsIfFalse__{{/if}}
                        #search: WireMock .hbs
                        #search: Handlebars
                    参考:
                        #ref: https://wiremock.org/studio/docs/response-templating/basics/
                        #ref: https://wiremock.org/docs/response-templating/
                        #ref: https://dev.classmethod.jp/articles/wiremock-practice/
                        #ref: https://kagamihoge.hatenablog.com/entry/2022/07/23/174110
                呼ばれた回数: #keyword: WireMock count  #ref: https://wiremock.org/docs/verifying/
                    基本:
                        書式: |
                            curl -X POST  "http://localhost:8080/__admin/requests/count"  -d '{"method": "__Method__", "url": "__Path__"}'
                        サンプル:  #search: WireMock count example
                    応用: |  #// 未確認  #ref: https://wiremock.org/docs/verifying/
                        curl -X POST  "http://localhost:8080/__admin/requests/count"  -d '{
                            "method": "POST",
                            "url": "/resource/to/count",
                            "headers": {
                                "Content-Type": {
                                    "matches": ".*/xml"
                                }
                            }
                        }'
                シナリオと状態: #keyword: WireMock scenario state  #// ユーザー定義の状態に応じてレスポンスを変えます
                    #ref: https://wiremock.org/docs/stateful-behaviour/
                    サンプル プロジェクト:  #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockScenarioState/README.yaml
                    初期状態:  #focus: Started
                        JSON: Started
                        Java: Scenario.STARTED
                    状態遷移:
                        リセット: #keyword: WireMock reset scenario
                            curl -X POST  http://localhost:8080/__admin/scenarios/reset
                        状態遷移だけする場合, テスト用:  #focus: ToDo, Posted
                            コマンド: #// ToDo シナリオの状態を Posted に設定します
                                curl -X POST  http://localhost:8080/my_admin/scenarios/ToDo/state/Posted
                            mappings: |  #// Posted 状態に変えることの mappings 定義
                                "scenarioName": "ToDo",
                                "newScenarioState": "Posted",
                                "request": {
                                    "method": "POST",
                                    "url": "/my_admin/scenarios/ToDo/state/Posted"
                                },
                                "response": {
                                    "body": "state changed",
                                    "status": 200
                                }
                            公式に対する補足:
                                #// 公式に書かれたドキュメントができないことの代わり  #search: not supported WireMock scenario
                        応答と同時に状態遷移する場合: |  #// Started 状態で request にマッチしたら response を返し、Cancel_Newspaper 状態に変わります
                                "scenarioName": "ToDo",
                                "requiredScenarioState": "Started",
                                "newScenarioState": "Cancel_Newspaper",
                                "request": {
                                    ...
                                },
                                "response": {
                                    ...
                            #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockScenarioState/mappings/scenario.json
                        複数の状態:  #search: WireMock multi requiredScenarioState
                    参照:  #// 状態の参照
                        特定のシナリオの状態:
                            コマンド:  #// 以下のいずれか
                                - curl -X GET  http://localhost:8080/__admin/scenarios | grep "\"\(name\|state\)\""
                            bash 関数: |
                                function  FindWireMockState() {
                                    local  scenarioName="ToDo"
                                    local  state="$( curl --silent  -X GET  http://localhost:8080/__admin/scenarios  | \
                                        python3 -c "import sys, json; print(list(x['state'] for x in json.load(sys.stdin)['scenarios'] if x['name']=='${scenarioName}'))"  | \
                                        sed -E "s/^\\['//"  |  sed -E "s/'\\]$//"  )"

                                    echo  "http://localhost:8080/__admin/scenarios: {\"name\" : \"${scenarioName}\", \"state\" : \"${state}\"}"
                                }
                        全ての状態:
                            コマンド:
                                curl -X GET  http://localhost:8080/__admin/scenarios
                            出力例: |
                                {
                                    "scenarios" : [ {
                                        "id" : "a421f2fa-5317-4cc9-82c2-f49f46d930de",
                                        "name" : "To do list",                                        ... シナリオ名
                                        "state" : "Cancel newspaper item added",                      ... 現在の状態
                                        "possibleStates" : [ "Cancel newspaper item added", "Started" ],
                                        "mappings" : [ {
                                            "id" : "9c45740f-1e69-41fb-bf50-94e665fad4c9",
                                            "request" : {
                                                "url" : "/todo/items",
                                                "method" : "GET"
                                            },
                                            "response" : {
                                                "status" : 200,
                                                "body" : "<items><item>Buy milk</item></items>"
                                            },
                                            "uuid" : "9c45740f-1e69-41fb-bf50-94e665fad4c9",
                                            "scenarioName" : "To do list",
                                            "requiredScenarioState" : "Started"
                                        }, {
                                            "id" : "3fb89973-d2ba-4059-aabb-9e3b4b41855c",
                                            "request" : {
                                            ...
                    できない？: #keyword: not supported WireMock scenario
                        複数の状態, 複数の requiredScenarioState: #keyword: WireMock multi requiredScenarioState
                            _: サポートしていません。
                                異なる状態に関する設定は、設定全体を複数書いてください。
                            設定の API と同期の API のケース:  #// それぞれの設定の中から 1つの設定 API を呼び出し、続けて共通の同期 API を呼び出すケース
                                設定時に状態遷移します。 サービスに実際に設定されるタイミングと、WireMock の状態が遷移するタイミングをずらします。
                        特定のシナリオのリセット:  #// 以下は機能しません
                            - curl -X PUT  http://localhost:8080/__admin/scenarios/ToDo/state  #// ドキュメントにはある
                            - curl -X PUT  http://localhost:8080/__admin/scenarios/ToDo/reset
                            - curl -X POST http://localhost:8080/__admin/scenarios/ToDo/reset
                        特定のシナリオの状態のセット: |  #// 以下は機能しません
                            - curl -X PUT  http://localhost:8080/__admin/scenarios/ToDo/state -d '{"state": "Cancel_Newspaper"}'  #// ドキュメントにはある
                            - curl -X POST http://localhost:8080/__admin/scenarios/ToDo/state -d '{"state": "Cancel_Newspaper"}'
                            - curl -X PUT  http://localhost:8080/__admin/scenarios/ToDo -d '{"state": "Cancel_Newspaper"}'
                            - curl -X POST http://localhost:8080/__admin/scenarios/ToDo -d '{"state": "Cancel_Newspaper"}'
                        特定のシナリオの状態の参照:  #// 以下は機能しません
                            - curl -X GET  http://localhost:8080/__admin/scenarios/ToDo/state
                            - curl -X GET  http://localhost:8080/__admin/scenarios/ToDo
                extensions (.jar package): #keyword: WireMock extensions
                    公式: #ref: https://hub.docker.com/r/wiremock/wiremock  >>  Use wiremock extensions
                    ResponseDefinitionTransformer: #keyword: WireMock ResponseDefinitionTransformer
                        プロジェクト: #search: try_WireMockExtension
                        サンプル: #keyword: OpenTable wiremock-body-transformer
                            #ref: https://github.com/opentable/wiremock-body-transformer
                            - そのまま Maven でビルドできます  #search: Maven
                            - BodyTransformer
                    ResponseTransformer: #keyword: WireMock ResponseTransformer  #// レスポンスを Java で作るときの スーパー クラス
                        プロジェクト: #search: try_WireMockExtension
                        サンプル:
                            #ref: https://myagilequality.wordpress.com/2018/01/16/dynamically-change-a-mocked-response-using-wiremock/
                            #ref: ${GitHub}/MyPrivateCode/WireMock/try_WireMockExtensionSource/LibraryBookReturnDateTransformer/LibraryBookReturnDateTransformer.java
                            - Maven でビルドできます  #search: Maven
                            - ビルド プロジェクト は  #search: OpenTable wiremock-body-transformer
                Swagger UI:  #// ユーザー定義の API は表示されません
                    Swagger UI をインストールします:  #search: Swagger UI
                    Swagger UI 内に入力する URL: http://localhost:8080/__admin/docs/swagger
            トラブルシューティング(WireMock):  #keyword: WireMock trouble shooting
                - #// 'equalTo' expected value cannot be null
                    手順: HTTP POST request
                    エラー: |
                        'equalTo' expected value cannot be null
                    対処:
                        mappings ファイル に HTTP POST に関する定義をしてください
                - #// Cannot start service wiremock: network not found
                    手順: docker-compose up で WireMock を起動します
                    エラー: |
                        ERROR: for wiremock  Cannot start service wiremock: network __NetworkID__ not found
                        ERROR: Encountered errors while bringing up the project.
                    対処:
                        一度 docker-compose down してから docker-compose up します。
                - #// No response could be served as there are no stub mappings in this WireMock instance.
                    手順: WireMock を起動した状態で HTTP リクエストを送ります
                    エラー: |  #// ブラウザーに表示されます
                        No response could be served as there are no stub mappings in this WireMock instance.
                    対処:
                        Java を使うスタンドアローン版 WireMock の場合:
                            対処A:
                                カレント フォルダー を mappings フォルダーがあるフォルダーに移動してから、
                                WireMock を起動します
                            対処B:
                                WireMock を起動したときの カレント フォルダー の直下の mappings フォルダーに
                                ___.json ファイルを作ります  #search: WireMock mappings
            設定: #settings:
                __WireMockJar__: wiremock-jre8-standalone-2.33.2.jar
                __PortNum__: 8080
    キャプチャー:  #keyword: HTTP capture  #// HTTP 通信の様子を表示します
        HTTP:
            Python: #search: capture XML-RPC Python client
            tcpdump: #keyword:  #// HTTP 通信をキャプチャーします
                手順:  #// インストール、キャプチャー、表示、モック作成
                    CentOS7 ping:  #keyword: tcpdump CentOS7 ping example   #// CentOS7 に tcpdump をインストールして ping の通信の様子をキャプチャーします
                        2つ VM を用意します:
                            #search: multi_vm_ansible
                        できた VM の IP アドレスをメモします: #settings:
                            __Host1__: 192.168.33.59
                            __Host2__: 192.168.33.61
                        1つの VM に tcpdump をインストールします:
                            (@192.168.33.59): sudo yum install -y  tcpdump  #template: __Host1__)
                        tcpdump を起動します:
                            (@192.168.33.59): sudo tcpdump -nn -i eth1  icmp  #template: __Host1__)
                            出力例: |
                                tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
                                listening on eth1, link-type EN10MB (Ethernet), capture size 262144 bytes
                        もう片方の VM から ping を実行します:
                            (@192.168.33.61): ping 192.168.33.59  #template: __Host2__): ping __Host1__
                        キャプチャーできた内容を確認します:
                            (@192.168.33.59) の出力: |  #template: __Host1__)
                                02:56:15.148266 IP 192.168.33.61 > 192.168.33.59: ICMP echo request, id 4518, seq 1, length 64
                                02:56:15.148286 IP 192.168.33.59 > 192.168.33.61: ICMP echo reply, id 4518, seq 1, length 64
                            説明: |
                                時刻(UTC) IP __Host2__ > __Host1__: ICMP echo request, id ____, seq ____, length ____
                                時刻(UTC) IP __Host1__ > __Host2__: ICMP echo reply, id ____, seq ____, length ____
                        tcpdump が動いている VM から ping を実行します:
                            (@192.168.33.59): ping 192.168.33.61  #template: __Host1__): ping __Host2__
                            (@192.168.33.59) の出力: |  #template: __Host1__)
                                03:31:08.172257 IP 192.168.33.59 > 192.168.33.61: ICMP echo request, id 6025, seq 2, length 64
                                03:31:08.173716 IP 192.168.33.61 > 192.168.33.59: ICMP echo reply, id 6025, seq 2, length 64
                            説明: |
                                時刻(UTC) IP __Host1__ > __Host2__: ICMP echo request, id ____, seq ____, length ____
                                時刻(UTC) IP __Host2__ > __Host1__: ICMP echo reply, id ____, seq ____, length ____
                    Web API (HTTP): #search: tcpdump Web API example  #// 例：Zabbix の Web API 呼び出しを tcpdump でキャプチャーして WireMock でサーバーのモックを作ります
                    疎通確認します:  #search: 疎通確認 tcpdump
                    HTTPS の場合: 暗号鍵をキャプチャーすれば可能
                インストール:  #keyword: install tcpdump
                    #// 通信元、または、通信先のどちらか片方に tcpdump をインストールします
                    インストール確認:  #// Linux に tcpdump がインストールされていることを確認します:
                        tcpdump --version
                    インストール:
                        sudo yum install tcpdump
                コマンド:
                    書式:
                        sudo tcpdump  __Options__  __Expression__
                    サンプル:
                        ping:  #// ping を実行したときの通信をキャプチャーします
                            #search: tcpdump CentOS7 ping example
                        コマンド:  #// コマンドのサンプル
                            - sudo tcpdump -nn  -i eth1  icmp  #// ping
                            - sudo tcpdump -nn  -i eth1  host 192.168.100.111  port 8080
                            - sudo tcpdump -nn  -i eth1  -tttt  host 192.168.100.111  port 8080  -w  tcpdump.pcap
                            - sudo tcpdump -nn  -i eth1  -tttt  host 192.168.100.111  port 8080  -w - -U | tee tcpdump.pcap | tcpdump -r -  #// 表示と保存
                            - sudo tcpdump -i lo  host 127.0.0.1  port 80  #// curl https://localhost/ にはマッチしません。127.0.0.1 とは区別されます
                    オプション, __Options__:
                        -w オプション: #keyword: tcpdump -w  #// 通信内容の出力先ファイル名
                            通常: 通信内容の出力先ファイル名
                            省略時: 標準出力に出力
                            標準出力にも出力する場合:
                                tcpdump  -i __EthernetAdaptorName__  -w  - -U | tee __LogFileName__ | tcpdump -r -
                            -C オプション:  #// 通信内容の出力先ファイルをローテーションします
                                MB 単位。ローテーションすると、ファイル名の末尾に数字が付きます。
                                tcpdump.pcap, tcpdump.pcap1, tcpdump.pcap2, ...
                            -W オプション:  #// 通信内容の出力先ファイルの最大数
                                -W 3 では tcpdump.pcap3 (4?) は作られず、ディスクを圧迫しません
                        -i オプション:  #// イーサネット アダプター
                            省略時: 最初の イーサネット アダプター を指定したときと同じ動作です
                            any: すべての イーサネット アダプター を指定したときと同じ動作です
                            その他: キャプチャーする イーサネット アダプター。ip address show コマンドで調べられます。
                        -nn オプション:  #// IP アドレスやポート番号をそのまま出力します
                            値なし。
                            IP アドレスやポート番号をそのまま出力します。
                            指定しないとホスト名が出力されます。
                        -s オプション:  #// キャプチャーのバッファサイズ
                        -p オプション:  #// プロミスキャス モード ではなくします
                        -tttt オプション:  #// 日付も出力します。タイムゾーンは UTC から変わりません
                        -A, -X, -x オプション:  #// 通信内容も出力します
                            -A: 文字。Unicode は \uaaaa 形式
                            -X: ダンプと文字
                            -x: ダンプ
                        参考: #ref: https://isleofhoso.com/linux-tcpdump-option/
                    条件式, __Expression__:  #// IP アドレス、ポート番号
                        サンプル:
                            host と port でフィルタリングするサンプル:
                                host 192.168.100.111  and  port 80
                            host のサンプル:  #// パケットの ソース フィールド または デスティネーション フィールド でフィルタリング
                                host 192.168.100.111
                            port のサンプル:
                                port 80
                            dst host のサンプル:  #// パケットの デスティネーション フィールド でフィルタリング
                                dst host 192.168.100.111
                            src host のサンプル:  #// パケットの ソース フィールド でフィルタリング
                                src host 192.168.100.111
                        host: #keyword: tcpdump host  #// host タイプに指定する値
                            IP アドレス: host 127.0.0.1
                            ホスト名:    host localhost  #// curl https://127.0.0.1/ にはマッチしません。localhost とは区別されます
                            host も net も省略された場合: すべてのホスト
                        port: #keyword: tcpdump port  #// tcp や udp プロトコルの場合に指定できます
                            ポート番号: port 80
                            省略時: すべてのポート
                        net: #keyword: tcpdump net
                            CIDR: net 192.168.100.0/24
                            host も net も省略された場合: すべてのホスト
                        書式:
                            primitive(要素):
                                書式:
                                    - __Type__  __Value__
                                    - __Direction__  __Type__  __Value__
                                    - __Protocol__
                                __Type__: host, port, net  #search: tcpdump host  #search: tcpdump port  #search: tcpdump net
                                __Value__:  #// __Type__ ごとに異なります
                                __Direction__: src, dst
                                    src, dst でフィルタリングするケースはほとんどありません。
                                    なぜなら、リクエストかレスポンスの片方しか出力されなくなるからです。
                                __Protocol__:
                                    省略時: すべて。ただし port が指定してあると、それに対応している tcp or udp に相当します
                                    icmp: ping  #search: ping
                                    その他: ether, fddi, mopdl, ip, ip6, arp, rarp, decnet, lat, sca, moprc, mopdl, icmp6, tcp, udp
                            and, or, not:
                                host 192.168.100.111  and  port 80
                        参考:  #ref: https://linuxjm.osdn.jp/html/tcpdump/man1/tcpdump.1.html >> expression(条件式)
                記録とその表示:  #// 通信内容をファイルに保存します。ファイルの内容を表示します
                    ファイルに保存しない場合:
                        #search: tcpdump CentOS7 ping example
                        #search: tcpdump Web API example
                    ファイルに保存する場合:
                        記録:
                            #search: tcpdump -w
                        記録の表示:
                            すべて:
                                tcpdump  -r tcpdump.pcap
                            特定のポート番号に関する記録のみ表示:
                                tcpdump  -r tcpdump.pcap  port 8080
                トラブルシューティング: #keyword: tcpdump trouble
                    - #// 0 packets captured
                        手順: tcpdump コマンドを実行
                        エラー: |
                            0 packets captured
                        対処:
                            tcpdump の -i オプションを指定します
                    - #// kernel: device eth0 entered promiscuous mode
                        手順: tcpdump コマンドを実行
                        エラー: |
                            kernel: device eth0 entered promiscuous mode
                        対処:
                            tcpdump の -p オプションを指定します
                参考: #ref: https://wiremock.org/docs/record-playback/
            tcpreplay: #keyword:  #// TCP replay。キャプチャーした HTTP 通信を再生します
                tcpreplay:
                    #ref: https://manpages.org/tcpreplay
                    CentOS7 のデフォルトには入っていません
                tcpreplay-edit:
                    #ref: https://linux.die.net/man/1/tcpreplay-edit
            Wireshark: #keyword:
                手順:
                    Linux の場合: #keyword: Wireshark Linux
                        HTTP 通信をキャプチャーします:
                            tcpdump のインストール:  #search: install tcpdump
                                tcpdump --version
                            キャプチャーします:
                                #search: tcpdump -w
                                tcpdump  -i __EthernetAdaptorName__  -w __LogFileName__
                            参考:
                                トラブルシューティング:  #search: tcpdump trouble
                            #// 以下に続きます
                        キャプチャーした HTTP 通信の内容を確認します:  #keyword: Wireshark show HTTP
                            （初回のみ）Wireshark をインストールします:
                                ダウンロードします:
                                    #ref: https://www.wireshark.org/download.html
                                インストールします:
                                    ダウンロードしたファイルを開き、デフォルトの設定でインストールします
                                再起動します:  #// ただし、tcpdump の出力内容を見るだけなら再起動不要
                                参考:
                                    Wireshark のインストール手順（Windows編）:
                                        #ref: https://qiita.com/yasushi-jp/items/7cacbe6089c760ad4202
                            データを表示します:
                                Wireshark を起動して、キャプチャーしたデータのファイルを Wireshark
                                のウィンドウにドラッグ＆ドロップします
                        キャプチャーした HTTPS 通信の内容を確認します:  #keyword: Wireshark show HTTPS
                            まずは HTTP 通信の内容を確認する手順を行います:
                                #search: Wireshark show HTTP
                            pre-master-secret.log ファイルのパスを設定します:
                                Wireshark >> 編集 メニュー >> 設定（最も下）>> Protocols（の左の>）>> TLS >> (Pre)-Master-Secret log filename >>
                                pre-master-secret.log ファイルのパス >> OK
                            （初回のみ）キャプチャーしたファイル tcpdump.pcap を開きます:
                                キャプチャーしたデータのファイルを Wireshark
                                のウィンドウにドラッグ＆ドロップします
                            （2回目以降）pre-master-secret.log と tcpdump.pcap をリロードします:
                                Ctrl + r
                            通信の様子:
                                ヘッダー:
                                    緑色の行 >> Hypertext Transfer Protocol
                                JSON の場合:
                                    緑色の行 >> JavaScript Object Notation（をダブルクリック）>>
                                        Object（を右クリック）>> コピー >> 印刷可能なテキストとして（下から 4番目）
                                text の場合:
                                    緑色の行 >> Line-based text data （を右クリック）>> コピー >> 値
                    Windows の場合: #keyword: Wireshark Windows
                        インストールします:  #// Wireshark をインストールします
                            Wireshark-win64-3.6.5.exe
                            オプションはすべてデフォルト
                        テストします:  #// キャプチャーできることをテストします
                            メニュー:
                                Wireshark for Windows >> キャプチャ メニュー >> オプション >>
                                イーサネットまたは Adapter for loopback traffic capture（NIC）>> 
                                開始（右下）
                            停止します:  #// キャプチャーを終了します
                                Wireshark for Windows >> キャプチャ メニュー >> 停止
                            キャプチャーできないとき:
                                キャプチャー対象の NIC を上記のように選んでください。
                        フィルタリングします:  #// キャプチャー対象のポートにフィルタリングします
                            キャプチャフィルタを設定します:
                                Wireshark for Windows >> キャプチャ メニュー >> オプション >>
                                イーサネットまたは Adapter for loopback traffic capture（NIC）>> 
                                キャプチャフィルタ…を入力（に）port 8080（などを入力）
                                #// 保存済みのキャプチャフィルタと同じフィルタ式が存在するときは、リボン ボタン が黄色になります
                            保存済みのキャプチャフィルタから選んで設定します:
                                Wireshark for Windows >> キャプチャ メニュー >> オプション >>
                                イーサネットまたは Adapter for loopback traffic capture（NIC）>> 
                                リボン ボタン（下）>>（保存済みキャプチャフィルタ名）
                                #// 保存済みのキャプチャフィルタが選ばれているときは、リボン ボタン が黄色になります
                            現在のキャプチャフィルタを保存します:
                                Wireshark for Windows >> キャプチャ メニュー >> オプション >>
                                イーサネットまたは Adapter for loopback traffic capture（NIC）>> 
                                キャプチャフィルタ…を入力（に）port 8080（などを入力）>>
                                リボン ボタン（下）>> このフィルタを保存 >>（最も下へスクロール）>>
                                新規キャプチャフィルタ（をダブルクリック）>>（キャプチャフィルタ名を入力）>>
                                OK ボタン
                        キャプチャーを開始します:
                            Wireshark for Windows >> キャプチャ メニュー >> 開始
                            #// 左端の ツール ボタン と同じ
                        キャプチャーを終了します:
                            Wireshark for Windows >> キャプチャ メニュー >> 終了
                            #// 左から 2番目の ツール ボタン と同じ
                        通信データをコピーします:
                            #search: Wireshark copy data
                通信内容:  #// 通信データ
                    コピーします: #keyword: Wireshark copy data
                        XML の場合: #keyword: Wireshark copy XML data  #// XML RPC で送信または受信した XML をクリップボードにコピーします:
                            （フレームを選びます：上の表の行）>>
                            eXtensible Markup Language（を右クリック：中央のツリーの最も下）>> サブツリーを展開 >>
                            eXtensible Markup Language（を右クリック）>> コピー >> すべての見えている項目
                    JSON に変換します:  #// .pcap を .json に変換します
                        Wireshark (GUI) >> ファイル(File) メニュー >> エキスパートパケット解析(Export Packet Dissections) >> JSONとして
                NIC 一覧:  #// Windows 標準では表示されない NIC（例 ローカル エリア接続* 1）も表示されます
                    Wireshark >> キャプチャ メニュー >> オプション >> インターフェース管理（右下）
                F5 Wireshark Plugin: #ref: https://qiita.com/Kaz_K/items/3de4a890f18f52ef5e5a
                参考: #ref: https://qiita.com/toshihirock/items/df8535ec83959b79f828
            Fiddler:  #keyword:  #// HTTP 通信の様子を表示します（キャプチャーします）
                注意: メアドの登録が必要です
                参考: #ref: https://qiita.com/taketakekaho/items/397bc6e9afa32329edd0
        XML-RPC:
            Python: #search: capture XML-RPC Python client
            Wireshark: #search:
    REST API: #keyword: REST API,  HTTP POST GET PUT DELETE Web RESTful API
        比較表: |
            /       URL                                         request body    response
            ---------------------------------------------------------------------------------------
            POST:   __Domain__/__Categoty__/__Objects__         __Attributes__  __ID__
            GET:    __Domain__/__Categoty__/__Objects__/__ID__                  __Attributes__
            PUT:    __Domain__/__Categoty__/__Objects__/__ID__  __Attributes__
            PATCH:  __Domain__/__Categoty__/__Objects__/__ID__  __PartOfAttributes__
            DELETE: __Domain__/__Categoty__/__Objects__/__ID__
        説明:
            POST GET PUT DELETE のどれも POST の HTTP メソッドが使われるようです。
        HTTP リクエストを送る:
            ツール: #search: HTTP request tool
            Python: #ref: ${GitHub}/MyPrivateCode/Python/try_Python_requests
        JavaScript のネットワーク: #search: JavaScript network
        HTTP に応答するサーバー:
            REQBIN:  #ref: https://reqbin.com/req/5nqtoxbx/get-json-example
        設計: #keyword: design REST API
            RESTful Web API の設計: #ref: https://docs.microsoft.com/ja-jp/azure/architecture/best-practices/api-design
            URL とポートの設計: #search:
            RESTful である条件:  #ref: https://www.redhat.com/ja/topics/api/what-is-a-rest-api
                HTTP 経由:
                ステートレス:
                キャッシュ可能:
                リソースは識別可能:
                ほか:
            提言されている設計原則:  #ref: https://qiita.com/TakahiRoyte/items/949f4e88caecb02119aa
                - アドレス指定可能なURIで公開されていること
                - インターフェース(HTTPメソッドの利用)の統一がされていること
                - ステートレスであること
                - 処理結果がHTTPステータスコードで通知されること
        参考:
            Snap Note:
                #ref: ${programming}/方法論/重要ソフト開発.svg#RESTful
                #ref: ${programming}/HTML ブラウザ/HTML文法.svg#WebAPI
            RedHat:
                #ref: https://www.redhat.com/ja/topics/api/what-is-a-rest-api
            その他:
                #ref: https://qiita.com/TakahiRoyte/items/949f4e88caecb02119aa
    HTTP メソッド: #keyword:
        比較表: |
            /     再送確認  body
            ---------------------------
            GET:  なし      通常なし
            POST: あり      あり
        他のメソッド:
            HEAD: GET したときのヘッダーだけリクエストします。たとえば生存確認するときに使われます
                #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Methods/HEAD
        説明:
            再送確認: ページに戻るときに再送確認があるかどうか
            body:  #keyword: HTTP body
                - リクエスト body。
                - リクエストに含まれる JSON など（レスポンスに含まれる JSON などは、ペイロードですが HTTP body ではありません）
                - HTTP の body は、HTML の <body> ではありません
            ペイロード:  #keyword: HTTP payload
                - HTTP のペイロードは body を指すことが殆ど（ペイロードは実質的な内容を指す一般的な用語）
                - リクエストに含まれる JSON など
                - レスポンスに含まれる JSON など
        ファイルのアップロード:  #keyword: HTTP file upload
            ブラウザーの開発者ツールで見る:
                メニュー: 開発者ツール >> ネットワーク（タブ：右上）>> ヘッダー（タブ：中央）>>
                要求ヘッダー:
                    Content-Length: アップロードするときだけ存在します
                    Content-Type: multipart/form-data; boundary=--WebKitFormBoundarypvJ____
                        #// アップロードしないときは通常 application/json
            Django: #search: Django file upload
        ステータス コード:  #keyword: HTTP status code
            2xx: #glossary: HTTP status code
                200: 成功
                201: 生成成功  #ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/201
                204: No Content。リクエストが正常に処理されたが、返す新規情報はない
            3xx: #glossary: HTTP status code  #search: HTTP Redirect  #ref: https://ja.wikipedia.org/wiki/HTTPステータスコード#3xx_Redirection_リダイレクション
                301: 恒久的なリダイレクト（旧）
                    古い URL にアクセスすると返る。ブックマークは新しい URL に変更すべきです
                    #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Redirections#permanent_redirections
                302: 一時的なリダイレクト（旧）
                305: プロキシ経由でアクセスするよう通知する。現在は非推奨
                307: 一時的なリダイレクト（新）
                308: 恒久的なリダイレクト（新）
            4xx: #glossary: HTTP status code  #// クライアントの使い方に問題があるその他のエラー
                400: Bad Request。サーバーが理解できない無効な要求
                401: Unauthorized。認証許可の要求をしていない
                403: #keyword: 403 Forbidden
                    エラー内容: Forbidden。拒否された
                    原因1: proxy サーバーが応答してしまった
                        #search: NO_PROXY
                        #search: SSH port forwarding 403 trouble
                    原因2: ファイルは見つかったが、現在のリクエスト元からアクセスが拒否された
                        #ref: ${programming}/HTML ブラウザ/HTML文法.svg#HTTP_status_code
                        #search: nginx error.log
                    原因3: フォルダーにアクセスできない設定になっている
                        nginx の autoindex off;
                    原因4: CSRF チェックに失敗した
                404:  #keyword: HTTP 404 error
                    エラー内容: Not Found。（許可されたが）要求されたリソースはサーバーに存在しない
                    対処法: URL を確認します
                "[401, 429, 504]": #ref: ${programming}/HTML ブラウザ/HTML文法.svg#HTTP_status_code
                412: | #// Precondition Failed
                    curl の場合、オプション -H "Content-Type: application/json-rpc" （値は編集すること）を追加します
                414: #// URL や URI が長すぎる  Request-URI Too Long
                415:   #// Unsupported Media Type
                    POST メソッド なら クエリー パラメーター ではなく body に JSON などで指定します  #search: curl POST
                422:   #// Unprocessable Content
                    POST メソッド の body の JSON の中のフィールドの値の書式がおかしい。
                    たとえば、base64 形式として正しくないバイナリ値
                    #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Status/422#例
            5xx:
                500: #// サーバー内のその他のエラー。サーバー内で例外が発生した
                503: #// ドメインが見つからない（プロキシ サーバー からのレスポンス）
            その他: #ref: https://ja.wikipedia.org/wiki/HTTPステータスコード
    HXR, fetch:
        XMLHttpRequest: #keyword:
            サンプル:
                #search: cypress HTTP GET JSON
        fetch API: #keyword: HTTP fetch,  TypeScript HTTP  #// ブラウザーと Node.js 18 以降で使えます
            MDN: #ref: https://developer.mozilla.org/ja/docs/Web/API/Fetch_API/Using_Fetch
            サンプル:
                #search: HTTP fetch example
                #search: cypress fetch
                #serach: Next.js Dynamic Routes API
            fetch: #// Window:fetch() メソッド
                サンプル: | #keyword: HTTP fetch example  #focus: fetch
                    import fetch from 'node-fetch';  // node-fetch, @types/node-fetch  // Node.js 18 以降では不要

                    async function  getJsonFrom(url: string): Promise<any> {

                        const response = await fetch(url);
                        if (!response.ok) {
                            throw new Error(`HTTP fetch error. status: ${response.status}`);
                        }

                        const  jsonData = await response.json();
                        return  jsonData;
                    }

                    interface User {
                        id: number;
                        username: string;
                        email: string;
                        address: {
                            street: string;
                            suite: string;
                            city: string;
                            zipcode: string;
                            geo: object;
                        },
                        phone: string;
                        website: string;
                        company: {
                            name: string;
                            catchPhone: string;
                            bs: string;
                        }
                    }

                    async function  main() {
                        const  downloadedData: User = await getJsonFrom("https://jsonplaceholder.typicode.com/users");
                        
                        console.log(downloadedData);
                    }

                    main().catch((exception) => {
                        console.error(exception.message);
                    });
                body: |
                    await fetch("https://ntfy.sh/topic1828389", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/x-www-form-urlencoded"
                        },
                        body: "Hello from ntfy!"
                    });
                モックに置き換える:  #search: Jest fetch mock
    HTTP Redirect: #keyword: HTTP Redirect, URL 転送  #ref: https://developer.mozilla.org/ja/docs/Web/HTTP/Redirections
        概要: 二つ以上の URL のアドレスを与える技術です
        内部動作:
            クライアントが HTTP リクエストを送信します:
            サーバーがリダイレクトレスポンスを返信します:
                HTTP ステータス コード: 3xx
                Location ヘッダー: #keyword:
                    リダイレクト先の URL。
                    Location ヘッダーを受け取ったブラウザーは、自動的にリダイレクト先のページを表示しようとします。
        機密ヘッダーの削除の必要性:  #// クロスドメインリダイレクトしたときの Authorization ヘッダー など
            ブラウザやHTTPクライアントがクロスドメインリダイレクトを検出した際に、機密性の高いヘッダー（Authorization等）を自動的に削除する仕様となっています
            サーバー側は単にリダイレクト先のURLを Location ヘッダーで指定するだけで十分です
    Webhook: #keyword:
        開発時の注意点:
            freee より: #ref: https://developers.freee.co.jp/entry/webhook-development-was-hard
                lambdaのpost先を監視する:
                    lambdaがどこへpostするかわからないので通信を監視した方がよい
                internetに出ていく部分のroute tableを編集することでroutingを制御する:
                    lambdaからvpc内のaws resourceにアクセス出来たりしないか？(監視のためにlambdaをvpc内にいれるという話が出ていた)
                lambda用の新たなvpcを作成する:
                    悪意あるユーザーによってfreeeのプロダクト内部のAPIを叩かれないか？
        webhook.site: #keyword:  #ref: https://github.com/webhooksite/webhook.site
            概要: Webhook を発行するサイトのサービス。実験用にローカルで起動するサービス
            参考:
                Webhookのデバッグに便利なツール「Webhook.site」の紹介: #ref: https://sendgrid.kke.co.jp/blog/?p=11340
        ngrok: #keyword:
            概要: 自分のローカルサーバーに対して、一時的にPublicなURLを割り当てることができるツール。
                Webhook を受信するプログラムの開発に使います。
            サンプル:
                ./ngrok http 80
                #// http|https://<random>.ngrok.io => http://localhost:80 へフォワーディングされます
            参考:
                webhookの開発にはngrokがおすすめ！: #ref: https://muoilog.xyz/web-development/webhookの開発にはngrokがおすすめ！/
                Webhookのデバッグに便利なツール「Webhook.site」の紹介: #ref: https://sendgrid.kke.co.jp/blog/?p=11340
    WebSocket: #keyword:  #// HTTP の上で双方向通信します
        概要:
            - HTTP 上で双方向通信します。セッション確立中は双方向で通信できます
            - クライアントは JavaScript の WebSocket API を使います
            - サーバーは Node.js や Python のライブラリにあります
            - (ChatGPT) #ref: ${typrm_files}/ref/HTML-AI.yaml#label: WebSocket example
        URL:
            暗号化なし: ws://...
            暗号化あり: wss://...
        クライアント:  #ref: https://developer.mozilla.org/ja/docs/Web/API/WebSockets_API
        サーバー:
            1つのポートで HTTP と WS に対応する:
                概要: https://localhost/ （443ポート）で HTML がダウンロードできるとき
                    wss://localhost/echo  (8080ポートではない）で WebSocket サーバーにアクセスします.
                Apache: #ref: ${typrm_files}/ref/HTML-AI.yaml#label: websocket reverse proxy
    RPC: #keyword:
        HTTPS RPC:
            - 多くの現代的な RPC システムは HTTP/HTTPS 上で動作し、RESTful APIとの共存が可能です。
        REST HTTP と RPC の違い: #keyword: RPC vs HTTP  #ref: https://nordicapis.com/whats-the-difference-between-rpc-and-rest/
            - RPC がアクション用に設計されているのに対し、REST はリソース中心
            - RPC は UDP または TCP の上、REST は HTTP の上
            - RPC は インターフェイス定義言語 (IDL) が必要？
            - RPCとRESTの両方を一緒に使用できる  #ref: https://nordicapis.com/whats-the-difference-between-rpc-and-rest/
                #search: Django REST and RPC
        トラブルシューティング:  #search: XML-RPC fault
        関連: #search: XML-RPC, JSON-RPC, gRPC
    gRPC: #keyword:  #ref: https://grpc.io/
        ライセンス: オープンソース
        セキュア通信:
            gRPC + SSL/TLS:
                Python:
                    #ref: https://grpc.io/docs/guides/auth/#python
                    #ref: https://grpc.github.io/grpc/python/grpc.html#create-client-credentials
                    ssl_channel_credentials:
        参考:
            サービス間通信のための新技術「gRPC」入門: #ref: https://knowledge.sakura.ad.jp/24059/
    Stubby:
        gRPCの前身
    JSON-RPC:
        HTTP/HTTPS + JSON の RPC
        #ref: https://knowledge.sakura.ad.jp/24059/
    XML-RPC: #keyword:  #// HTTP/HTTPS + XML の RPC
        エラーを返すとき:
            サンプル: #ref: http://xmlrpc.com/spec.md >> Response example
            fault: #keyword: XML-RPC fault  #ref: https://ja.wikipedia.org/wiki/XML-RPC
                レスポンスに含まれます:
                    <?xml version="1.0"?>
                    <methodResponse>
                        <fault>
                            <value>
                                <struct>
                                    <member>
                                        <name>faultCode</name>
                                        <value><int>1</int></value>
                                    </member>
                                    <member>
                                        <name>faultString</name>
                                        <value><string>&lt;class 'NameError'&gt;:name 'Type' is not defined</string></value>
                                    </member>
                                </struct>
                            </value>
                        </fault>
                    </methodResponse>
                Python:  #keyword: Python xmlrpc.client.Fault  #ref: https://docs.python.org/ja/3/library/xmlrpc.client.html#fault-objects
                    クライアント側: |
                        xmlrpc.client.Fault: <Fault 1: "<class 'NameError'>:name 'Type' is not defined">
                    サーバー側: |
                        NameError: name 'Type' is not defined
            faultCode の値の意味は決まっていないが、PHP のものが受け入れられています:
                StackOverflow: #ref: https://stackoverflow.com/questions/1149035/whats-the-standard-for-xml-rpc-fault-codes
                PHP RPC Fault Code: #ref: http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php
        Python: #search: Python XML-RPC
        参考: #ref: https://knowledge.sakura.ad.jp/24059/
    サーバー プッシュ: #keyword: server push
        HTTP/2サーバプッシュサポート廃止検討と、103 Early Hintsについて:  #ref: https://asnokaze.hatenablog.com/entry/2020/11/13/001110
            Prelaod と103 Early Hints
    その他:  #search: RabbitMQ  #search: MQTT  #search: Kafka  #search: D-bus
    トラブルシューティング(HTTP):
        - #// 通信をキャプチャーします
            #search: HTTP capture
        - #// RPC  #search: XML-RPC fault
        - #// ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: self signed certificate
            手順: クライアントから HTTPS ポートを開く
            エラー: |
                ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: self signed certificate
            対処A:
                オレオレ証明書から正規の証明書に置き換えます
            対処:
                自己署名証明書を受け入れます  #search: accept self signed certificate
        - #// 400 The plain HTTP request was sent to HTTPS port
            手順: curl  http://192.168.56.102:8443/
            エラー: |
                400 The plain HTTP request was sent to HTTPS port
            対処:
                URL の先頭を http から https に変更します
                curl  https://192.168.56.102:8443/
        - #// ConnectionRefusedError: [Errno 111] Connection refused  #keyword: nginx Connection refused
            手順: クライアントからポートを開く
            エラー: |
                ConnectionRefusedError: [Errno 111] Connection refused
            原因:
                nginx の server.listen に指定していないポート番号にアクセスしています
            対処:
                nginx の server.listen を正しく設定します
            その他の対策:  #search: Connection refused
        - #// xmlrpc.client.ProtocolError: <ProtocolError for __URL__/RPC: 404 Not Found>
            手順: クライアントからポートを開く
            エラー: |
                xmlrpc.client.ProtocolError: <ProtocolError for __URL__/RPC: 404 Not Found>
            原因:
                別のサービスがポートを使っている可能性があります
URL: #keyword:
    URL:  #ref: ${programming}/HTML ブラウザ/URL.svg#url
        書式1:
            http://www.example.com/ :
                http: スキーム, プロトコル
                www: ホスト名
                www.example.com: FQDN, コモンネーム  #keyword: FQDN in URL
                example.com: ドメイン名
                .com: トップレベルドメイン, TLD
        サブドメイン: #ref: https://qiita.com/blue_islands/items/317be82c277938951f3e  >>  第5章
        localhost: #keyword:
            IPv4: 127.0.0.1
            IPv6: ::1   #// DNS(bind9)では末尾に ; を付けるので ::1;
        絶対 URL と 相対 URL:
            絶対 URL:
                #  http://example.com/folder/file.html
            相対 URL, スキーム 相対 URL:
                #  //example.com/folder/file.html
            相対 URL, ホスト 相対 URL, 絶対パス:
                #  /folder/file.html
            相対 URL, 相対パス:
                #  file.html
            #ref: https://knooto.info/url-absolute-relative/
        短縮 URL: #keyword:
            展開ツール:  #ref: https://bitly.doratool.com  など
    クエリー パラメーター:  #keyword: クエリー パラメーター, query parameter
        複数指定（配列）:
            ____?a=x&a=y :
                PHP以外: a=["x","y"]
                PHP: a="y"
            ____?a[]=x&a[]=y : a=["x","y"]
        セミコロン:
            a=x%3dy : a="x;y"
            a=x;y :
                Go以外: a="x;y"
                Go: a="x", y=""
        解析:
            bash: |  #// 下記は & の分離のみ。シェルに入力するときは "A=B&C=D" のように " " で囲むこと。バックグラウンド タスク になってしまうため
                local  ampersandKeyValues="$1"  #// "__Key__=__Value__&__Key__=__Value__&__Key__&__Key__" ...
                local  keyValues=( $( echo "${ampersandKeyValues}" | sed 's/&/ /g' ) )
    フラグメント: #keyword: URL fragment  #// URL の # より右
    (%)表記, URLエンコード:  #keyword: URL %,  URLエンコード,  パーセント エンコーディング,  percent URL
        Unicode 文字列に変換します:
            オンライン:  #ref: https://tech-unlimited.com/urlencode.html
            CentOS7:
                echo "__%E3%83%AF%E3%83%BC%E3%83%89__"  |  sed 's/+/ /g;s/%/\\x/g'  |  xargs -0 printf "%b"
                    #// __%E3%83%AF%E3%83%BC%E3%83%89__ の部分を置き換えてください
                #ref: https://askubuntu.com/questions/53770/how-can-i-encode-and-decode-percent-encoded-strings-on-the-command-line#answer-295312
        パーセント エンコーディング に変換します:
            オンライン:  #ref: https://tech-unlimited.com/urlencode.html
            CentOS7:
                curl -s -o /dev/null -w %{url_effective} --get --data-urlencode "__ワード__" ""  |  sed -E 's/^.{2}//';  echo  ""
                    #// __ワード__ の部分を置き換えてください
                #ref: https://gist.github.com/westfly/ed7e25ee4353751d94132f92837a7074
        参考:
            下記のスクリプトは、漢字に対応していません: |  #ref: https://askubuntu.com/questions/53770/how-can-i-encode-and-decode-percent-encoded-strings-on-the-command-line#:~:text=urlencode()
                #!/bin/bash

                function  urlencode() {
                    local  unicodeString="$1"
                    local  length="${#unicodeString}"

                    for (( i = 0; i < length; i += 1 )); do
                        local  character="${unicodeString:i:1}"
                        if echo "${character}"  |  grep '[a-zA-Z0-9.~_-]' > /dev/null; then
                            printf "${character}"
                        else
                            printf '%%%02X' "'${character}"
                        fi
                    done
                    printf  "\n"
                }

                urlencode  "$1"
    Scroll to Text Fragment:  #keyword: URL Scroll to Text Fragment,  (#:~:text=),  ブラウザー ジャンプ 強調表示 highlight URL Chrome text search link
        #// ❗ - は %2d に変えてください
        #// URL にページ内を検索するキーワードを指定して、キーワードを強調表示します。必要ならスクロールもします。ブラウザーの機能です
        覚え方: フラグメント(#) と にょろ涙(:~:) と (text=)
        サンプル:
            - https://en.wikipedia.org/wiki/URL_encoding#:~:text=segments
            - https://ja.wikipedia.org/wiki/パーセントエンコーディング#:~:text=%E9%96%8B%E3%81%8D
                #// パーセント エンコーディング してください  #search: URL %
        互換性:
            GitHub ではジャンプできますが、ジャンプしたら URL から Scroll to Text Fragment が消えます。
            コードの下のほうにはジャンプできません。
                #ref: https://github.com/Takakiriy/typrm/tree/master#:~:text=install
                #ref: https://github.com/Takakiriy/typrm/blob/master/specifications.yaml#:~:text=check
        #ref: https://chromestatus.com/feature/4733392803332096
        #ref: https://stackoverflow.com/questions/62161819/what-exactly-is-the-text-location-hash-in-an-url
    変更, リダイレクト: #keyword: URL redirect
        IPA 2023:  #ref: https://twitter.com/ipajp/status/1641644238315347968
            IPAのURLから"https://"を抜いて、前に"warp.ndl.go.jp/info:ndljp/pid…" をつければ見れますよ  #search: WARP プロジェクト
        WARP プロジェクト: #keyword:  #// 魚拓  #ref: https://warp.da.ndl.go.jp/info/WARP_Intro.html
    署名付き URL: #keyword:
    設計:
        RESTful Web API の設計:  #search: design REST API
        URL とポートの設計: #keyword:
            プロトコルやプロセス（サーバー側）が異なるならポートを共有できない
            リクエスト元がインターネットかサブネット内かの違いがあれば、URL のパスを追加するよりポートを追加するほうが良い
                インターネットから来るリクエストを受けるポートをブロックできるから
    DNS:
